{"code":{"__map":true,"values":[["1","const {html, render} = import(\"./preact.standalone.module.js\");\nconst {stringify, parse} = import (\"./stable-stringify.js\");\n\nRenkon.addBreakpoint(\"selectButton\")\n\nconst selectButton = Events.listener(init.querySelector(\"#select\"), \"click\", evt => evt);\nconst lineButton = Events.listener(init.querySelector(\"#line\"), \"click\", evt => evt);\nconst arcButton = Events.listener(init.querySelector(\"#arc\"), \"click\", evt => evt);\nconst deleteButton = Events.listener(init.querySelector(\"#delete\"), \"click\", evt => evt);\nconst undoButton = Events.listener(init.querySelector(\"#undo\"), \"click\", evt => evt);\n\nconst charClick = Events.listener(init.querySelector(\"#chars\"), \"click\", evt => evt);\n\nconst saveButton = Events.listener(init.querySelector(\"#saveButton\"), \"click\", evt => evt);\nconst loadButton = Events.listener(init.querySelector(\"#loadButton\"), \"click\", evt => evt);\n\nconst dragRequest = Events.receiver();\nconst fileLoadRequest = Events.receiver();\nconst undoRequest = Events.receiver();\n\nconsole.log(undoRequest);\n\nconst exampleStringInput = Events.listener(init.querySelector(\"#exampleEditor\"), \"input\", evt => evt);\n\nconst exampleString = Behaviors.collect(init.querySelector(\"#exampleEditor\").textContent, exampleStringInput, (_old, v) => v.target.textContent);\n\nconst toolState = Behaviors.collect(\n    \"line\",\n    Events.or(selectButton, lineButton, arcButton, deleteButton),\n    (old, evt) => evt.target.id\n);\n\n// toolHighlighter\n((toolState, init) => {\n    for (const child of [...init.querySelector(\"#tools\").childNodes]) {\n        if (child.setAttribute) {\n            child.setAttribute(\"toolSelected\", child.id === toolState ? \"true\" : \"false\");\n        }\n    }\n})(toolState, init);\n\nconsole.log(toolState);\n\nconst charSelected = Events.collect(\" \", charClick, (old, evt) => {\n    const id = evt.target.id;\n    const match = /([0-9]+)/.exec(id);\n    const n = parseFloat(match[1]);\n    return String.fromCharCode(n);\n});\n\nconsole.log(charSelected);\n\nconst charData = Behaviors.select(\n    {selected: \" \", segs: [], data: new Map()},\n    fileLoadRequest, (current, change) => {\n        return {\n            selected: current.selected,\n            segs: change.data.data.get(current.selected) || [],\n            data: change.data.data\n        };\n    },\n    charSelected, (current, change) => {\n        // selected char changed\n        if (current.selected === change) {return current;}\n        current.data.set(current.selected, current.segs);\n        return {selected: change, segs: current.segs, data: current.data}\n    },\n    Events.change($segments), (current, change) => {\n        current.data.set(current.selected, change);\n        return {selected: current.selected, segs: change, data: current.data};\n    }\n);\n\nconst griddedMap = (evt, half) => {\n    const f = half ? 2 : 1;\n    const rect = evt.target.getBoundingClientRect();\n    const gridX = gridSpec.width / (gridSpec.x * f);\n    const gridY = gridSpec.height / (gridSpec.y * f);\n    const x = Math.max(0, Math.round((evt.clientX - rect.x - (gridX / 2)) / gridX));\n    const y = (gridSpec.y * f) - 1 - Math.round((evt.clientY - rect.y - (gridY / 2)) / gridY);\n\n    return {x: x / f, y: y / f, target: evt.target};\n};\n\nconst toCharCoordinates = (evt) => {\n    const rect = evt.target.getBoundingClientRect();\n    const gridX = gridSpec.width / gridSpec.x;\n    const gridY = gridSpec.height / gridSpec.y;\n    const x = (evt.clientX - rect.x - (gridX / 2)) / gridX;\n    const y = gridSpec.y - 1 - ((evt.clientY - rect.y - (gridY / 2)) / gridY);\n    return {x, y, target: evt.target};\n};\n\nconst griddedUnmap = (p, dom) => {\n    const gridX = gridSpec.width / gridSpec.x;\n    const gridY = gridSpec.height / gridSpec.y;\n    let offset;\n    if (dom) {\n        const rect = dom.getBoundingClientRect();\n        offset = {x: rect.x, y: rect.y};\n    } else {\n        offset = {x: 0, y: 0};\n    }\n    return {\n        x: p.x * gridX + (gridX / 2) + offset.x,\n        y: (gridSpec.y - p.y - 1) * gridY + (gridY / 2) + offset.y\n    }\n};\n\nconst interactionBuffer = Events.select(\n    {command: \"line\", points: [], state: null},\n    Events.change(toolState), (_points, command) => {\n        return {command, points: [], state: null};\n    },\n    editorDown, (points, evt) => {\n        const shiftKey = evt.shiftKey;\n        const p = griddedMap(evt);\n        const coord = toCharCoordinates(evt);\n        const newPoints = [...points.points, p];\n        if (points.command === \"select\") {\n            return {command: \"select\", points: [], state: coord};\n        }\n        if (points.command === \"line\") {\n            if (points.points.length === 0) {\n                return {command: \"line\", points: newPoints, state: null};\n            }\n            if (points.points.length === 1) {\n                return {command: \"line\", points: [], state: newPoints, shiftKey};\n            }\n        } else if (points.command === \"arc\") {\n            if (points.points.length === 0 || points.points.length === 1) {\n                return {command: \"arc\", points: newPoints, state: null};\n            }\n            if (points.points.length === 2) {\n                return {command: \"arc\", points: [], state: newPoints, shiftKey};\n            }\n        } else if (points.command === \"delete\") {\n            return {command: \"delete\", points: [], state: [toCharCoordinates(evt)], shiftKey};\n        }\n    }\n);\n\nconst hit = (seg, p) => {\n    if (seg.command === \"line\") {\n        const threshold = 0.25;\n        const p1 = seg.start;\n        const p2 = seg.end;\n        return distance(p1, p) < threshold || distance(p2, p) < threshold;\n    } else if (seg.command === \"arc\") {\n        const threshold = 0.25;\n        const {center, start, end, radius} = seg;\n        const s = {x: Math.cos(start) * radius + center.x, y: Math.sin(start) * radius + center.y};\n        const e = {x: Math.cos(end) * radius + center.x, y: Math.sin(end) * radius + center.y};\n\n        if (distance(center, p) < threshold) {return true}\n        if (distance(s, p) < threshold) {return true}\n        if (distance(e, p) < threshold) {return true}\n    }\n    return false;\n};\n\nconst distance = (p1, p2) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\nconst rotation = (p1, p2, center, winding) => {\n    let n1 = Math.atan2(p1.y - center.y, p1.x - center.x);\n    let n2 = Math.atan2(p2.y - center.y, p2.x - center.x);\n\n    if (Math.sign(n1) !== Math.sign(n2)) {\n        n1 = Math.PI * 2 + n1;\n        n2 = Math.PI * 2 + n2;\n    }\n    let diff = n2 - n1;\n    if (diff < 0) {diff += Math.PI * 2}\n    return winding ? Math.PI * 2 - diff : diff;\n}\n\nconst lineData = (seg) => {\n    const ps = seg.state;\n    const start = ps[0];\n    const end = ps[1];\n    return {command: \"line\", start: {x: start.x, y: start.y}, end: {x: end.x, y: end.y}};\n}\n\nconst arcData = (seg) => {\n    const ps = seg.state;\n    /*\n    const center = ps[0];\n    const start = ps[1];\n    const control = ps[2];\n    */\n\n    const start = ps[0];\n    const control = ps[2];\n    const center = {x: (start.x + ps[1].x) / 2, y: (start.y + ps[1].y) / 2};\n\n    const r = distance(center, start);\n\n    const startRad = Math.atan2(start.y - center.y, start.x - center.x);\n    let endRad = Math.atan2(control.y - center.y, control.x - center.x);\n\n    if (Math.abs(startRad - endRad) < 0.001) {\n        endRad = startRad + Math.PI * 2;\n    }\n    return {command: \"arc\", center: {x: center.x, y: center.y}, radius: r, start: startRad, end: endRad};\n}\n\nconst segments = Behaviors.select(\n    [],\n    interactionBuffer, (segs, change) => {\n        const buffer = change;\n        if (!buffer.state) {return segs;}\n        if (buffer.command === \"delete\") {\n            const p = buffer.state[0];\n            for (let index = segs.length - 1; index >= 0; index--) {\n                const seg = segs[index];\n                if (hit(seg, p)) {\n                    const result = [...segs];\n                    result.splice(index, 1);\n                    return result;\n                }\n            }\n            return segs;\n        }\n\n        if (buffer.command === \"line\") {\n            return [...segs, lineData(buffer)];\n        }\n\n        if (buffer.command === \"select\") {\n            return segs;\n        }\n\n        if (buffer.command === \"arc\") {\n            return [...segs, arcData(buffer)];\n        }\n        return [...segs, buffer];\n    },\n    Events.change(charData), (segs, change) => {\n        // charData changed\n        const maybe = change.data.get(change.selected);\n        if (!maybe) {return [];}\n        return maybe;\n    },\n    dragRequest, (segs, change) => {\n        const newSegs = [...segs];\n        const newEntry = {...newSegs[change.index]};\n        if (change.segment.command === \"arc\") {\n            if (change.dragRequest === \"center\") {\n                newEntry.center = change.gridded;\n            }\n            if (change.dragRequest === \"start\") {\n                newEntry.radius = change.radius;\n                newEntry.start = change.start;\n            }\n            if (change.dragRequest === \"end\") {\n                newEntry.radius = change.radius;\n                newEntry.end = change.end;\n            }\n        }\n        if (change.segment.command === \"line\") {\n            if (change.dragRequest === \"start\") {\n                newEntry.start = {x: change.start.x, y: change.start.y};\n            }\n            if (change.dragRequest === \"end\") {\n                newEntry.end = {x: change.end.x, y: change.end.y};\n            }\n        }\n        newSegs[change.index] = newEntry;\n        return newSegs;\n    },\n    undoRequest, (segs, change) => {\n        return [...change.obj];\n    }\n);\n\nconst undoState = Behaviors.collect([], Events.or(undoRequest, Events.change(segments)), (old, segsOrUndo) => {\n    if (segsOrUndo.type === \"undo\") {\n        return old.slice(0, old.length - 1);\n    }\n    return [...old, segsOrUndo];\n});\n\nconst _undoObj = ((_ev) => {\n    if (undoState.length === 0) {return;}\n    if (undoState.length === 1) {return;}\n    Events.send(undoRequest, {type: \"undo\", obj: undoState[undoState.length - 2]});\n})(undoButton);\n\nconst maybeSelect = Behaviors.collect(null, Events.or(interactionBuffer, editorUp), (_old, buffer) => {\n    if (toolState === \"select\" && buffer.state) {\n        const p = buffer.state;\n        for (let i = segments.length - 1; i >= 0; i--) {\n            const segment = segments[i];\n            if (segment.command === \"arc\") {\n                const {start, end, radius, center} = segment;\n                const threshold = 0.25;\n                const s = {x: Math.cos(start) * radius + center.x, y: Math.sin(start) * radius + center.y};\n                const e = {x: Math.cos(end) * radius + center.x, y: Math.sin(end) * radius + center.y};\n\n                if (distance(segment.center, p) < threshold) {\n                    return {index: i, segment, type: \"center\", point: p}\n                }\n                if (distance(s, p) < threshold) {\n                    return {index: i, segment, type: \"start\", point: p}\n                }\n                if (distance(e, p) < threshold) {\n                    return {index: i, segment, type: \"end\", point: p}\n                }\n            }\n            if (segment.command === \"line\") {\n                const {start, end} = segment;\n                const threshold = 0.25;\n                if (distance(start, p) < threshold) {\n                    return {index: i, segment, type: \"start\", point: p}\n                }\n                if (distance(end, p) < threshold) {\n                    return {index: i, segment, type: \"end\", point: p}\n                }\n            }\n        }\n    }\n    return null;\n});\n\nconsole.log(maybeSelect);\n\nconst _dragObject = ((evt) => {\n    const gridded = griddedMap(evt);\n    if (!maybeSelect) {return;}\n\n    if (maybeSelect.segment.command === \"arc\") {\n        if (maybeSelect.type === \"center\") {\n            // console.log(maybeSelect);\n            const halfGridded = griddedMap(evt, true);\n            Events.send(dragRequest, {dragRequest: \"center\", ...maybeSelect, gridded: halfGridded});\n            return;\n        }\n        if (maybeSelect.type === \"start\") {\n            // console.log(\"start\", maybeSelect);\n            const {center, radius} = maybeSelect.segment;\n            const coord = toCharCoordinates(evt)\n\n            const newRadius = radius;\n            const newStart = Math.atan2(coord.y - center.y, coord.x - center.x);\n            Events.send(dragRequest, {dragRequest: \"start\", ...maybeSelect, radius: newRadius, start: newStart});\n            return;\n        }\n        if (maybeSelect.type === \"end\") {\n            // console.log(\"end\", maybeSelect);\n            const {center, radius} = maybeSelect.segment;\n            const coord = toCharCoordinates(evt)\n            const newRadius = radius;\n            const newEnd = Math.atan2(coord.y - center.y, coord.x - center.x);\n            Events.send(dragRequest, {dragRequest: \"end\", ...maybeSelect, radius: newRadius, end: newEnd});\n            return;\n        }\n    }\n    if (maybeSelect.segment.command === \"line\") {\n        if (maybeSelect.type === \"start\") {\n            Events.send(dragRequest, {dragRequest: \"start\", ...maybeSelect, start: gridded});\n            return;\n        }\n        if (maybeSelect.type === \"end\") {\n            Events.send(dragRequest, {dragRequest: \"end\", ...maybeSelect, end: gridded});\n            return;\n        }\n    }\n})(editorMove);\n\nconst makeLine = (p1, p2, html) => {\n    return html`<line x1=\"${p1.x}\" y1=\"${p1.y}\" x2=\"${p2.x}\" y2=\"${p2.y}\" stroke=\"#ddd\" stroke-width=\"${gridSpec.lineWidth}\" stroke-linecap=\"round\"></line>`;\n};\n\nconst makeArc = (start, end, center, long, sweep, html) => {\n    const r = distance(center, start);\n    if (distance(start, end) < 0.001) {\n        return makeCircle(center, start, html);\n    }\n    return html`<path d=\"M ${start.x} ${start.y} A ${r} ${r} 0 ${long ? \"1\" : \"0\"} ${sweep ? \"1\" : \"0\"} ${end.x} ${end.y}\" stroke=\"#ddd\" stroke-width=\"${gridSpec.lineWidth}\" fill=\"transparent\" stroke-linecap=\"round\"></path>`;\n};\n\nconst makeCircle = (center, p, html) => {\n    return html`<circle cx=\"${center.x}\" cy=\"${center.y}\" r=\"${distance(center, p)}\" stroke=\"#ddd\" stroke-width=\"${gridSpec.lineWidth}\" fill=\"transparent\" stroke-linecap=\"round\"></path>`;\n};\n\nconst lines = (segs) => {\n    return segs.map((seg) => {\n        if (seg.command === \"line\") {\n            const p1 = griddedUnmap(seg.start);\n            const p2 = griddedUnmap(seg.end);\n            return makeLine(p1, p2, html);\n        } if (seg.command === \"arc\") {\n            const {center, radius, start, end, shiftKey} = seg;\n\n            const s = {x: Math.cos(start) * radius + center.x, y: Math.sin(start) * radius + center.y};\n            const e = {x: Math.cos(end) * radius + center.x, y: Math.sin(end) * radius + center.y};\n\n            const rot = rotation(s, e, center);\n\n            return makeArc(griddedUnmap(s), griddedUnmap(e), griddedUnmap(center), shiftKey ? rot < Math.PI : rot > Math.PI, shiftKey, html);\n        }\n    });\n};\n\nconst linesSVG = ((segments, lines) => {\n    const ls = lines(segments);\n    return html`<svg viewBox=\"0 0 ${gridSpec.width} ${gridSpec.height}\" xmlns=\"http://www.w3.org/2000/svg\">${[...ls, rubberBandLine]}</svg>`;\n})(segments, lines);\n\nrender(linesSVG, document.querySelector(\"#editorPane2\"));\n\nconst editorDown = Events.listener(init.querySelector(\"#editorPane\"), \"pointerdown\", (evt) => evt);\nconst editorMove = Events.listener(init.querySelector(\"#editorPane\"), \"pointermove\", (evt) => evt);\nconst editorUp = Events.listener(init.querySelector(\"#editorPane\"), \"pointerup\", (evt) => evt);\n\nconst _gridMover = ((editorMove, toolState) => {\n    const gridded = toolState === \"delete\" ? toCharCoordinates(editorMove) : griddedMap(editorMove);\n    const p = griddedUnmap(gridded, document.querySelector(\"#editorPane\"));\n    const gridCursor = document.querySelector(\"#gridCursor\");\n    gridCursor.style.left = `${p.x - 5}px`;\n    gridCursor.style.top = `${p.y - 5}px`;\n})(editorMove, toolState);\n\nconst rubberBandUpdate = ((interactionBuffer, editorMove, html) => {\n    const points = interactionBuffer.points;\n    if (interactionBuffer.command === \"line\") {\n        if (points.length === 1) {\n            const p1 = griddedUnmap(points[0]);\n            const p2 = griddedUnmap(griddedMap(editorMove));\n            return makeLine(p1, p2, html);\n        }\n    } else if (interactionBuffer.command === \"arc\") {\n        if (points.length === 1) {\n            const p1 = griddedUnmap(points[0]);\n            const p2 = griddedUnmap(griddedMap(editorMove));\n            return makeLine(p1, p2, html);\n        } else if (points.length === 2) {\n\n            const start = points[0];\n            const center = {x: (start.x + points[1].x) / 2, y: (start.y + points[1].y) / 2};\n            const control = griddedMap(editorMove);\n\n            const shiftKey = editorMove.shiftKey;\n\n            const r = distance(center, start);\n            const rot = rotation(start, control, center);\n\n            const endRad = Math.atan2(control.y - center.y, control.x - center.x);\n\n            const end = {x: r * Math.cos(endRad) + center.x, y: r * Math.sin(endRad) + center.y};\n\n            return makeArc(griddedUnmap(start), griddedUnmap(end), griddedUnmap(center), shiftKey ? rot < Math.PI : rot > Math.PI, shiftKey, html);\n        }\n    }\n    return makeLine({x: -1, y: -1}, {x: -1, y: -1}, html);\n})(Behaviors.keep(interactionBuffer), editorMove, html);\n\nconst _highlightControls = ((editorMove, toolState, segments) => {\n    const highlight1 = document.querySelector(\"#highlight1\");\n    highlight1.style.display = \"none\";\n    const highlight2 = document.querySelector(\"#highlight2\");\n    highlight2.style.display = \"none\";\n    const highlight3 = document.querySelector(\"#highlight3\");\n    highlight3.style.display = \"none\";\n    if (toolState !== \"select\" && toolState !== \"delete\") {return;}\n    const p = toCharCoordinates(editorMove);\n\n    const editorPane = document.querySelector(\"#editorPane\");\n\n    for (let index = segments.length - 1; index >= 0; index--) {\n        const seg = segments[index];\n        if (hit(seg, p)) {\n            if (seg.command === \"arc\") {\n                const {start, end, radius, center} = seg;\n                const s = {x: Math.cos(start) * radius + center.x, y: Math.sin(start) * radius + center.y};\n                const e = {x: Math.cos(end) * radius + center.x, y: Math.sin(end) * radius + center.y};\n\n                let p = griddedUnmap(center,  editorPane);\n\n                highlight1.style.display = \"inherit\";\n                highlight1.style.left = `${p.x - 5}px`;\n                highlight1.style.top = `${p.y - 5}px`;\n\n                p = griddedUnmap(s,  editorPane);\n                highlight2.style.display = \"inherit\";\n                highlight2.style.left = `${p.x - 5}px`;\n                highlight2.style.top = `${p.y - 5}px`;\n\n                p = griddedUnmap(e,  editorPane);\n                highlight3.style.display = \"inherit\";\n                highlight3.style.left = `${p.x - 5}px`;\n                highlight3.style.top = `${p.y - 5}px`;\n                return;\n            } else if (seg.command === \"line\") {\n                const {start, end} = seg;\n                let p = griddedUnmap(start, editorPane);\n                highlight1.style.display = \"inherit\";\n                highlight1.style.left = `${p.x - 5}px`;\n                highlight1.style.top = `${p.y - 5}px`;\n\n                p = griddedUnmap(end, editorPane);\n                highlight2.style.display = \"inherit\";\n                highlight2.style.left = `${p.x - 5}px`;\n                highlight2.style.top = `${p.y - 5}px`;\n            }\n            return;\n        }\n    }\n    return;\n})(editorMove, toolState, segments);\n\nconst rubberBandLine = Behaviors.collect(\n    makeLine({x: 0, y: 0}, {x: 0, y: 0}, html),\n    rubberBandUpdate,\n    (_old, r) => r);\n\nconst charEntry = (i, charData, html) => {\n    const c = String.fromCharCode(i);\n    const segs = charData.data.get(c) || [];\n    const ls = lines(segs);\n    const isSelected = charData.selected === c ? \"charSelected\" : \"\";\n    return html`<div class=\"charHolder\" id=\"holder-${i}\"><div class=\"charName ${isSelected}\">${c}</div><div class=\"charView\">\n        ${html`<svg viewBox=\"0 0 ${gridSpec.width} ${gridSpec.height}\" xmlns=\"http://www.w3.org/2000/svg\">${ls}</svg>`}</div></div>`;\n}\n\nconst charList = ((html, charEntry, charData) => [...Array(96).keys()].map((i) => charEntry(i + 32, charData, html)))(html, charEntry, charData);\n\nconst charsHTML = html`<div class=\"charViews\">${charList}</div>`;\n\nconst exampleDisplay = ((charData, exampleString, html) => {\n    const result = exampleString.split(\"\").map((c) => {\n        const segs = charData.data.get(c) || [];\n        const ls = lines(segs);\n        const svg = html`<svg viewBox=\"0 0 ${gridSpec.width} ${gridSpec.height}\" xmlns=\"http://www.w3.org/2000/svg\">${ls}</svg>`;\n        return  html`<div class=\"exampleCharHolder\"><div class=\"exampleChar\">${svg}</div></div>`;\n    });\n\n    return html`<div class=\"exampleView\">${result}</div>`;\n})(charData, exampleString, html);\n\nrender(charsHTML, document.querySelector(\"#chars\"));\nrender(exampleDisplay, document.querySelector(\"#example\"));\n\nfunction makeGridCanvas(options) {\n    const {width, height, x, y, radius, canvas} = options;\n    const cellW = width / x;\n    const cellH = height / y;\n\n    const r = radius || 2;\n\n    // each cell is in the size of (cellW, cellH)\n    // the center of the dot is ((cellW/2) + i * cellW, (cellH/2) + j * cellH)\n    // where i is [0..x] and j is [0..y]\n\n    const myCanvas = canvas || document.createElement(\"canvas\");\n    myCanvas.width = width;\n    myCanvas.height = height;\n    const ctx = myCanvas.getContext(\"2d\");\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.fillStyle = \"#bbb\";\n\n    for (let j = 0; j < y; j++) {\n        for (let i = 0; i < x; i++) {\n            ctx.beginPath();\n            ctx.ellipse((cellW / 2) + i * cellW, (cellH / 2) + j * cellH, r, r, 0, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n\n    for (let j = 0; j < y; j++) {\n        ctx.fillText(`${y - 1 - j}`, 0, (cellH / 2) + j * cellH);\n    }\n    for (let i = 0; i < x; i++) {\n        ctx.fillText(`${i}`, (cellW / 2) + i * cellW, height - 5);\n    }\n    return myCanvas;\n}\n\nmakeGridCanvas({...gridSpec, canvas: document.querySelector(\"#gridCanvas\")});\n\nconst _saver = ((charData) => {\n    const data = stringify({version: 1, data: charData.data});\n    const div = document.createElement(\"a\");\n    const dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(data);\n    div.setAttribute(\"href\", dataStr);\n    div.setAttribute(\"download\", `sketchpad-font.json`);\n    div.click();\n})(charData, saveButton);\n\nconst _loader = (() => {\n    const input = document.createElement(\"div\");\n    input.innerHTML = `<input id=\"imageinput\" type=\"file\" accept=\"application/json\">`;\n    const imageInput = input.firstChild;\n\n    imageInput.onchange = () => {\n        const file = imageInput.files[0];\n        if (!file) {return;}\n        new Promise(resolve => {\n            let reader = new FileReader();\n            reader.onload = () => resolve(reader.result);\n            reader.readAsArrayBuffer(file);\n        }).then((data) => {\n            const result = new TextDecoder(\"utf-8\").decode(data);\n            Events.send(fileLoadRequest, {type: \"fileLoad\", data: parse(result)});\n        })\n        imageInput.value = \"\";\n    };\n    document.body.appendChild(imageInput);\n    imageInput.click();\n})(loadButton);\n"],["2","const gridSpec = {width: 512, height: 512, x: 16, y: 16, lineWidth: 32};\nconst exampleSettings = {advanceWidth: 200, originX: 50};\n"],["3","const css = `\n#all {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n#charEditor {\n    background-color: white;\n    display: flex;\n}\n\n#tools {\n    background-color: #888;\n    width: 64px;\n    height: 592px;\n    display: flex;\n    flex-direction: column;\n}\n\n.charHolder {\n    display: flex;\n    flex-direction: column;\n}\n\n.charName {\n    color: black;\n    height: 20px;\n    pointer-events: none;\n}\n\n.charView {\n    width: 32px;\n    height: 32px;\n    border: 1px ridge rgba(211, 220, 220, .6);\n    background-color: #222;\n    pointer-events: none;\n}\n        \n.toolButton {\n    font-size: 18px;\n    width: 56px;\n    height: 56px;\n    color: #eee;\n    text-align: center;\n    border: 4px solid #888;\n}\n\n.toolButton[toolSelected=\"true\"] {\n    background-color: #ccc;\n    border: 2px ridge rgba(120, 120, 120, .6);\n    border-radius: 4px;\n}\n\n.no-select {\n    user-select: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n}\n\n#editorPaneHolder {\n    height: 592px;\n    box-sizing: border-box;\n    display: flex;\n    flex-direction: column;\n}\n\n.zeroHeight {\n    height: 0px;\n}\n\n#editorPane {\n    background-color: transparent;\n    width: calc(512px);\n    height: calc(512px);\n    margin: 40px;\n}\n\n#editorPane2 {\n    box-sizing: border-box;\n    background-color: transparent;\n    width: calc(512px + 40px + 40px);\n    height: calc(512px + 40px + 40px);\n    border: 40px ridge rgba(211, 220, 220, .6);\n    pointer-events: none;\n}\n\n#gridCanvas {\n    box-sizing: border-box;\n    background-color: #222;\n    width: calc(512px + 40px + 40px);\n    height: calc(512px + 40px + 40px);\n    border: 40px ridge rgba(211, 220, 220, .6);\n    pointer-events: none;\n}\n\n#example {\n    background-color: #222;\n    height: 40px;\n    width: 70%;\n    margin-top: 20px;\n}\n\n.exampleView {\n    display: flex;\n}\n\n#exampleEditor {\n    margin-top: 5px;\n    margin-bottom: 20px;\n    border: 2px ridge #222;\n    width: 70%;\n}\n\n.exampleCharHolder {\n\n}\n\n.exampleChar {\n    width: 32px;\n    height: 32px;\n    border: 0px;\n    background-color: #222;\n    pointer-events: none;\n}\n    \n.charSelected {\n    background-color: #edd;\n}\n\n#chars {\n    width: 70%;\n    background-color: #ccc;\n    flex-grow: 1;\n}\n\n.charViews {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: flex-start;\n}\n\n.highlight {\n    width: 10px;\n    height: 10px;\n    background-color: #bbb;\n    position: absolute;\n    pointer-events: none;\n    transition: top 0.2s;\n    transition: left 0.2s;\n}\n\n.toDelete {\n    background-color: #b66;\n}`;\n\n((css) => {\n    const renkon = document.querySelector(\"#renkon\");\n    const style = document.createElement(\"style\");\n    style.id = \"pad-css\";\n    style.textContent = css;\n    renkon.querySelector(\"#pad-css\")?.remove();\n    renkon.appendChild(style);\n})(css);\n\n"],["4","const init = (() => {\n    const renkon = document.createElement(\"div\");\n    renkon.id = \"renkon\";\n    renkon.innerHTML = `\n<div id=\"all\">\n        <div id=\"charEditor\">\n          <div id=\"tools\">\n            <div id=\"select\" class=\"toolButton no-select\">Select</div>\n            <div id=\"line\" class=\"toolButton no-select\">Line</div>\n            <div id=\"arc\" class=\"toolButton no-select\">Arc</div>\n            <div id=\"delete\" class=\"toolButton no-select\">Delete</div>\n            <div id=\"undo\" class=\"toolButton no-select\">Undo</div>\n          </div>\n          <div id=\"editorPaneHolder\">\n              <div class=\"zeroHeight\">\n                  <canvas id=\"gridCanvas\"></canvas>\n              </div>\n              <div class=\"zeroHeight\">\n                  <div id=\"editorPane\"></div>\n              </div>\n              <div class=\"zeroHeight\">\n                  <div id=\"editorPane2\"></div>\n              </div>\n            <div id=\"gridCursor\" class=\"highlight\"></div>\n            <div id=\"highlight1\" class=\"highlight toDelete\"></div>\n            <div id=\"highlight2\" class=\"highlight toDelete\"></div>\n            <div id=\"highlight3\" class=\"highlight toDelete\"></div>\n          </div>\n          <div id=\"fileButtons\">\n              <button id=\"saveButton\">Save</button>\n              <button id=\"loadButton\">Load</button>\n          </div>\n        </div>\n        <hr>\n        <div id=\"example\"></div>\n        <div id=\"example2\"></div>\n        <div id=\"example4\"></div>\n        <div id=\"exampleEditor\" contentEditable>Hello Sketchpad!</div>\n        <hr>\n        <div id=\"chars\"></div>\n      </div>\n`.trim();\n\n    document.body.querySelector(\"#renkon\")?.remove();\n    document.body.appendChild(renkon);\n    debugger;\n    return document;\n})();"]]},"positions":{"map":{"__map":true,"values":[["1",{"height":926.35546875,"id":"1","type":"move","width":963.94921875,"x":618.3038491609235,"y":-175.8379076353923}],["2",{"height":120,"id":"2","type":"resize","width":555.62109375,"x":40,"y":40}],["3",{"height":278.85546875,"id":"3","type":"resize","width":518.14453125,"x":50.36328125,"y":197.6171875}],["4",{"height":908.3980343387511,"id":"4","type":"resize","width":783.1771550330272,"x":48.84375,"y":504.66796875}]]}},"titles":{"map":{"__map":true,"values":[["1",{"id":"1","state":false,"title":"untitled"}],["2",{"id":"2","state":false,"title":"untitled"}],["3",{"id":"3","state":false,"title":"CSS"}],["4",{"id":"4","state":false,"title":"untitled"}]]}},"version":1,"windowTypes":{"map":{"__map":true,"values":[["1","code"],["2","code"],["3","code"],["4","code"]]}},"windows":["1","2","3","4"],"zIndex":{"map":{"__map":true,"values":[["1",103],["2",100],["3",102],["4",101]]}}}
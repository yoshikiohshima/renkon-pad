var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
let rangeFrom = [], rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s2) => s2 ? parseInt(s2, 36) : 1);
  for (let i2 = 0, n2 = 0; i2 < numbers.length; i2++)
    (i2 % 2 ? rangeTo : rangeFrom).push(n2 = n2 + numbers[i2]);
})();
function isExtendingChar(code2) {
  if (code2 < 768) return false;
  for (let from = 0, to = rangeFrom.length; ; ) {
    let mid = from + to >> 1;
    if (code2 < rangeFrom[mid]) to = mid;
    else if (code2 >= rangeTo[mid]) from = mid + 1;
    else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code2) {
  return code2 >= 127462 && code2 <= 127487;
}
const ZWJ = 8205;
function findClusterBreak$1(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow$1(str.charCodeAt(pos)) && surrogateHigh$1(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt$1(str, pos);
  pos += codePointSize$1(prev);
  while (pos < str.length) {
    let next = codePointAt$1(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize$1(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i2 = pos - 2;
      while (i2 >= 0 && isRegionalIndicator(codePointAt$1(str, i2))) {
        countBefore++;
        i2 -= 2;
      }
      if (countBefore % 2 == 0) break;
      else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt$1(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh$1(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow$1(code1)) return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function surrogateLow$1(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh$1(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointSize$1(code2) {
  return code2 < 65536 ? 1 : 2;
}
class Text {
  /**
  Get the line description around the given position.
  */
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(n2) {
    if (n2 < 1 || n2 > this.lines)
      throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`);
    return this.lineInner(n2, true, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(
      0,
      from,
      parts,
      2
      /* Open.To */
    );
    if (text.length)
      text.decompose(
        0,
        text.length,
        parts,
        1 | 2
        /* Open.To */
      );
    this.decompose(
      to,
      this.length,
      parts,
      1
      /* Open.From */
    );
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  /**
  Append another document to this one.
  */
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(from, to = this.length) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
    let a2 = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start, pos = start; ; ) {
      a2.next(skip);
      b.next(skip);
      skip = 0;
      if (a2.lineBreak != b.lineBreak || a2.done != b.done || a2.value != b.value)
        return false;
      pos += a2.value.length;
      if (a2.done || pos >= end)
        return true;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null)
        to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
}
class TextLeaf extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let string2 = this.text[i2], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof TextLeaf))
      return super.replace(from, to, text);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i2 = 0; pos <= to && i2 < this.text.length; i2++) {
      let line = this.text[i2], end = pos + line.length;
      if (pos > from && i2)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new TextLeaf(part, len));
    return target;
  }
}
class TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i2 = 0; ; i2++) {
      let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i2 = 0, pos = 0; pos <= to && i2 < this.children.length; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    if (text.lines < this.lines)
      for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i2] = updated;
            return new TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to; i2++) {
      let child = this.children[i2], end = pos + child.length;
      if (pos > from && i2)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode))
      return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length = children.reduce((l2, ch) => l2 + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(
      32,
      lines >> 5
      /* Tree.BranchShift */
    ), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add2(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node2 of child.children)
          add2(node2);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add2(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to; i2++) {
    let line = text[i2], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
class RawTextCursor {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
class Line {
  /**
  @internal
  */
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function clip(text, from, to) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to))];
}
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return findClusterBreak$1(str, pos, forward, includeExtending);
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code2) {
  if (code2 <= 65535)
    return String.fromCharCode(code2);
  code2 -= 65536;
  return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
}
function codePointSize(code2) {
  return code2 < 65536 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
class ChangeDesc {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(sections) {
    this.sections = sections;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let result = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2)
      result += this.sections[i2];
    return result;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let result = 0;
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let ins = this.sections[i2 + 1];
      result += ins < 0 ? this.sections[i2] : ins;
    }
    return result;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(f2) {
    for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0) {
        f2(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(f2, individual = false) {
    iterChanges(this, f2, individual);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let sections = [];
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(from, to = from) {
    for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to; ) {
      let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  /**
  @internal
  */
  toString() {
    let result = "";
    for (let i2 = 0; i2 < this.sections.length; ) {
      let len = this.sections[i2++], ins = this.sections[i2++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a2) => typeof a2 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }
  /**
  @internal
  */
  static create(sections) {
    return new ChangeDesc(sections);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
      let len = sections[i2], ins = sections[i2 + 1];
      if (ins >= 0) {
        sections[i2] = ins;
        sections[i2 + 1] = len;
        let index = i2 >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(f2, individual = false) {
    iterChanges(this, f2, individual);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  /**
  @internal
  */
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i2 = 0, pos = 0; ; ) {
      let next = i2 == ranges.length ? 1e9 : ranges[i2++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0)
          addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i2++];
      while (pos < end) {
        if (iter.done)
          break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let parts = [];
    for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
      let len = this.sections[i2], ins = this.sections[i2 + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
    }
    return parts;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i2 = 0; i2 < json.length; i2++) {
      let part = json[i2];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e2, i3) => i3 && typeof e2 != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i2)
          inserted.push(Text.empty);
        inserted[i2] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i2].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
  /**
  @internal
  */
  static createSet(sections, inserted) {
    return new ChangeSet(sections, inserted);
  }
}
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (last >= 0 && len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f2, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
    let len = desc.sections[i2++], ins = desc.sections[i2++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i2 - 2 >> 1]);
        if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
          break;
        len = desc.sections[i2++];
        ins = desc.sections[i2++];
      }
      f2(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a2.done && b.len || b.done && a2.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a2.ins == -1 && b.ins == -1) {
      let len = Math.min(a2.len, b.len);
      addSection(sections, len, -1);
      a2.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a2.ins < 0 || inserted == a2.i || a2.off == 0 && (b.len < a2.len || b.len == a2.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a2.len, len);
        if (a2.ins >= 0 && inserted < a2.i && a2.len <= piece) {
          addSection(sections, 0, a2.ins);
          if (insert2)
            addInsert(insert2, sections, a2.text);
          inserted = a2.i;
        }
        a2.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a2.ins >= 0) {
      let len = 0, left = a2.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a2.i ? a2.ins : 0);
      if (insert2 && inserted < a2.i)
        addInsert(insert2, sections, a2.text);
      inserted = a2.i;
      a2.forward(a2.len - left);
    } else if (a2.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a2.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
    } else if (a2.ins == 0) {
      addSection(sections, a2.len, 0, open);
      a2.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a2.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a2.len2, b.len), sectionLen = sections.length;
      if (a2.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a2.off ? 0 : a2.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a2.textBit(len));
      } else {
        addSection(sections, a2.off ? 0 : a2.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a2.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a2.forward2(len);
      b.forward(len);
    }
  }
}
class SectionIter {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from, to, flags2) {
    this.from = from;
    this.to = to;
    this.flags = flags2;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? void 0 : value;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(change, assoc = -1) {
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  /**
  Compare this range to another range.
  */
  eq(other, includeAssoc = false) {
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  /**
  @internal
  */
  static create(from, to, flags2) {
    return new SelectionRange(from, to, flags2);
  }
}
class EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r2) => r2.map(change, assoc)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(other, includeAssoc = false) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i2 = 0; i2 < this.ranges.length; i2++)
      if (!this.ranges[i2].eq(other.ranges[i2], includeAssoc))
        return false;
    return true;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((r2) => r2.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map((r2) => SelectionRange.fromJSON(r2)), json.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
      let range = ranges[i2];
      if (range.empty ? range.from <= pos : range.from < pos)
        return EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags2 = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags2) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags2);
  }
  /**
  @internal
  */
  static normalized(ranges, mainIndex = 0) {
    let main = ranges[mainIndex];
    ranges.sort((a2, b) => a2.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i2 = 1; i2 < ranges.length; i2++) {
      let range = ranges[i2], prev = ranges[i2 - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from, to = Math.max(range.to, prev.to);
        if (i2 <= mainIndex)
          mainIndex--;
        ranges.splice(--i2, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
      }
    }
    return new EditorSelection(ranges, mainIndex);
  }
}
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(config2 = {}) {
    return new Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b) => a2 === b), config2.compare || (!config2.combine ? sameArray$1 : (a2, b) => a2 === b), !!config2.static, config2.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x2) => x2;
    return this.compute([field], (state) => get(state.field(field)));
  }
}
function sameArray$1(a2, b) {
  return a2 == b || a2.length == b.length && a2.every((e2, i2) => e2 === b[i2]);
}
class FacetProvider {
  constructor(dependencies2, facet, type2, value) {
    this.dependencies = dependencies2;
    this.facet = facet;
    this.type = type2;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal, oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare2) : compare2(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a2, b, compare2) {
  if (a2.length != b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!compare2(a2[i2], b[i2]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p2) => addresses[p2.id]);
  let providerTypes = providers.map((p2) => p2.type);
  let dynamic = providerAddrs.filter((p2) => !(p2 & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i2 = 0; i2 < providerAddrs.length; i2++) {
      let value = getAddr(state, providerAddrs[i2]);
      if (providerTypes[i2] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = /* @__PURE__ */ Facet.define({ static: true });
class StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(config2) {
    let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b) => a2 === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i2) => i2.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  /**
  @internal
  */
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;
        if ((reInit = init.find((i2) => i2.field == this)) && reInit != oldInit.find((i2) => i2.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
const Prec = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ prec(Prec_.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ prec(Prec_.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ prec(Prec_.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ prec(Prec_.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
}
class Compartment {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a2) => field.slot(a2));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every(
        (p2) => p2.type == 0
        /* Provider.Static */
      )) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray$1(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p2) => p2.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p2 of providers) {
          if (p2.type == 0) {
            address[p2.id] = staticValues.length << 1 | 1;
            staticValues.push(p2.value);
          } else {
            address[p2.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a2) => p2.dynamicSlot(a2));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f2) => f2(address));
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e2 of ext)
        inner(e2, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a2, b) => a2.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = /* @__PURE__ */ Facet.define();
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v2) => v2),
  static: true
});
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
const changeFilter = /* @__PURE__ */ Facet.define();
const transactionFilter = /* @__PURE__ */ Facet.define();
const transactionExtender = /* @__PURE__ */ Facet.define();
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : false
});
class Annotation {
  /**
  @internal
  */
  constructor(type2, value) {
    this.type = type2;
    this.value = value;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  /**
  Create an instance of this annotation.
  */
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  /**
  @internal
  */
  constructor(map) {
    this.map = map;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  /**
  @internal
  */
  constructor(type2, value) {
    this.type = type2;
    this.value = value;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(type2) {
    return this.type == type2;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v2) => v2));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
class Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a2) => a2.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  /**
  @internal
  */
  static create(startState, changes, selection, effects, annotations, scrollIntoView2) {
    return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView2);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(type2) {
    for (let ann of this.annotations)
      if (ann.type == type2)
        return ann.value;
    return void 0;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(event) {
    let e2 = this.annotation(Transaction.userEvent);
    return !!(e2 && (e2 == event || e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == "."));
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a2, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a2.length && (iB == b.length || b[iB] >= a2[iA])) {
      from = a2[iA++];
      to = a2[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a2, b, sequential) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a2.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a2.changes);
    mapForB = a2.changes.mapDesc(b.changes, true);
    changes = a2.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a2.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a2.annotations.length ? a2.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a2.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray$1(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray$1(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter2) {
  let s2 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter2 = false;
  for (let i2 = 1; i2 < specs.length; i2++) {
    if (specs[i2].filter === false)
      filter2 = false;
    let seq = !!specs[i2].sequential;
    s2 = mergeTransaction(s2, resolveTransactionInner(state, specs[i2], seq ? s2.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s2.changes, s2.selection, s2.effects, s2.annotations, s2.scrollIntoView);
  return extendTransaction(filter2 ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter2 of state.facet(changeFilter)) {
    let value = filter2(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i2 = filters.length - 1; i2 >= 0; i2--) {
    let filtered = filters[i2](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray$1(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
    let extension = extenders[i2](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none$2 = [];
function asArray$1(value) {
  return value == null ? none$2 : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i2 = 0; i2 < str.length; i2++) {
    let ch = str[i2];
    if (/\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i2 = 0; i2 < wordChars.length; i2++)
      if (char.indexOf(wordChars[i2]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config2, doc2, selection, values, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection;
    this.values = values;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
      ensureAddr(this, i2 << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  /**
  @internal
  */
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = /* @__PURE__ */ new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray$1(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base2, compartments, this);
      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(f2) {
    let sel = this.selection;
    let result1 = f2(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray$1(result1.effects);
    for (let i2 = 1; i2 < sel.ranges.length; i2++) {
      let result = f2(sel.ranges[i2]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i2; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray$1(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(json, config2 = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json, prop)) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(readOnly);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(phrase2, ...insert2) {
    for (let map of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
        phrase2 = map[phrase2];
        break;
      }
    if (insert2.length)
      phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m2, i2) => {
        if (i2 == "$")
          return "$";
        let n2 = +(i2 || 1);
        return !n2 || n2 > insert2.length ? m2 : insert2[n2 - 1];
      });
    return phrase2;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(name2, pos, side = -1) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from, end = pos - from;
    while (start > 0) {
      let prev = findClusterBreak(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word)
        break;
      start = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a2, b) {
    let kA = Object.keys(a2), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k) => a2[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0) ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults2)
    if (result[key] === void 0)
      result[key] = defaults2[key];
  return result;
}
class RangeValue {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(other) {
    return this == other;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(from, to = from) {
    return Range$1.create(from, to, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
let Range$1 = class Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  /**
  @internal
  */
  static create(from, to, value) {
    return new Range(from, to, value);
  }
};
function cmpRange(a2, b) {
  return a2.from - b.from || a2.value.startSide - b.value.startSide;
}
class Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f2) {
    for (let i2 = this.findIndex(from, -1e9, true), e2 = this.findIndex(to, 1e9, false, i2); i2 < e2; i2++)
      if (f2(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i2 = 0; i2 < this.value.length; i2++) {
      let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  /**
  @internal
  */
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  /**
  @internal
  */
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  /**
  @internal
  */
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(updateSpec) {
    let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter2 = updateSpec.filter;
    if (add2.length == 0 && !filter2)
      return this;
    if (sort)
      add2 = add2.slice().sort(cmpRange);
    if (this.isEmpty)
      return add2.length ? RangeSet.of(add2) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i2 < add2.length) {
      if (i2 < add2.length && (cur2.from - add2[i2].from || cur2.startSide - add2[i2].value.startSide) >= 0) {
        let range = add2[i2++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i2].from) && (!filter2 || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter2 || filterFrom > cur2.to || filterTo < cur2.from || filter2(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range$1.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter: filter2, filterFrom, filterTo }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk = this.chunk[i2];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(from, to, f2) {
    if (this.isEmpty)
      return;
    for (let i2 = 0; i2 < this.chunk.length; i2++) {
      let start = this.chunkPos[i2], chunk = this.chunk[i2];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f2) === false)
        return;
    }
    this.nextLayer.between(from, to, f2);
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a2 = oldSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a2, b, textDiff);
    let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9 - 1;
    let a2 = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a2.length != b.length)
      return false;
    if (!a2.length)
      return true;
    let sharedChunks = findSharedChunks(a2, b);
    let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor2 = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let openRanges = cursor2.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor2.to, to);
      if (cursor2.point) {
        let active = cursor2.activeForPoint(cursor2.to);
        let openCount = cursor2.pointFrom < from ? active.length + 1 : cursor2.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor2.point, active, openCount, cursor2.pointRank);
        openRanges = Math.min(cursor2.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor2.active, openRanges);
        openRanges = cursor2.openEnd(curTo);
      }
      if (cursor2.to > to)
        return openRanges + (cursor2.point && cursor2.to > to ? 1 : 0);
      pos = cursor2.to;
      cursor2.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range$1 ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(sets) {
    if (!sets.length)
      return RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i2 = sets.length - 2; i2 >= 0; i2--) {
      for (let layer2 = sets[i2]; layer2 != RangeSet.empty; layer2 = layer2.nextLayer)
        result = new RangeSet(layer2.chunkPos, layer2.chunk, result, Math.max(layer2.maxPoint, result.maxPoint));
    }
    return result;
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
      let cur2 = ranges[i2];
      if (cmpRange(prev, cur2) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur2;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  /**
  @internal
  */
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  /**
  @internal
  */
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  /**
  @internal
  */
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
}
function findSharedChunks(a2, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set of a2)
    for (let i2 = 0; i2 < set.chunk.length; i2++)
      if (set.chunk[i2].maxPoint <= 0)
        inA.set(set.chunk[i2], set.chunkPos[i2]);
  let shared = /* @__PURE__ */ new Set();
  for (let set of b)
    for (let i2 = 0; i2 < set.chunk.length; i2++) {
      let known = inA.get(set.chunk[i2]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i2].length)))
        shared.add(set.chunk[i2]);
    }
  return shared;
}
class LayerCursor {
  constructor(layer2, skip, minPoint, rank = 0) {
    this.layer = layer2;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i2 = 0; i2 < sets.length; i2++) {
      for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i2));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
      heapBubble(this.heap, i2);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index) {
  for (let cur2 = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index] = child;
    index = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i2 = 0, { value, to, rank } = this.cursor;
    while (i2 < this.activeRank.length && (rank - this.activeRank[i2] || to - this.activeTo[i2]) > 0)
      i2++;
    insert(this.active, i2, value);
    insert(this.activeTo, i2, to);
    insert(this.activeRank, i2, rank);
    if (trackOpen)
      insert(trackOpen, i2, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let a2 = this.minActive;
      if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a2] > from) {
          this.to = this.activeTo[a2];
          this.endSide = this.active[a2].endSide;
          break;
        }
        this.removeActive(a2);
        if (trackOpen)
          remove(trackOpen, a2);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i2 = trackOpen.length - 1; i2 >= 0 && trackOpen[i2] < from; i2--)
        this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
      if (this.activeRank[i2] < this.pointRank)
        break;
      if (this.activeTo[i2] > to || this.activeTo[i2] == to && this.active[i2].endSide >= this.point.endSide)
        active.push(this.active[i2]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to; i2--)
      open++;
    return open;
  }
}
function compare(a2, startA, b, startB, length, comparator) {
  a2.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let dEnd = a2.to + dPos - b.to, diff = dEnd || a2.endSide - b.endSide;
    let end = diff < 0 ? a2.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a2.point || b.point) {
      if (!(a2.point && b.point && (a2.point == b.point || a2.point.eq(b.point)) && sameValues(a2.activeForPoint(a2.to), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a2.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a2.active, b.active))
        comparator.compareRange(pos, clipEnd, a2.active, b.active);
    }
    if (end > endB)
      break;
    if ((dEnd || a2.openEnd != b.openEnd) && comparator.boundChange)
      comparator.boundChange(end);
    pos = end;
    if (diff <= 0)
      a2.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a2, b) {
  if (a2.length != b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (a2[i2] != b[i2] && !a2[i2].eq(b[i2]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i2 = index, e2 = array.length - 1; i2 < e2; i2++)
    array[i2] = array[i2 + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i2 = array.length - 1; i2 >= index; i2--)
    array[i2 + 1] = array[i2];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i2 = 0; i2 < array.length; i2++)
    if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
      found = i2;
      foundPos = array[i2];
    }
  return found;
}
function countColumn(string2, tabSize, to = string2.length) {
  let n2 = 0;
  for (let i2 = 0; i2 < to && i2 < string2.length; ) {
    if (string2.charCodeAt(i2) == 9) {
      n2 += tabSize - n2 % tabSize;
      i2++;
    } else {
      n2++;
      i2 = findClusterBreak(string2, i2);
    }
  }
  return n2;
}
function findColumn(string2, col, tabSize, strict2) {
  for (let i2 = 0, n2 = 0; ; ) {
    if (n2 >= col)
      return i2;
    if (i2 == string2.length)
      break;
    n2 += string2.charCodeAt(i2) == 9 ? tabSize - n2 % tabSize : 1;
    i2 = findClusterBreak(string2, i2);
  }
  return strict2 === true ? -1 : string2.length;
}
const State = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Annotation,
  AnnotationType,
  ChangeDesc,
  ChangeSet,
  get CharCategory() {
    return CharCategory;
  },
  Compartment,
  EditorSelection,
  EditorState,
  Facet,
  Line,
  get MapMode() {
    return MapMode;
  },
  Prec,
  Range: Range$1,
  RangeSet,
  RangeSetBuilder,
  RangeValue,
  SelectionRange,
  StateEffect,
  StateEffectType,
  StateField,
  Text,
  Transaction,
  codePointAt,
  codePointSize,
  combineConfig,
  countColumn,
  findClusterBreak,
  findColumn,
  fromCodePoint
}, Symbol.toStringTag, { value: "Module" }));
const C$1 = "ͼ";
const COUNT = typeof Symbol == "undefined" ? "__" + C$1 : Symbol.for(C$1);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null) return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b) => a2.concat(b)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l2) => "-" + l2.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join("\n");
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let id2 = top[COUNT] || 1;
    top[COUNT] = id2 + 1;
    return C$1 + id2.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(root, modules, options) {
    let set = root[SET], nonce = options && options.nonce;
    if (!set) set = new StyleSet(root, nonce);
    else if (nonce) set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules], root);
  }
}
let adoptedSet = /* @__PURE__ */ new Map();
class StyleSet {
  constructor(root, nonce) {
    let doc2 = root.ownerDocument || root, win = doc2.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc2);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc2, this);
    } else {
      this.styleTag = doc2.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i2 = 0; i2 < modules.length; i2++) {
      let mod = modules[i2], index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++)
          sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0)
        root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i2 = 0; i2 < this.modules.length; i2++)
        text += this.modules[i2].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root.head || root;
      if (this.styleTag.parentNode != target)
        target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce)
      this.styleTag.setAttribute("nonce", nonce);
  }
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$1 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i$1 = 0; i$1 < 10; i$1++) base[48 + i$1] = base[96 + i$1] = String(i$1);
for (var i$1 = 1; i$1 <= 24; i$1++) base[i$1 + 111] = "F" + i$1;
for (var i$1 = 65; i$1 <= 90; i$1++) {
  base[i$1] = String.fromCharCode(i$1 + 32);
  shift[i$1] = String.fromCharCode(i$1);
}
for (var code$1 in base) if (!shift.hasOwnProperty(code$1)) shift[code$1] = base[code$1];
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie$1 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name2 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name2 == "Esc") name2 = "Escape";
  if (name2 == "Del") name2 = "Delete";
  if (name2 == "Left") name2 = "ArrowLeft";
  if (name2 == "Up") name2 = "ArrowUp";
  if (name2 == "Right") name2 = "ArrowRight";
  if (name2 == "Down") name2 = "ArrowDown";
  return name2;
}
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i2 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name2 in next) if (Object.prototype.hasOwnProperty.call(next, name2)) {
      var value = next[name2];
      if (typeof value == "string") elt.setAttribute(name2, value);
      else if (value != null) elt[name2] = value;
    }
    i2++;
  }
  for (; i2 < arguments.length; i2++) add(elt, arguments[i2]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) ;
  else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i2 = 0; i2 < child.length; i2++) add(elt, child[i2]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
const ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser$3 = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  safari,
  safari_version: safari ? +(/* @__PURE__ */ /\bVersion\/(\d+(\.\d+)?)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
const noAttrs$1 = /* @__PURE__ */ Object.create(null);
function attrsEq(a2, b, ignore2) {
  if (a2 == b)
    return true;
  if (!a2)
    a2 = noAttrs$1;
  if (!b)
    b = noAttrs$1;
  let keysA = Object.keys(a2), keysB = Object.keys(b);
  if (keysA.length - 0 != keysB.length - 0)
    return false;
  for (let key of keysA) {
    if (key != ignore2 && (keysB.indexOf(key) == -1 || a2[key] !== b[key]))
      return false;
  }
  return true;
}
function setAttrs(dom, attrs) {
  for (let i2 = dom.attributes.length - 1; i2 >= 0; i2--) {
    let name2 = dom.attributes[i2].name;
    if (attrs[name2] == null)
      dom.removeAttribute(name2);
  }
  for (let name2 in attrs) {
    let value = attrs[name2];
    if (name2 == "style")
      dom.style.cssText = value;
    else if (dom.getAttribute(name2) != value)
      dom.setAttribute(name2, value);
  }
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs)) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = "";
        else
          dom.removeAttribute(name2);
      }
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2])) {
        changed = true;
        if (name2 == "style")
          dom.style.cssText = attrs[name2];
        else
          dom.setAttribute(name2, attrs[name2]);
      }
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0; i2 < dom.attributes.length; i2++) {
    let attr = dom.attributes[i2];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
class WidgetType {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(widget) {
    return false;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(dom, view) {
    return false;
  }
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(event) {
    return true;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(dom, pos, side) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return false;
  }
  /**
  @internal
  */
  get editable() {
    return false;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(dom) {
  }
}
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return false;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(spec) {
    let side = Math.max(-1e4, Math.min(1e4, spec.side || 0)), block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start, end } = getInclusive(spec, block);
      startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(spec) {
    return new LineDecoration(spec);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start, end } = getInclusive(spec);
    super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.attrs = spec.class && spec.attributes ? combineAttrs(spec.attributes, { class: spec.class }) : spec.class ? { class: spec.class } : spec.attributes || noAttrs$1;
  }
  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start, inclusiveEnd: end } = spec;
  if (start == null)
    start = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a2, b) {
  return a2 == b || !!(a2 && b && a2.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
class BlockWrapper extends RangeValue {
  constructor(tagName, attributes) {
    super();
    this.tagName = tagName;
    this.attributes = attributes;
  }
  eq(other) {
    return other == this || other instanceof BlockWrapper && this.tagName == other.tagName && attrsEq(this.attributes, other.attributes);
  }
  /**
  Create a block wrapper object with the given tag name and
  attributes.
  */
  static create(spec) {
    return new BlockWrapper(spec.tagName, spec.attributes || noAttrs$1);
  }
  /**
  Create a range set from the given block wrapper ranges.
  */
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
}
BlockWrapper.prototype.startSide = BlockWrapper.prototype.endSide = -1;
function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains$1(dom, node2) {
  return node2 ? dom == node2 || dom.contains(node2.nodeType != 1 ? node2.parentNode : node2) : false;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains$1(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node2, off2, targetNode, targetOff) {
  return targetNode ? scanFor(node2, off2, targetNode, targetOff, -1) || scanFor(node2, off2, targetNode, targetOff, 1) : false;
}
function domIndex(node2) {
  for (var index = 0; ; index++) {
    node2 = node2.previousSibling;
    if (!node2)
      return index;
  }
}
function isBlockElement(node2) {
  return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
}
function scanFor(node2, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node2 == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : maxOffset(node2))) {
      if (node2.nodeName == "DIV")
        return false;
      let parent = node2.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off2 = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      node2 = node2.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node2.nodeType == 1 && node2.contentEditable == "false")
        return false;
      off2 = dir < 0 ? maxOffset(node2) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function flattenRect(rect, left) {
  let x2 = left ? rect.left : rect.right;
  return { left: x2, right: x2, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
    scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
    scaleY = 1;
  return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x2, y2, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom, stop = false; cur2 && !stop; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      let scaleX = 1, scaleY = 1;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur2).position))
          stop = true;
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect2 = cur2.getBoundingClientRect();
        ({ scaleX, scaleY } = getScale(cur2, rect2));
        bounding = {
          left: rect2.left,
          right: rect2.left + cur2.clientWidth * scaleX,
          top: rect2.top,
          bottom: rect2.top + cur2.clientHeight * scaleY
        };
      }
      let moveX = 0, moveY = 0;
      if (y2 == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY)
            moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top)
            moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x2 == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX)
            moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX)
            moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x2 == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start = cur2.scrollTop;
            cur2.scrollTop += moveY / scaleY;
            movedY = (cur2.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur2.scrollLeft;
            cur2.scrollLeft += moveX / scaleX;
            movedX = (cur2.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x2 = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y2 = "nearest";
        }
      }
      if (top2)
        break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right)
        rect = {
          left: Math.max(rect.left, bounding.left),
          right: Math.min(rect.right, bounding.right),
          top: Math.max(rect.top, bounding.top),
          bottom: Math.min(rect.bottom, bounding.bottom)
        };
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc2 = dom.ownerDocument, x2, y2;
  for (let cur2 = dom.parentNode; cur2; ) {
    if (cur2 == doc2.body || x2 && y2) {
      break;
    } else if (cur2.nodeType == 1) {
      if (!y2 && cur2.scrollHeight > cur2.clientHeight)
        y2 = cur2;
      if (!x2 && cur2.scrollWidth > cur2.clientWidth)
        x2 = cur2;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
  return { x: x2, y: y2 };
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let { anchorNode, focusNode } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
if (browser$3.safari && browser$3.safari_version >= 26)
  preventScrollSupported = false;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i2 = 0; i2 < stack.length; ) {
      let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
let scratchRange;
function textRange(node2, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node2, to);
  range.setStart(node2, from);
  return range;
}
function dispatchKey(elt, name2, code2, mods) {
  let options = { key: name2, code: name2, keyCode: code2, which: code2, cancelable: true };
  if (mods)
    ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node2) {
  while (node2) {
    if (node2 && (node2.nodeType == 9 || node2.nodeType == 11 && node2.host))
      return node2;
    node2 = node2.assignedSlot || node2.parentNode;
  }
  return null;
}
function atElementStart(doc2, selection) {
  let node2 = selection.focusNode, offset = selection.focusOffset;
  if (!node2 || selection.anchorNode != node2 || selection.anchorOffset != offset)
    return false;
  offset = Math.min(offset, maxOffset(node2));
  for (; ; ) {
    if (offset) {
      if (node2.nodeType != 1)
        return false;
      let prev = node2.childNodes[offset - 1];
      if (prev.contentEditable == "false")
        offset--;
      else {
        node2 = prev;
        offset = maxOffset(node2);
      }
    } else if (node2 == doc2) {
      return true;
    } else {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node2 = startNode, offset = startOffset; ; ) {
    if (node2.nodeType == 3 && offset > 0) {
      return { node: node2, offset };
    } else if (node2.nodeType == 1 && offset > 0) {
      if (node2.contentEditable == "false")
        return null;
      node2 = node2.childNodes[offset - 1];
      offset = maxOffset(node2);
    } else if (node2.parentNode && !isBlockElement(node2)) {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node2 = startNode, offset = startOffset; ; ) {
    if (node2.nodeType == 3 && offset < node2.nodeValue.length) {
      return { node: node2, offset };
    } else if (node2.nodeType == 1 && offset < node2.childNodes.length) {
      if (node2.contentEditable == "false")
        return null;
      node2 = node2.childNodes[offset];
      offset = 0;
    } else if (node2.parentNode && !isBlockElement(node2)) {
      offset = domIndex(node2) + 1;
      node2 = node2.parentNode;
    } else {
      return null;
    }
  }
}
class DOMPos {
  constructor(node2, offset, precise = true) {
    this.node = node2;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i2 = 0; i2 < str.length; i2++)
    result.push(1 << +str[i2]);
  return result;
}
const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
for (let p2 of ["()", "[]", "{}"]) {
  let l2 = /* @__PURE__ */ p2.charCodeAt(0), r2 = /* @__PURE__ */ p2.charCodeAt(1);
  Brackets[l2] = r2;
  Brackets[r2] = -l2;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8204 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  /**
  @internal
  */
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  /**
  @internal
  */
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  /**
  @internal
  */
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i2 = 0; i2 < order.length; i2++) {
      let span = order[i2];
      if (span.from <= index && span.to >= index) {
        if (span.level == level)
          return i2;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
          maybe = i2;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
}
function isolatesEq(a2, b) {
  if (a2.length != b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    let iA = a2[i2], iB = b[i2];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
      return false;
  }
  return true;
}
const types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to; i2++) {
      let type2 = charType(line.charCodeAt(i2));
      if (type2 == 512)
        type2 = prev;
      else if (type2 == 8 && prevStrong == 4)
        type2 = 16;
      types[i2] = type2 == 4 ? 2 : type2;
      if (type2 & 7)
        prevStrong = type2;
      prev = type2;
    }
    for (let i2 = from, prev = prevType, prevStrong = prevType; i2 < to; i2++) {
      let type2 = types[i2];
      if (type2 == 128) {
        if (i2 < to - 1 && prev == types[i2 + 1] && prev & 24)
          type2 = types[i2] = prev;
        else
          types[i2] = 256;
      } else if (type2 == 64) {
        let end = i2 + 1;
        while (end < to && types[end] == 64)
          end++;
        let replace2 = i2 && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end; j++)
          types[j] = replace2;
        i2 = end - 1;
      } else if (type2 == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev = type2;
      if (type2 & 7)
        prevStrong = type2;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from, ch, br, type2; i2 < to; i2++) {
      if (br = Brackets[ch = line.charCodeAt(i2)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags2 = BracketStack[sJ + 2];
              let type3 = flags2 & 2 ? outerType : !(flags2 & 4) ? 0 : flags2 & 1 ? oppositeType : outerType;
              if (type3)
                types[i2] = types[BracketStack[sJ]] = type3;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type2 = types[i2]) == 2 || type2 == 1) {
        let embed = type2 == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i2 = from; i2 < to; ) {
      let type2 = types[i2];
      if (type2 == 256) {
        let end = i2 + 1;
        for (; ; ) {
          if (end == to) {
            if (iI == isolates.length)
              break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i2; ) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace2;
        }
        i2 = end;
      } else {
        prev = type2;
        i2++;
      }
    }
  }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to; ) {
      let sameDir = true, isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum)
            break run;
          let iso = isolates[iI];
          if (!sameDir)
            for (let upto = iso.to, jI = iI + 1; ; ) {
              if (upto == to)
                break run;
              if (jI < isolates.length && isolates[jI].from == upto)
                upto = isolates[jI++].to;
              else if (types[upto] == ourType)
                break run;
              else
                break;
            }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh)
              order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse)
        emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
      else if (iCh < iScan)
        order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from; ) {
      let sameDir = true, isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (; ; ) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum)
            break run;
          let iso = isolates[--iI];
          if (!sameDir)
            for (let upto = iso.from, jI = iI; ; ) {
              if (upto == from)
                break run;
              if (jI && isolates[jI - 1].to == upto)
                upto = isolates[--jI].from;
              else if (types[upto - 1] == ourType)
                break run;
              else
                break;
            }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh)
              order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse)
        emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
      else if (iScan < iCh)
        order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to, isolates, outerType);
  processBracketPairs(line, from, to, isolates, outerType);
  processNeutrals(from, to, isolates, outerType);
  emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line)
    return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line))
    return trivialOrder(line.length);
  if (isolates.length)
    while (line.length > types.length)
      types[types.length] = 256;
  let order = [], level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a2;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
  let span = order[spanI], spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length)
      return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to)
    nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
  for (let i2 = from; i2 < to; i2++) {
    let type2 = charType(text.charCodeAt(i2));
    if (type2 == 1)
      return LTR;
    if (type2 == 2 || type2 == 4)
      return RTL;
  }
  return LTR;
}
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
const exceptionSink = /* @__PURE__ */ Facet.define();
const updateListener = /* @__PURE__ */ Facet.define();
const inputHandler$1 = /* @__PURE__ */ Facet.define();
const focusChangeEffect = /* @__PURE__ */ Facet.define();
const clipboardInputFilter = /* @__PURE__ */ Facet.define();
const clipboardOutputFilter = /* @__PURE__ */ Facet.define();
const perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x2) => x2)
});
const nativeSelectionHidden = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x2) => x2)
});
const scrollHandler = /* @__PURE__ */ Facet.define();
class ScrollTarget {
  constructor(range, y2 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5, isSnapshot = false) {
    this.range = range;
    this.y = y2;
    this.x = x2;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const scrollIntoView$1 = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
const setEditContextFormatting = /* @__PURE__ */ StateEffect.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror && window.onerror(String(exception), context, void 0, void 0, exception)) ;
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
const editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /* @__PURE__ */ Facet.define({
  combine(plugins) {
    return plugins.filter((p2, i2) => {
      for (let j = 0; j < i2; j++)
        if (plugins[j].plugin == p2.plugin)
          return false;
      return true;
    });
  }
});
class ViewPlugin {
  constructor(id2, create, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id2;
    this.create = create;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.baseExtensions = buildExtensions(this);
    this.extension = this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(arg) {
    return this.baseExtensions.concat(viewPlugin.of({ plugin: this, arg }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(create, spec) {
    const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
    return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin2) => {
      let ext = [];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin2);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin2));
      return ext;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(cls, spec) {
    return ViewPlugin.define((view, arg) => new cls(view, arg), spec);
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.plugin.create(view, this.spec.arg);
        } catch (e2) {
          logException(view.state, e2, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e2) {
          logException(update.state, e2, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e2) {
        logException(view.state, e2, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define();
const contentAttributes = /* @__PURE__ */ Facet.define();
const decorations = /* @__PURE__ */ Facet.define();
const blockWrappers = /* @__PURE__ */ Facet.define();
const outerDecorations = /* @__PURE__ */ Facet.define();
const atomicRanges = /* @__PURE__ */ Facet.define();
const bidiIsolatedRanges = /* @__PURE__ */ Facet.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length)
    return isolates;
  let sets = isolates.map((i2) => i2 instanceof Function ? i2(view) : i2);
  let result = [];
  RangeSet.spans(sets, line.from, line.to, {
    point() {
    },
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from, to = toDoc - line.from;
      let level = result;
      for (let i2 = active.length - 1; i2 >= 0; i2--, open--) {
        let direction = active[i2].spec.bidiIsolate, update;
        if (direction == null)
          direction = autoDirection(line.text, from, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add2 = { from, to, direction, inner: [] };
          level.push(add2);
          level = add2.inner;
        }
      }
    }
  });
  return result;
}
const scrollMargins = /* @__PURE__ */ Facet.define();
function getScrollMargins(view) {
  let left = 0, right = 0, top2 = 0, bottom = 0;
  for (let source of view.state.facet(scrollMargins)) {
    let m2 = source(view);
    if (m2) {
      if (m2.left != null)
        left = Math.max(left, m2.left);
      if (m2.right != null)
        right = Math.max(right, m2.right);
      if (m2.top != null)
        top2 = Math.max(top2, m2.top);
      if (m2.bottom != null)
        bottom = Math.max(bottom, m2.bottom);
    }
  }
  return { left, right, top: top2, bottom };
}
const styleModule = /* @__PURE__ */ Facet.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i2 = set.length, me = this;
    for (; i2 > 0; i2--) {
      let range = set[i2 - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i2 - 1, 1);
    }
    set.splice(i2, 0, me);
    return set;
  }
  // Extend a set to cover all the content in `ranges`, which is a
  // flat array with each pair of numbers representing fromB/toB
  // positions. These pairs are generated in unchanged ranges, so the
  // offset between doc A and doc B is the same for their start and
  // end points.
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, off2 = 0; ; ) {
      let nextD = dI < diff.length ? diff[dI].fromB : 1e9;
      let nextR = rI < ranges.length ? ranges[rI] : 1e9;
      let fromB = Math.min(nextD, nextR);
      if (fromB == 1e9)
        break;
      let fromA = fromB + off2, toB = fromB, toA = fromA;
      for (; ; ) {
        if (rI < ranges.length && ranges[rI] <= toB) {
          let end = ranges[rI + 1];
          rI += 2;
          toB = Math.max(toB, end);
          for (let i2 = dI; i2 < diff.length && diff[i2].fromB <= toB; i2++)
            off2 = diff[i2].toA - diff[i2].toB;
          toA = Math.max(toA, end + off2);
        } else if (dI < diff.length && diff[dI].fromB <= toB) {
          let next = diff[dI++];
          toB = Math.max(toB, next.toB);
          toA = Math.max(toA, next.toA);
          off2 = next.toA - next.toB;
        } else {
          break;
        }
      }
      result.push(new ChangedRange(fromA, toA, fromB, toB));
    }
    return result;
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  /**
  @internal
  */
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
const noChildren = [];
class Tile {
  constructor(dom, length, flags2 = 0) {
    this.dom = dom;
    this.length = length;
    this.flags = flags2;
    this.parent = null;
    dom.cmTile = this;
  }
  get breakAfter() {
    return this.flags & 1;
  }
  get children() {
    return noChildren;
  }
  isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  isComposite() {
    return false;
  }
  isLine() {
    return false;
  }
  isText() {
    return false;
  }
  isBlock() {
    return false;
  }
  get domAttrs() {
    return null;
  }
  sync(track) {
    this.flags |= 2;
    if (this.flags & 4) {
      this.flags &= -5;
      let attrs = this.domAttrs;
      if (attrs)
        setAttrs(this.dom, attrs);
    }
  }
  toString() {
    return this.constructor.name + (this.children.length ? `(${this.children})` : "") + (this.breakAfter ? "#" : "");
  }
  destroy() {
    this.parent = null;
  }
  setDOM(dom) {
    this.dom = dom;
    dom.cmTile = this;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(tile, start = this.posAtStart) {
    let pos = start;
    for (let child of this.children) {
      if (child == tile)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(tile) {
    return this.posBefore(tile) + tile.length;
  }
  covers(side) {
    return true;
  }
  coordsIn(pos, side) {
    return null;
  }
  domPosFor(off2, side) {
    let index = domIndex(this.dom);
    let after = this.length ? off2 > 0 : side > 0;
    return new DOMPos(this.parent.dom, index + (after ? 1 : 0), off2 == 0 || off2 == this.length);
  }
  markDirty(attrs) {
    this.flags &= -3;
    if (attrs)
      this.flags |= 4;
    if (this.parent && this.parent.flags & 2)
      this.parent.markDirty(false);
  }
  get overrideDOMText() {
    return null;
  }
  get root() {
    for (let t2 = this; t2; t2 = t2.parent)
      if (t2 instanceof DocTile)
        return t2;
    return null;
  }
  static get(dom) {
    return dom.cmTile;
  }
}
class CompositeTile extends Tile {
  constructor(dom) {
    super(dom, 0);
    this._children = [];
  }
  isComposite() {
    return true;
  }
  get children() {
    return this._children;
  }
  get lastChild() {
    return this.children.length ? this.children[this.children.length - 1] : null;
  }
  append(child) {
    this.children.push(child);
    child.parent = this;
  }
  sync(track) {
    if (this.flags & 2)
      return;
    super.sync(track);
    let parent = this.dom, prev = null, next;
    let tracking = (track === null || track === void 0 ? void 0 : track.node) == parent ? track : null;
    let length = 0;
    for (let child of this.children) {
      child.sync(track);
      length += child.length + child.breakAfter;
      next = prev ? prev.nextSibling : parent.firstChild;
      if (tracking && next != child.dom)
        tracking.written = true;
      if (child.dom.parentNode == parent) {
        while (next && next != child.dom)
          next = rm$1(next);
      } else {
        parent.insertBefore(child.dom, next);
      }
      prev = child.dom;
    }
    next = prev ? prev.nextSibling : parent.firstChild;
    if (tracking && next)
      tracking.written = true;
    while (next)
      next = rm$1(next);
    this.length = length;
  }
}
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class DocTile extends CompositeTile {
  constructor(view, dom) {
    super(dom);
    this.view = view;
  }
  owns(tile) {
    for (; tile; tile = tile.parent)
      if (tile == this)
        return true;
    return false;
  }
  isBlock() {
    return true;
  }
  nearest(dom) {
    for (; ; ) {
      if (!dom)
        return null;
      let tile = Tile.get(dom);
      if (tile && this.owns(tile))
        return tile;
      dom = dom.parentNode;
    }
  }
  blockTiles(f2) {
    for (let stack = [], cur2 = this, i2 = 0, pos = 0; ; ) {
      if (i2 == cur2.children.length) {
        if (!stack.length)
          return;
        cur2 = cur2.parent;
        if (cur2.breakAfter)
          pos++;
        i2 = stack.pop();
      } else {
        let next = cur2.children[i2++];
        if (next instanceof BlockWrapperTile) {
          stack.push(i2);
          cur2 = next;
          i2 = 0;
        } else {
          let end = pos + next.length;
          let result = f2(next, pos);
          if (result !== void 0)
            return result;
          pos = end + next.breakAfter;
        }
      }
    }
  }
  // Find the block at the given position. If side < -1, make sure to
  // stay before block widgets at that position, if side > 1, after
  // such widgets (used for selection drawing, which needs to be able
  // to get coordinates for positions that aren't valid cursor positions).
  resolveBlock(pos, side) {
    let before, beforeOff = -1, after, afterOff = -1;
    this.blockTiles((tile, off2) => {
      let end = off2 + tile.length;
      if (pos >= off2 && pos <= end) {
        if (tile.isWidget() && side >= -1 && side <= 1) {
          if (tile.flags & 32)
            return true;
          if (tile.flags & 16)
            before = void 0;
        }
        if ((off2 < pos || pos == end && (side < -1 ? tile.length : tile.covers(1))) && (!before || !tile.isWidget() && before.isWidget())) {
          before = tile;
          beforeOff = pos - off2;
        }
        if ((end > pos || pos == off2 && (side > 1 ? tile.length : tile.covers(-1))) && (!after || !tile.isWidget() && after.isWidget())) {
          after = tile;
          afterOff = pos - off2;
        }
      }
    });
    if (!before && !after)
      throw new Error("No tile at position " + pos);
    return before && side < 0 || !after ? { tile: before, offset: beforeOff } : { tile: after, offset: afterOff };
  }
}
class BlockWrapperTile extends CompositeTile {
  constructor(dom, wrapper) {
    super(dom);
    this.wrapper = wrapper;
  }
  isBlock() {
    return true;
  }
  covers(side) {
    if (!this.children.length)
      return false;
    return side < 0 ? this.children[0].covers(-1) : this.lastChild.covers(1);
  }
  get domAttrs() {
    return this.wrapper.attributes;
  }
  static of(wrapper, dom) {
    let tile = new BlockWrapperTile(dom || document.createElement(wrapper.tagName), wrapper);
    if (!dom)
      tile.flags |= 4;
    return tile;
  }
}
class LineTile extends CompositeTile {
  constructor(dom, attrs) {
    super(dom);
    this.attrs = attrs;
  }
  isLine() {
    return true;
  }
  static start(attrs, dom, keepAttrs) {
    let line = new LineTile(dom || document.createElement("div"), attrs);
    if (!dom || !keepAttrs)
      line.flags |= 4;
    return line;
  }
  get domAttrs() {
    return this.attrs;
  }
  // Find the tile associated with a given position in this line.
  resolveInline(pos, side, forCoords) {
    let before = null, beforeOff = -1, after = null, afterOff = -1;
    function scan(tile, pos2) {
      for (let i2 = 0, off2 = 0; i2 < tile.children.length && off2 <= pos2; i2++) {
        let child = tile.children[i2], end = off2 + child.length;
        if (end >= pos2) {
          if (child.isComposite()) {
            scan(child, pos2 - off2);
          } else if ((!after || after.isHidden && (side > 0 || forCoords && onSameLine(after, child))) && (end > pos2 || child.flags & 32)) {
            after = child;
            afterOff = pos2 - off2;
          } else if (off2 < pos2 || child.flags & 16 && !child.isHidden) {
            before = child;
            beforeOff = pos2 - off2;
          }
        }
        off2 = end;
      }
    }
    scan(this, pos);
    let target = (side < 0 ? before : after) || before || after;
    return target ? { tile: target, offset: target == before ? beforeOff : afterOff } : null;
  }
  coordsIn(pos, side) {
    let found = this.resolveInline(pos, side, true);
    if (!found)
      return fallbackRect(this);
    return found.tile.coordsIn(Math.max(0, found.offset), side);
  }
  domIn(pos, side) {
    let found = this.resolveInline(pos, side);
    if (found) {
      let { tile, offset } = found;
      if (this.dom.contains(tile.dom)) {
        if (tile.isText())
          return new DOMPos(tile.dom, Math.min(tile.dom.nodeValue.length, offset));
        return tile.domPosFor(offset, tile.flags & 16 ? 1 : tile.flags & 32 ? -1 : side);
      }
      let parent = found.tile.parent, saw = false;
      for (let ch of parent.children) {
        if (saw)
          return new DOMPos(ch.dom, 0);
        if (ch == found.tile) {
          saw = true;
        }
      }
    }
    return new DOMPos(this.dom, 0);
  }
}
function fallbackRect(tile) {
  let last = tile.dom.lastChild;
  if (!last)
    return tile.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function onSameLine(a2, b) {
  let posA = a2.coordsIn(0, 1), posB = b.coordsIn(0, 1);
  return posA && posB && posB.top < posA.bottom;
}
class MarkTile extends CompositeTile {
  constructor(dom, mark) {
    super(dom);
    this.mark = mark;
  }
  get domAttrs() {
    return this.mark.attrs;
  }
  static of(mark, dom) {
    let tile = new MarkTile(dom || document.createElement(mark.tagName), mark);
    if (!dom)
      tile.flags |= 4;
    return tile;
  }
}
class TextTile extends Tile {
  constructor(dom, text) {
    super(dom, text.length);
    this.text = text;
  }
  sync(track) {
    if (this.flags & 2)
      return;
    super.sync(track);
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  isText() {
    return true;
  }
  toString() {
    return JSON.stringify(this.text);
  }
  coordsIn(pos, side) {
    let length = this.dom.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten2 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser$3.chrome || browser$3.gecko)) {
        if (pos) {
          from--;
          flatten2 = 1;
        } else if (to < length) {
          to++;
          flatten2 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(this.dom, from, to).getClientRects();
    if (!rects.length)
      return null;
    let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser$3.safari && !flatten2 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect;
    return flatten2 ? flattenRect(rect, flatten2 < 0) : rect || null;
  }
  static of(text, dom) {
    let tile = new TextTile(dom || document.createTextNode(text), text);
    if (!dom)
      tile.flags |= 2;
    return tile;
  }
}
class WidgetTile extends Tile {
  constructor(dom, length, widget, flags2) {
    super(dom, length, flags2);
    this.widget = widget;
  }
  isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  covers(side) {
    if (this.flags & 48)
      return false;
    return (this.flags & (side < 0 ? 64 : 128)) > 0;
  }
  coordsIn(pos, side) {
    return this.coordsInWidget(pos, side, false);
  }
  coordsInWidget(pos, side, block) {
    let custom2 = this.widget.coordsAt(this.dom, pos, side);
    if (custom2)
      return custom2;
    if (block) {
      return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
    } else {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return null;
      let fromBack = this.flags & 16 ? true : this.flags & 32 ? false : pos > 0;
      for (let i2 = fromBack ? rects.length - 1 : 0; ; i2 += fromBack ? -1 : 1) {
        rect = rects[i2];
        if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return flattenRect(rect, !fromBack);
    }
  }
  get overrideDOMText() {
    if (!this.length)
      return Text.empty;
    let { root } = this;
    if (!root)
      return Text.empty;
    let start = this.posAtStart;
    return root.view.state.doc.slice(start, start + this.length);
  }
  destroy() {
    super.destroy();
    this.widget.destroy(this.dom);
  }
  static of(widget, view, length, flags2, dom) {
    if (!dom) {
      dom = widget.toDOM(view);
      if (!widget.editable)
        dom.contentEditable = "false";
    }
    return new WidgetTile(dom, length, widget, flags2);
  }
}
class WidgetBufferTile extends Tile {
  constructor(flags2) {
    let img = document.createElement("img");
    img.className = "cm-widgetBuffer";
    img.setAttribute("aria-hidden", "true");
    super(img, 0, flags2);
  }
  get isHidden() {
    return false;
  }
  get overrideDOMText() {
    return Text.empty;
  }
  coordsIn(pos) {
    return this.dom.getBoundingClientRect();
  }
}
class TilePointer {
  constructor(top2) {
    this.index = 0;
    this.beforeBreak = false;
    this.parents = [];
    this.tile = top2;
  }
  // Advance by the given distance. If side is -1, stop leaving or
  // entering tiles, or skipping zero-length tiles, once the distance
  // has been traversed. When side is 1, leave, enter, or skip
  // everything at the end position.
  advance(dist2, side, walker) {
    let { tile, index, beforeBreak, parents } = this;
    while (dist2 || side > 0) {
      if (!tile.isComposite()) {
        if (index == tile.length) {
          beforeBreak = !!tile.breakAfter;
          ({ tile, index } = parents.pop());
          index++;
        } else if (!dist2) {
          break;
        } else {
          let take = Math.min(dist2, tile.length - index);
          if (walker)
            walker.skip(tile, index, index + take);
          dist2 -= take;
          index += take;
        }
      } else if (beforeBreak) {
        if (!dist2)
          break;
        if (walker)
          walker.break();
        dist2--;
        beforeBreak = false;
      } else if (index == tile.children.length) {
        if (!dist2 && !parents.length)
          break;
        if (walker)
          walker.leave(tile);
        beforeBreak = !!tile.breakAfter;
        ({ tile, index } = parents.pop());
        index++;
      } else {
        let next = tile.children[index], brk = next.breakAfter;
        if ((side > 0 ? next.length <= dist2 : next.length < dist2) && (!walker || walker.skip(next, 0, next.length) !== false || !next.isComposite)) {
          beforeBreak = !!brk;
          index++;
          dist2 -= next.length;
        } else {
          parents.push({ tile, index });
          tile = next;
          index = 0;
          if (walker && next.isComposite())
            walker.enter(next);
        }
      }
    }
    this.tile = tile;
    this.index = index;
    this.beforeBreak = beforeBreak;
    return this;
  }
  get root() {
    return this.parents.length ? this.parents[0].tile : this.tile;
  }
}
class OpenWrapper {
  constructor(from, to, wrapper, rank) {
    this.from = from;
    this.to = to;
    this.wrapper = wrapper;
    this.rank = rank;
  }
}
class TileBuilder {
  constructor(cache2, root, blockWrappers2) {
    this.cache = cache2;
    this.root = root;
    this.blockWrappers = blockWrappers2;
    this.curLine = null;
    this.lastBlock = null;
    this.afterWidget = null;
    this.pos = 0;
    this.wrappers = [];
    this.wrapperPos = 0;
  }
  addText(text, marks, openStart, tile) {
    var _a2;
    this.flushBuffer();
    let parent = this.ensureMarks(marks, openStart);
    let prev = parent.lastChild;
    if (prev && prev.isText() && !(prev.flags & 8)) {
      this.cache.reused.set(
        prev,
        2
        /* Reused.DOM */
      );
      let tile2 = parent.children[parent.children.length - 1] = new TextTile(prev.dom, prev.text + text);
      tile2.parent = parent;
    } else {
      parent.append(tile || TextTile.of(text, (_a2 = this.cache.find(TextTile)) === null || _a2 === void 0 ? void 0 : _a2.dom));
    }
    this.pos += text.length;
    this.afterWidget = null;
  }
  addComposition(composition, context) {
    let line = this.curLine;
    if (line.dom != context.line.dom) {
      line.setDOM(this.cache.reused.has(context.line) ? freeNode(context.line.dom) : context.line.dom);
      this.cache.reused.set(
        context.line,
        2
        /* Reused.DOM */
      );
    }
    let head = line;
    for (let i2 = context.marks.length - 1; i2 >= 0; i2--) {
      let mark = context.marks[i2];
      let last = head.lastChild;
      if (last instanceof MarkTile && last.mark.eq(mark.mark)) {
        if (last.dom != mark.dom)
          last.setDOM(freeNode(mark.dom));
        head = last;
      } else {
        if (this.cache.reused.get(mark)) {
          let tile = Tile.get(mark.dom);
          if (tile)
            tile.setDOM(freeNode(mark.dom));
        }
        let nw = MarkTile.of(mark.mark, mark.dom);
        head.append(nw);
        head = nw;
      }
      this.cache.reused.set(
        mark,
        2
        /* Reused.DOM */
      );
    }
    let text = new TextTile(composition.text, composition.text.nodeValue);
    text.flags |= 8;
    head.append(text);
  }
  addInlineWidget(widget, marks, openStart) {
    let noSpace = this.afterWidget && widget.flags & 48 && (this.afterWidget.flags & 48) == (widget.flags & 48);
    if (!noSpace)
      this.flushBuffer();
    let parent = this.ensureMarks(marks, openStart);
    if (!noSpace && !(widget.flags & 16))
      parent.append(this.getBuffer(1));
    parent.append(widget);
    this.pos += widget.length;
    this.afterWidget = widget;
  }
  addMark(tile, marks, openStart) {
    this.flushBuffer();
    let parent = this.ensureMarks(marks, openStart);
    parent.append(tile);
    this.pos += tile.length;
    this.afterWidget = null;
  }
  addBlockWidget(widget) {
    this.getBlockPos().append(widget);
    this.pos += widget.length;
    this.lastBlock = widget;
    this.endLine();
  }
  continueWidget(length) {
    let widget = this.afterWidget || this.lastBlock;
    widget.length += length;
    this.pos += length;
  }
  addLineStart(attrs, dom) {
    var _a2;
    if (!attrs)
      attrs = lineBaseAttrs;
    let tile = LineTile.start(attrs, dom || ((_a2 = this.cache.find(LineTile)) === null || _a2 === void 0 ? void 0 : _a2.dom), !!dom);
    this.getBlockPos().append(this.lastBlock = this.curLine = tile);
  }
  addLine(tile) {
    this.getBlockPos().append(tile);
    this.pos += tile.length;
    this.lastBlock = tile;
    this.endLine();
  }
  addBreak() {
    this.lastBlock.flags |= 1;
    this.endLine();
    this.pos++;
  }
  addLineStartIfNotCovered(attrs) {
    if (!this.blockPosCovered())
      this.addLineStart(attrs);
  }
  ensureLine(attrs) {
    if (!this.curLine)
      this.addLineStart(attrs);
  }
  ensureMarks(marks, openStart) {
    var _a2;
    let parent = this.curLine;
    for (let i2 = marks.length - 1; i2 >= 0; i2--) {
      let mark = marks[i2], last;
      if (openStart > 0 && (last = parent.lastChild) && last instanceof MarkTile && last.mark.eq(mark)) {
        parent = last;
        openStart--;
      } else {
        let tile = MarkTile.of(mark, (_a2 = this.cache.find(MarkTile, (m2) => m2.mark.eq(mark))) === null || _a2 === void 0 ? void 0 : _a2.dom);
        parent.append(tile);
        parent = tile;
        openStart = 0;
      }
    }
    return parent;
  }
  endLine() {
    if (this.curLine) {
      this.flushBuffer();
      let last = this.curLine.lastChild;
      if (!last || !hasContent(this.curLine, false) || last.dom.nodeName != "BR" && last.isWidget() && !(browser$3.ios && hasContent(this.curLine, true)))
        this.curLine.append(this.cache.findWidget(
          BreakWidget,
          0,
          32
          /* TileFlag.After */
        ) || new WidgetTile(
          BreakWidget.toDOM(),
          0,
          BreakWidget,
          32
          /* TileFlag.After */
        ));
      this.curLine = this.afterWidget = null;
    }
  }
  updateBlockWrappers() {
    if (this.wrapperPos > this.pos + 1e4) {
      this.blockWrappers.goto(this.pos);
      this.wrappers.length = 0;
    }
    for (let i2 = this.wrappers.length - 1; i2 >= 0; i2--)
      if (this.wrappers[i2].to < this.pos)
        this.wrappers.splice(i2, 1);
    for (let cur2 = this.blockWrappers; cur2.value && cur2.from <= this.pos; cur2.next())
      if (cur2.to >= this.pos) {
        let wrap = new OpenWrapper(cur2.from, cur2.to, cur2.value, cur2.rank), i2 = this.wrappers.length;
        while (i2 > 0 && (this.wrappers[i2 - 1].rank - wrap.rank || this.wrappers[i2 - 1].to - wrap.to) < 0)
          i2--;
        this.wrappers.splice(i2, 0, wrap);
      }
    this.wrapperPos = this.pos;
  }
  getBlockPos() {
    var _a2;
    this.updateBlockWrappers();
    let parent = this.root;
    for (let wrap of this.wrappers) {
      let last = parent.lastChild;
      if (wrap.from < this.pos && last instanceof BlockWrapperTile && last.wrapper.eq(wrap.wrapper)) {
        parent = last;
      } else {
        let tile = BlockWrapperTile.of(wrap.wrapper, (_a2 = this.cache.find(BlockWrapperTile, (t2) => t2.wrapper.eq(wrap.wrapper))) === null || _a2 === void 0 ? void 0 : _a2.dom);
        parent.append(tile);
        parent = tile;
      }
    }
    return parent;
  }
  blockPosCovered() {
    let last = this.lastBlock;
    return last != null && !last.breakAfter && (!last.isWidget() || (last.flags & (32 | 128)) > 0);
  }
  getBuffer(side) {
    let flags2 = 2 | (side < 0 ? 16 : 32);
    let found = this.cache.find(
      WidgetBufferTile,
      void 0,
      1
      /* Reused.Full */
    );
    if (found)
      found.flags = flags2;
    return found || new WidgetBufferTile(flags2);
  }
  flushBuffer() {
    if (this.afterWidget && !(this.afterWidget.flags & 32)) {
      this.afterWidget.parent.append(this.getBuffer(-1));
      this.afterWidget = null;
    }
  }
}
class TextStream {
  constructor(doc2) {
    this.skipCount = 0;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
  }
  skip(len) {
    if (this.textOff + len <= this.text.length) {
      this.textOff += len;
    } else {
      this.skipCount += len - (this.text.length - this.textOff);
      this.text = "";
      this.textOff = 0;
    }
  }
  next(maxLen2) {
    if (this.textOff == this.text.length) {
      let { value, lineBreak, done } = this.cursor.next(this.skipCount);
      this.skipCount = 0;
      if (done)
        throw new Error("Ran out of text content when drawing inline views");
      this.text = value;
      let len = this.textOff = Math.min(maxLen2, value.length);
      return lineBreak ? null : value.slice(0, len);
    }
    let end = Math.min(this.text.length, this.textOff + maxLen2);
    let chars = this.text.slice(this.textOff, end);
    this.textOff = end;
    return chars;
  }
}
const buckets = [WidgetTile, LineTile, TextTile, MarkTile, WidgetBufferTile, BlockWrapperTile, DocTile];
for (let i2 = 0; i2 < buckets.length; i2++)
  buckets[i2].bucket = i2;
class TileCache {
  constructor(view) {
    this.view = view;
    this.buckets = buckets.map(() => []);
    this.index = buckets.map(() => 0);
    this.reused = /* @__PURE__ */ new Map();
  }
  // Put a tile in the cache.
  add(tile) {
    let i2 = tile.constructor.bucket, bucket = this.buckets[i2];
    if (bucket.length < 6)
      bucket.push(tile);
    else
      bucket[
        this.index[i2] = (this.index[i2] + 1) % 6
        /* C.Bucket */
      ] = tile;
  }
  find(cls, test, type2 = 2) {
    let i2 = cls.bucket;
    let bucket = this.buckets[i2], off2 = this.index[i2];
    for (let j = bucket.length - 1; j >= 0; j--) {
      let index = (j + off2) % bucket.length, tile = bucket[index];
      if ((!test || test(tile)) && !this.reused.has(tile)) {
        bucket.splice(index, 1);
        if (index < off2)
          this.index[i2]--;
        this.reused.set(tile, type2);
        return tile;
      }
    }
    return null;
  }
  findWidget(widget, length, flags2) {
    let widgets = this.buckets[0];
    if (widgets.length)
      for (let i2 = 0, pass = 0; ; i2++) {
        if (i2 == widgets.length) {
          if (pass)
            return null;
          pass = 1;
          i2 = 0;
        }
        let tile = widgets[i2];
        if (!this.reused.has(tile) && (pass == 0 ? tile.widget.compare(widget) : tile.widget.constructor == widget.constructor && widget.updateDOM(tile.dom, this.view))) {
          widgets.splice(i2, 1);
          if (i2 < this.index[0])
            this.index[0]--;
          this.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          tile.length = length;
          tile.flags = tile.flags & -498 | flags2;
          return tile;
        }
      }
  }
  reuse(tile) {
    this.reused.set(
      tile,
      1
      /* Reused.Full */
    );
    return tile;
  }
  maybeReuse(tile, type2 = 2) {
    if (this.reused.has(tile))
      return void 0;
    this.reused.set(tile, type2);
    return tile.dom;
  }
}
class TileUpdate {
  constructor(view, old, blockWrappers2, decorations2, disallowBlockEffectsFor) {
    this.view = view;
    this.decorations = decorations2;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.openWidget = false;
    this.openMarks = 0;
    this.cache = new TileCache(view);
    this.text = new TextStream(view.state.doc);
    this.builder = new TileBuilder(this.cache, new DocTile(view, view.contentDOM), RangeSet.iter(blockWrappers2));
    this.cache.reused.set(
      old,
      2
      /* Reused.DOM */
    );
    this.old = new TilePointer(old);
  }
  run(changes, composition) {
    let compositionContext = composition && this.getCompositionContext(composition.text);
    for (let posA = 0, posB = 0, i2 = 0; ; ) {
      let next = i2 < changes.length ? changes[i2++] : null;
      let skipA = next ? next.fromA : this.old.root.length;
      if (skipA > posA) {
        let len = skipA - posA;
        this.preserve(len, !i2, !next);
        posA = skipA;
        posB += len;
      }
      if (!next)
        break;
      this.forward(next.fromA, next.toA);
      if (composition && next.fromA <= composition.range.fromA && next.toA >= composition.range.toA) {
        this.emit(posB, composition.range.fromB);
        this.builder.addComposition(composition, compositionContext);
        this.emit(composition.range.toB, next.toB);
      } else {
        this.emit(posB, next.toB);
      }
      posB = next.toB;
      posA = next.toA;
    }
    if (this.builder.curLine)
      this.builder.endLine();
    return this.builder.root;
  }
  preserve(length, incStart, incEnd) {
    let activeMarks = getMarks(this.old), openMarks = this.openMarks;
    this.old.advance(length, incEnd ? 1 : -1, {
      skip: (tile, from, to) => {
        if (tile.isWidget()) {
          if (this.openWidget) {
            this.builder.continueWidget(to - from);
          } else {
            let widget = to > 0 || from < tile.length ? WidgetTile.of(tile.widget, this.view, to - from, tile.flags & 496, this.cache.maybeReuse(tile)) : this.cache.reuse(tile);
            if (widget.flags & 256) {
              widget.flags &= -2;
              this.builder.addBlockWidget(widget);
            } else {
              this.builder.ensureLine(null);
              this.builder.addInlineWidget(widget, activeMarks, openMarks);
              openMarks = activeMarks.length;
            }
          }
        } else if (tile.isText()) {
          this.builder.ensureLine(null);
          if (!from && to == tile.length) {
            this.builder.addText(tile.text, activeMarks, openMarks, this.cache.reuse(tile));
          } else {
            this.cache.add(tile);
            this.builder.addText(tile.text.slice(from, to), activeMarks, openMarks);
          }
          openMarks = activeMarks.length;
        } else if (tile.isLine()) {
          tile.flags &= -2;
          this.cache.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          this.builder.addLine(tile);
        } else if (tile instanceof WidgetBufferTile) {
          this.cache.add(tile);
        } else if (tile instanceof MarkTile) {
          this.builder.ensureLine(null);
          this.builder.addMark(tile, activeMarks, openMarks);
          this.cache.reused.set(
            tile,
            1
            /* Reused.Full */
          );
          openMarks = activeMarks.length;
        } else {
          return false;
        }
        this.openWidget = false;
      },
      enter: (tile) => {
        if (tile.isLine()) {
          this.builder.addLineStart(tile.attrs, this.cache.maybeReuse(tile));
        } else {
          this.cache.add(tile);
          if (tile instanceof MarkTile)
            activeMarks.unshift(tile.mark);
        }
        this.openWidget = false;
      },
      leave: (tile) => {
        if (tile.isLine()) {
          if (activeMarks.length)
            activeMarks.length = openMarks = 0;
        } else if (tile instanceof MarkTile) {
          activeMarks.shift();
          openMarks = Math.min(openMarks, activeMarks.length);
        }
      },
      break: () => {
        this.builder.addBreak();
        this.openWidget = false;
      }
    });
    this.text.skip(length);
  }
  emit(from, to) {
    let pendingLineAttrs = null;
    let b = this.builder, markCount = 0;
    let openEnd = RangeSet.spans(this.decorations, from, to, {
      point: (from2, to2, deco, active, openStart, index) => {
        if (deco instanceof PointDecoration) {
          if (this.disallowBlockEffectsFor[index]) {
            if (deco.block)
              throw new RangeError("Block decorations may not be specified via plugins");
            if (to2 > this.view.state.doc.lineAt(from2).to)
              throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
          }
          markCount = active.length;
          if (openStart > active.length) {
            b.continueWidget(to2 - from2);
          } else {
            let widget = deco.widget || (deco.block ? NullWidget.block : NullWidget.inline);
            let flags2 = widgetFlags(deco);
            let tile = this.cache.findWidget(widget, to2 - from2, flags2) || WidgetTile.of(widget, this.view, to2 - from2, flags2);
            if (deco.block) {
              if (deco.startSide > 0)
                b.addLineStartIfNotCovered(pendingLineAttrs);
              b.addBlockWidget(tile);
            } else {
              b.ensureLine(pendingLineAttrs);
              b.addInlineWidget(tile, active, openStart);
            }
          }
          pendingLineAttrs = null;
        } else {
          pendingLineAttrs = addLineDeco(pendingLineAttrs, deco);
        }
        if (to2 > from2)
          this.text.skip(to2 - from2);
      },
      span: (from2, to2, active, openStart) => {
        for (let pos = from2; pos < to2; ) {
          let chars = this.text.next(Math.min(512, to2 - pos));
          if (chars == null) {
            b.addLineStartIfNotCovered(pendingLineAttrs);
            b.addBreak();
            pos++;
          } else {
            b.ensureLine(pendingLineAttrs);
            b.addText(chars, active, openStart);
            pos += chars.length;
          }
          pendingLineAttrs = null;
        }
      }
    });
    b.addLineStartIfNotCovered(pendingLineAttrs);
    this.openWidget = openEnd > markCount;
    this.openMarks = openEnd;
  }
  forward(from, to) {
    this.old.advance(to - from, 1, {
      skip: (tile, from2, to2) => {
        if (tile.isText() || to2 == tile.length)
          this.cache.add(tile);
      },
      enter: (tile) => this.cache.add(tile),
      leave: () => {
      },
      break: () => {
      }
    });
  }
  getCompositionContext(text) {
    let marks = [], line = null;
    for (let parent = text.parentNode; ; parent = parent.parentNode) {
      let tile = Tile.get(parent);
      if (parent == this.view.contentDOM)
        break;
      if (tile instanceof MarkTile)
        marks.push(tile);
      else if (tile === null || tile === void 0 ? void 0 : tile.isLine())
        line = tile;
      else if (parent.nodeName == "DIV" && !line && parent != this.view.contentDOM)
        line = new LineTile(parent, lineBaseAttrs);
      else
        marks.push(MarkTile.of(new MarkDecoration({ tagName: parent.nodeName.toLowerCase(), attributes: getAttrs(parent) }), parent));
    }
    return { line, marks };
  }
}
function hasContent(tile, requireText) {
  let scan = (tile2) => {
    for (let ch of tile2.children)
      if ((requireText ? ch.isText() : ch.length) || scan(ch))
        return true;
    return false;
  };
  return scan(tile);
}
function widgetFlags(deco) {
  let flags2 = deco.isReplace ? (deco.startSide < 0 ? 64 : 0) | (deco.endSide > 0 ? 128 : 0) : deco.startSide > 0 ? 32 : 16;
  if (deco.block)
    flags2 |= 256;
  return flags2;
}
const lineBaseAttrs = { class: "cm-line" };
function addLineDeco(value, deco) {
  let attrs = deco.spec.attributes, cls = deco.spec.class;
  if (!attrs && !cls)
    return value;
  if (!value)
    value = { class: "cm-line" };
  if (attrs)
    combineAttrs(attrs, value);
  if (cls)
    value.class += " " + cls;
  return value;
}
function getMarks(ptr) {
  let found = [];
  for (let i2 = ptr.parents.length; i2 > 1; i2--) {
    let tile = i2 == ptr.parents.length ? ptr.tile : ptr.parents[i2].tile;
    if (tile instanceof MarkTile)
      found.push(tile.mark);
  }
  return found;
}
function freeNode(node2) {
  let tile = Tile.get(node2);
  if (tile)
    tile.setDOM(node2.cloneNode());
  return node2;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
NullWidget.inline = /* @__PURE__ */ new NullWidget("span");
NullWidget.block = /* @__PURE__ */ new NullWidget("div");
const BreakWidget = /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    return document.createElement("br");
  }
  get isHidden() {
    return true;
  }
  get editable() {
    return true;
  }
}();
class DocView {
  constructor(view) {
    this.view = view;
    this.decorations = [];
    this.blockWrappers = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.updateDeco();
    this.tile = new DocTile(view, view.contentDOM);
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], null);
  }
  // Update the document view to a given state.
  update(update) {
    var _a2;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a2 = this.domChanged) === null || _a2 === void 0 ? void 0 : _a2.newSel)
        readCompositionAt = this.domChanged.newSel.head;
      else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
        readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      let { from, to } = this.hasComposition;
      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
    if ((browser$3.ie || browser$3.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, prevWrappers = this.blockWrappers;
    this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, this.decorations, update.changes);
    if (decoDiff.length)
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    let blockDiff = findChangedWrappers(prevWrappers, this.blockWrappers, update.changes);
    if (blockDiff.length)
      changedRanges = ChangedRange.extendWithRanges(changedRanges, blockDiff);
    if (composition && !changedRanges.some((r2) => r2.fromA <= composition.range.fromA && r2.toA >= composition.range.toA))
      changedRanges = composition.range.addToSet(changedRanges.slice());
    if (this.tile.flags & 2 && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, composition);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(changes, composition) {
    this.view.viewState.mustMeasureContent = true;
    let { observer } = this.view;
    observer.ignore(() => {
      if (composition || changes.length) {
        let oldTile = this.tile;
        let builder = new TileUpdate(this.view, oldTile, this.blockWrappers, this.decorations, this.dynamicDecorationMap);
        this.tile = builder.run(changes, composition);
        destroyDropped(oldTile, builder.cache.reused);
      }
      this.tile.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.tile.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser$3.chrome || browser$3.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.tile.sync(track);
      if (track && (track.written || observer.selectionRange.focusNode != track.node || !this.tile.dom.contains(track.node)))
        this.forceSelection = true;
      this.tile.dom.style.height = "";
    });
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.tile.children)
        if (child.isWidget() && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (let tr of update.transactions)
      for (let effect of tr.effects)
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    let { dom } = this.tile;
    let activeElt = this.view.root.activeElement, focused = activeElt == dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || dom.tabIndex > -1) && hasSelection(dom, this.view.observer.selectionRange) && !(activeElt && dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main, anchor, head;
    if (main.empty) {
      head = anchor = this.inlineDOMNearPos(main.anchor, main.assoc || 1);
    } else {
      head = this.inlineDOMNearPos(main.head, main.head == main.from ? 1 : -1);
      anchor = this.inlineDOMNearPos(main.anchor, main.anchor == main.from ? 1 : -1);
    }
    if (browser$3.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser$3.android && browser$3.chrome && dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, dom)) {
          dom.blur();
          dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;
        else if (main.empty) {
          if (browser$3.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text)
                anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== void 0)
            rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {
          }
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == dom) {
          dom.blur();
          if (activeElt)
            activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(sel, cursor2) {
    return this.hasComposition && cursor2.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor2.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view } = this, cursor2 = view.state.selection.main;
    let sel = getSelection(view.root);
    let { anchorNode, anchorOffset } = view.observer.selectionRange;
    if (!sel || !cursor2.empty || !cursor2.assoc || !sel.modify)
      return;
    let line = this.lineAt(cursor2.head, cursor2.assoc);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor2.head == lineStart || cursor2.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor2.head, -1), after = this.coordsAt(cursor2.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor2.head + cursor2.assoc, cursor2.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor2.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor2.from)
      sel.collapse(anchorNode, anchorOffset);
  }
  posFromDOM(node2, offset) {
    let tile = this.tile.nearest(node2);
    if (!tile)
      return this.tile.dom.compareDocumentPosition(node2) & 2 ? 0 : this.view.state.doc.length;
    let start = tile.posAtStart;
    if (tile.isComposite()) {
      let after;
      if (node2 == tile.dom) {
        after = tile.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node2) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node2.parentNode;
          if (parent == tile.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node2 == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node2 = parent;
        }
        if (bias < 0)
          after = node2;
        else
          after = node2.nextSibling;
      }
      if (after == tile.dom.firstChild)
        return start;
      while (after && !Tile.get(after))
        after = after.nextSibling;
      if (!after)
        return start + tile.length;
      for (let i2 = 0, pos = start; ; i2++) {
        let child = tile.children[i2];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    } else if (tile.isText()) {
      return node2 == tile.dom ? start + offset : start + (offset ? tile.length : 0);
    } else {
      return start;
    }
  }
  domAtPos(pos, side) {
    let { tile, offset } = this.tile.resolveBlock(pos, side);
    if (tile.isWidget())
      return tile.domPosFor(pos, side);
    return tile.domIn(offset, side);
  }
  inlineDOMNearPos(pos, side) {
    let before, beforeOff = -1, beforeBad = false;
    let after, afterOff = -1, afterBad = false;
    this.tile.blockTiles((tile, off2) => {
      if (tile.isWidget()) {
        if (tile.flags & 32 && off2 >= pos)
          return true;
        if (tile.flags & 16)
          beforeBad = true;
      } else {
        let end = off2 + tile.length;
        if (off2 <= pos) {
          before = tile;
          beforeOff = pos - off2;
          beforeBad = end < pos;
        }
        if (end >= pos && !after) {
          after = tile;
          afterOff = pos - off2;
          afterBad = off2 > pos;
        }
        if (off2 > pos && after)
          return true;
      }
    });
    if (!before && !after)
      return this.domAtPos(pos, side);
    if (beforeBad && after)
      before = null;
    else if (afterBad && before)
      after = null;
    return before && side < 0 || !after ? before.domIn(beforeOff, side) : after.domIn(afterOff, side);
  }
  coordsAt(pos, side) {
    let { tile, offset } = this.tile.resolveBlock(pos, side);
    if (tile.isWidget()) {
      if (tile.widget instanceof BlockGapWidget)
        return null;
      return tile.coordsInWidget(offset, side, true);
    }
    return tile.coordsIn(offset, side);
  }
  lineAt(pos, side) {
    let { tile } = this.tile.resolveBlock(pos, side);
    return tile.isLine() ? tile : null;
  }
  coordsForChar(pos) {
    let { tile, offset } = this.tile.resolveBlock(pos, 1);
    if (!tile.isLine())
      return null;
    function scan(tile2, offset2) {
      if (tile2.isComposite()) {
        for (let ch of tile2.children) {
          if (ch.length >= offset2) {
            let found = scan(ch, offset2);
            if (found)
              return found;
          }
          offset2 -= ch.length;
          if (offset2 < 0)
            break;
        }
      } else if (tile2.isText() && offset2 < tile2.length) {
        let end = findClusterBreak(tile2.text, offset2);
        if (end == offset2)
          return null;
        let rects = textRange(tile2.dom, offset2, end).getClientRects();
        for (let i2 = 0; i2 < rects.length; i2++) {
          let rect = rects[i2];
          if (i2 == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
            return rect;
        }
      }
      return null;
    }
    return scan(tile, offset);
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from, to } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    let spaceAbove = 0;
    let scan = (tile, pos, measureBounds) => {
      for (let i2 = 0; i2 < tile.children.length; i2++) {
        if (pos > to)
          break;
        let child = tile.children[i2], end = pos + child.length;
        let childRect = child.dom.getBoundingClientRect(), { height } = childRect;
        if (measureBounds && !i2)
          spaceAbove += childRect.top - measureBounds.top;
        if (child instanceof BlockWrapperTile) {
          if (end > from)
            scan(child, pos, childRect);
        } else if (pos >= from) {
          if (spaceAbove > 0)
            result.push(-spaceAbove);
          result.push(height + spaceAbove);
          spaceAbove = 0;
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        if (measureBounds && i2 == tile.children.length - 1)
          spaceAbove += measureBounds.bottom - childRect.bottom;
        pos = end + child.breakAfter;
      }
    };
    scan(this.tile, 0, null);
    return result;
  }
  textDirectionAt(pos) {
    let { tile } = this.tile.resolveBlock(pos, 1);
    return getComputedStyle(tile.dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    let lineMeasure = this.tile.blockTiles((tile) => {
      if (tile.isLine() && tile.children.length && tile.length <= 20) {
        let totalWidth = 0, textHeight2;
        for (let child of tile.children) {
          if (!child.isText() || /[^ -~]/.test(child.text))
            return void 0;
          let rects = clientRectsFor(child.dom);
          if (rects.length != 1)
            return void 0;
          totalWidth += rects[0].width;
          textHeight2 = rects[0].height;
        }
        if (totalWidth)
          return {
            lineHeight: tile.dom.getBoundingClientRect().height,
            charWidth: totalWidth / tile.length,
            textHeight: textHeight2
          };
      }
    });
    if (lineMeasure)
      return lineMeasure;
    let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.tile.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect && rect.width ? rect.width / 27 : 7;
      textHeight = rect && rect.height ? rect.height : lineHeight;
      dummy.remove();
    });
    return { lineHeight, charWidth, textHeight };
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i2 = 0; ; i2++) {
      let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
      let end = next ? next.from - 1 : this.view.state.doc.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i2 = 1;
    let allDeco = this.view.state.facet(decorations).map((d2) => {
      let dynamic = this.dynamicDecorationMap[i2++] = typeof d2 == "function";
      return dynamic ? d2(this.view) : d2;
    });
    let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d2, i3) => {
      let dynamic = typeof d2 == "function";
      if (dynamic)
        dynamicOuter = true;
      return dynamic ? d2(this.view) : d2;
    });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i2++] = dynamicOuter;
      allDeco.push(RangeSet.join(outerDeco));
    }
    this.decorations = [
      this.editContextFormatting,
      ...allDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
    while (i2 < this.decorations.length)
      this.dynamicDecorationMap[i2++] = false;
    this.blockWrappers = this.view.state.facet(blockWrappers).map((v2) => typeof v2 == "function" ? v2(this.view) : v2);
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref2 = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref2.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (let handler of this.view.state.facet(scrollHandler)) {
      try {
        if (handler(this.view, target.range, target))
          return true;
      } catch (e2) {
        logException(this.view.state, e2, "scroll handler");
      }
    }
    let { range } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
    if (!rect)
      return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
      rect = {
        left: Math.min(rect.left, other.left),
        top: Math.min(rect.top, other.top),
        right: Math.max(rect.right, other.right),
        bottom: Math.max(rect.bottom, other.bottom)
      };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let { offsetWidth, offsetHeight } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
  lineHasWidget(pos) {
    let scan = (child) => child.isWidget() || child.children.some(scan);
    return scan(this.tile.resolveBlock(pos, 1).tile);
  }
  destroy() {
    destroyDropped(this.tile);
  }
}
function destroyDropped(tile, reused) {
  let r2 = reused === null || reused === void 0 ? void 0 : reused.get(tile);
  if (r2 != 1) {
    if (r2 == null)
      tile.destroy();
    for (let ch of tile.children)
      destroyDropped(ch, reused);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let tileAfter = Tile.get(textAfter.node);
    if (!tileAfter || tileAfter.isText() && tileAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let tileBefore = Tile.get(textBefore.node);
      if (!(!tileBefore || tileBefore.isText() && tileBefore.text != textBefore.node.nodeValue))
        textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode)
    return null;
  let from = headPos - textNode.offset;
  return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found)
    return null;
  let { node: textNode, from, to } = found, text = textNode.nodeValue;
  if (/[\n\r]/.test(text))
    return null;
  if (view.state.doc.sliceString(found.from, found.to) != text)
    return null;
  let inv = changes.invertedDesc;
  return { range: new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to), text: textNode };
}
function nextToUneditable(node2, offset) {
  if (node2.nodeType != 1)
    return 0;
  return (offset && node2.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node2.childNodes.length && node2.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
let DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a2, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a2, b, diff, comp);
  return comp.changes;
}
class WrapperComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint() {
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
}
function findChangedWrappers(a2, b, diff) {
  let comp = new WrapperComparator();
  RangeSet.compare(a2, b, diff, comp);
  return comp.changes;
}
function inUneditable(node2, inside) {
  for (let cur2 = node2; cur2 && cur2 != inside; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition)
    changes.iterChangedRanges((from, to) => {
      if (from < composition.to && to > composition.from)
        touched = true;
    });
  return touched;
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function posAtCoordsImprecise(view, contentRect, block, x2, y2) {
  let into = Math.round((x2 - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y2 - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function blockAt(view, pos, side) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    let best;
    for (let l2 of line.type) {
      if (l2.from > pos)
        break;
      if (l2.to < pos)
        continue;
      if (l2.from < pos && l2.to > pos)
        return l2;
      if (!best || l2.type == BlockType.Text && (best.type != l2.type || (side < 0 ? l2.from < pos : l2.to > pos)))
        best = l2;
    }
    return best || line;
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head, start.assoc || -1);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur2 = start, check2 = null; ; ) {
    let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check2) {
      if (!by)
        return next;
      check2 = by(char);
    } else if (!check2(char)) {
      return cur2;
    }
    cur2 = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start.assoc);
  let goal = start.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist2 = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    return EditorSelection.cursor(pos.pos, pos.assoc, void 0, goal);
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (; ; ) {
    let moved = 0;
    for (let set of atoms) {
      set.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1);
          pos = side < 0 ? from : to;
          moved = side;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
function skipAtomsForSelection(atoms, sel) {
  let ranges = null;
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let range = sel.ranges[i2], updated = null;
    if (range.empty) {
      let pos = skipAtomicRanges(atoms, range.from, 0);
      if (pos != range.from)
        updated = EditorSelection.cursor(pos, -1);
    } else {
      let from = skipAtomicRanges(atoms, range.from, -1);
      let to = skipAtomicRanges(atoms, range.to, 1);
      if (from != range.from || to != range.to)
        updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
    }
    if (updated) {
      if (!ranges)
        ranges = sel.ranges.slice();
      ranges[i2] = updated;
    }
  }
  return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f2) => f2(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}
class PosAssoc {
  constructor(pos, assoc) {
    this.pos = pos;
    this.assoc = assoc;
  }
}
function posAtCoords(view, coords, precise, scanY) {
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let { x: x2, y: y2 } = coords, yOffset = y2 - docTop, block;
  for (; ; ) {
    if (yOffset < 0)
      return new PosAssoc(0, 1);
    if (yOffset > view.viewState.docHeight)
      return new PosAssoc(view.state.doc.length, -1);
    block = view.elementAtHeight(yOffset);
    if (scanY == null)
      break;
    if (block.type == BlockType.Text) {
      let rect = view.docView.coordsAt(scanY < 0 ? block.from : block.to, scanY);
      if (rect && (scanY < 0 ? rect.top <= yOffset + docTop : rect.bottom >= yOffset + docTop))
        break;
    }
    let halfLine = view.viewState.heightOracle.textHeight / 2;
    yOffset = scanY > 0 ? block.bottom + halfLine : block.top - halfLine;
  }
  if (view.viewport.from >= block.to || view.viewport.to <= block.from) {
    if (precise)
      return null;
    if (block.type == BlockType.Text) {
      let pos = posAtCoordsImprecise(view, content2, block, x2, y2);
      return new PosAssoc(pos, pos == block.from ? 1 : -1);
    }
  }
  if (block.type != BlockType.Text)
    return yOffset < (block.top + block.bottom) / 2 ? new PosAssoc(block.from, 1) : new PosAssoc(block.to, -1);
  let line = view.docView.lineAt(block.from, 2);
  if (!line || line.length != block.length)
    line = view.docView.lineAt(block.from, -2);
  return posAtCoordsInline(view, line, block.from, x2, y2);
}
function posAtCoordsInline(view, tile, offset, x2, y2) {
  let closest = -1, closestRect = null;
  let dxClosest = 1e9, dyClosest = 1e9;
  let rowTop = y2, rowBot = y2;
  let checkRects = (rects, index) => {
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.top == rect.bottom)
        continue;
      let dx = rect.left > x2 ? rect.left - x2 : rect.right < x2 ? x2 - rect.right : 0;
      let dy = rect.top > y2 ? rect.top - y2 : rect.bottom < y2 ? y2 - rect.bottom : 0;
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowTop = Math.min(rect.top, rowTop);
        rowBot = Math.max(rect.bottom, rowBot);
        dy = 0;
      }
      if (closest < 0 || (dy - dyClosest || dx - dxClosest) < 0) {
        if (closest >= 0 && dyClosest && dxClosest < dx && closestRect.top <= rowBot - 2 && closestRect.bottom >= rowTop + 2) {
          dyClosest = 0;
        } else {
          closest = index;
          dxClosest = dx;
          dyClosest = dy;
          closestRect = rect;
        }
      }
    }
  };
  if (tile.isText()) {
    for (let i2 = 0; i2 < tile.length; ) {
      let next = findClusterBreak(tile.text, i2);
      checkRects(textRange(tile.dom, i2, next).getClientRects(), i2);
      if (!dxClosest && !dyClosest)
        break;
      i2 = next;
    }
    let after = x2 > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);
    return after ? new PosAssoc(offset + findClusterBreak(tile.text, closest), -1) : new PosAssoc(offset + closest, 1);
  } else {
    if (!tile.length)
      return new PosAssoc(offset, 1);
    for (let i2 = 0; i2 < tile.children.length; i2++) {
      let child = tile.children[i2];
      if (child.flags & 48)
        continue;
      let rects = (child.dom.nodeType == 1 ? child.dom : textRange(child.dom, 0, child.length)).getClientRects();
      checkRects(rects, i2);
      if (!dxClosest && !dyClosest)
        break;
    }
    let inner = tile.children[closest], innerOff = tile.posBefore(inner, offset);
    if (inner.isComposite() || inner.isText())
      return posAtCoordsInline(view, inner, innerOff, Math.max(closestRect.left, Math.min(closestRect.right, x2)), y2);
    let after = x2 > (closestRect.left + closestRect.right) / 2 == (dirAt(view, closest + offset) == Direction.LTR);
    return after ? new PosAssoc(innerOff + inner.length, -1) : new PosAssoc(innerOff, 1);
  }
}
function dirAt(view, pos) {
  let line = view.state.doc.lineAt(pos), spans = view.bidiSpans(line);
  return spans[BidiSpan.find(view.bidiSpans(line), pos - line.from, -1, 1)].dir;
}
const LineBreakPlaceholder = "￿";
class DOMReader {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start)
      return this;
    let parent = start.parentNode;
    for (let cur2 = start; ; ) {
      this.findPointBefore(parent, cur2);
      let oldLen = this.text.length;
      this.readNode(cur2);
      let tile = Tile.get(cur2), next = cur2.nextSibling;
      if (next == end) {
        if ((tile === null || tile === void 0 ? void 0 : tile.breakAfter) && !next)
          this.lineBreak();
        break;
      }
      let nextTile = Tile.get(next);
      if ((tile && nextTile ? tile.breakAfter : (tile ? tile.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || (tile === null || tile === void 0 ? void 0 : tile.isWidget())) && this.text.length > oldLen) && !isEmptyToEnd(next, end))
        this.lineBreak();
      cur2 = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node2) {
    let text = node2.nodeValue;
    for (let point of this.points)
      if (point.node == node2)
        point.pos = this.text.length + Math.min(point.offset, text.length);
    for (let off2 = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m2;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off2);
        breakSize = this.lineSeparator.length;
      } else if (m2 = re.exec(text)) {
        nextBreak = m2.index;
        breakSize = m2[0].length;
      }
      this.append(text.slice(off2, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point of this.points)
          if (point.node == node2 && point.pos > this.text.length)
            point.pos -= breakSize - 1;
      }
      off2 = nextBreak + breakSize;
    }
  }
  readNode(node2) {
    let tile = Tile.get(node2);
    let fromView = tile && tile.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node2, fromView.length);
      for (let i2 = fromView.iter(); !i2.next().done; ) {
        if (i2.lineBreak)
          this.lineBreak();
        else
          this.append(i2.value);
      }
    } else if (node2.nodeType == 3) {
      this.readTextNode(node2);
    } else if (node2.nodeName == "BR") {
      if (node2.nextSibling)
        this.lineBreak();
    } else if (node2.nodeType == 1) {
      this.readRange(node2.firstChild, null);
    }
  }
  findPointBefore(node2, next) {
    for (let point of this.points)
      if (point.node == node2 && node2.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointInside(node2, length) {
    for (let point of this.points)
      if (node2.nodeType == 3 ? point.node == node2 : node2.contains(point.node))
        point.pos = this.text.length + (isAtEnd(node2, point.node, point.offset) ? length : 0);
  }
}
function isAtEnd(parent, node2, offset) {
  for (; ; ) {
    if (!node2 || offset < maxOffset(node2))
      return false;
    if (node2 == parent)
      return true;
    offset = domIndex(node2) + 1;
    node2 = node2.parentNode;
  }
}
function isEmptyToEnd(node2, end) {
  let widgets;
  for (; ; node2 = node2.nextSibling) {
    if (node2 == end || !node2)
      break;
    let view = Tile.get(node2);
    if (!(view === null || view === void 0 ? void 0 : view.isWidget()))
      return false;
    if (view)
      (widgets || (widgets = [])).push(view);
  }
  if (widgets)
    for (let w of widgets) {
      let override = w.overrideDOMText;
      if (override === null || override === void 0 ? void 0 : override.length)
        return false;
    }
  return true;
}
class DOMPoint {
  constructor(node2, offset) {
    this.node = node2;
    this.offset = offset;
    this.pos = -1;
  }
}
class DOMChange {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = domBoundsAround(view.docView.tile, start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains$1(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains$1(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser$3.ios || browser$3.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from = Math.min(head, anchor), to = Math.max(head, anchor);
        let offFrom = vp.from - from, offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      if (view.inputState.composing > -1 && view.state.selection.ranges.length > 1)
        this.newSel = view.state.selection.replaceRange(EditorSelection.range(anchor, head));
      else
        this.newSel = EditorSelection.single(anchor, head);
    }
  }
}
function domBoundsAround(tile, from, to, offset) {
  if (tile.isComposite()) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i2 = 0, pos = offset, prevEnd = offset; i2 < tile.children.length; i2++) {
      let child = tile.children[i2], end = pos + child.length;
      if (pos < from && end > to)
        return domBoundsAround(child, from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i2;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == tile.dom) {
        toI = i2;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + tile.length : toEnd,
      startDOM: (fromI ? tile.children[fromI - 1].dom.nextSibling : null) || tile.dom.firstChild,
      endDOM: toI < tile.children.length && toI >= 0 ? tile.children[toI].dom : null
    };
  } else if (tile.isText()) {
    return { from: offset, to: offset + tile.length, startDOM: tile.dom, endDOM: tile.dom.nextSibling };
  } else {
    return null;
  }
}
function applyDOMChange(view, domChange) {
  let change;
  let { newSel } = domChange, sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let { from, to } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (lastKey === 8 || browser$3.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser$3.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel)
    return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if ((browser$3.mac || browser$3.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: change.from, to: change.to, insert: Text.of([change.insert.toString().replace(".", " ")]) };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (view.state.doc.lineAt(sel.from).to < sel.to && view.docView.lineHasWidget(sel.to) && view.inputState.insertingTextAt > Date.now() - 50) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.toText(view.inputState.insertingText)
    };
  } else if (browser$3.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView2 = true;
      userEvent = view.inputState.lastSelectionOrigin;
      if (userEvent == "select.pointer")
        newSel = skipAtomsForSelection(view.state.facet(atomicRanges).map((f2) => f2(view)), newSel);
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey = -1) {
  if (browser$3.ios && view.inputState.flushIOSKey(change))
    return true;
  let sel = view.state.selection.main;
  if (browser$3.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
    return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0)
    view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler$1).some((h2) => h2(view, change.from, change.to, text, defaultInsert)))
    view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr, startState = view.state, sel = startState.selection.main, inAtomic = -1;
  if (change.from == change.to && change.from < sel.from || change.from > sel.to) {
    let side = change.from < sel.from ? -1 : 1, pos = side < 0 ? sel.from : sel.to;
    let moved = skipAtomicRanges(startState.facet(atomicRanges).map((f2) => f2(view)), pos, side);
    if (change.from == moved)
      inAtomic = moved;
  }
  if (inAtomic > -1) {
    tr = {
      changes: change,
      selection: EditorSelection.cursor(change.from + change.insert.length, -1)
    };
  } else if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : void 0;
    if (startState.selection.ranges.length > 1 && (view.inputState.composing >= 0 || view.inputState.compositionPendingChange) && change.to <= sel.to + 10 && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = { from: composition.from, to: composition.to - dLen };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to;
      tr = startState.changeByRange((range) => {
        if (range.from == sel.from && range.to == sel.to)
          return { changes, range: mainSel || range.map(changes) };
        let to = range.to - offset, from = to - replaced.length;
        if (view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        to >= compositionRange.from && from <= compositionRange.to)
          return { range };
        let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a2, b, preferredPos, preferredSide) {
  let minLen = Math.min(a2.length, b.length);
  let from = 0;
  while (from < minLen && a2.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a2.length == b.length)
    return null;
  let toA = a2.length, toB = b.length;
  while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a2.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
class InputState {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = void 0;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.insertingText = "";
    this.insertingTextAt = 0;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser$3.safari)
      view.contentDOM.addEventListener("input", () => null);
    if (browser$3.gecko)
      firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
      return;
    if (event.type == "keydown" && this.keydown(event))
      return;
    if (this.view.updateState != 0)
      Promise.resolve().then(() => this.runHandlers(event.type, event));
    else
      this.runHandlers(event.type, event);
  }
  runHandlers(type2, event) {
    let handlers2 = this.handlers[type2];
    if (handlers2) {
      for (let observer of handlers2.observers)
        observer(this.view, event);
      for (let handler of handlers2.handlers) {
        if (event.defaultPrevented)
          break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers2 = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
    for (let type2 in handlers2)
      if (type2 != "scroll") {
        let passive = !handlers2[type2].handlers.length;
        let exists = prev[type2];
        if (exists && passive != !exists.handlers.length) {
          dom.removeEventListener(type2, this.handleEvent);
          exists = null;
        }
        if (!exists)
          dom.addEventListener(type2, this.handleEvent, { passive });
      }
    for (let type2 in prev)
      if (type2 != "scroll" && !handlers2[type2])
        dom.removeEventListener(type2, this.handleEvent);
    this.handlers = handlers2;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
      this.tabFocusMode = -1;
    if (browser$3.android && browser$3.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser$3.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229)
      this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString()))
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : void 0);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type) || event.synthetic)
      return false;
    if (this.composing > 0)
      return true;
    if (browser$3.safari && !browser$3.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged)
      this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
}
function bindHandler(plugin2, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin2, event, view);
    } catch (e2) {
      logException(view.state, e2);
    }
  };
}
function computeHandlers(plugins) {
  let result = /* @__PURE__ */ Object.create(null);
  function record(type2) {
    return result[type2] || (result[type2] = { observers: [], handlers: [] });
  }
  for (let plugin2 of plugins) {
    let spec = plugin2.spec, handlers2 = spec && spec.plugin.domEventHandlers, observers2 = spec && spec.plugin.domEventObservers;
    if (handlers2)
      for (let type2 in handlers2) {
        let f2 = handlers2[type2];
        if (f2)
          record(type2).handlers.push(bindHandler(plugin2.value, f2));
      }
    if (observers2)
      for (let type2 in observers2) {
        let f2 = observers2[type2];
        if (f2)
          record(type2).observers.push(bindHandler(plugin2.value, f2));
      }
  }
  for (let type2 in handlers)
    record(type2).handlers.push(handlers[type2]);
  for (let type2 in observers)
    record(type2).observers.push(observers[type2]);
  return result;
}
const PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist2) {
  return Math.max(0, dist2) * 0.7 + 8;
}
function dist(a2, b) {
  return Math.max(Math.abs(a2.clientX - b.clientX), Math.abs(a2.clientY - b.clientY));
}
class MouseSelection {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = { x: 0, y: 0 };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map((f2) => f2(view));
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false)
      this.select(event);
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
      return;
    this.select(this.lastEvent = event);
    let sx = 0, sy = 0;
    let left = 0, top2 = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;
    if (this.scrollParents.x)
      ({ left, right } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y)
      ({ top: top2, bottom } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin)
      sx = -dragScrollSpeed(left - event.clientX);
    else if (event.clientX + margins.right >= right - dragScrollMargin)
      sx = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top2 + dragScrollMargin)
      sy = -dragScrollSpeed(top2 - event.clientY);
    else if (event.clientY + margins.bottom >= bottom - dragScrollMargin)
      sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = { x: sx, y: sy };
    if (sx || sy) {
      if (this.scrolling < 0)
        this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let { x: x2, y: y2 } = this.scrollSpeed;
    if (x2 && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x2;
      x2 = 0;
    }
    if (y2 && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y2;
      y2 = 0;
    }
    if (x2 || y2)
      this.view.win.scrollBy(x2, y2);
    if (this.dragging === false)
      this.select(this.lastEvent);
  }
  select(event) {
    let { view } = this, selection = skipAtomsForSelection(this.atoms, this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))
      this.view.dispatch({
        selection,
        userEvent: "select.pointer"
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some((tr) => tr.isUserEvent("input.type")))
      this.destroy();
    else if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser$3.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser$3.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i2 = 0; i2 < rects.length; i2++) {
    let rect = rects[i2];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node2 = event.target, tile; node2 != view.contentDOM; node2 = node2.parentNode)
    if (!node2 || node2.nodeType == 11 || (tile = Tile.get(node2)) && tile.isWidget() && !tile.isHidden && tile.widget.ignoreEvent(event))
      return false;
  return true;
}
const handlers = /* @__PURE__ */ Object.create(null);
const observers = /* @__PURE__ */ Object.create(null);
const brokenClipboardAPI = browser$3.ie && browser$3.ie_version < 15 || browser$3.ios && browser$3.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (let filter2 of state.facet(facet))
    text = filter2(text, state);
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let { state } = view, changes, i2 = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r2) => r2.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i2++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i2++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = (view) => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0)
    view.inputState.tabFocusMode = Date.now() + 2e3;
  return false;
};
observers.touchstart = (view, e2) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return false;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus)
      view.observer.ignore(() => {
        focusPreventScroll(view.contentDOM);
        let active = view.root.activeElement;
        if (active && !active.contains(view.contentDOM))
          active.blur();
      });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  } else {
    view.inputState.setSelectionOrigin("select.pointer");
  }
  return false;
};
function rangeForClick(view, pos, bias, type2) {
  if (type2 == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type2 == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = view.docView.lineAt(pos, bias), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
const BadMouseDetail = browser$3.ie && browser$3.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = view.posAndSideAtCoords({ x: event.clientX, y: event.clientY }, false), type2 = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, extend, multiple) {
      let cur2 = view.posAndSideAtCoords({ x: event2.clientX, y: event2.clientY }, false), removed;
      let range = rangeForClick(view, cur2.pos, cur2.assoc, type2);
      if (start.pos != cur2.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.assoc, type2);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple && type2 == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur2.pos)))
        return removed;
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i2 = 0; i2 < sel.ranges.length; i2++) {
    let { from, to } = sel.ranges[i2];
    if (from <= pos && to >= pos)
      return EditorSelection.create(sel.ranges.slice(0, i2).concat(sel.ranges.slice(i2 + 1)), sel.mainIndex == i2 ? 0 : sel.mainIndex - (sel.mainIndex > i2 ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let { selection: { main: range } } = view.state;
  if (event.target.draggable) {
    let tile = view.docView.tile.nearest(event.target);
    if (tile && tile.isWidget()) {
      let from = tile.posAtStart, to = from + tile.length;
      if (from >= range.to || to <= range.from)
        range = EditorSelection.range(from, to);
    }
  }
  let { inputState } = view;
  if (inputState.mouseSelection)
    inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = (view) => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text)
    return;
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let { draggedContent } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? { from: draggedContent.from, to: draggedContent.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer)
    return false;
  if (view.state.readOnly)
    return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text.filter((s2) => s2 != null).join(view.state.lineBreak), false);
    };
    for (let i2 = 0; i2 < files.length; i2++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i2] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i2]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly)
    return true;
  view.observer.flush();
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  if (data2) {
    doPaste(view, data2.getData("text/plain") || data2.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: textFilter(state, clipboardOutputFilter, content2.join(state.lineBreak)), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text && !linewise)
    return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
  let data2 = brokenClipboardAPI ? null : event.clipboardData;
  if (data2) {
    data2.clearData();
    data2.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
const isFocusChange = /* @__PURE__ */ Annotation.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (let getEffect of state.facet(focusChangeEffect)) {
    let effect = getEffect(state, focus);
    if (effect)
      effects.push(effect);
  }
  return effects.length ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr)
        view.dispatch(tr);
      else
        view.update([]);
    }
  }, 10);
}
observers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = (view) => {
  if (view.observer.editContext)
    return;
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = (view) => {
  if (view.observer.editContext)
    return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser$3.chrome && browser$3.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition)
        view.update([]);
    }, 50);
  }
};
observers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a2, _b;
  if (event.inputType == "insertText" || event.inputType == "insertCompositionText") {
    view.inputState.insertingText = event.data;
    view.inputState.insertingTextAt = Date.now();
  }
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a2 = event.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.getData("text/plain"), ranges = event.getTargetRanges();
    if (text && ranges.length) {
      let r2 = ranges[0];
      let from = view.posAtDOM(r2.startContainer, r2.startOffset), to = view.posAtDOM(r2.endContainer, r2.endOffset);
      applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);
      return true;
    }
  }
  let pending;
  if (browser$3.chrome && browser$3.android && (pending = PendingKeys.find((key) => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser$3.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser$3.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
const appliedFirefoxHack = /* @__PURE__ */ new Set();
function firefoxCopyCutHack(doc2) {
  if (!appliedFirefoxHack.has(doc2)) {
    appliedFirefoxHack.add(doc2);
    doc2.addEventListener("copy", () => {
    });
    doc2.addEventListener("cut", () => {
    });
  }
}
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
class HeightOracle {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = Text.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / Math.max(1, this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i2 = 0; i2 < lineHeights.length; i2++) {
      let h2 = lineHeights[i2];
      if (h2 < 0) {
        i2++;
      } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i2 = 0; i2 < knownHeights.length; i2++) {
        let h2 = knownHeights[i2];
        if (h2 < 0)
          i2++;
        else
          this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  /**
  @internal
  */
  constructor(from, length, top2, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this._content = _content;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(other) {
    let content2 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content2);
  }
}
var QueryType$1 = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType$1 || (QueryType$1 = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length, height, flags2 = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags2;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & -3;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        heightChangeFlag = true;
      this.height = height;
    }
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this, doc2 = oracle.doc;
    for (let i2 = changes.length - 1; i2 >= 0; i2--) {
      let { fromA, toA, fromB, toB } = changes[i2];
      let start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
        fromA = changes[i2 - 1].fromA;
        fromB = changes[i2 - 1].fromB;
        i2--;
        if (fromA < start.from)
          start = me.lineAt(fromA, QueryType$1.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc2), decorations2, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i2 = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i2 == j) {
        if (before > after * 2) {
          let split = nodes[i2 - 1];
          if (split.break)
            nodes.splice(--i2, 1, split.left, null, split.right);
          else
            nodes.splice(--i2, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i2++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i2 - 1] == null) {
      brk = 1;
      i2--;
    } else if (nodes[i2] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i2)), brk, HeightMap.of(nodes.slice(j)));
  }
}
function replace(old, val) {
  if (old == val)
    return old;
  if (old.constructor != val.constructor)
    heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
const SpaceDeco = /* @__PURE__ */ Decoration.replace({});
class HeightMapBlock extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
    this.spaceAbove = 0;
  }
  mainBlock(top2, offset) {
    return new BlockInfo(offset, this.length, top2 + this.spaceAbove, this.height - this.spaceAbove, this.deco || 0);
  }
  blockAt(height, _oracle, top2, offset) {
    return this.spaceAbove && height < top2 + this.spaceAbove ? new BlockInfo(offset, 0, top2, this.spaceAbove, SpaceDeco) : this.mainBlock(top2, offset);
  }
  lineAt(_value, _type, oracle, top2, offset) {
    let main = this.mainBlock(top2, offset);
    return this.spaceAbove ? this.blockAt(0, oracle, top2, offset).join(main) : main;
  }
  forEachLine(from, to, oracle, top2, offset, f2) {
    if (from <= offset + this.length && to >= offset)
      f2(this.lineAt(0, QueryType$1.ByPos, oracle, top2, offset));
  }
  setMeasuredHeight(measured) {
    let next = measured.heights[measured.index++];
    if (next < 0) {
      this.spaceAbove = -next;
      next = measured.heights[measured.index++];
    } else {
      this.spaceAbove = 0;
    }
    this.setHeight(next);
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setMeasuredHeight(measured);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length, height, above) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
    this.spaceAbove = above;
  }
  mainBlock(top2, offset) {
    return new BlockInfo(offset, this.length, top2 + this.spaceAbove, this.height - this.spaceAbove, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node2 = nodes[0];
    if (nodes.length == 1 && (node2 instanceof HeightMapText || node2 instanceof HeightMapGap && node2.flags & 4) && Math.abs(this.length - node2.length) < 10) {
      if (node2 instanceof HeightMapGap)
        node2 = new HeightMapText(node2.length, this.height, this.spaceAbove);
      else
        node2.height = this.height;
      if (!this.outdated)
        node2.outdated = false;
      return node2;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more) {
      this.setMeasuredHeight(measured);
    } else if (force || this.outdated) {
      this.spaceAbove = 0;
      this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    }
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine, perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1)
        perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return { firstLine, lastLine, perLine, perChar };
  }
  blockAt(height, oracle, top2, offset) {
    let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top2) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top2, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / perLine)));
      let { from, length } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top2 + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type2, oracle, top2, offset) {
    if (type2 == QueryType$1.ByHeight)
      return this.blockAt(value, oracle, top2, offset);
    if (type2 == QueryType$1.ByPosNoHeight) {
      let { from, to } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, 0);
    }
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top2 + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top2, Math.min(lineTop, top2 + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to, oracle, top2, offset, f2) {
    from = Math.max(from, offset);
    to = Math.min(to, offset + this.length);
    let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top2; pos <= to; ) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f2(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from + first.length);
      else
        nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height = measured.heights[measured.index++], above = 0;
        if (height < 0) {
          above = -height;
          height = measured.heights[measured.index++];
        }
        if (singleHeight == -1)
          singleHeight = height;
        else if (Math.abs(height - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line = new HeightMapText(len, height, above);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
        heightChangeFlag = true;
      return replace(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top2, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type2, oracle, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type2 == QueryType$1.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type2, oracle, top2, offset) : this.right.lineAt(value, type2, oracle, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type2 == QueryType$1.ByPosNoHeight ? QueryType$1.ByPosNoHeight : QueryType$1.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, oracle, top2, offset).join(base2);
  }
  forEachLine(from, to, oracle, top2, offset, f2) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, oracle, top2, offset, f2);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f2);
    } else {
      let mid = this.lineAt(rightOffset, QueryType$1.ByPos, oracle, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, oracle, top2, offset, f2);
      if (mid.to >= from && mid.from <= to)
        f2(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f2);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node2 of nodes)
      result.push(node2);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1, 0));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0)
        height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1, 0));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1, 0);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0)
      this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1, 0));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node2 of this.nodes) {
      if (node2 instanceof HeightMapText)
        node2.updateHeight(this.oracle, pos);
      pos += node2 ? node2.length : 1;
    }
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(oracle, decorations2, from, to) {
    let builder = new NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
}
function heightRelevantDecoChanges(a2, b, diff) {
  let comp = new DecorationComparator2();
  RangeSet.compare(a2, b, diff, comp, 0);
  return comp.changes;
}
class DecorationComparator2 {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a2, b) {
    if (from < to || a2 && a2.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt) {
  let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
class LineGap {
  constructor(from, to, size, displaySize) {
    this.from = from;
    this.to = to;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a2, b) {
    if (a2.length != b.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++) {
      let gA = a2[i2], gB = b[i2];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some((v2) => typeof v2 != "function" && v2.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter((d2) => typeof d2 != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i2 = 0; i2 < 2; i2++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport())
        break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i2 = 0; i2 <= 1; i2++) {
      let pos = i2 ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a2, b) => a2.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block) => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d2) => typeof d2 != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag)
      update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = prevHeight;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges(update.changes);
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden))
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    if (domRect.width && domRect.height) {
      let { scaleX, scaleY } = getScale(dom, domRect);
      if (scaleX > 5e-3 && Math.abs(this.scaleX - scaleX) > 5e-3 || scaleY > 5e-3 && Math.abs(this.scaleY - scaleY) > 5e-3) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom))
      return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, Math.max(5, contentWidth / charWidth), lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2)
        result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, oracle = this.heightOracle;
    let { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType$1.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType$1.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let { head } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType$1.ByPos, oracle, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType$1.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from, to }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from, QueryType$1.ByPos, this.heightOracle, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType$1.ByPos, this.heightOracle, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(
      -bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(
      bias,
      250
      /* VP.MaxCoverMargin */
    ))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    return mapped;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, (gap2) => gap2.from >= line.from && gap2.to <= line.to && Math.abs(gap2.from - from) < halfMargin && Math.abs(gap2.to - to) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r2) => r2.from <= to && r2.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;
          if (lineStart > from)
            to = lineStart;
        }
        let size = this.gapSize(line, from, to, structure);
        let displaySize = wrapping || size < 2e6 ? size : 2e6;
        gap = new LineGap(from, to, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = (line) => {
      if (line.length < doubleMargin || line.type != BlockType.Text)
        return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin)
        return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2e6)
          for (let old of current) {
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left)
              horizOffset = old.size - old.displaySize;
          }
        let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from)
        addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to)
        addGap(viewTo, line.to, line, structure);
    };
    for (let line of this.viewportLines) {
      if (Array.isArray(line.type))
        line.type.forEach(checkLine);
      else
        checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i2 = 0; i2 < ranges.length && !(changed & 8); i2++) {
        let old = this.visibleRanges[i2], nw = ranges[i2];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to))
            changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType$1.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l2) => l2.top <= height && l2.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType$1.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
function lineStructure(from, to, stateDeco) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(stateDeco, from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i2 = 0; ; i2++) {
    let { from, to } = ranges[i2], size = to - from;
    if (dist2 <= size)
      return from + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f2) {
  for (let val of array)
    if (f2(val))
      return val;
  return void 0;
}
const IdScaler = {
  toDOM(n2) {
    return n2;
  },
  fromDOM(n2) {
    return n2;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
class BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType$1.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType$1.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n2) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp || n2 < vp.top)
        return domBase + (n2 - base2) * this.scale;
      if (n2 <= vp.bottom)
        return vp.domTop + (n2 - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n2) {
    for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
      let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
      if (!vp || n2 < vp.domTop)
        return base2 + (n2 - domBase) / this.scale;
      if (n2 <= vp.domBottom)
        return vp.top + (n2 - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof BigScaler))
      return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i2) => vp.from == other.viewports[i2].from && vp.to == other.viewports[i2].to);
  }
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b) => scaleBlock(b, scaler)) : block._content);
}
const theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m2) => {
        if (m2 == "&")
          return main;
        if (!scopes || !scopes[m2])
          throw new RangeError(`Unsupported selector: ${m2}`);
        return scopes[m2];
      }) : main + " " + sel;
    }
  });
}
const baseTheme$1$3 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser$3.ie && browser$3.ie_version <= 11;
class DOMObserver {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser$3.ie && browser$3.ie_version <= 11 || browser$3.ios && view.composing) && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (window.EditContext && browser$3.android && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(browser$3.chrome && browser$3.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable))
        view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia)
      this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a2;
        if (((_a2 = this.view.docView) === null || _a2 === void 0 ? void 0 : _a2.lastUpdate) < Date.now() - 75)
          this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, { threshold: [0, 1e-3] });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries) => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e2) {
    this.view.inputState.runHandlers("scroll", e2);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e2) {
    if (this.intersecting)
      this.flush(false);
    if (this.editContext)
      this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e2);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches)
      return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g2, i2) => g2 != gaps[i2]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.tile.nearest(sel.anchorNode);
    if (context && context.isWidget() && context.widget.ignoreEvent(event)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser$3.ie && browser$3.ie_version <= 11 || browser$3.android && browser$3.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let selection = getSelection(view.root);
    if (!selection)
      return false;
    let range = browser$3.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
    if (!range || this.selectionRange.eq(range))
      return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i2 = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom)
          i2++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i2);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i2 < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i2);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f2) {
    if (!this.active)
      return f2();
    try {
      this.stop();
      return f2();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  // Throw away any pending changes
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key2.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        // Only run the key handler when no changes are detected if
        // this isn't coming right after another change, in which case
        // it is probably part of a weird chain of updates, and should
        // be ignored if it returns the DOM to its previous state.
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (let mut of this.observer.takeRecords())
      this.queue.push(mut);
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length)
      this.queue = [];
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return { from, to, typeOver };
  }
  readChange() {
    let { from, to, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel)
      return null;
    if (from > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to, typeOver);
    this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
    return change;
  }
  // Apply pending changes, if any
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main)))
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let tile = this.view.docView.tile.nearest(rec.target);
    if (!tile || tile.isWidget())
      return null;
    tile.markDirty(rec.type == "attributes");
    if (rec.type == "childList") {
      let childBefore = findChild(tile, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(tile, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? tile.posAfter(childBefore) : tile.posAtStart,
        to: childAfter ? tile.posBefore(childAfter) : tile.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: tile.posAtStart, to: tile.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener)
        this.printQuery.addEventListener("change", this.onPrint);
      else
        this.printQuery.addListener(this.onPrint);
    } else
      win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener)
        this.printQuery.removeEventListener("change", this.onPrint);
      else
        this.printQuery.removeListener(this.onPrint);
    } else
      win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable))
        update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
}
function findChild(tile, dom, dir) {
  while (dom) {
    let curTile = Tile.get(dom);
    if (curTile && curTile.parent == tile)
      return curTile;
    let parent = dom.parentNode;
    dom = parent != tile.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor, 1);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariSelectionRangeHack(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = /* @__PURE__ */ Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = (e2) => {
      let main = view.state.selection.main, { anchor, head } = main;
      let from = this.toEditorPos(e2.updateRangeStart), to = this.toEditorPos(e2.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing)
        this.composing = { contextBase: e2.updateRangeStart, editorBase: from, drifted: false };
      let deletes = to - from > e2.text.length;
      if (from == this.from && anchor < this.from)
        from = anchor;
      else if (to == this.to && anchor > this.to)
        to = anchor;
      let diff = findDiff(view.state.sliceDoc(from, to), e2.text, (deletes ? main.from : main.to) - from, deletes ? "end" : null);
      if (!diff) {
        let newSel = EditorSelection.single(this.toEditorPos(e2.selectionStart), this.toEditorPos(e2.selectionEnd));
        if (!newSel.main.eq(main))
          view.dispatch({ selection: newSel, userEvent: "select" });
        return;
      }
      let change = {
        from: diff.from + from,
        to: diff.toA + from,
        insert: Text.of(e2.text.slice(diff.from, diff.toB).split("\n"))
      };
      if ((browser$3.mac || browser$3.android) && change.from == head - 1 && /^\. ?$/.test(e2.text) && view.contentDOM.getAttribute("autocorrect") == "off")
        change = { from, to, insert: Text.of([e2.text.replace(".", " ")]) };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e2.selectionStart, newLen), this.toEditorPos(e2.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
      if (change.from < change.to && !change.insert.length && view.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(context.text.slice(Math.max(0, e2.updateRangeStart - 1), Math.min(context.text.length, e2.updateRangeStart + 1))))
        this.handlers.compositionend(e2);
    };
    this.handlers.characterboundsupdate = (e2) => {
      let rects = [], prev = null;
      for (let i2 = this.toEditorPos(e2.rangeStart), end = this.toEditorPos(e2.rangeEnd); i2 < end; i2++) {
        let rect = view.coordsForChar(i2);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e2.rangeStart, rects);
    };
    this.handlers.textformatupdate = (e2) => {
      let deco = [];
      for (let format2 of e2.getTextFormats()) {
        let lineStyle = format2.underlineStyle, thickness = format2.underlineThickness;
        if (!/none/i.test(lineStyle) && !/none/i.test(thickness)) {
          let from = this.toEditorPos(format2.rangeStart), to = this.toEditorPos(format2.rangeEnd);
          if (from < to) {
            let style = `text-decoration: underline ${/^[a-z]/.test(lineStyle) ? lineStyle + " " : lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${/thin/i.test(thickness) ? 1 : 2}px`;
            deco.push(Decoration.mark({ attributes: { style } }).range(from, to));
          }
        }
      }
      view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let { drifted } = this.composing;
        this.composing = null;
        if (drifted)
          this.reset(view.state);
      }
    };
    for (let event in this.handlers)
      context.addEventListener(event, this.handlers[event]);
    this.measureReq = { read: (view2) => {
      this.editContext.updateControlBounds(view2.contentDOM.getBoundingClientRect());
      let sel = getSelection(view2.root);
      if (sel && sel.rangeCount)
        this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(update) {
    let off2 = 0, abort = false, pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert2) => {
      if (abort)
        return;
      let dLen = insert2.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert2)) {
          pending = this.pendingContextChange = null;
          off2 += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off2;
      toA += off2;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert2.length > 3e4) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert2.toString());
        this.to += dLen;
      }
      off2 += dLen;
    });
    if (pending && !abort)
      this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange, startSel = update.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr) => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet)
      update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let { head } = state.selection.main;
    this.from = Math.max(
      0,
      head - 1e4
      /* CxVp.Margin */
    );
    this.to = Math.min(
      state.doc.length,
      head + 1e4
      /* CxVp.Margin */
    );
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let { main } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)
      this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let { head } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(contextPos, clipLen = this.to - this.from) {
    contextPos = Math.min(contextPos, clipLen);
    let c2 = this.composing;
    return c2 && c2.drifted ? c2.editorBase + (contextPos - c2.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c2 = this.composing;
    return c2 && c2.drifted ? c2.contextBase + (editorPos - c2.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers)
      this.editContext.removeEventListener(event, this.handlers[event]);
  }
}
class EditorView {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(config2 = {}) {
    var _a2;
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config2.parent)
      config2.parent.appendChild(this.dom);
    let { dispatch } = config2;
    this.dispatchTransactions = config2.dispatchTransactions || dispatch && ((trs) => trs.forEach((tr) => dispatch(tr, this))) || ((trs) => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    if (config2.scrollTo && config2.scrollTo.is(scrollIntoView$1))
      this.viewState.scrollTarget = config2.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin2 of this.plugins)
      plugin2.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a2 = document.fonts) === null || _a2 === void 0 ? void 0 : _a2.ready)
      document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...input) {
    let trs = input.length == 1 && input[0] instanceof Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
    if (transactions.some((tr) => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus)
        focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (let e2 of tr.effects)
          if (e2.is(scrollIntoView$1))
            scrollTarget = e2.value.clip(this.state);
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (redrawn)
      this.docViewUpdate();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener)) {
        try {
          listener(update);
        } catch (e2) {
          logException(this.state, e2, "update listener");
        }
      }
    if (dispatchFocus || domChange)
      Promise.resolve().then(() => {
        if (dispatchFocus && this.state == dispatchFocus.startState)
          this.dispatch(dispatchFocus);
        if (domChange) {
          if (!applyDOMChange(this, domChange) && pendingKey.force)
            dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
        }
      });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin2 of this.plugins)
        plugin2.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin2 of this.plugins)
        plugin2.update(this);
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin2 = this.plugins[found];
          plugin2.mustUpdate = update;
          newPlugins.push(plugin2);
        }
      }
      for (let plugin2 of this.plugins)
        if (plugin2.mustUpdate != update)
          plugin2.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (let p2 of this.plugins)
        p2.mustUpdate = update;
    }
    for (let i2 = 0; i2 < this.plugins.length; i2++)
      this.plugins[i2].update(this);
    if (prevSpecs != specs)
      this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let plugin2 of this.plugins) {
      let val = plugin2.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e2) {
          logException(this.state, e2, "doc view update listener");
        }
      }
    }
  }
  /**
  @internal
  */
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
    let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
      scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i2 = 0; ; i2++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i2 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m2) => {
          try {
            return m2.read(this);
          } catch (e2) {
            logException(this.state, e2);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn)
            this.docViewUpdate();
        }
        for (let i3 = 0; i3 < measuring.length; i3++)
          if (measured[i3] != BadMeasure) {
            try {
              let m2 = measuring[i3];
              if (m2.write)
                m2.write(measured[i3], this);
            } catch (e2) {
              logException(this.state, e2);
            }
          }
        if (redrawn)
          this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser$3.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(EditorView.cspNonce);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$3).reverse(), nonce ? { nonce } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1)
        return;
      if (request.key != null)
        for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
          if (this.measureRequests[i2].key === request.key) {
            this.measureRequests[i2] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(plugin2) {
    let known = this.pluginMap.get(plugin2);
    if (known === void 0 || known && known.plugin != plugin2)
      this.pluginMap.set(plugin2, known = this.plugins.find((p2) => p2.plugin == plugin2) || null);
    return known && known.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(line, end) {
    let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(start, forward, includeWrap = true) {
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(pos, side = 1) {
    return this.docView.domAtPos(pos, side);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(node2, offset = 0) {
    return this.docView.posFromDOM(node2, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    let found = posAtCoords(this, coords, precise);
    return found && found.pos;
  }
  posAndSideAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from), isolates;
    for (let entry of this.bidiCache) {
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))
        return entry.order;
    }
    if (!isolates)
      isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser$3.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    if (this.root.activeElement == this.contentDOM)
      this.contentDOM.blur();
    for (let plugin2 of this.plugins)
      plugin2.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(pos, options = {}) {
    return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop, scrollLeft } = this.scrollDOM;
    let ref2 = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView$1.of(new ScrollTarget(EditorSelection.cursor(ref2.from), "start", "start", ref2.top - scrollTop, scrollLeft, true));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(to) {
    if (to == null)
      this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;
    else if (typeof to == "boolean")
      this.inputState.tabFocusMode = to ? 0 : -1;
    else if (this.inputState.tabFocusMode != 0)
      this.inputState.tabFocusMode = Date.now() + to;
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(observers2) {
    return ViewPlugin.define(() => ({}), { eventObservers: observers2 });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let tile = content2 && Tile.get(content2) || Tile.get(dom);
    return ((_a2 = tile === null || tile === void 0 ? void 0 : tile.root) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler$1;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.blockWrappers = blockWrappers;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : "" });
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache2, changes) {
    if (changes.empty && !cache2.some((c2) => c2.fresh))
      return cache2;
    let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
    for (let i2 = Math.max(0, cache2.length - 10); i2 < cache2.length; i2++) {
      let entry = cache2[i2];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
    let source = sources[i2], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
const currentPlatform = browser$3.mac ? "mac" : browser$3.windows ? "win" : browser$3.linux ? "linux" : "key";
function normalizeKeyName(name2, platform2) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i2 = 0; i2 < parts.length - 1; ++i2) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform2 == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event, shift2) {
  if (event.altKey)
    name2 = "Alt-" + name2;
  if (event.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
const handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
const keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
const Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map)
    Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a2, b) => a2.concat(b), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4e3;
function buildKeymap(bindings, platform2 = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add2 = (scope, key, command2, preventDefault, stopPropagation) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform2));
    for (let i2 = 1; i2 < parts.length; i2++) {
      let prefix = parts.slice(0, i2).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix])
        scopeObj[prefix] = {
          preventDefault: true,
          stopPropagation: false,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding2 = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command2)
      binding2.run.push(command2);
    if (preventDefault)
      binding2.preventDefault = true;
    if (stopPropagation)
      binding2.stopPropagation = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
        let { any } = b;
        for (let key in scopeObj)
          scopeObj[key].run.push((view) => any(view, currentKeyEvent));
      }
    let name2 = b[platform2] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add2(scope, name2, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift)
        add2(scope, "Shift-" + name2, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
  currentKeyEvent = event;
  let name2 = keyName(event);
  let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
  let prefix = "", handled = false, prevented = false, stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding2) => {
    if (binding2) {
      for (let cmd2 of binding2.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view)) {
            if (binding2.stopPropagation)
              stopPropagation = true;
            return true;
          }
        }
      if (binding2.preventDefault) {
        if (binding2.stopPropagation)
          stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name2, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(browser$3.windows && event.ctrlKey && event.altKey) && // Alt-combinations on macOS tend to be typed characters
    !(browser$3.mac && event.altKey && !(event.ctrlKey || event.metaKey)) && (baseName = base[event.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name2, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any))
      handled = true;
  }
  if (prevented)
    handled = true;
  if (handled && stopPropagation)
    event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
class RectangleMarker {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(className, left, top2, width, height) {
    this.className = className;
    this.left = left;
    this.top = top2;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className)
      return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null)
      elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p2) {
    return this.left == p2.left && this.top == p2.top && this.width == p2.width && this.height == p2.height && this.className == p2.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos)
        return [];
      let base2 = getBase(view);
      return [new RectangleMarker(className, pos.left - base2.left, pos.top - base2.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
}
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, side, inside) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords)
    return inside;
  let editorRect = view.dom.getBoundingClientRect();
  let y2 = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({ x: editorRect.left + 1, y: y2 });
  let right = view.posAtCoords({ x: editorRect.right - 1, y: y2 });
  if (left == null || right == null)
    return inside;
  return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to)
    return [];
  let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
  let lineElt = content2.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from, 1), endBlock = blockAt(view, to, -1);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
    visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
    visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top2.bottom + view.defaultLineHeight / 2 < bottom.top)
      between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
    else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
      top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
    return pieces(top2).concat(between).concat(pieces(bottom));
  }
  function piece(left, top2, right, bottom) {
    return new RectangleMarker(className, left - base2.left, top2 - base2.top, right - left, bottom - top2);
  }
  function pieces({ top: top2, bottom, horizontal }) {
    let pieces2 = [];
    for (let i2 = 0; i2 < horizontal.length; i2 += 2)
      pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
    return pieces2;
  }
  function drawForLine(from2, to2, line) {
    let top2 = 1e9, bottom = -1e9, horizontal = [];
    function addSpan(from3, fromOpen, to3, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
      if (!fromCoords || !toCoords)
        return;
      top2 = Math.min(fromCoords.top, toCoords.top, top2);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR)
        horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
      else
        horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
    for (let r2 of view.visibleRanges)
      if (r2.to > start && r2.from < end) {
        for (let pos = Math.max(r2.from, start), endPos = Math.min(r2.to, end); ; ) {
          let docLine = view.state.doc.lineAt(pos);
          for (let span of view.bidiSpans(docLine)) {
            let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
            if (spanFrom >= endPos)
              break;
            if (spanTo > pos)
              addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos)
            break;
        }
      }
    if (horizontal.length == 0)
      addSpan(start, from2 == null, end, to2 == null, view.textDirection);
    return { top: top2, bottom, horizontal };
  }
  function drawForWidget(block, top2) {
    let y2 = contentRect.top + (top2 ? block.top : block.bottom);
    return { top: y2, bottom: y2, horizontal: [] };
  }
}
function sameMarker(a2, b) {
  return a2.constructor == b.constructor && a2.eq(b);
}
class LayerView {
  constructor(view, layer2) {
    this.view = view;
    this.layer = layer2;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer2.above)
      this.dom.classList.add("cm-layer-above");
    if (layer2.class)
      this.dom.classList.add(layer2.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer2.mount)
      layer2.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
      this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false)
      view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0, order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer)
      pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX, scaleY } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p2, i2) => !sameMarker(p2, this.drawn[i2]))) {
      let old = this.dom.firstChild, oldI = 0;
      for (let marker of markers) {
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
      if (browser$3.safari && browser$3.safari_version >= 26)
        this.dom.style.display = this.dom.firstChild ? "" : "none";
    }
  }
  destroy() {
    if (this.layer.destroy)
      this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
}
const layerOrder = /* @__PURE__ */ Facet.define();
function layer(config2) {
  return [
    ViewPlugin.define((v2) => new LayerView(v2, config2)),
    layerOrder.of(config2)
  ];
}
const selectionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a2, b) => Math.min(a2, b),
      drawRangeCursor: (a2, b) => a2 || b
    });
  }
});
function drawSelection(config2 = {}) {
  return [
    selectionConfig.of(config2),
    cursorLayer,
    selectionLayer,
    hideNativeSelection,
    nativeSelectionHidden.of(true)
  ];
}
function getDrawSelectionConfig(state) {
  return state.facet(selectionConfig);
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = /* @__PURE__ */ layer({
  above: true,
  markers(view) {
    let { state } = view, conf = state.facet(selectionConfig);
    let cursors2 = [];
    for (let r2 of state.selection.ranges) {
      let prim = r2 == state.selection.main;
      if (r2.empty || conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor2 = r2.empty ? r2 : EditorSelection.cursor(r2.head, r2.head > r2.anchor ? -1 : 1);
        for (let piece of RectangleMarker.forRange(view, className, cursor2))
          cursors2.push(piece);
      }
    }
    return cursors2;
  },
  update(update, dom) {
    if (update.transactions.some((tr) => tr.selection))
      dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange)
      setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = /* @__PURE__ */ layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map((r2) => r2.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r2)).reduce((a2, b) => a2.concat(b));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
const hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
}));
const setDropCursorPos = /* @__PURE__ */ StateEffect.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
const dropCursorPos = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(pos, tr) {
    if (pos != null)
      pos = tr.changes.mapPos(pos);
    return tr.effects.reduce((pos2, e2) => e2.is(setDropCursorPos) ? e2.value : pos2, pos);
  }
});
const drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(update) {
    var _a2;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
        this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let { view } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect)
      return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let { scaleX, scaleY } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor)
      this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos)
      this.view.dispatch({ effects: setDropCursorPos.of(pos) });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
        this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc2, re, from, to, f2) {
  re.lastIndex = 0;
  for (let cursor2 = doc2.iterRange(from, to), pos = from, m2; !cursor2.next().done; pos += cursor2.value.length) {
    if (!cursor2.lineBreak)
      while (m2 = re.exec(cursor2.value))
        f2(pos + m2.index, m2);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
    return visible;
  let result = [];
  for (let { from, to } of visible) {
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from)
      result[result.length - 1].to = to;
    else
      result.push({ from, to });
  }
  return result;
}
class MatchDecorator {
  /**
  Create a decorator.
  */
  constructor(config2) {
    const { regexp, decoration, decorate, boundary, maxLength = 1e3 } = config2;
    if (!regexp.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add2) => decorate(add2, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add2) => {
        let deco = decoration(match, view, from);
        if (deco)
          add2(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add2) => add2(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(view) {
    let build = new RangeSetBuilder(), add2 = build.add.bind(build);
    for (let { from, to } of matchRanges(view, this.maxLength))
      iterMatches(view.state.doc, this.regexp, from, to, (from2, m2) => this.addMatch(m2, view, from2, add2));
    return build.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(update, deco) {
    let changeFrom = 1e9, changeTo = -1;
    if (update.docChanged)
      update.changes.iterChanges((_f, _t, from, to) => {
        if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
          changeFrom = Math.min(from, changeFrom);
          changeTo = Math.max(to, changeTo);
        }
      });
    if (update.viewportMoved || changeTo - changeFrom > 1e3)
      return this.createDeco(update.view);
    if (changeTo > -1)
      return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (let r2 of view.visibleRanges) {
      let from = Math.max(r2.from, updateFrom), to = Math.min(r2.to, updateTo);
      if (to >= from) {
        let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r2.from, fromLine.from), end = Math.min(r2.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--)
            if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
              start = from;
              break;
            }
          for (; to < toLine.to; to++)
            if (this.boundary.test(toLine.text[to - toLine.from])) {
              end = to;
              break;
            }
        }
        let ranges = [], m2;
        let add2 = (from2, to2, deco2) => ranges.push(deco2.range(from2, to2));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m2 = this.regexp.exec(fromLine.text)) && m2.index < end - fromLine.from)
            this.addMatch(m2, view, m2.index + fromLine.from, add2);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from2, m3) => this.addMatch(m3, view, from2, add2));
        }
        deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
      }
    }
    return deco;
  }
}
const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /* @__PURE__ */ new RegExp("[\0-\b\n--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]", UnicodeRegexpSupport);
const Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
  var _a2;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
const specialCharConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let config2 = combineConfig(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config2.replaceTabs = !supportsTabSize())
      config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
    if (config2.addSpecialChars)
      config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
    return config2;
  }
});
function highlightSpecialChars(config2 = {}) {
  return [specialCharConfig.of(config2), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = /* @__PURE__ */ Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m2, view, pos) => {
          let { doc: doc2 } = view.state;
          let code2 = codePointAt(m2[0], 0);
          if (code2 == 9) {
            let line = doc2.lineAt(pos);
            let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code2] || (this.decorationCache[code2] = Decoration.replace({ widget: new SpecialCharWidget(conf, code2) }));
        },
        boundary: conf.replaceTabs ? void 0 : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: (v2) => v2.decorations
  }));
}
const DefaultPlaceholder = "•";
function placeholder$1(code2) {
  if (code2 >= 32)
    return DefaultPlaceholder;
  if (code2 == 10)
    return "␤";
  return String.fromCharCode(9216 + code2);
}
class SpecialCharWidget extends WidgetType {
  constructor(options, code2) {
    super();
    this.options = options;
    this.code = code2;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom2 = this.options.render && this.options.render(this.code, desc, ph);
    if (custom2)
      return custom2;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}
class TabWidget extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "	";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}
const plugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor() {
    this.height = 1e3;
    this.attrs = { style: "padding-bottom: 1000px" };
  }
  update(update) {
    let { view } = update;
    let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;
    if (height >= 0 && height != this.height) {
      this.height = height;
      this.attrs = { style: `padding-bottom: ${height}px` };
    }
  }
});
function scrollPastEnd() {
  return [plugin, contentAttributes.of((view) => {
    var _a2;
    return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.attrs) || null;
  })];
}
function highlightActiveLine() {
  return activeLineHighlighter;
}
const lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1, deco = [];
    for (let r2 of view.state.selection.ranges) {
      let line = view.lineBlockAt(r2.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v2) => v2.decorations
});
class Placeholder extends WidgetType {
  constructor(content2) {
    super();
    this.content = content2;
  }
  toDOM(view) {
    let wrap = document.createElement("span");
    wrap.className = "cm-placeholder";
    wrap.style.pointerEvents = "none";
    wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
    wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
    if (!rects.length)
      return null;
    let style = window.getComputedStyle(dom.parentNode);
    let rect = flattenRect(rects[0], style.direction != "rtl");
    let lineHeight = parseInt(style.lineHeight);
    if (rect.bottom - rect.top > lineHeight * 1.5)
      return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
    return rect;
  }
  ignoreEvent() {
    return false;
  }
}
function placeholder(content2) {
  let plugin2 = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = content2 ? Decoration.set([Decoration.widget({ widget: new Placeholder(content2), side: 1 }).range(0)]) : Decoration.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }
  }, { decorations: (v2) => v2.decorations });
  return typeof content2 == "string" ? [
    plugin2,
    EditorView.contentAttributes.of({ "aria-placeholder": content2 })
  ] : plugin2;
}
const MaxOff = 2e3;
function rectangleFor(state, a2, b) {
  let startLine = Math.min(a2.line, b.line), endLine = Math.max(a2.line, b.line);
  let ranges = [];
  if (a2.off > MaxOff || b.off > MaxOff || a2.col < 0 || b.col < 0) {
    let startOff = Math.min(a2.off, b.off), endOff = Math.max(a2.off, b.off);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line = state.doc.line(i2);
      if (line.length <= endOff)
        ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a2.col, b.col), endCol = Math.max(a2.col, b.col);
    for (let i2 = startLine; i2 <= endLine; i2++) {
      let line = state.doc.line(i2);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x2) {
  let ref2 = view.coordsAtPos(view.viewport.from);
  return ref2 ? Math.round(Math.abs((ref2.left - x2) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  let line = view.state.doc.lineAt(offset), off2 = offset - line.from;
  let col = off2 > MaxOff ? -1 : off2 == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return { line: line.number, col, off: off2 };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event), startSel = view.state.selection;
  if (!start)
    return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
        startSel = startSel.map(update.changes);
      }
    },
    get(event2, _extend, multiple) {
      let cur2 = getPos(view, event2);
      if (!cur2)
        return startSel;
      let ranges = rectangleFor(view.state, start, cur2);
      if (!ranges.length)
        return startSel;
      if (multiple)
        return EditorSelection.create(ranges.concat(startSel.ranges));
      else
        return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter2 = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e2) => e2.altKey && e2.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter2(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
  Alt: [18, (e2) => !!e2.altKey],
  Control: [17, (e2) => !!e2.ctrlKey],
  Shift: [16, (e2) => !!e2.shiftKey],
  Meta: [91, (e2) => !!e2.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
function crosshairCursor(options = {}) {
  let [code2, getter] = keys[options.key || "Alt"];
  let plugin2 = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e2) {
        this.set(e2.keyCode == code2 || getter(e2));
      },
      keyup(e2) {
        if (e2.keyCode == code2 || !getter(e2))
          this.set(false);
      },
      mousemove(e2) {
        this.set(getter(e2));
      }
    }
  });
  return [
    plugin2,
    EditorView.contentAttributes.of((view) => {
      var _a2;
      return ((_a2 = view.plugin(plugin2)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
    })
  ];
}
const Outside = "-10000px";
class TooltipViewManager {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t2) => t2);
    let prev = null;
    this.tooltipViews = this.tooltips.map((t2) => prev = createTooltipView(t2, prev));
  }
  update(update, above) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips2 = input.filter((x2) => x2);
    if (input === this.input) {
      for (let t2 of this.tooltipViews)
        if (t2.update)
          t2.update(update);
      return false;
    }
    let tooltipViews = [], newAbove = above ? [] : null;
    for (let i2 = 0; i2 < tooltips2.length; i2++) {
      let tip = tooltips2[i2], known = -1;
      if (!tip)
        continue;
      for (let i3 = 0; i3 < this.tooltips.length; i3++) {
        let other = this.tooltips[i3];
        if (other && other.create == tip.create)
          known = i3;
      }
      if (known < 0) {
        tooltipViews[i2] = this.createTooltipView(tip, i2 ? tooltipViews[i2 - 1] : null);
        if (newAbove)
          newAbove[i2] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
        if (newAbove)
          newAbove[i2] = above[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t2 of this.tooltipViews)
      if (tooltipViews.indexOf(t2) < 0) {
        this.removeTooltipView(t2);
        (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
      }
    if (above) {
      newAbove.forEach((val, i2) => above[i2] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips2;
    this.tooltipViews = tooltipViews;
    return true;
  }
}
function tooltips(config2 = {}) {
  return tooltipConfig.of(config2);
}
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: docElt.clientHeight, right: docElt.clientWidth };
}
const tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    var _a2, _b, _c;
    return {
      position: browser$3.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
const knownHeight = /* @__PURE__ */ new WeakMap();
const tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t2, p2) => this.createTooltip(t2, p2), (t2) => {
      if (this.resizeObserver)
        this.resizeObserver.unobserve(t2.dom);
      t2.dom.remove();
    });
    this.above = this.manager.tooltips.map((t2) => !!t2.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t2 of this.manager.tooltipViews)
        this.container.appendChild(t2.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    if (this.resizeObserver)
      this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a2, _b, _c;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    if (this.parent)
      this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let scaleX = 1, scaleY = 1, makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom } = this.manager.tooltipViews[0];
      if (browser$3.safari) {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 1e4) > 1 || Math.abs(rect.left) > 1;
      } else {
        makeAbsolute = !!dom.offsetParent && dom.offsetParent != this.container.ownerDocument.body;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({ scaleX, scaleY } = this.view.viewState);
      }
    }
    let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);
    return {
      visible: {
        left: visible.left + margins.left,
        top: visible.top + margins.top,
        right: visible.right - margins.right,
        bottom: visible.bottom - margins.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((t2, i2) => {
        let tv = this.manager.tooltipViews[i2];
        return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a2;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (let t2 of this.manager.tooltipViews)
        t2.dom.style.position = "absolute";
    }
    let { visible, space: space2, scaleX, scaleY } = measured;
    let others = [];
    for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
      let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom } = tView;
      let pos = measured.pos[i2], size = measured.size[i2];
      if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space2.top) || pos.top >= Math.min(visible.bottom, space2.bottom) || pos.right < Math.max(visible.left, space2.left) - 0.1 || pos.left > Math.min(visible.right, space2.right) + 0.1)) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left, height = (_a2 = knownHeight.get(tView)) !== null && _a2 !== void 0 ? _a2 : size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space2.right - space2.left ? ltr ? space2.left : space2.right - size.width : ltr ? Math.max(space2.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space2.right - width)) : Math.min(Math.max(space2.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space2.right - width);
      let above = this.above[i2];
      if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space2.top : pos.bottom + height + arrowHeight + offset.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top)
        above = this.above[i2] = !above;
      let spaceVert = (above ? pos.top - space2.top : space2.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (let r2 of others)
          if (r2.left < right && r2.right > left && r2.top < top2 + height && r2.bottom > top2)
            top2 = above ? r2.top - height - 2 - arrowHeight : r2.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = (top2 - measured.parent.top) / scaleY + "px";
        setLeftStyle(dom, (left - measured.parent.left) / scaleX);
      } else {
        dom.style.top = top2 / scaleY + "px";
        setLeftStyle(dom, left / scaleX);
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true)
        others.push({ left, top: top2, right, bottom: top2 + height });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function setLeftStyle(elt, value) {
  let current = parseInt(elt.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1)
    elt.style.left = value + "px";
}
const baseTheme$4 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
const noOffset = { x: 0, y: 0 };
const showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme$4]
});
const showHoverTooltip = /* @__PURE__ */ Facet.define({
  combine: (inputs) => inputs.reduce((a2, i2) => a2.concat(i2), [])
});
class HoverTooltipHost {
  // Needs to be static so that host tooltip instances always match
  static create(view) {
    return new HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t2, p2) => this.createHostedView(t2, p2), (t2) => t2.dom.remove());
  }
  createHostedView(tooltip, prev) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
    if (this.mounted && hostedView.mount)
      hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.mount)
        hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space2) {
    for (let hostedView of this.manager.tooltipViews) {
      if (hostedView.positioned)
        hostedView.positioned(space2);
    }
  }
  update(update) {
    this.manager.update(update);
  }
  destroy() {
    var _a2;
    for (let t2 of this.manager.tooltipViews)
      (_a2 = t2.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t2);
  }
  passProp(name2) {
    let value = void 0;
    for (let view of this.manager.tooltipViews) {
      let given = view[name2];
      if (given !== void 0) {
        if (value === void 0)
          value = given;
        else if (value !== given)
          return void 0;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state) => {
  let tooltips2 = state.facet(showHoverTooltip);
  if (tooltips2.length === 0)
    return null;
  return {
    pos: Math.min(...tooltips2.map((t2) => t2.pos)),
    end: Math.max(...tooltips2.map((t2) => {
      var _a2;
      return (_a2 = t2.end) !== null && _a2 !== void 0 ? _a2 : t2.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips2[0].above,
    arrow: tooltips2.some((t2) => t2.arrow)
  };
});
class HoverPlugin {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active.length)
      return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
    else
      this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view, lastMove } = this;
    let tile = view.docView.tile.nearest(lastMove.target);
    if (!tile)
      return;
    let pos, side = 1;
    if (tile.isWidget()) {
      pos = tile.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null)
        return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth)
        return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s2) => s2.from <= pos && s2.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = { pos };
      open.then((result) => {
        if (this.pending == pending) {
          this.pending = null;
          if (result && !(Array.isArray(result) && !result.length))
            view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });
        }
      }, (e2) => logException(view.state, e2, "hover tooltip"));
    } else if (open && !(Array.isArray(open) && !open.length)) {
      view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });
    }
  }
  get tooltip() {
    let plugin2 = this.view.plugin(tooltipPlugin);
    let index = plugin2 ? plugin2.manager.tooltips.findIndex((t2) => t2.create == HoverTooltipHost.create) : -1;
    return index > -1 ? plugin2.manager.tooltipViews[index] : null;
  }
  mousemove(event) {
    var _a2, _b;
    this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
    if (this.hoverTimeout < 0)
      this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let { active, tooltip } = this;
    if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
      let { pos } = active[0] || this.pending, end = (_b = (_a2 = active[0]) === null || _a2 === void 0 ? void 0 : _a2.end) !== null && _b !== void 0 ? _b : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
        this.view.dispatch({ effects: this.setHover.of([]) });
        this.pending = null;
      }
    }
  }
  mouseleave(event) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let { active } = this;
    if (active.length) {
      let { tooltip } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
      if (!inTooltip)
        this.view.dispatch({ effects: this.setHover.of([]) });
      else
        this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch = (event) => {
      tooltip.removeEventListener("mouseleave", watch);
      if (this.active.length && !this.view.dom.contains(event.relatedTarget))
        this.view.dispatch({ effects: this.setHover.of([]) });
    };
    tooltip.addEventListener("mouseleave", watch);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
  let { left, right, top: top2, bottom } = tooltip.getBoundingClientRect(), arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top2 = Math.min(arrowRect.top, top2);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top2 - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x2, y2, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x2 || rect.right < x2 || rect.top > y2 || Math.min(rect.bottom, docBottom) < y2)
    return false;
  let pos = view.posAtCoords({ x: x2, y: y2 }, false);
  return pos >= from && pos <= to;
}
function hoverTooltip(source, options = {}) {
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr) {
      if (value.length) {
        if (options.hideOnChange && (tr.docChanged || tr.selection))
          value = [];
        else if (options.hideOn)
          value = value.filter((v2) => !options.hideOn(tr, v2));
        if (tr.docChanged) {
          let mapped = [];
          for (let tooltip of value) {
            let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy = Object.assign(/* @__PURE__ */ Object.create(null), tooltip);
              copy.pos = newPos;
              if (copy.end != null)
                copy.end = tr.changes.mapPos(copy.end);
              mapped.push(copy);
            }
          }
          value = mapped;
        }
      }
      for (let effect of tr.effects) {
        if (effect.is(setHover))
          value = effect.value;
        if (effect.is(closeHoverTooltipEffect))
          value = [];
      }
      return value;
    },
    provide: (f2) => showHoverTooltip.from(f2)
  });
  return {
    active: hoverState,
    extension: [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(
        view,
        source,
        hoverState,
        setHover,
        options.hoverTime || 300
        /* Hover.Time */
      )),
      showHoverTooltipHost
    ]
  };
}
function getTooltip(view, tooltip) {
  let plugin2 = view.plugin(tooltipPlugin);
  if (!plugin2)
    return null;
  let found = plugin2.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin2.manager.tooltipViews[found];
}
function hasHoverTooltips(state) {
  return state.facet(showHoverTooltip).some((x2) => x2);
}
const closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
const closeHoverTooltips = /* @__PURE__ */ closeHoverTooltipEffect.of(null);
function repositionTooltips(view) {
  let plugin2 = view.plugin(tooltipPlugin);
  if (plugin2)
    plugin2.maybeMeasure();
}
const panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c2 of configs) {
      topContainer = topContainer || c2.topContainer;
      bottomContainer = bottomContainer || c2.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
function panels(config2) {
  return config2 ? [panelConfig.of(config2)] : [];
}
function getPanel(view, panel) {
  let plugin2 = view.plugin(panelPlugin);
  let index = plugin2 ? plugin2.specs.indexOf(panel) : -1;
  return index > -1 ? plugin2.panels[index] : null;
}
const panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s2) => s2);
    this.panels = this.specs.map((spec) => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter((p2) => p2.top));
    this.bottom.sync(this.panels.filter((p2) => !p2.top));
    for (let p2 of this.panels) {
      p2.dom.classList.add("cm-panel");
      if (p2.mount)
        p2.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x2) => x2);
      let panels2 = [], top2 = [], bottom = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels2.push(panel);
        (panel.top ? top2 : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels2;
      this.top.sync(top2);
      this.bottom.sync(bottom);
      for (let p2 of mount) {
        p2.dom.classList.add("cm-panel");
        if (p2.mount)
          p2.mount();
      }
    } else {
      for (let p2 of this.panels)
        if (p2.update)
          p2.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin2) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin2);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
class PanelGroup {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels2) {
    for (let p2 of this.panels)
      if (p2.destroy && panels2.indexOf(p2) < 0)
        p2.destroy();
    this.panels = panels2;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
}
function rm(node2) {
  let next = node2.nextSibling;
  node2.remove();
  return next;
}
const showPanel = /* @__PURE__ */ Facet.define({
  enables: panelPlugin
});
function showDialog(view, config2) {
  let resolve2;
  let promise = new Promise((r2) => resolve2 = r2);
  let panelCtor = (view2) => createDialog(view2, config2, resolve2);
  if (view.state.field(dialogField$1, false)) {
    view.dispatch({ effects: openDialogEffect.of(panelCtor) });
  } else {
    view.dispatch({ effects: StateEffect.appendConfig.of(dialogField$1.init(() => [panelCtor])) });
  }
  let close = closeDialogEffect.of(panelCtor);
  return { close, result: promise.then((form) => {
    let queue2 = view.win.queueMicrotask || ((f2) => view.win.setTimeout(f2, 10));
    queue2(() => {
      if (view.state.field(dialogField$1).indexOf(panelCtor) > -1)
        view.dispatch({ effects: close });
    });
    return form;
  }) };
}
function getDialog(view, className) {
  let dialogs = view.state.field(dialogField$1, false) || [];
  for (let open of dialogs) {
    let panel = getPanel(view, open);
    if (panel && panel.dom.classList.contains(className))
      return panel;
  }
  return null;
}
const dialogField$1 = /* @__PURE__ */ StateField.define({
  create() {
    return [];
  },
  update(dialogs, tr) {
    for (let e2 of tr.effects) {
      if (e2.is(openDialogEffect))
        dialogs = [e2.value].concat(dialogs);
      else if (e2.is(closeDialogEffect))
        dialogs = dialogs.filter((d2) => d2 != e2.value);
    }
    return dialogs;
  },
  provide: (f2) => showPanel.computeN([f2], (state) => state.field(f2))
});
const openDialogEffect = /* @__PURE__ */ StateEffect.define();
const closeDialogEffect = /* @__PURE__ */ StateEffect.define();
function createDialog(view, config2, result) {
  let content2 = config2.content ? config2.content(view, () => done(null)) : null;
  if (!content2) {
    content2 = crelt("form");
    if (config2.input) {
      let input = crelt("input", config2.input);
      if (/^(text|password|number|email|tel|url)$/.test(input.type))
        input.classList.add("cm-textfield");
      if (!input.name)
        input.name = "input";
      content2.appendChild(crelt("label", (config2.label || "") + ": ", input));
    } else {
      content2.appendChild(document.createTextNode(config2.label || ""));
    }
    content2.appendChild(document.createTextNode(" "));
    content2.appendChild(crelt("button", { class: "cm-button", type: "submit" }, config2.submitLabel || "OK"));
  }
  let forms = content2.nodeName == "FORM" ? [content2] : content2.querySelectorAll("form");
  for (let i2 = 0; i2 < forms.length; i2++) {
    let form = forms[i2];
    form.addEventListener("keydown", (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        done(null);
      } else if (event.keyCode == 13) {
        event.preventDefault();
        done(form);
      }
    });
    form.addEventListener("submit", (event) => {
      event.preventDefault();
      done(form);
    });
  }
  let panel = crelt("div", content2, crelt("button", {
    onclick: () => done(null),
    "aria-label": view.state.phrase("close"),
    class: "cm-dialog-close",
    type: "button"
  }, ["×"]));
  if (config2.class)
    panel.className = config2.class;
  panel.classList.add("cm-dialog");
  function done(form) {
    if (panel.contains(panel.ownerDocument.activeElement))
      view.focus();
    result(form);
  }
  return {
    dom: panel,
    top: config2.top,
    mount: () => {
      if (config2.focus) {
        let focus;
        if (typeof config2.focus == "string")
          focus = content2.querySelector(config2.focus);
        else
          focus = content2.querySelector("input") || content2.querySelector("button");
        if (focus && "select" in focus)
          focus.select();
        else if (focus && "focus" in focus)
          focus.focus();
      }
    }
  };
}
class GutterMarker extends RangeValue {
  /**
  @internal
  */
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(other) {
    return false;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(dom) {
  }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const gutterLineClass = /* @__PURE__ */ Facet.define();
const gutterWidgetClass = /* @__PURE__ */ Facet.define();
const defaults$1 = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
};
const activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config2) {
  return [gutters(), activeGutters.of({ ...defaults$1, ...config2 })];
}
const unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x2) => x2)
});
function gutters(config2) {
  let result = [
    gutterView
  ];
  if (config2 && config2.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
const gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.domAfter = null;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters cm-gutters-before";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    this.fixed = !view.state.facet(unfixGutters);
    for (let gutter2 of this.gutters) {
      if (gutter2.config.side == "after")
        this.getDOMAfter().appendChild(gutter2.dom);
      else
        this.dom.appendChild(gutter2.dom);
    }
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  getDOMAfter() {
    if (!this.domAfter) {
      this.domAfter = document.createElement("div");
      this.domAfter.className = "cm-gutters cm-gutters-after";
      this.domAfter.setAttribute("aria-hidden", "true");
      this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
      this.domAfter.style.position = this.fixed ? "sticky" : "";
      this.view.scrollDOM.appendChild(this.domAfter);
    }
    return this.domAfter;
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport, vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      let min = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = min;
      if (this.domAfter)
        this.domAfter.style.minHeight = min;
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
      if (this.domAfter)
        this.domAfter.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach) {
      this.dom.remove();
      if (this.domAfter)
        this.domAfter.remove();
    }
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
    for (let line of this.view.viewportLineBlocks) {
      if (classSet.length)
        classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (let b of line.type) {
          if (b.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b.from);
            for (let cx of contexts)
              cx.line(this.view, b, classSet);
            first = false;
          } else if (b.widget) {
            for (let cx of contexts)
              cx.widget(this.view, b);
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, line, classSet);
      } else if (line.widget) {
        for (let cx of contexts)
          cx.widget(this.view, line);
      }
    }
    for (let cx of contexts)
      cx.finish();
    if (detach) {
      this.view.scrollDOM.insertBefore(this.dom, after);
      if (this.domAfter)
        this.view.scrollDOM.appendChild(this.domAfter);
    }
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur2 = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur2) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur2) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g2 of this.gutters) {
        g2.dom.remove();
        if (gutters2.indexOf(g2) < 0)
          g2.destroy();
      }
      for (let g2 of gutters2) {
        if (g2.config.side == "after")
          this.getDOMAfter().appendChild(g2.dom);
        else
          this.dom.appendChild(g2.dom);
      }
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    for (let view of this.gutters)
      view.destroy();
    this.dom.remove();
    if (this.domAfter)
      this.domAfter.remove();
  }
}, {
  provide: (plugin2) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin2);
    if (!value || value.gutters.length == 0 || !value.fixed)
      return null;
    let before = value.dom.offsetWidth * view.scaleX, after = value.domAfter ? value.domAfter.offsetWidth * view.scaleX : 0;
    return view.textDirection == Direction.LTR ? { left: before, right: after } : { right: before, left: after };
  })
});
function asArray(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor2, collect, pos) {
  while (cursor2.value && cursor2.from <= pos) {
    if (cursor2.from == pos)
      collect.push(cursor2.value);
    cursor2.next();
  }
}
class UpdateContext {
  constructor(gutter2, viewport, height) {
    this.gutter = gutter2;
    this.height = height;
    this.i = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let { gutter: gutter2 } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      gutter2.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length)
      localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;
    for (let cls of view.state.facet(gutterWidgetClass)) {
      let marker2 = cls(view, block.widget, block);
      if (marker2)
        (markers || (markers = [])).push(marker2);
    }
    if (markers)
      this.addElement(view, block, markers);
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i) {
      let last = gutter2.elements.pop();
      gutter2.dom.removeChild(last.dom);
      last.destroy();
    }
  }
}
class SingleGutterView {
  constructor(view, config2) {
    this.view = view;
    this.config = config2;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config2.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let target = event.target, y2;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom)
            target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y2 = (rect.top + rect.bottom) / 2;
        } else {
          y2 = event.clientY;
        }
        let line = view.lineBlockAtHeight(y2 - view.documentTop);
        if (config2.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray(config2.markers(view));
    if (config2.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (let elt of this.elements)
      elt.destroy();
  }
}
class GutterElement {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers))
      this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement", domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0; ; ) {
      let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
      if (marker) {
        let c2 = marker.elementClass;
        if (c2)
          cls += " " + c2;
        for (let i2 = iOld; i2 < this.markers.length; i2++)
          if (this.markers[i2].compare(marker)) {
            skipTo = i2;
            matched = true;
            break;
          }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker)
        break;
      if (marker.toDOM) {
        if (matched)
          domPos = domPos.nextSibling;
        else
          this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched)
        iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function sameMarkers(a2, b) {
  if (a2.length != b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!a2[i2].compare(b[i2]))
      return false;
  return true;
}
const lineNumberMarkers = /* @__PURE__ */ Facet.define();
const lineNumberWidgetMarker = /* @__PURE__ */ Facet.define();
const lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a2, b) {
        let result = Object.assign({}, a2);
        for (let event in b) {
          let exists = result[event], add2 = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
        }
        return result;
      }
    });
  }
});
class NumberMarker extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
const lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m2) => m2.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (let m2 of view.state.facet(lineNumberWidgetMarker)) {
      let result = m2(view, widget, block);
      if (result)
        return result;
    }
    return null;
  },
  lineMarkerChange: (update) => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers,
  side: "before"
}));
function lineNumbers(config2 = {}) {
  return [
    lineNumberConfig.of(config2),
    gutters(),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}
const activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
const activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state) => {
  let marks = [], last = -1;
  for (let range of state.selection.ranges) {
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks.push(activeLineGutterMarker.range(linePos));
    }
  }
  return RangeSet.of(marks);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
function matcher(decorator) {
  return ViewPlugin.define((view) => ({
    decorations: decorator.createDeco(view),
    update(u2) {
      this.decorations = decorator.updateDeco(u2, this.decorations);
    }
  }), {
    decorations: (v2) => v2.decorations
  });
}
const tabDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-highlightTab" });
const spaceDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-highlightSpace" });
const whitespaceHighlighter = /* @__PURE__ */ matcher(/* @__PURE__ */ new MatchDecorator({
  regexp: /\t| /g,
  decoration: (match) => match[0] == "	" ? tabDeco : spaceDeco,
  boundary: /\S/
}));
function highlightWhitespace() {
  return whitespaceHighlighter;
}
const trailingHighlighter = /* @__PURE__ */ matcher(/* @__PURE__ */ new MatchDecorator({
  regexp: /\s+$/g,
  decoration: /* @__PURE__ */ Decoration.mark({ class: "cm-trailingSpace" })
}));
function highlightTrailingWhitespace() {
  return trailingHighlighter;
}
const __test = {
  HeightMap,
  HeightOracle,
  MeasuredHeights,
  QueryType: QueryType$1,
  ChangedRange,
  computeOrder,
  moveVisually,
  clearHeightChangeFlag,
  getHeightChangeFlag: () => heightChangeFlag
};
const View = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BidiSpan,
  BlockInfo,
  get BlockType() {
    return BlockType;
  },
  BlockWrapper,
  Decoration,
  get Direction() {
    return Direction;
  },
  EditorView,
  GutterMarker,
  MatchDecorator,
  RectangleMarker,
  ViewPlugin,
  ViewUpdate,
  WidgetType,
  __test,
  closeHoverTooltips,
  crosshairCursor,
  drawSelection,
  dropCursor,
  getDialog,
  getDrawSelectionConfig,
  getPanel,
  getTooltip,
  gutter,
  gutterLineClass,
  gutterWidgetClass,
  gutters,
  hasHoverTooltips,
  highlightActiveLine,
  highlightActiveLineGutter,
  highlightSpecialChars,
  highlightTrailingWhitespace,
  highlightWhitespace,
  hoverTooltip,
  keymap,
  layer,
  lineNumberMarkers,
  lineNumberWidgetMarker,
  lineNumbers,
  logException,
  panels,
  placeholder,
  rectangularSelection,
  repositionTooltips,
  runScopeHandlers,
  scrollPastEnd,
  showDialog,
  showPanel,
  showTooltip,
  tooltips
}, Symbol.toStringTag, { value: "Module" }));
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range2 {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
class NodeProp {
  /**
  Create a new node prop type.
  */
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
    this.combine = config2.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type2) => {
      let result = match(type2);
      return result === void 0 ? null : [this, result];
    };
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
class MountedTree {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
}
const noProps = /* @__PURE__ */ Object.create(null);
class NodeType {
  /**
  @internal
  */
  constructor(name2, props, id2, flags2 = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags2;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags2 = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type2 = new NodeType(spec.name || "", props, spec.id, flags2);
    if (spec.props)
      for (let src2 of spec.props) {
        if (!Array.isArray(src2))
          src2 = src2(type2);
        if (src2) {
          if (src2[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src2[0].id] = src2[1];
        }
      }
    return type2;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node2) => {
      for (let groups = node2.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
        let found = direct[i2 < 0 ? node2.name : groups[i2]];
        if (found)
          return found;
      }
    };
  }
}
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types2) {
    this.types = types2;
    for (let i2 = 0; i2 < types2.length; i2++)
      if (types2[i2].id != i2)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type2 of this.types) {
      let newProps = null;
      for (let source of props) {
        let add2 = source(type2);
        if (add2) {
          if (!newProps)
            newProps = Object.assign({}, type2.props);
          let value = add2[1], prop = add2[0];
          if (prop.combine && prop.id in newProps)
            value = prop.combine(newProps[prop.id], value);
          newProps[prop.id] = value;
        }
      }
      newTypes.push(newProps ? new NodeType(type2.name, newProps, type2.id, type2.flags) : type2);
    }
    return new NodeSet(newTypes);
  }
}
const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
class Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type2, children, positions, length, props) {
    this.type = type2;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor2 = new TreeCursor(scope);
    cursor2.moveTo(pos, side);
    CachedNode.set(this, cursor2._tree);
    return cursor2;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node2 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node2);
    return node2;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node2 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node2);
    return node2;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c2 = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c2.from <= to && c2.to >= from && (!anon && c2.type.isAnonymous || enter(c2) !== false)) {
        if (c2.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c2.type.isAnonymous))
          leave(c2);
        if (c2.nextSibling())
          break;
        if (!c2.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data2) {
    return buildTree(data2);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type2 = this.set.types[id2], result = type2.name;
    if (/\W/.test(result) && !type2.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
      if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
        pick = i2;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i2 = startI, j = 0; i2 < endI; ) {
      copy[j++] = b[i2++];
      copy[j++] = b[i2++] - from;
      let to = copy[j++] = b[i2++] - from;
      copy[j++] = b[i2++] - startI;
      len = Math.max(len, to);
    }
    return new TreeBuffer(copy, len, this.set);
  }
}
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node2, pos, side, overlays) {
  var _a2;
  while (node2.from == node2.to || (side < 1 ? node2.from >= pos : node2.from > pos) || (side > -1 ? node2.to <= pos : node2.to < pos)) {
    let parent = !overlays && node2 instanceof TreeNode && node2.index < 0 ? null : node2.parent;
    if (!parent)
      return node2;
    node2 = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node2, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
        node2 = parent;
    }
  for (; ; ) {
    let inner = node2.enter(pos, side, mode);
    if (!inner)
      return node2;
    node2 = inner;
  }
}
class BaseNode {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type2, before = null, after = null) {
    let r2 = getChildren(this, type2, before, after);
    return r2.length ? r2[0] : null;
  }
  getChildren(type2, before = null, after = null) {
    return getChildren(this, type2, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node2 = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node2 = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node2;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class TreeNode extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i2, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e2 = dir > 0 ? children.length : -1; i2 != e2; i2 += dir) {
        let next = children[i2], start = positions[i2] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i2, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new TreeNode(mounted.tree, start, i2, parent);
          let inner = new TreeNode(next, start, i2, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i2 = parent.index + dir;
      else
        i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this._tree.prop(prop);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function getChildren(node2, type2, before, after) {
  let cur2 = node2.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur2.type.is(before);
      if (!cur2.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type2))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node2, context, i2 = context.length - 1) {
  for (let p2 = node2; i2 >= 0; p2 = p2.parent) {
    if (!p2)
      return false;
    if (!p2.type.isAnonymous) {
      if (context[i2] && context[i2] != p2.name)
        return false;
      i2--;
    }
  }
  return true;
}
class BufferContext {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
}
class BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this.type.prop(prop);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i2 = 1; i2 < heads.length; i2++) {
    let node2 = heads[i2];
    if (node2.from > picked.from || node2.to < picked.to) {
      picked = node2;
      pick = i2;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
class StackIterator {
  constructor(heads, node2) {
    this.heads = heads;
    this.node = node2;
  }
  get next() {
    return iterStack(this.heads);
  }
}
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
class TreeCursor {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node2, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node2 instanceof TreeNode) {
      this.yieldNode(node2);
    } else {
      this._tree = node2.context.parent;
      this.buffer = node2.context;
      for (let n2 = node2._parent; n2; n2 = n2._parent)
        this.stack.unshift(n2.index);
      this.bufferNode = node2;
      this.yieldBuf(node2.index);
    }
  }
  yieldNode(node2) {
    if (!node2)
      return false;
    this._tree = node2;
    this.type = node2.type;
    this.from = node2.from;
    this.to = node2.to;
    return true;
  }
  yieldBuf(index, type2) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type2 || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node2) {
    if (!node2)
      return false;
    if (node2 instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node2);
    }
    this.buffer = node2.context;
    return this.yieldBuf(node2.index, node2.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d2 = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d2 < 0 ? 0 : this.stack[d2] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d2 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d2] + 3]))
        return this.yieldBuf(after);
    }
    return d2 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i2 = 0; i2 < this.index; i2++)
          if (buffer.buffer.buffer[i2 + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i2 = index + dir, e2 = dir < 0 ? -1 : parent._tree.children.length; i2 != e2; i2 += dir) {
          let child = parent._tree.children[i2];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth2 = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan: for (let index = this.index, d2 = this.stack.length; d2 >= 0; ) {
        for (let c2 = cache2; c2; c2 = c2._parent)
          if (c2.index == index) {
            if (index == this.index)
              return c2;
            result = c2;
            depth2 = d2 + 1;
            break scan;
          }
        index = this.stack[--d2];
      }
    }
    for (let i2 = depth2; i2 < this.stack.length; i2++)
      result = new BufferNode(this.buffer, result, this.stack[i2]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth2 = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth2++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth2)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth2--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types: types2 } = buffer.set;
    for (let i2 = context.length - 1, d2 = this.stack.length - 1; i2 >= 0; d2--) {
      if (d2 < 0)
        return matchNodeContext(this._tree, context, i2);
      let type2 = types2[buffer.buffer[this.stack[d2]]];
      if (!type2.isAnonymous) {
        if (context[i2] && context[i2] != type2.name)
          return false;
        i2--;
      }
    }
    return true;
  }
}
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data2) {
  var _a2;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data2;
  let cursor2 = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth2) {
    let { id: id2, start, end, size } = cursor2;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    if (size < 0) {
      cursor2.next();
      if (size == -1) {
        let node3 = reused[id2];
        children2.push(node3);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type2 = types2[id2], node2, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor2.pos - minPos, inRepeat))) {
      let data3 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor2.pos - buffer2.size, index = data3.length;
      while (cursor2.pos > endPos)
        index = copyToBuffer(buffer2.start, data3, index);
      node2 = new TreeBuffer(data3, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor2.pos - size;
      cursor2.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor2.pos > endPos) {
        if (localInRepeat >= 0 && cursor2.id == localInRepeat && cursor2.size >= 0) {
          if (cursor2.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor2.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor2.end;
          }
          cursor2.next();
        } else if (depth2 > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth2 + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type2, contextAtStart);
        node2 = balanceRange(type2, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node2 = makeTree(type2, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node2);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor2.pos > minPos) {
      let { id: id2, start, end, size } = cursor2;
      if (size > 4) {
        cursor2.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor2.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i2 = nodes.length - 3, j = 0; i2 >= 0; i2 -= 3) {
        buffer2[j++] = nodes[i2];
        buffer2[j++] = nodes[i2 + 1] - start;
        buffer2[j++] = nodes[i2 + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type2, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type2 && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type2, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base2, i2, from, to, type2, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i2) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base2 - from);
    }
    children2.push(makeTree(nodeSet.types[type2], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base2);
  }
  function makeTree(type2, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type2, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor2.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
      let nodeSize2 = fork.size;
      if (fork.id == inRepeat && nodeSize2 >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize2;
      if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
        break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart2 = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3 || fork.size == -4)
            localSkipped += 4;
          else
            break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart2;
      size += nodeSize2;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor2;
    cursor2.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor2.pos - (size - 4);
        while (cursor2.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor2.pos > 0)
    takeNode(data2.start || 0, data2.bufferStart || 0, children, positions, -1, 0);
  let length = (_a2 = data2.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[data2.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node2) {
  if (!balanceType.isAnonymous || node2 instanceof TreeBuffer || node2.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node2);
  if (size == null) {
    size = 1;
    for (let child of node2.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node2, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i2 = from; i2 < to; i2++)
    total += nodeSize(balanceType, children[i2]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i2 = from2; i2 < to2; ) {
      let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
      i2++;
      for (; i2 < to2; i2++) {
        let nextSize = nodeSize(balanceType, children2[i2]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i2 == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
class NodeWeakMap {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer, index, value) {
    let inner = this.map.get(buffer);
    if (!inner)
      this.map.set(buffer, inner = /* @__PURE__ */ new Map());
    inner.set(index, value);
  }
  getBuffer(buffer, index) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index);
  }
  /**
  Set the value for this syntax node.
  */
  set(node2, value) {
    if (node2 instanceof BufferNode)
      this.setBuffer(node2.context.buffer, node2.index, value);
    else if (node2 instanceof TreeNode)
      this.map.set(node2.tree, value);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(node2) {
    return node2 instanceof BufferNode ? this.getBuffer(node2.context.buffer, node2.index) : node2 instanceof TreeNode ? this.map.get(node2.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(cursor2, value) {
    if (cursor2.buffer)
      this.setBuffer(cursor2.buffer.buffer, cursor2.index, value);
    else
      this.map.set(cursor2.tree, value);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(cursor2) {
    return cursor2.buffer ? this.getBuffer(cursor2.buffer.buffer, cursor2.index) : this.map.get(cursor2.tree);
  }
}
class TreeFragment {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(from, to, tree, offset, openStart = false, openEnd = false) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (let f2 of fragments)
      if (f2.to > tree.length)
        result.push(f2);
    return result;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off2 = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off2) {
            let fFrom = Math.max(cut.from, pos) - off2, fTo = Math.min(cut.to, nextPos) - off2;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off2, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off2 = nextC.toA - nextC.toB;
    }
    return result;
  }
}
class Parser {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r2) => new Range2(r2.from, r2.to)) : [new Range2(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
}
class StringInput {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
}
new NodeProp({ perNode: true });
let nextTagID = 0;
class Tag {
  /**
  @internal
  */
  constructor(name2, set, base2, modified) {
    this.name = name2;
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a2, b) => a2.id - b.id));
    };
  }
}
let nextModifierID = 0;
class Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base2.name, set, base2, mods);
    for (let m2 of mods)
      m2.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set.push(Modifier.get(parent, config2));
    return tag;
  }
}
function sameArray(a2, b) {
  return a2.length == b.length && a2.every((x2, i2) => x2 == b[i2]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i2 = 0; i2 < array.length; i2++) {
    for (let j = 0, e2 = sets.length; j < e2; j++) {
      sets.push(sets[j].concat(array[i2]));
    }
  }
  return sets.sort((a2, b) => b.length - a2.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m2 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m2)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m2[0] == "*" ? "" : m2[0][0] == '"' ? JSON.parse(m2[0]) : m2[0]);
          pos += m2[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
const ruleNodeProp = new NodeProp({
  combine(a2, b) {
    let cur2, root, take;
    while (a2 || b) {
      if (!a2 || b && a2.depth >= b.depth) {
        take = b;
        b = b.next;
      } else {
        take = a2;
        a2 = a2.next;
      }
      if (cur2 && cur2.mode == take.mode && !take.context && !cur2.context)
        continue;
      let copy = new Rule(take.tags, take.mode, take.context);
      if (cur2)
        cur2.next = copy;
      else
        root = copy;
      cur2 = copy;
    }
    return root;
  }
});
class Rule {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
class HighlightBuilder {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class)
      this.span(this.at, to, this.class);
  }
  highlightRange(cursor2, from, to, inheritedClass, highlighters) {
    let { type: type2, from: start, to: end } = cursor2;
    if (start >= to || end <= from)
      return;
    if (type2.isTop)
      highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type2));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor2) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque)
      return;
    let mounted = cursor2.tree && cursor2.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor2.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
      let hasChild2 = cursor2.firstChild();
      for (let i2 = 0, pos = start; ; i2++) {
        let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom2 = Math.max(from, pos), rangeTo2 = Math.min(to, nextPos);
        if (rangeFrom2 < rangeTo2 && hasChild2) {
          while (cursor2.from < rangeTo2) {
            this.highlightRange(cursor2, rangeFrom2, rangeTo2, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo2, cursor2.to), cls);
            if (cursor2.to >= nextPos || !cursor2.nextSibling())
              break;
          }
        }
        if (!next || nextPos > to)
          break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild2)
        cursor2.parent();
    } else if (cursor2.firstChild()) {
      if (mounted)
        inheritedClass = "";
      do {
        if (cursor2.to <= from)
          continue;
        if (cursor2.from >= to)
          break;
        this.highlightRange(cursor2, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor2.to), cls);
      } while (cursor2.nextSibling());
      cursor2.parent();
    }
  }
}
function getStyleTags(node2) {
  let rule = node2.type.prop(ruleNodeProp);
  while (rule && rule.context && !node2.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
const t$1 = Tag.define;
const comment$1 = t$1(), name = t$1(), typeName = t$1(name), propertyName = t$1(name), literal = t$1(), string = t$1(literal), number = t$1(literal), content = t$1(), heading = t$1(content), keyword$2 = t$1(), operator = t$1(), punctuation = t$1(), bracket = t$1(punctuation), meta = t$1();
const tags = {
  /**
  A comment.
  */
  comment: comment$1,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t$1(comment$1),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t$1(comment$1),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t$1(comment$1),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t$1(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t$1(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t$1(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t$1(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t$1(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t$1(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t$1(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t$1(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t$1(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t$1(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t$1(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t$1(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t$1(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t$1(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t$1(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t$1(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t$1(literal),
  /**
  A language keyword.
  */
  keyword: keyword$2,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t$1(keyword$2),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t$1(keyword$2),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t$1(keyword$2),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t$1(keyword$2),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t$1(keyword$2),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t$1(keyword$2),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t$1(keyword$2),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t$1(keyword$2),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t$1(keyword$2),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t$1(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t$1(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t$1(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t$1(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t$1(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t$1(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t$1(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t$1(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t$1(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t$1(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t$1(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t$1(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t$1(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t$1(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t$1(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t$1(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t$1(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t$1(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t$1(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t$1(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t$1(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t$1(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t$1(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t$1(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t$1(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t$1(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t$1(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t$1(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t$1(),
  /**
  Deleted text.
  */
  deleted: t$1(),
  /**
  Changed text.
  */
  changed: t$1(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t$1(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t$1(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t$1(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t$1(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);
var _a;
const languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
const sublanguageProp = /* @__PURE__ */ new NodeProp();
class Language {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(data2, parser2, extraExtensions = [], name2 = "") {
    this.data = data2;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => {
        let top2 = topNodeAt(state, pos, side), data3 = top2.type.prop(languageDataProp);
        if (!data3)
          return [];
        let base2 = state.facet(data3), sub = top2.type.prop(sublanguageProp);
        if (sub) {
          let innerNode = top2.resolve(pos - top2.from, side);
          for (let sublang of sub)
            if (sublang.test(innerNode, state)) {
              let data4 = state.facet(sublang.facet);
              return sublang.type == "replace" ? data4 : data4.concat(base2);
            }
        }
        return base2;
      })
    ].concat(extraExtensions);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(state, pos, side = -1) {
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({ from, to: from + tree.length });
        return;
      }
      let mount = tree.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r2 of mount.overlay)
              result.push({ from: r2.from + from, to: r2.to + from });
          else
            result.push({ from, to: from + tree.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size)
            return;
        }
      }
      for (let i2 = 0; i2 < tree.children.length; i2++) {
        let ch = tree.children[i2];
        if (ch instanceof Tree)
          explore(ch, tree.positions[i2] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
}
Language.setState = /* @__PURE__ */ StateEffect.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language), tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node2 = tree; node2; node2 = node2.enter(pos, side, IterMode.ExcludeBuffers))
      if (node2.type.isTop)
        tree = node2;
  }
  return tree;
}
class LRLanguage extends Language {
  constructor(data2, parser2, name2) {
    super(data2, parser2, [], name2);
    this.parser = parser2;
  }
  /**
  Define a language from a parser.
  */
  static define(spec) {
    let data2 = defineLanguageFacet(spec.languageData);
    return new LRLanguage(data2, spec.parser.configure({
      props: [languageDataProp.add((type2) => type2.isTop ? data2 : void 0)]
    }), spec.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(options, name2) {
    return new LRLanguage(this.data, this.parser.configure(options), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
class DocInput {
  /**
  Create an input object for the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
}
let currentContext = null;
class ParseContext {
  constructor(parser2, state, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(parser2, state, viewport) {
    return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f2) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f2();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r2; r2 = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r2.from, r2.to);
    return fragments;
  }
  /**
  @internal
  */
  changes(changes, newState) {
    let { fragments, tree, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r2 of this.skipped) {
          let from = changes.mapPos(r2.from, 1), to = changes.mapPos(r2.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i2 = 0; i2 < this.skipped.length; i2++) {
      let { from, to } = this.skipped[i2];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i2--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  /**
  @internal
  */
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from, to = ranges[ranges.length - 1].to;
        let parser2 = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r2 of ranges)
                cx.tempSkipped.push(r2);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new Tree(NodeType.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser2;
      }
    }();
  }
  /**
  @internal
  */
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return currentContext;
  }
}
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
}
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e2 of tr.effects)
      if (e2.is(Language.setState))
        return e2.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
let requestIdle = (callback) => {
  let timeout = setTimeout(
    () => callback(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout = setTimeout(
      () => {
        idle = requestIdleCallback(callback, {
          timeout: 500 - 100
          /* Work.MinPause */
        });
      },
      100
      /* Work.MinPause */
    );
    return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
  };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(
      vpTo + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
const language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang = state.facet(language2);
      return lang && lang.name ? { "data-language": lang.name } : {};
    })
  ]
});
class LanguageSupport {
  /**
  Create a language support object.
  */
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
}
const indentService = /* @__PURE__ */ Facet.define();
const indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values) => {
    if (!values.length)
      return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some((e2) => e2 != unit[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
  if (ch == "	") {
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i2 = 0; i2 < cols; i2++)
    result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result !== void 0)
      return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
class IndentContext {
  /**
  Create an indent context.
  */
  constructor(state, options = {}) {
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(pos, bias = 1) {
    let line = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
      else
        return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
    }
    return line;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text, from } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  /**
  Find the column for the given position.
  */
  column(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1)
      result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(line, pos = line.length) {
    return countColumn(line, this.state.tabSize, pos);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(pos, bias = 1) {
    let { text, from } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast2, pos) {
  let stack = ast2.resolveStack(pos);
  let inner = ast2.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add2 = [];
    for (let cur2 = inner; cur2 && !(cur2.from < stack.node.from || cur2.to > stack.node.to || cur2.from == stack.node.from && cur2.type == stack.node.type); cur2 = cur2.parent)
      add2.push(cur2);
    for (let i2 = add2.length - 1; i2 >= 0; i2--)
      stack = { node: add2[i2], next: stack };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur2 = stack; cur2; cur2 = cur2.next) {
    let strategy = indentStrategy(cur2.node);
    if (strategy)
      return strategy(TreeIndentContext.create(cx, pos, cur2));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
class TreeIndentContext extends IndentContext {
  constructor(base2, pos, context) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.context = context;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(base2, pos, context) {
    return new TreeIndentContext(base2, pos, context);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(node2) {
    let line = this.state.doc.lineAt(node2.from);
    for (; ; ) {
      let atBreak = node2.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, node2))
        break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
}
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from), last = tree.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next = tree.childAfter(pos);
    if (!next || next == last)
      return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd)
        return null;
      let space2 = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return { from: openToken.from, to: openToken.to + space2 };
    }
    pos = next.to;
  }
}
function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
  return (context) => delimitedStrategy(context, align, units, closing2);
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context.pos + space2;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
const flatIndent = (context) => context.baseIndent;
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
const DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of((tr) => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
      return tr;
    let rules2 = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules2.length)
      return tr;
    let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
    if (head > line.from + DontIndentBeyond)
      return tr;
    let lineStart = doc2.sliceString(line.from, head);
    if (!rules2.some((r2) => r2.test(lineStart)))
      return tr;
    let { state } = tr, last = -1, changes = [];
    for (let { head: head2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(head2);
      if (line2.from == last)
        continue;
      last = line2.from;
      let indent2 = getIndentation(state, line2.from);
      if (indent2 == null)
        continue;
      let cur2 = /^\s*/.exec(line2.text)[0];
      let norm = indentString(state, indent2);
      if (cur2 != norm)
        changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
    return changes.length ? [tr, { changes, sequential: true }] : tr;
  });
}
const foldService = /* @__PURE__ */ Facet.define();
const foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside(node2) {
  let first = node2.firstChild, last = node2.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node2.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end)
    return null;
  let stack = tree.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur2 = iter.node;
    if (cur2.to <= end || cur2.from > end)
      continue;
    if (found && cur2.from < start)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end && value.from >= start && value.to > end)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node2) {
  let ch = node2.lastChild;
  return ch && ch.to == node2.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
  return from >= to ? void 0 : { from, to };
}
const foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
const unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head } of view.state.selection.ranges) {
    if (lines.some((l2) => l2.from <= head && l2.to >= head))
      continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
const foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    if (tr.isUserEvent("delete"))
      tr.changes.iterChangedRanges((fromA, toA) => folded = clearTouchedFolds(folded, fromA, toA));
    folded = folded.map(tr.changes);
    for (let e2 of tr.effects) {
      if (e2.is(foldEffect) && !foldExists(folded, e2.value.from, e2.value.to)) {
        let { preparePlaceholder } = tr.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e2.value)) });
        folded = folded.update({ add: [widget.range(e2.value.from, e2.value.to)] });
      } else if (e2.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to) => e2.value.from != from || e2.value.to != to,
          filterFrom: e2.value.from,
          filterTo: e2.value.to
        });
      }
    }
    if (tr.selection)
      folded = clearTouchedFolds(folded, tr.selection.main.head);
    return folded;
  },
  provide: (f2) => EditorView.decorations.from(f2),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to) => {
      ranges.push(from, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i2 = 0; i2 < value.length; ) {
      let from = value[i2++], to = value[i2++];
      if (typeof from != "number" || typeof to != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to));
    }
    return Decoration.set(ranges, true);
  }
});
function clearTouchedFolds(folded, from, to = from) {
  let touched = false;
  folded.between(from, to, (a2, b) => {
    if (a2 < to && b > from)
      touched = true;
  });
  return !touched ? folded : folded.update({
    filterFrom: from,
    filterTo: to,
    filter: (a2, b) => a2 >= to || b <= from
  });
}
function findFold(state, from, to) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
    if (!found || found.from > from2)
      found = { from: from2, to: to2 };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a2, b) => {
    if (a2 == from && b == to)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
const foldCode = (view) => {
  for (let line of selectedLines(view)) {
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
      return true;
    }
  }
  return false;
};
const unfoldCode = (view) => {
  if (!view.state.field(foldState, false))
    return false;
  let effects = [];
  for (let line of selectedLines(view)) {
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length)
    view.dispatch({ effects });
  return effects.length > 0;
};
function announceFold(view, range, fold = true) {
  let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
const foldAll = (view) => {
  let { state } = view, effects = [];
  for (let pos = 0; pos < state.doc.length; ) {
    let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
    if (range)
      effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
  }
  if (effects.length)
    view.dispatch({ effects: maybeEnable(view.state, effects) });
  return !!effects.length;
};
const unfoldAll = (view) => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size)
    return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({ from, to }));
  });
  view.dispatch({ effects });
  return true;
};
const foldKeymap = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
  { key: "Ctrl-Alt-[", run: foldAll },
  { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig$1 = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
};
const foldConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, defaultConfig$1);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$1$2];
  return result;
}
function widgetToDOM(view, prepared) {
  let { state } = view, conf = state.facet(foldConfig);
  let onclick = (event) => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded)
      view.dispatch({ effects: unfoldEffect.of(folded) });
    event.preventDefault();
  };
  if (conf.placeholderDOM)
    return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
const foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM(view) {
    return widgetToDOM(view, null);
  }
}() });
class PreparedFoldWidget extends WidgetType {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
}
const foldGutterDefaults = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
class FoldMarker extends GutterMarker {
  constructor(config2, open) {
    super();
    this.config = config2;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
}
function foldGutter(config2 = {}) {
  let fullConfig = { ...foldGutterDefaults, ...config2 };
  let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
  let markers = ViewPlugin.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update))
        this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new RangeSetBuilder();
      for (let line of view.viewportLineBlocks) {
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark)
          builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let { domEventHandlers } = fullConfig;
  return [
    markers,
    gutter({
      class: "cm-foldGutter",
      markers(view) {
        var _a2;
        return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
      },
      initialSpacer() {
        return new FoldMarker(fullConfig, false);
      },
      domEventHandlers: {
        ...domEventHandlers,
        click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({ effects: foldEffect.of(range) });
            return true;
          }
          return false;
        }
      }
    }),
    codeFolding()
  ];
}
const baseTheme$1$2 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : void 0;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? (type2) => type2.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type2) => type2 == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style) => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
}
const highlighterFacet = /* @__PURE__ */ Facet.define();
const fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      }, from, to);
    }
    return builder.finish();
  }
}
const treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v2) => v2.decorations
}));
const defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.meta,
    color: "#404740"
  },
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
const baseTheme$3 = /* @__PURE__ */ EditorView.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 1e4, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
const matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
  let decorations2 = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations2.push(mark.range(match.start.from, match.start.to));
  if (match.end)
    decorations2.push(mark.range(match.end.from, match.end.to));
  return decorations2;
}
const bracketMatchingState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection)
      return deco;
    let decorations2 = [];
    let config2 = tr.state.facet(bracketMatchingConfig);
    for (let range of tr.state.selection.ranges) {
      if (!range.empty)
        continue;
      let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
      if (match)
        decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
    }
    return Decoration.set(decorations2, true);
  },
  provide: (f2) => EditorView.decorations.from(f2)
});
const bracketMatchingUnique = [
  bracketMatchingState,
  baseTheme$3
];
function bracketMatching(config2 = {}) {
  return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
}
const bracketMatchingHandle = /* @__PURE__ */ new NodeProp();
function matchingNodes(node2, dir, brackets) {
  let byProp = node2.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node2.name.length == 1) {
    let index = brackets.indexOf(node2.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index + dir]];
  }
  return null;
}
function findHandle(node2) {
  let hasHandle = node2.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node2.node) : node2;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree = syntaxTree(state), node2 = tree.resolveInner(pos, dir);
  for (let cur2 = node2; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to) {
      let handle = findHandle(cur2);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
        return matchMarkedBrackets(state, pos, dir, cur2, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node2.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
  let depth2 = 0, cursor2 = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor2 && (dir < 0 ? cursor2.childBefore(token.from) : cursor2.childAfter(token.to)))
    do {
      if (dir < 0 ? cursor2.to <= token.from : cursor2.from >= token.to) {
        if (depth2 == 0 && matching.indexOf(cursor2.type.name) > -1 && cursor2.from < cursor2.to) {
          let endHandle = findHandle(cursor2);
          return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : void 0, matched: true };
        } else if (matchingNodes(cursor2.type, dir, brackets)) {
          depth2++;
        } else if (matchingNodes(cursor2.type, -dir, brackets)) {
          if (depth2 == 0) {
            let endHandle = findHandle(cursor2);
            return {
              start: firstToken,
              end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : void 0,
              matched: false
            };
          }
          depth2--;
        }
      }
    } while (dir < 0 ? cursor2.prevSibling() : cursor2.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth2 = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
    let text = iter.value;
    if (dir < 0)
      distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
      let found = brackets.indexOf(text[pos2]);
      if (found < 0 || tree.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth2++;
      } else if (depth2 == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth2--;
      }
    }
    if (dir > 0)
      distance += text.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
const noTokens = /* @__PURE__ */ Object.create(null);
const typeArray = [NodeType.none];
const warned = [];
const byTag = /* @__PURE__ */ Object.create(null);
const defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (let name3 of tagStr.split(" ")) {
    let found = [];
    for (let part of name3.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          found = found.map(value);
      } else {
        if (found.length)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          found = Array.isArray(value) ? value : [value];
      }
    }
    for (let tag of found)
      tags$1.push(tag);
  }
  if (!tags$1.length)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), key = name2 + " " + tags$1.map((t2) => t2.id);
  let known = byTag[key];
  if (known)
    return known.id;
  let type2 = byTag[key] = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tags$1 })]
  });
  typeArray.push(type2);
  return type2.id;
}
({
  rtl: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "rtl" }, bidiIsolate: Direction.RTL }),
  ltr: /* @__PURE__ */ Decoration.mark({ class: "cm-iso", inclusive: true, attributes: { dir: "ltr" }, bidiIsolate: Direction.LTR })
});
const toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f2, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f2(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
const toggleLineComment = /* @__PURE__ */ command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
const lineComment = /* @__PURE__ */ command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
const lineUncomment = /* @__PURE__ */ command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
const toggleBlockComment = /* @__PURE__ */ command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
const blockComment = /* @__PURE__ */ command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
const blockUncomment = /* @__PURE__ */ command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
const toggleBlockCommentByLine = /* @__PURE__ */ command(
  (o2, s2) => changeBlockComment(o2, s2, selectedLineRanges(s2)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data2 = state.languageDataAt("commentTokens", pos, 1);
  return data2.length ? data2[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r2 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r2.from);
    let toLine = r2.to <= fromLine.to ? fromLine : state.doc.lineAt(r2.to);
    if (toLine.from > fromLine.from && toLine.from == r2.to)
      toLine = r2.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r2.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r2) => getConfig(state, r2.from).block);
  if (!tokens.every((c2) => c2))
    return null;
  let comments = ranges.map((r2, i2) => findBlockComment(state, tokens[i2], r2.from, r2.to));
  if (option != 2 && !comments.every((c2) => c2)) {
    return { changes: state.changes(ranges.map((range, i2) => {
      if (comments[i2])
        return [];
      return [{ from: range.from, insert: tokens[i2].open + " " }, { from: range.to, insert: " " + tokens[i2].close }];
    })) };
  } else if (option != 1 && comments.some((c2) => c2)) {
    let changes = [];
    for (let i2 = 0, comment2; i2 < comments.length; i2++)
      if (comment2 = comments[i2]) {
        let token = tokens[i2], { open, close } = comment2;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent2 = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent2 == line.length;
        let comment2 = line.text.slice(indent2, indent2 + token.length) == token ? indent2 : -1;
        if (indent2 < line.text.length && indent2 < minIndent)
          minIndent = indent2;
        lines.push({ line, comment: comment2, token, indent: indent2, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i2 = startI; i2 < lines.length; i2++)
        if (lines[i2].indent < lines[i2].line.text.length)
          lines[i2].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l2) => l2.comment < 0 && (!l2.empty || l2.single))) {
    let changes = [];
    for (let { line, token, indent: indent2, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent2, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l2) => l2.comment >= 0)) {
    let changes = [];
    for (let { line, comment: comment2, token } of lines)
      if (comment2 >= 0) {
        let from = line.from + comment2, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
const fromHistory = /* @__PURE__ */ Annotation.define();
const isolateHistory = /* @__PURE__ */ Annotation.define();
const invertedEffects = /* @__PURE__ */ Facet.define();
const historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a2, b) => (tr, adj) => a2(tr, adj) || b(tr, adj)
    });
  }
});
const historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e2) => e2.toJSON()), undone: value.undone.map((e2) => e2.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e2, view) {
        let command2 = e2.inputType == "historyUndo" ? undo : e2.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e2.preventDefault();
        return command2(view);
      }
    })
  ];
}
const historyField = historyField_;
function cmd(side, selection) {
  return function({ state, dispatch }) {
    if (!selection && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
const undo = /* @__PURE__ */ cmd(0, false);
const redo = /* @__PURE__ */ cmd(1, false);
const undoSelection = /* @__PURE__ */ cmd(0, true);
const redoSelection = /* @__PURE__ */ cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
const undoDepth = /* @__PURE__ */ depth(
  0
  /* BranchName.Done */
);
const redoDepth = /* @__PURE__ */ depth(
  1
  /* BranchName.Undone */
);
class HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
    };
  }
  static fromJSON(json) {
    return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection) {
    let effects = none$1;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none$1);
  }
  static selection(selections) {
    return new HistEvent(void 0, none$1, void 0, void 0, selections);
  }
}
function updateBranch(branch, to, maxLen2, newEvent) {
  let start = to + 1 > maxLen2 + 20 ? to - maxLen2 - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a2, b) {
  let ranges = [], isAdjacent2 = false;
  a2.iterChangedRanges((f2, t2) => ranges.push(f2, t2));
  b.iterChangedRanges((_f, _t, f2, t2) => {
    for (let i2 = 0; i2 < ranges.length; ) {
      let from = ranges[i2++], to = ranges[i2++];
      if (t2 >= from && f2 <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a2, b) {
  return a2.ranges.length == b.ranges.length && a2.ranges.filter((r2, i2) => r2.empty != b.ranges[i2].empty).length === 0;
}
function conc(a2, b) {
  return !a2.length ? b : !b.length ? a2 : a2.concat(b);
}
const none$1 = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection))
      return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none$1;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none$1;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s2) => s2.map(mapping)) : none$1, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$1));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new HistoryState(done, none$1, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$1;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
      return this;
    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none$1 : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
}
HistoryState.empty = /* @__PURE__ */ new HistoryState(none$1, none$1);
const historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
const cursorCharForward = (view) => cursorByChar(view, true);
const cursorCharBackward = (view) => cursorByChar(view, false);
function byCharLogical(state, range, forward) {
  let pos = range.head, line = state.doc.lineAt(pos);
  if (pos == (forward ? line.to : line.from))
    pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);
  else
    pos = line.from + findClusterBreak(line.text, pos - line.from, forward);
  return EditorSelection.cursor(pos, forward ? -1 : 1);
}
function moveByCharLogical(target, forward) {
  return moveSel(target, (range) => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));
}
const cursorCharForwardLogical = (target) => moveByCharLogical(target, true);
const cursorCharBackwardLogical = (target) => moveByCharLogical(target, false);
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
const cursorGroupForward = (view) => cursorByGroup(view, true);
const cursorGroupBackward = (view) => cursorByGroup(view, false);
function toGroupStart(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start), initial = cat != CharCategory.Space;
  return (next) => {
    let nextCat = categorize(next);
    if (nextCat != CharCategory.Space)
      return initial && nextCat == cat;
    initial = false;
    return true;
  };
}
const cursorGroupForwardWin = (view) => {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, true, (start) => toGroupStart(view, range.head, start)) : rangeEnd(range, true));
};
const segmenter = typeof Intl != "undefined" && Intl.Segmenter ? /* @__PURE__ */ new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function moveBySubword(view, range, forward) {
  let categorize = view.state.charCategorizer(range.from);
  let cat = CharCategory.Space, pos = range.from, steps = 0;
  let done = false, sawUpper = false, sawLower = false;
  let step = (next) => {
    if (done)
      return false;
    pos += forward ? next.length : -next.length;
    let nextCat = categorize(next), ahead;
    if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\W_]/.test(next))
      nextCat = -1;
    if (cat == CharCategory.Space)
      cat = nextCat;
    if (cat != nextCat)
      return false;
    if (cat == CharCategory.Word) {
      if (next.toLowerCase() == next) {
        if (!forward && sawUpper)
          return false;
        sawLower = true;
      } else if (sawLower) {
        if (forward)
          return false;
        done = true;
      } else {
        if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word && ahead.toLowerCase() == ahead)
          return false;
        sawUpper = true;
      }
    }
    steps++;
    return true;
  };
  let end = view.moveByChar(range, forward, (start) => {
    step(start);
    return step;
  });
  if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {
    let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);
    let skipped = view.state.sliceDoc(from, to);
    if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
      let segments = Array.from(segmenter.segment(skipped));
      if (segments.length > 1) {
        if (forward)
          return EditorSelection.cursor(range.head + segments[1].index, -1);
        return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);
      }
    }
  }
  return end;
}
function cursorBySubword(view, forward) {
  return moveSel(view, (range) => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
const cursorSubwordForward = (view) => cursorBySubword(view, true);
const cursorSubwordBackward = (view) => cursorBySubword(view, false);
function interestingNode(state, node2, bracketProp) {
  if (node2.type.prop(bracketProp))
    return true;
  let len = node2.to - node2.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node2.from, node2.to))) || node2.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
const cursorLineUp = (view) => cursorByLine(view, false);
const cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection), { effects: effect });
  return true;
}
const cursorPageUp = (view) => cursorByPage(view, false);
const cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space2 = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space2 && start.head != line.from + space2)
      moved = EditorSelection.cursor(line.from + space2);
  }
  return moved;
}
const cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
const cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
const cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
const cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
const cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection));
  return true;
}
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
const selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);
function extendSel(target, how) {
  let selection = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
const selectCharForward = (view) => selectByChar(view, true);
const selectCharBackward = (view) => selectByChar(view, false);
const selectCharForwardLogical = (target) => extendSel(target, (range) => byCharLogical(target.state, range, true));
const selectCharBackwardLogical = (target) => extendSel(target, (range) => byCharLogical(target.state, range, false));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
const selectGroupForward = (view) => selectByGroup(view, true);
const selectGroupBackward = (view) => selectByGroup(view, false);
const selectGroupForwardWin = (view) => {
  return extendSel(view, (range) => view.moveByChar(range, true, (start) => toGroupStart(view, range.head, start)));
};
function selectBySubword(view, forward) {
  return extendSel(view, (range) => moveBySubword(view, range, forward));
}
const selectSubwordForward = (view) => selectBySubword(view, true);
const selectSubwordBackward = (view) => selectBySubword(view, false);
const selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
const selectLineUp = (view) => selectByLine(view, false);
const selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
const selectPageUp = (view) => selectByPage(view, false);
const selectPageDown = (view) => selectByPage(view, true);
const selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
const selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
const selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
const selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
const selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
const cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
const cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
const selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
const selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
const selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
const selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
const selectParentSyntax = ({ state, dispatch }) => {
  let selection = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur2 = stack; cur2; cur2 = cur2.next) {
      let { node: node2 } = cur2;
      if ((node2.from < range.from && node2.to >= range.to || node2.to > range.to && node2.from <= range.from) && cur2.next)
        return EditorSelection.range(node2.to, node2.from);
    }
    return range;
  });
  if (selection.eq(state.selection))
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function addCursorVertically(view, forward) {
  let { state } = view, sel = state.selection, ranges = state.selection.ranges.slice();
  for (let range of state.selection.ranges) {
    let line = state.doc.lineAt(range.head);
    if (forward ? line.to < view.state.doc.length : line.from > 0)
      for (let cur2 = range; ; ) {
        let next = view.moveVertically(cur2, forward);
        if (next.head < line.from || next.head > line.to) {
          if (!ranges.some((r2) => r2.head == next.head))
            ranges.push(next);
          break;
        } else if (next.head == cur2.head) {
          break;
        } else {
          cur2 = next;
        }
      }
  }
  if (ranges.length == sel.ranges.length)
    return false;
  view.dispatch(setSel(state, EditorSelection.create(ranges, ranges.length - 1)));
  return true;
}
const addCursorAbove = (view) => addCursorVertically(view, false);
const addCursorBelow = (view) => addCursorVertically(view, true);
const simplifySelection = ({ state, dispatch }) => {
  let cur2 = state.selection, selection = null;
  if (cur2.ranges.length > 1)
    selection = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection)
    return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f2) => f2(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
const deleteCharBackward = (view) => deleteByChar(view, false, true);
const deleteCharBackwardStrict = (view) => deleteByChar(view, false, false);
const deleteCharForward = (view) => deleteByChar(view, true, false);
const deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
const deleteGroupBackward = (target) => deleteByGroup(target, false);
const deleteGroupForward = (target) => deleteByGroup(target, true);
const deleteGroupForwardWin = (view) => deleteBy(view, (range) => view.moveByChar(range, true, (start) => toGroupStart(view, range.head, start)).head);
const deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
const deleteToLineStart = (view) => deleteBy(view, (range) => {
  let lineStart = view.lineBlockAt(range.head).from;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
const deleteTrailingWhitespace = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let pos = 0, prev = "", iter = state.doc.iter(); ; ) {
    iter.next();
    if (iter.lineBreak || iter.done) {
      let trailing = prev.search(/\s+$/);
      if (trailing > -1)
        changes.push({ from: pos - (prev.length - trailing), to: pos });
      if (iter.done)
        break;
      prev = "";
    } else {
      prev = iter.value;
    }
    pos += iter.value.length;
  }
  if (!changes.length)
    return false;
  dispatch(state.update({ changes, userEvent: "delete" }));
  return true;
};
const splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
const transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size), Math.min(state.doc.length, r2.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(r2.anchor - size, r2.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
const deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection = updateSel(state.selection, (range) => {
    let dist2 = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist2 = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist2);
  }).map(changes);
  view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
const insertNewline = ({ state, dispatch }) => {
  dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: "input" }));
  return true;
};
const insertNewlineKeepIndent = ({ state, dispatch }) => {
  dispatch(state.update(state.changeByRange((range) => {
    let indent2 = /^\s*/.exec(state.doc.lineAt(range.from).text)[0];
    return {
      changes: { from: range.from, to: range.to, insert: state.lineBreak + indent2 },
      range: EditorSelection.cursor(range.from + indent2.length + 1)
    };
  }), { scrollIntoView: true, userEvent: "input" }));
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
const insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
const insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent2 = getIndentation(cx, from);
      if (indent2 == null)
        indent2 = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert2 = ["", indentString(state, indent2)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from + 1 + insert2[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f2) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f2(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
const indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent2 = getIndentation(context, line.from);
    if (indent2 == null)
      return;
    if (!/\S/.test(line.text))
      indent2 = 0;
    let cur2 = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent2);
    if (cur2 != norm || range.from < line.from + cur2.length) {
      updated[line.from] = indent2;
      changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
const indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
const indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space2 = /^\s*/.exec(line.text)[0];
    if (!space2)
      return;
    let col = countColumn(space2, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space2.length && keep < insert2.length && space2.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space2.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
const toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
const temporarilySetTabFocusMode = (view) => {
  view.setTabFocusMode(2e3);
  return true;
};
const insertTab = ({ state, dispatch }) => {
  if (state.selection.ranges.some((r2) => !r2.empty))
    return indentMore({ state, dispatch });
  dispatch(state.update(state.replaceSelection("	"), { scrollIntoView: true, userEvent: "input" }));
  return true;
};
const emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
const standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward, preventDefault: true },
  { key: "Delete", run: deleteCharForward, preventDefault: true },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward, preventDefault: true },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward, preventDefault: true },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward, preventDefault: true },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward, preventDefault: true }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
const defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Mod-Alt-ArrowUp", run: addCursorAbove },
  { key: "Mod-Alt-ArrowDown", run: addCursorBelow },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);
const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };
const Com = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCursorAbove,
  addCursorBelow,
  blockComment,
  blockUncomment,
  copyLineDown,
  copyLineUp,
  cursorCharBackward,
  cursorCharBackwardLogical,
  cursorCharForward,
  cursorCharForwardLogical,
  cursorCharLeft,
  cursorCharRight,
  cursorDocEnd,
  cursorDocStart,
  cursorGroupBackward,
  cursorGroupForward,
  cursorGroupForwardWin,
  cursorGroupLeft,
  cursorGroupRight,
  cursorLineBoundaryBackward,
  cursorLineBoundaryForward,
  cursorLineBoundaryLeft,
  cursorLineBoundaryRight,
  cursorLineDown,
  cursorLineEnd,
  cursorLineStart,
  cursorLineUp,
  cursorMatchingBracket,
  cursorPageDown,
  cursorPageUp,
  cursorSubwordBackward,
  cursorSubwordForward,
  cursorSyntaxLeft,
  cursorSyntaxRight,
  defaultKeymap,
  deleteCharBackward,
  deleteCharBackwardStrict,
  deleteCharForward,
  deleteGroupBackward,
  deleteGroupForward,
  deleteGroupForwardWin,
  deleteLine,
  deleteLineBoundaryBackward,
  deleteLineBoundaryForward,
  deleteToLineEnd,
  deleteToLineStart,
  deleteTrailingWhitespace,
  emacsStyleKeymap,
  history,
  historyField,
  historyKeymap,
  indentLess,
  indentMore,
  indentSelection,
  indentWithTab,
  insertBlankLine,
  insertNewline,
  insertNewlineAndIndent,
  insertNewlineKeepIndent,
  insertTab,
  invertedEffects,
  isolateHistory,
  lineComment,
  lineUncomment,
  moveLineDown,
  moveLineUp,
  redo,
  redoDepth,
  redoSelection,
  selectAll,
  selectCharBackward,
  selectCharBackwardLogical,
  selectCharForward,
  selectCharForwardLogical,
  selectCharLeft,
  selectCharRight,
  selectDocEnd,
  selectDocStart,
  selectGroupBackward,
  selectGroupForward,
  selectGroupForwardWin,
  selectGroupLeft,
  selectGroupRight,
  selectLine,
  selectLineBoundaryBackward,
  selectLineBoundaryForward,
  selectLineBoundaryLeft,
  selectLineBoundaryRight,
  selectLineDown,
  selectLineEnd,
  selectLineStart,
  selectLineUp,
  selectMatchingBracket,
  selectPageDown,
  selectPageUp,
  selectParentSyntax,
  selectSubwordBackward,
  selectSubwordForward,
  selectSyntaxLeft,
  selectSyntaxRight,
  simplifySelection,
  splitLine,
  standardKeymap,
  temporarilySetTabFocusMode,
  toggleBlockComment,
  toggleBlockCommentByLine,
  toggleComment,
  toggleLineComment,
  toggleTabFocusMode,
  transposeChars,
  undo,
  undoDepth,
  undoSelection
}, Symbol.toStringTag, { value: "Module" }));
const basicNormalize = typeof String.prototype.normalize == "function" ? (x2) => x2.normalize("NFKD") : (x2) => x2;
class SearchCursor {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to = text.length, normalize2, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize2 ? (x2) => normalize2(basicNormalize(x2)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      if (norm.length)
        for (let i2 = 0, pos = start; ; i2++) {
          let code2 = norm.charCodeAt(i2);
          let match = this.match(code2, pos, this.bufferPos + this.bufferStart);
          if (i2 == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start && i2 < str.length && str.charCodeAt(i2) == code2)
            pos++;
        }
    }
  }
  match(code2, pos, end) {
    let match = null;
    for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
      let index = this.matches[i2], keep = false;
      if (this.query.charCodeAt(index) == code2) {
        if (index == this.query.length - 1) {
          match = { from: this.matches[i2 + 1], to: end };
        } else {
          this.matches[i2]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i2, 2);
        i2 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code2) {
      if (this.query.length == 1)
        match = { from: pos, to: end };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
}
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
const empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
class RegExpCursor {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to = text.length) {
    this.text = text;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off2 = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off2;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          return this;
        }
        off2 = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off2 = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
}
const flattened = /* @__PURE__ */ new WeakMap();
class FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc2, from, to) {
    let cached = flattened.get(doc2);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new FlattenedDoc(from, doc2.sliceString(from, to));
      flattened.set(doc2, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc2.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to)
      text += doc2.sliceString(cached.to, to);
    flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }
}
class MultilineRegExpCursor {
  constructor(text, query, options, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off2 = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off2) {
        this.re.lastIndex = off2 + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")), crelt("button", {
    name: "close",
    onclick: () => {
      view.dispatch({ effects: dialogEffect.of(false) });
      view.focus();
    },
    "aria-label": view.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: "center" })],
      selection
    });
    view.focus();
  }
  return { dom };
}
const dialogEffect = /* @__PURE__ */ StateEffect.define();
const dialogField = /* @__PURE__ */ StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e2 of tr.effects)
      if (e2.is(dialogEffect))
        value = e2.value;
    return value;
  },
  provide: (f2) => showPanel.from(f2, (val) => val ? createLineDialog : null)
});
const gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1$1]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
const baseTheme$1$1 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
});
const defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
const highlightConfig = /* @__PURE__ */ Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a2, b) => a2 || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
const matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check2, state, from, to) {
  return (from == 0 || check2(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check2(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check2, state, from, to) {
  return check2(state.sliceDoc(from, from + 1)) == CharCategory.Word && check2(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
const matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check2 = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check2 = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check2 = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check2, state, range.from, range.to) && insideWord(check2, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to);
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor2.next().done) {
        let { from, to } = cursor2.value;
        if (!check2 || insideWordBoundaries(check2, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v2) => v2.decorations
});
const defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
const selectWord = ({ state, dispatch }) => {
  let { selection } = state;
  let newSel = EditorSelection.create(selection.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
  if (newSel.eq(selection))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
const selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
const searchConfigFacet = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
function search(config2) {
  return config2 ? [searchConfigFacet.of(config2), searchExtensions] : searchExtensions;
}
class SearchQuery {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st.doc.length;
    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
  }
}
class QueryType {
  constructor(spec) {
    this.spec = spec;
  }
}
function stringCursor(spec, state, from, to) {
  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc2, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2);
      buf = doc2.sliceString(bufPos, Math.min(doc2.length, to + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
class StringQuery extends QueryType {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor2.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
      cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
    }
    return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor2.nextOverlapping().done)
        range = cursor2.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom);
    if (!found)
      found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
    return found && (found.from != curFrom || found.to != curTo) ? found : null;
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
}
function regexpCursor(spec, state, from, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to);
}
function charBefore(str, index) {
  return str.slice(findClusterBreak(str, index, false), index);
}
function charAfter(str, index) {
  return str.slice(index, findClusterBreak(str, index));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
class RegExpQuery extends QueryType {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor2.done)
      cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(state, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor2 = regexpCursor(this.spec, state, start, to), range = null;
      while (!cursor2.next().done)
        range = cursor2.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (m2, i2) => {
      if (i2 == "&")
        return result.match[0];
      if (i2 == "$")
        return "$";
      for (let l2 = i2.length; l2 > 0; l2--) {
        let n2 = +i2.slice(0, l2);
        if (n2 > 0 && n2 < result.match.length)
          return result.match[n2] + i2.slice(l2);
      }
      return m2;
    });
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
}
const setSearchQuery = /* @__PURE__ */ StateEffect.define();
const togglePanel$1 = /* @__PURE__ */ StateEffect.define();
const searchState = /* @__PURE__ */ StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel$1))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f2) => showPanel.from(f2, (val) => val.panel)
});
function getSearchQuery(state) {
  let curState = state.field(searchState, false);
  return curState ? curState.query.spec : defaultQuery(state);
}
function searchPanelOpen(state) {
  var _a2;
  return ((_a2 = state.field(searchState, false)) === null || _a2 === void 0 ? void 0 : _a2.panel) != null;
}
class SearchState {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
}
const matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i2 = 0, ranges = view.visibleRanges, l2 = ranges.length; i2 < l2; i2++) {
      let { from, to } = ranges[i2];
      while (i2 < l2 - 1 && to > ranges[i2 + 1].from - 2 * 250)
        to = ranges[++i2].to;
      query.highlight(view.state, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v2) => v2.decorations
});
function searchCommand(f2) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f2(view, state) : openSearchPanel(view);
  };
}
const findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state, to, to);
  if (!next)
    return false;
  let selection = EditorSelection.single(next.from, next.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, next), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
const findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection = EditorSelection.single(prev.from, prev.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection,
    effects: [announceMatch(view, prev), config2.scrollToMatch(selection.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
const selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
const selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur2 = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur2.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur2.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
const replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let match = query.nextMatch(state, from, from);
  if (!match)
    return false;
  let next = match;
  let changes = [], selection, replacement;
  let effects = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  let changeSet = view.state.changes(changes);
  if (next) {
    selection = EditorSelection.single(next.from, next.to).map(changeSet);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
  }
  view.dispatch({
    changes: changeSet,
    selection,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
const replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a2, _b, _c, _d, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a2 !== void 0 ? _a2 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config2.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
const openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel$1.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
const closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel$1.of(false) });
  return true;
};
const searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
class SearchPanel {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name2, onclick, content2) {
      return crelt("button", { class: "cm-button", name: name2, onclick, type: "button" }, content2);
    }
    this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e2) {
    if (runScopeHandlers(this.view, e2, "search-panel")) {
      e2.preventDefault();
    } else if (e2.keyCode == 13 && e2.target == this.searchField) {
      e2.preventDefault();
      (e2.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
      e2.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
}
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i2 = 0; i2 < AnnounceMargin; i2++)
      if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
        text = text.slice(i2);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
      if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
        text = text.slice(0, i2);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
const baseTheme$2 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
  searchState,
  /* @__PURE__ */ Prec.low(searchHighlighter),
  baseTheme$2
];
const Search = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RegExpCursor,
  SearchCursor,
  SearchQuery,
  closeSearchPanel,
  findNext,
  findPrevious,
  getSearchQuery,
  gotoLine,
  highlightSelectionMatches,
  openSearchPanel,
  replaceAll,
  replaceNext,
  search,
  searchKeymap,
  searchPanelOpen,
  selectMatches,
  selectNextOccurrence,
  selectSelectionMatches,
  setSearchQuery
}, Symbol.toStringTag, { value: "Module" }));
class CompletionContext {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(state, pos, explicit, view) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.view = view;
    this.abortListeners = [];
    this.abortOnDocChange = false;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(types2) {
    let token = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token && types2.indexOf(token.name) < 0)
      token = token.parent;
    return token ? {
      from: token.from,
      to: this.pos,
      text: this.state.sliceDoc(token.from, this.pos),
      type: token.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(expr) {
    let line = this.state.doc.lineAt(this.pos);
    let start = Math.max(line.from, this.pos - 250);
    let str = line.text.slice(start - line.from, this.pos - line.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(type2, listener, options) {
    if (type2 == "abort" && this.abortListeners) {
      this.abortListeners.push(listener);
      if (options && options.onDocChange)
        this.abortOnDocChange = true;
    }
  }
}
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options) {
    first[label[0]] = true;
    for (let i2 = 1; i2 < label.length; i2++)
      rest[label[i2]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list) {
  let options = list.map((o2) => typeof o2 == "string" ? { label: o2 } : o2);
  let [validFor, match] = options.every((o2) => /^\w+$/.test(o2.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
  return (context) => {
    let token = context.matchBefore(match);
    return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
      if (nodes.indexOf(pos.name) > -1)
        return null;
      if (pos.type.isTop)
        break;
    }
    return source(context);
  };
}
class Option {
  constructor(completion, source, match, score2) {
    this.completion = completion;
    this.source = source;
    this.match = match;
    this.score = score2;
  }
}
function cur(state) {
  return state.selection.main.from;
}
function ensureAnchor(expr, start) {
  var _a2;
  let { source } = expr;
  let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
const pickedCompletion = /* @__PURE__ */ Annotation.define();
function insertCompletionText(state, text, from, to) {
  let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
  return {
    ...state.changeByRange((range) => {
      if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
        return { range };
      let lines = state.toText(text);
      return {
        changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },
        range: EditorSelection.cursor(range.from + fromOff + lines.length)
      };
    }),
    scrollIntoView: true,
    userEvent: "input.complete"
  };
}
const SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
const startCompletionEffect = /* @__PURE__ */ StateEffect.define();
const closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
class FuzzyMatcher {
  constructor(pattern2) {
    this.pattern = pattern2;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    this.score = 0;
    this.matched = [];
    for (let p2 = 0; p2 < pattern2.length; ) {
      let char = codePointAt(pattern2, p2), size = codePointSize(char);
      this.chars.push(char);
      let part = pattern2.slice(p2, p2 + size), upper = part.toUpperCase();
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
      p2 += size;
    }
    this.astral = pattern2.length != this.chars.length;
  }
  ret(score2, matched) {
    this.score = score2;
    this.matched = matched;
    return this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(word) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt(word, 0), firstSize = codePointSize(first);
      let score2 = firstSize == word.length ? 0 : -100;
      if (first == chars[0]) ;
      else if (first == folded[0])
        score2 += -200;
      else
        return null;
      return this.ret(score2, [0, firstSize]);
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return this.ret(word.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i2 = 0, e2 = Math.min(word.length, 200); i2 < e2 && anyTo < len; ) {
        let next = codePointAt(word, i2);
        if (next == chars[anyTo] || next == folded[anyTo])
          any[anyTo++] = i2;
        i2 += codePointSize(next);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i2 = 0, e2 = Math.min(word.length, 200), prevType = 0; i2 < e2 && byWordTo < len; ) {
      let next = codePointAt(word, i2);
      if (direct < 0) {
        if (preciseTo < len && next == chars[preciseTo])
          precise[preciseTo++] = i2;
        if (adjacentTo < len) {
          if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i2;
            adjacentEnd = i2 + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type2 = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i2 || type2 == 1 && hasLower || prevType == 0 && type2 != 0) {
        if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
          byWord[byWordTo++] = i2;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type2;
      i2 += codePointSize(next);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return this.ret(-200 - word.length + (adjacentEnd == word.length ? 0 : -100), [0, adjacentEnd]);
    if (direct > -1)
      return this.ret(-700 - word.length, [direct, direct + this.pattern.length]);
    if (adjacentTo == len)
      return this.ret(-200 + -700 - word.length, [adjacentStart, adjacentEnd]);
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [], i2 = 0;
    for (let pos of positions) {
      let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i2 && result[i2 - 1] == pos)
        result[i2 - 1] = to;
      else {
        result[i2++] = pos;
        result[i2++] = to;
      }
    }
    return this.ret(score2 - word.length, result);
  }
}
class StrictMatcher {
  constructor(pattern2) {
    this.pattern = pattern2;
    this.matched = [];
    this.score = 0;
    this.folded = pattern2.toLowerCase();
  }
  match(word) {
    if (word.length < this.pattern.length)
      return null;
    let start = word.slice(0, this.pattern.length);
    let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 : null;
    if (match == null)
      return null;
    this.matched = [0, start.length];
    this.score = match + (word.length == this.pattern.length ? 0 : -100);
    return this;
  }
}
const completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: defaultPositionInfo,
      filterStrict: false,
      compareCompletions: (a2, b) => (a2.sortText || a2.label).localeCompare(b.sortText || b.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (a2, b) => a2 && b,
      closeOnBlur: (a2, b) => a2 && b,
      icons: (a2, b) => a2 && b,
      tooltipClass: (a2, b) => (c2) => joinClass(a2(c2), b(c2)),
      optionClass: (a2, b) => (c2) => joinClass(a2(c2), b(c2)),
      addToOptions: (a2, b) => a2.concat(b),
      filterStrict: (a2, b) => a2 || b
    });
  }
});
function joinClass(a2, b) {
  return a2 ? b ? a2 + " " + b : a2 : b;
}
function defaultPositionInfo(view, list, option, info, space2, tooltip) {
  let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
  let side = "top", offset, maxWidth;
  let spaceLeft = list.left - space2.left, spaceRight = space2.right - list.right;
  let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
  if (left && spaceLeft < Math.min(infoWidth, spaceRight))
    left = false;
  else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
    left = true;
  if (infoWidth <= (left ? spaceLeft : spaceRight)) {
    offset = Math.max(space2.top, Math.min(option.top, space2.bottom - infoHeight)) - list.top;
    maxWidth = Math.min(400, left ? spaceLeft : spaceRight);
  } else {
    narrow = true;
    maxWidth = Math.min(
      400,
      (rtl ? list.right : space2.right - list.left) - 30
      /* Info.Margin */
    );
    let spaceBelow = space2.bottom - list.bottom;
    if (spaceBelow >= infoHeight || spaceBelow > list.top) {
      offset = option.bottom - list.top;
    } else {
      side = "bottom";
      offset = list.bottom - option.top;
    }
  }
  let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
  let scaleX = (list.right - list.left) / tooltip.offsetWidth;
  return {
    style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
    class: "cm-completionInfo-" + (narrow ? rtl ? "left-narrow" : "right-narrow" : left ? "left" : "right")
  };
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, _v, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let label = completion.displayLabel || completion.label, off2 = 0;
      for (let j = 0; j < match.length; ) {
        let from = match[j++], to = match[j++];
        if (from > off2)
          labelElt.appendChild(document.createTextNode(label.slice(off2, from)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from, to)));
        span.className = "cm-completionMatchedText";
        off2 = to;
      }
      if (off2 < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off2)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a2, b) => a2.position - b.position).map((a2) => a2.render);
}
function rangeAroundSelected(total, selected, max) {
  if (total <= max)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off3 = Math.floor(selected / max);
    return { from: off3 * max, to: (off3 + 1) * max };
  }
  let off2 = Math.floor((total - selected) / max);
  return { from: total - (off2 + 1) * max, to: total - off2 * max };
}
class CompletionTooltip {
  constructor(view, stateField, applyCompletion2) {
    this.view = view;
    this.stateField = stateField;
    this.applyCompletion = applyCompletion2;
    this.info = null;
    this.infoDestroy = null;
    this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (pos) => this.placeInfo(pos),
      key: this
    };
    this.space = null;
    this.currentClass = "";
    let cState = view.state.field(stateField);
    let { options, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.tooltipClass = config2.tooltipClass;
    this.range = rangeAroundSelected(options.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.updateTooltipClass(view.state);
    this.dom.addEventListener("mousedown", (e2) => {
      let { options: options2 } = view.state.field(stateField).open;
      for (let dom = e2.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
          this.applyCompletion(view, options2[+match[1]]);
          e2.preventDefault();
          return;
        }
      }
    });
    this.dom.addEventListener("focusout", (e2) => {
      let state = view.state.field(this.stateField, false);
      if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e2.relatedTarget != view.contentDOM)
        view.dispatch({ effects: closeCompletionEffect.of(null) });
    });
    this.showOptions(options, cState.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(options, id2) {
    if (this.list)
      this.list.remove();
    this.list = this.dom.appendChild(this.createListBox(options, id2, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(update) {
    var _a2;
    let cState = update.state.field(this.stateField);
    let prevState = update.startState.field(this.stateField);
    this.updateTooltipClass(update.state);
    if (cState != prevState) {
      let { options, selected, disabled } = cState.open;
      if (!prevState.open || prevState.open.options != options) {
        this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
        this.showOptions(options, cState.id);
      }
      this.updateSel();
      if (disabled != ((_a2 = prevState.open) === null || _a2 === void 0 ? void 0 : _a2.disabled))
        this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
    }
  }
  updateTooltipClass(state) {
    let cls = this.tooltipClass(state);
    if (cls != this.currentClass) {
      for (let c2 of this.currentClass.split(" "))
        if (c2)
          this.dom.classList.remove(c2);
      for (let c2 of cls.split(" "))
        if (c2)
          this.dom.classList.add(c2);
      this.currentClass = cls;
    }
  }
  positioned(space2) {
    this.space = space2;
    if (this.info)
      this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.showOptions(open.options, cState.id);
    }
    let newSel = this.updateSelectedOption(open.selected);
    if (newSel) {
      this.destroyInfo();
      let { completion } = open.options[open.selected];
      let { info } = completion;
      if (!info)
        return;
      let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((obj) => {
          if (obj && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(obj, completion);
        }).catch((e2) => logException(this.view.state, e2, "completion info"));
      } else {
        this.addInfoPane(infoResult, completion);
        newSel.setAttribute("aria-describedby", this.info.id);
      }
    }
  }
  addInfoPane(content2, completion) {
    this.destroyInfo();
    let wrap = this.info = document.createElement("div");
    wrap.className = "cm-tooltip cm-completionInfo";
    wrap.id = "cm-completionInfo-" + Math.floor(Math.random() * 65535).toString(16);
    if (content2.nodeType != null) {
      wrap.appendChild(content2);
      this.infoDestroy = null;
    } else {
      let { dom, destroy } = content2;
      wrap.appendChild(dom);
      this.infoDestroy = destroy || null;
    }
    this.dom.appendChild(wrap);
    this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(selected) {
    let set = null;
    for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
      if (opt.nodeName != "LI" || !opt.id) {
        i2--;
      } else if (i2 == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected")) {
          opt.removeAttribute("aria-selected");
          opt.removeAttribute("aria-describedby");
        }
      }
    }
    if (set)
      scrollIntoView(this.list, set);
    return set;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    let space2 = this.space;
    if (!space2) {
      let docElt = this.dom.ownerDocument.documentElement;
      space2 = { left: 0, top: 0, right: docElt.clientWidth, bottom: docElt.clientHeight };
    }
    if (selRect.top > Math.min(space2.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space2.top, listRect.top) + 10)
      return null;
    return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space2, this.dom);
  }
  placeInfo(pos) {
    if (this.info) {
      if (pos) {
        if (pos.style)
          this.info.style.cssText = pos.style;
        this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
      } else {
        this.info.style.cssText = "top: -1e6px";
      }
    }
  }
  createListBox(options, id2, range) {
    const ul = document.createElement("ul");
    ul.id = id2;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    ul.addEventListener("mousedown", (e2) => {
      if (e2.target == ul)
        e2.preventDefault();
    });
    let curSection = null;
    for (let i2 = range.from; i2 < range.to; i2++) {
      let { completion, match } = options[i2], { section } = completion;
      if (section) {
        let name2 = typeof section == "string" ? section : section.name;
        if (name2 != curSection && (i2 > range.from || range.from == 0)) {
          curSection = name2;
          if (typeof section != "string" && section.header) {
            ul.appendChild(section.header(section));
          } else {
            let header = ul.appendChild(document.createElement("completion-section"));
            header.textContent = name2;
          }
        }
      }
      const li = ul.appendChild(document.createElement("li"));
      li.id = id2 + "-" + i2;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node2 = source(completion, this.view.state, this.view, match);
        if (node2)
          li.appendChild(node2);
      }
    }
    if (range.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range.to < options.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
  destroyInfo() {
    if (this.info) {
      if (this.infoDestroy)
        this.infoDestroy();
      this.info.remove();
      this.info = null;
    }
  }
  destroy() {
    this.destroyInfo();
  }
}
function completionTooltip(stateField, applyCompletion2) {
  return (view) => new CompletionTooltip(view, stateField, applyCompletion2);
}
function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  let scaleY = parent.height / container.offsetHeight;
  if (self2.top < parent.top)
    container.scrollTop -= (parent.top - self2.top) / scaleY;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += (self2.bottom - parent.bottom) / scaleY;
}
function score(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active, state) {
  let options = [];
  let sections = null, dynamicSectionScore = null;
  let addOption = (option) => {
    options.push(option);
    let { section } = option.completion;
    if (section) {
      if (!sections)
        sections = [];
      let name2 = typeof section == "string" ? section : section.name;
      if (!sections.some((s2) => s2.name == name2))
        sections.push(typeof section == "string" ? { name: name2 } : section);
    }
  };
  let conf = state.facet(completionConfig);
  for (let a2 of active)
    if (a2.hasResult()) {
      let getMatch = a2.result.getMatch;
      if (a2.result.filter === false) {
        for (let option of a2.result.options) {
          addOption(new Option(option, a2.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
        }
      } else {
        let pattern2 = state.sliceDoc(a2.from, a2.to), match;
        let matcher2 = conf.filterStrict ? new StrictMatcher(pattern2) : new FuzzyMatcher(pattern2);
        for (let option of a2.result.options)
          if (match = matcher2.match(option.label)) {
            let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];
            let score2 = match.score + (option.boost || 0);
            addOption(new Option(option, a2.source, matched, score2));
            if (typeof option.section == "object" && option.section.rank === "dynamic") {
              let { name: name2 } = option.section;
              if (!dynamicSectionScore)
                dynamicSectionScore = /* @__PURE__ */ Object.create(null);
              dynamicSectionScore[name2] = Math.max(score2, dynamicSectionScore[name2] || -1e9);
            }
          }
      }
    }
  if (sections) {
    let sectionOrder = /* @__PURE__ */ Object.create(null), pos = 0;
    let cmp = (a2, b) => {
      return (a2.rank === "dynamic" && b.rank === "dynamic" ? dynamicSectionScore[b.name] - dynamicSectionScore[a2.name] : 0) || (typeof a2.rank == "number" ? a2.rank : 1e9) - (typeof b.rank == "number" ? b.rank : 1e9) || (a2.name < b.name ? -1 : 1);
    };
    for (let s2 of sections.sort(cmp)) {
      pos -= 1e5;
      sectionOrder[s2.name] = pos;
    }
    for (let option of options) {
      let { section } = option.completion;
      if (section)
        option.score += sectionOrder[typeof section == "string" ? section : section.name];
    }
  }
  let result = [], prev = null;
  let compare2 = conf.compareCompletions;
  for (let opt of options.sort((a2, b) => b.score - a2.score || compare2(a2.completion, b.completion))) {
    let cur2 = opt.completion;
    if (!prev || prev.label != cur2.label || prev.detail != cur2.detail || prev.type != null && cur2.type != null && prev.type != cur2.type || prev.apply != cur2.apply || prev.boost != cur2.boost)
      result.push(opt);
    else if (score(opt.completion) > score(prev))
      result[result.length - 1] = opt;
    prev = opt.completion;
  }
  return result;
}
class CompletionDialog {
  constructor(options, attrs, tooltip, timestamp, selected, disabled) {
    this.options = options;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
    this.disabled = disabled;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected, this.disabled);
  }
  static build(active, state, id2, prev, conf, didSetActive) {
    if (prev && !didSetActive && active.some((s2) => s2.isPending))
      return prev.setDisabled();
    let options = sortOptions(active, state);
    if (!options.length)
      return prev && active.some((a2) => a2.isPending) ? prev.setDisabled() : null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev && prev.selected != selected && prev.selected != -1) {
      let selectedValue = prev.options[prev.selected].completion;
      for (let i2 = 0; i2 < options.length; i2++)
        if (options[i2].completion == selectedValue) {
          selected = i2;
          break;
        }
    }
    return new CompletionDialog(options, makeAttrs(id2, selected), {
      pos: active.reduce((a2, b) => b.hasResult() ? Math.min(a2, b.from) : a2, 1e8),
      create: createTooltip,
      above: conf.aboveCursor
    }, prev ? prev.timestamp : Date.now(), selected, false);
  }
  map(changes) {
    return new CompletionDialog(this.options, this.attrs, { ...this.tooltip, pos: changes.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);
  }
}
class CompletionState {
  constructor(active, id2, open) {
    this.active = active;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new CompletionState(none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf = state.facet(completionConfig);
    let sources = conf.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active = sources.map((source) => {
      let value = this.active.find((s2) => s2.source == source) || new ActiveSource(
        source,
        this.active.some(
          (a2) => a2.state != 0
          /* State.Inactive */
        ) ? 1 : 0
        /* State.Inactive */
      );
      return value.update(tr, conf);
    });
    if (active.length == this.active.length && active.every((a2, i2) => a2 == this.active[i2]))
      active = this.active;
    let open = this.open, didSet = tr.effects.some((e2) => e2.is(setActiveEffect));
    if (open && tr.docChanged)
      open = open.map(tr.changes);
    if (tr.selection || active.some((a2) => a2.hasResult() && tr.changes.touchesRange(a2.from, a2.to)) || !sameResults(active, this.active) || didSet)
      open = CompletionDialog.build(active, state, this.id, open, conf, didSet);
    else if (open && open.disabled && !active.some((a2) => a2.isPending))
      open = null;
    if (!open && active.every((a2) => !a2.isPending) && active.some((a2) => a2.hasResult()))
      active = active.map((a2) => a2.hasResult() ? new ActiveSource(
        a2.source,
        0
        /* State.Inactive */
      ) : a2);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;
  }
}
function sameResults(a2, b) {
  if (a2 == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a2.length && !a2[iA].hasResult())
      iA++;
    while (iB < b.length && !b[iB].hasResult())
      iB++;
    let endA = iA == a2.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a2[iA++].result != b[iB++].result)
      return false;
  }
}
const baseAttrs = {
  "aria-autocomplete": "list"
};
const noAttrs = {};
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
const none = [];
function getUpdateType(tr, conf) {
  if (tr.isUserEvent("input.complete")) {
    let completion = tr.annotation(pickedCompletion);
    if (completion && conf.activateOnCompletion(completion))
      return 4 | 8;
  }
  let typing = tr.isUserEvent("input.type");
  return typing && conf.activateOnTyping ? 4 | 1 : typing ? 1 : tr.isUserEvent("delete.backward") ? 2 : tr.selection ? 8 : tr.docChanged ? 16 : 0;
}
class ActiveSource {
  constructor(source, state, explicit = false) {
    this.source = source;
    this.state = state;
    this.explicit = explicit;
  }
  hasResult() {
    return false;
  }
  get isPending() {
    return this.state == 1;
  }
  update(tr, conf) {
    let type2 = getUpdateType(tr, conf), value = this;
    if (type2 & 8 || type2 & 16 && this.touches(tr))
      value = new ActiveSource(
        value.source,
        0
        /* State.Inactive */
      );
    if (type2 & 4 && value.state == 0)
      value = new ActiveSource(
        this.source,
        1
        /* State.Pending */
      );
    value = value.updateFor(tr, type2);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new ActiveSource(value.source, 1, effect.value);
      else if (effect.is(closeCompletionEffect))
        value = new ActiveSource(
          value.source,
          0
          /* State.Inactive */
        );
      else if (effect.is(setActiveEffect)) {
        for (let active of effect.value)
          if (active.source == value.source)
            value = active;
      }
    }
    return value;
  }
  updateFor(tr, type2) {
    return this.map(tr.changes);
  }
  map(changes) {
    return this;
  }
  touches(tr) {
    return tr.changes.touchesRange(cur(tr.state));
  }
}
class ActiveResult extends ActiveSource {
  constructor(source, explicit, limit, result, from, to) {
    super(source, 3, explicit);
    this.limit = limit;
    this.result = result;
    this.from = from;
    this.to = to;
  }
  hasResult() {
    return true;
  }
  updateFor(tr, type2) {
    var _a2;
    if (!(type2 & 3))
      return this.map(tr.changes);
    let result = this.result;
    if (result.map && !tr.changes.empty)
      result = result.map(result, tr.changes);
    let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if (pos > to || !result || type2 & 2 && (cur(tr.startState) == this.from || pos < this.limit))
      return new ActiveSource(
        this.source,
        type2 & 4 ? 1 : 0
        /* State.Inactive */
      );
    let limit = tr.changes.mapPos(this.limit);
    if (checkValid(result.validFor, tr.state, from, to))
      return new ActiveResult(this.source, this.explicit, limit, result, from, to);
    if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))
      return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a2 = result.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
    return new ActiveSource(this.source, 1, this.explicit);
  }
  map(mapping) {
    if (mapping.empty)
      return this;
    let result = this.result.map ? this.result.map(this.result, mapping) : this.result;
    if (!result)
      return new ActiveSource(
        this.source,
        0
        /* State.Inactive */
      );
    return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
  touches(tr) {
    return tr.changes.touchesRange(this.from, this.to);
  }
}
function checkValid(validFor, state, from, to) {
  if (!validFor)
    return false;
  let text = state.sliceDoc(from, to);
  return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
const setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s2) => s2.map(mapping));
  }
});
const setSelectedEffect = /* @__PURE__ */ StateEffect.define();
const completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f2) => [
    showTooltip.from(f2, (val) => val.tooltip),
    EditorView.contentAttributes.from(f2, (state) => state.attrs)
  ]
});
function applyCompletion(view, option) {
  const apply = option.completion.apply || option.completion.label;
  let result = view.state.field(completionState).active.find((a2) => a2.source == option.source);
  if (!(result instanceof ActiveResult))
    return false;
  if (typeof apply == "string")
    view.dispatch({
      ...insertCompletionText(view.state, apply, result.from, result.to),
      annotations: pickedCompletion.of(option.completion)
    });
  else
    apply(view, option.completion, result.from, result.to);
  return true;
}
const createTooltip = /* @__PURE__ */ completionTooltip(completionState, applyCompletion);
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
      step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length - 1;
    else if (selected >= length)
      selected = by == "page" ? length - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
const acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  return applyCompletion(view, cState.open.options[cState.open.selected]);
};
const startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
const closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some(
    (a2) => a2.state != 0
    /* State.Inactive */
  ))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
class RunningQuery {
  constructor(active, context) {
    this.active = active;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
}
const MaxUpdateCount = 50, MinAbortTime = 1e3;
const completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.pendingStart = false;
    this.composing = 0;
    for (let active of view.state.field(completionState).active)
      if (active.isPending)
        this.startQuery(active);
  }
  update(update) {
    let cState = update.state.field(completionState);
    let conf = update.state.facet(completionConfig);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      let type2 = getUpdateType(tr, conf);
      return type2 & 8 || (tr.selection || tr.docChanged) && !(type2 & 3);
    });
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e2) {
            logException(this.view.state, e2);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i2--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    if (update.transactions.some((tr) => tr.effects.some((e2) => e2.is(startCompletionEffect))))
      this.pendingStart = true;
    let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;
    this.debounceUpdate = cState.active.some((a2) => a2.isPending && !this.running.some((q) => q.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), delay) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (tr.isUserEvent("input.type"))
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    this.pendingStart = false;
    let { state } = this.view, cState = state.field(completionState);
    for (let active of cState.active) {
      if (active.isPending && !this.running.some((r2) => r2.active.source == active.source))
        this.startQuery(active);
    }
    if (this.running.length && cState.open && cState.open.disabled)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  startQuery(active) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active.explicit, this.view);
    let pending = new RunningQuery(active, context);
    this.running.push(pending);
    Promise.resolve(active.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);
    for (let i2 = 0; i2 < this.running.length; i2++) {
      let query = this.running[i2];
      if (query.done === void 0)
        continue;
      this.running.splice(i2--, 1);
      if (query.done) {
        let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);
        let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));
        let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : pos);
        for (let tr of query.updates)
          active = active.update(tr, conf);
        if (active.hasResult()) {
          updated.push(active);
          continue;
        }
      }
      let current = cState.active.find((a2) => a2.source == query.active.source);
      if (current && current.isPending) {
        if (query.done == null) {
          let active = new ActiveSource(
            query.active.source,
            0
            /* State.Inactive */
          );
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (!active.isPending)
            updated.push(active);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length || cState.open && cState.open.disabled)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur(event) {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
        let dialog = state.open && getTooltip(this.view, state.open.tooltip);
        if (!dialog || !dialog.dom.contains(event.relatedTarget))
          setTimeout(() => this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
const windows$1 = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform);
const commitCharacters = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event, view) {
    let field = view.state.field(completionState, false);
    if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows$1 && event.altKey) || event.metaKey)
      return false;
    let option = field.open.options[field.open.selected];
    let result = field.active.find((a2) => a2.source == option.source);
    let commitChars = option.completion.commitCharacters || result.result.commitCharacters;
    if (commitChars && commitChars.indexOf(event.key) > -1)
      applyCompletion(view, option);
    return false;
  }
}));
const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class FieldPos {
  constructor(field, line, from, to) {
    this.field = field;
    this.line = line;
    this.from = from;
    this.to = to;
  }
}
class FieldRange {
  constructor(field, from, to) {
    this.field = field;
    this.from = from;
    this.to = to;
  }
  map(changes) {
    let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
    let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
    return from == null || to == null ? null : new FieldRange(this.field, from, to);
  }
}
class Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state, pos) {
    let text = [], lineStart = [pos];
    let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line of this.lines) {
      if (text.length) {
        let indent2 = baseIndent, tabs = /^\t*/.exec(line)[0].length;
        for (let i2 = 0; i2 < tabs; i2++)
          indent2 += state.facet(indentUnit);
        lineStart.push(pos + indent2.length - tabs);
        line = indent2 + line.slice(tabs);
      }
      text.push(line);
      pos += line.length + 1;
    }
    let ranges = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return { text, ranges };
  }
  static parse(template) {
    let fields = [];
    let lines = [], positions = [], m2;
    for (let line of template.split(/\r\n?|\n/)) {
      while (m2 = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(line)) {
        let seq = m2[1] ? +m2[1] : null, rawName = m2[2] || m2[3] || "", found = -1;
        let name2 = rawName.replace(/\\[{}]/g, (m3) => m3[1]);
        for (let i2 = 0; i2 < fields.length; i2++) {
          if (seq != null ? fields[i2].seq == seq : name2 ? fields[i2].name == name2 : false)
            found = i2;
        }
        if (found < 0) {
          let i2 = 0;
          while (i2 < fields.length && (seq == null || fields[i2].seq != null && fields[i2].seq < seq))
            i2++;
          fields.splice(i2, 0, { seq, name: name2 });
          found = i2;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > m2.index) {
            let snip = m2[2] ? 3 + (m2[1] || "").length : 2;
            pos.from -= snip;
            pos.to -= snip;
          }
        positions.push(new FieldPos(found, lines.length, m2.index, m2.index + name2.length));
        line = line.slice(0, m2.index) + rawName + line.slice(m2.index + m2[0].length);
      }
      line = line.replace(/\\([{}])/g, (_, brace, index) => {
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > index) {
            pos.from--;
            pos.to--;
          }
        return brace;
      });
      lines.push(line);
    }
    return new Snippet(lines, positions);
  }
}
let fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
let fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
  constructor(ranges, active) {
    this.ranges = ranges;
    this.active = active;
    this.deco = Decoration.set(ranges.map((r2) => (r2.from == r2.to ? fieldMarker : fieldRange).range(r2.from, r2.to)), true);
  }
  map(changes) {
    let ranges = [];
    for (let r2 of this.ranges) {
      let mapped = r2.map(changes);
      if (!mapped)
        return null;
      ranges.push(mapped);
    }
    return new ActiveSnippet(ranges, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range) => this.ranges.some((r2) => r2.field == this.active && r2.from <= range.from && r2.to >= range.to));
  }
}
const setActive = /* @__PURE__ */ StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
const moveToField = /* @__PURE__ */ StateEffect.define();
const snippetState = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f2) => EditorView.decorations.from(f2, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
  return EditorSelection.create(ranges.filter((r2) => r2.field == field).map((r2) => EditorSelection.range(r2.from, r2.to)));
}
function snippet(template) {
  let snippet2 = Snippet.parse(template);
  return (editor, completion, from, to) => {
    let { text, ranges } = snippet2.instantiate(editor.state, from);
    let { main } = editor.state.selection;
    let spec = {
      changes: { from, to: to == main.from ? main.to : to, insert: Text.of(text) },
      scrollIntoView: true,
      annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of("input.complete")] : void 0
    };
    if (ranges.length)
      spec.selection = fieldSelection(ranges, 0);
    if (ranges.some((r2) => r2.field > 0)) {
      let active = new ActiveSnippet(ranges, 0);
      let effects = spec.effects = [setActive.of(active)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme$1]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active || dir < 0 && active.active == 0)
      return false;
    let next = active.active + dir, last = dir > 0 && !active.ranges.some((r2) => r2.field == next + dir);
    dispatch(state.update({
      selection: fieldSelection(active.ranges, next),
      effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
      scrollIntoView: true
    }));
    return true;
  };
}
const clearSnippet = ({ state, dispatch }) => {
  let active = state.field(snippetState, false);
  if (!active)
    return false;
  dispatch(state.update({ effects: setActive.of(null) }));
  return true;
};
const nextSnippetField = /* @__PURE__ */ moveField(1);
const prevSnippetField = /* @__PURE__ */ moveField(-1);
const defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
const snippetKeymap = /* @__PURE__ */ Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
const addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion(template, completion) {
  return { ...completion, apply: snippet(template) };
}
const snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
  mousedown(event, view) {
    let active = view.state.field(snippetState, false), pos;
    if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
      return false;
    let match = active.ranges.find((r2) => r2.from <= pos && r2.to >= pos);
    if (!match || match.field == active.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active.ranges, match.field),
      effects: setActive.of(active.ranges.some((r2) => r2.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),
      scrollIntoView: true
    });
    return true;
  }
});
const defaults = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
const closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
const closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    value = value.map(tr.changes);
    if (tr.selection) {
      let line = tr.state.doc.lineAt(tr.selection.main.head);
      value = value.update({ filter: (from) => from >= line.from && from <= line.to });
    }
    for (let effect of tr.effects)
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
    return value;
  }
});
function closeBrackets() {
  return [inputHandler, bracketState];
}
const definedClosing = "()[]{}<>«»»«［］｛｝";
function closing(ch) {
  for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
    if (definedClosing.charCodeAt(i2) == ch)
      return definedClosing.charAt(i2 + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config$2(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
const android$1 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
const inputHandler = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
  if ((android$1 ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
const deleteBracketPair = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let conf = config$2(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty) {
      let before = prevChar(state.doc, range.head);
      for (let token of tokens) {
        if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
          return {
            changes: { from: range.head - token.length, to: range.head + token.length },
            range: EditorSelection.cursor(range.head - token.length)
          };
      }
    }
    return { range: dont = range };
  });
  if (!dont)
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
  return !dont;
};
const closeBracketsKeymap = [
  { key: "Backspace", run: deleteBracketPair }
];
function insertBracket(state, bracket2) {
  let conf = config$2(state, state.selection.main.head);
  let tokens = conf.brackets || defaults.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from) => {
    if (from == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next = doc2.sliceString(pos, pos + 2);
  return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc2, pos) {
  let prev = doc2.sliceString(pos - 2, pos);
  return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
        effects: closeBracketEffect.of(range.to + open.length),
        range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
      };
    let next = nextChar(state.doc, range.head);
    if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
      return {
        changes: { insert: open + close, from: range.head },
        effects: closeBracketEffect.of(range.head + open.length),
        range: EditorSelection.cursor(range.head + open.length)
      };
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, changes = state.changeByRange((range) => {
    if (range.empty && nextChar(state.doc, range.head) == close)
      return {
        changes: { from: range.head, to: range.head + close.length, insert: close },
        range: EditorSelection.cursor(range.head + close.length)
      };
    return dont = { range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleSame(state, token, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults.stringPrefixes;
  let dont = null, changes = state.changeByRange((range) => {
    if (!range.empty)
      return {
        changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
        effects: closeBracketEffect.of(range.to + token.length),
        range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
      };
    let pos = range.head, next = nextChar(state.doc, pos), start;
    if (next == token) {
      if (nodeStart(state, pos)) {
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
        let content2 = isTriple ? token + token + token : token;
        return {
          changes: { from: pos, to: pos + content2.length, insert: content2 },
          range: EditorSelection.cursor(pos + content2.length)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {
      return {
        changes: { insert: token + token + token + token, from: pos },
        effects: closeBracketEffect.of(pos + token.length),
        range: EditorSelection.cursor(pos + token.length)
      };
    } else if (state.charCategorizer(pos)(next) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
        return {
          changes: { insert: token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
    }
    return { range: dont = range };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart(state, pos) {
  let tree = syntaxTree(state).resolveInner(pos + 1);
  return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
  let node2 = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes.reduce((m2, p2) => Math.max(m2, p2.length), 0);
  for (let i2 = 0; i2 < 5; i2++) {
    let start = state.sliceDoc(node2.from, Math.min(node2.to, node2.from + quoteToken.length + maxPrefix));
    let quotePos = start.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
      let first = node2.firstChild;
      while (first && first.from == node2.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node2.to == pos && node2.parent;
    if (!parent)
      break;
    node2 = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix of prefixes) {
    let start = pos - prefix.length;
    if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)
      return start;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    commitCharacters,
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme$1
  ];
}
const completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { mac: "Alt-`", run: startCompletion },
  { mac: "Alt-i", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
class SelectedDiagnostic {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
}
class LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      diagnostics = diagnosticFilter(diagnostics, state);
    let sorted = diagnostics.slice().sort((a2, b) => a2.from - b.from || a2.to - b.to);
    let deco = new RangeSetBuilder(), active = [], pos = 0;
    let scan = state.doc.iter(), scanPos = 0, docLen = state.doc.length;
    for (let i2 = 0; ; ) {
      let next = i2 == sorted.length ? null : sorted[i2];
      if (!next && !active.length)
        break;
      let from, to;
      if (active.length) {
        from = pos;
        to = active.reduce((p2, d2) => Math.min(p2, d2.to), next && next.from > from ? next.from : 1e8);
      } else {
        from = next.from;
        if (from > docLen)
          break;
        to = next.to;
        active.push(next);
        i2++;
      }
      while (i2 < sorted.length) {
        let next2 = sorted[i2];
        if (next2.from == from && (next2.to > next2.from || next2.to == from)) {
          active.push(next2);
          i2++;
          to = Math.min(next2.to, to);
        } else {
          to = Math.min(next2.from, to);
          break;
        }
      }
      to = Math.min(to, docLen);
      let widget = false;
      if (active.some((d2) => d2.from == from && (d2.to == to || to == docLen))) {
        widget = from == to;
        if (!widget && to - from < 10) {
          let behind = from - (scanPos + scan.value.length);
          if (behind > 0) {
            scan.next(behind);
            scanPos = from;
          }
          for (let check2 = from; ; ) {
            if (check2 >= to) {
              widget = true;
              break;
            }
            if (!scan.lineBreak && scanPos + scan.value.length > check2)
              break;
            check2 = scanPos + scan.value.length;
            scanPos += scan.value.length;
            scan.next();
          }
        }
      }
      let sev = maxSeverity(active);
      if (widget) {
        deco.add(from, from, Decoration.widget({
          widget: new DiagnosticWidget(sev),
          diagnostics: active.slice()
        }));
      } else {
        let markClass = active.reduce((c2, d2) => d2.markClass ? c2 + " " + d2.markClass : c2, "");
        deco.add(from, to, Decoration.mark({
          class: "cm-lintRange cm-lintRange-" + sev + markClass,
          diagnostics: active.slice(),
          inclusiveEnd: active.some((a2) => a2.to > to)
        }));
      }
      pos = to;
      if (pos == docLen)
        break;
      for (let i3 = 0; i3 < active.length; i3++)
        if (active[i3].to <= pos)
          active.splice(i3--, 1);
    }
    let set = deco.finish();
    return new LintState(set, panel, findDiagnostic(set));
  }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)
      return;
    if (!found)
      found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);
    else if (spec.diagnostics.indexOf(found.diagnostic) < 0)
      return false;
    else
      found = new SelectedDiagnostic(found.from, to, found.diagnostic);
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let from = tooltip.pos, to = tooltip.end || from;
  let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
  if (result != null)
    return result;
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
const setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
const togglePanel = /* @__PURE__ */ StateEffect.define();
const movePanelSelection = /* @__PURE__ */ StateEffect.define();
const lintState = /* @__PURE__ */ StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged && value.diagnostics.size) {
      let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
        panel = null;
      value = new LintState(mapped, panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
        value = LintState.init(effect.value, panel, tr.state);
      } else if (effect.is(togglePanel)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f2) => [
    showPanel.from(f2, (val) => val.panel),
    EditorView.decorations.from(f2, (s2) => s2.diagnostics)
  ]
});
function diagnosticCount(state) {
  let lint = state.field(lintState, false);
  return lint ? lint.diagnostics.size : 0;
}
const activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found, start = -1, end = -1;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found = spec.diagnostics;
      start = from;
      end = to;
      return false;
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (found && diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found)
    return null;
  return {
    pos: start,
    end,
    above: view.state.doc.lineAt(start).to < end,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d2) => renderDiagnostic(view, d2, false)));
}
const openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
const closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
const nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
const previousDiagnostic = (view) => {
  let { state } = view, field = state.field(lintState, false);
  if (!field)
    return false;
  let sel = state.selection.main;
  let prevFrom, prevTo, lastFrom, lastTo;
  field.diagnostics.between(0, state.doc.length, (from, to) => {
    if (to < sel.to && (prevFrom == null || prevFrom < from)) {
      prevFrom = from;
      prevTo = to;
    }
    if (lastFrom == null || from > lastFrom) {
      lastFrom = from;
      lastTo = to;
    }
  });
  if (lastFrom == null || prevFrom == null && lastFrom == sel.from)
    return false;
  view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });
  return true;
};
const lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
const lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    clearTimeout(this.timeout);
    let now = Date.now();
    if (now < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      if (sources.length)
        batchResults(sources.map((s2) => Promise.resolve(s2(this.view))), (annotations) => {
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a2, b) => a2.concat(b))));
        }, (error) => {
          logException(this.view.state, error);
        });
    }
  }
  update(update) {
    let config2 = update.state.facet(lintConfig);
    if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function batchResults(promises, sink, error) {
  let collected = [], timeout = -1;
  for (let p2 of promises)
    p2.then((value) => {
      collected.push(value);
      clearTimeout(timeout);
      if (collected.length == promises.length)
        sink(collected);
      else
        timeout = setTimeout(() => sink(collected), 200);
    }, error);
}
const lintConfig = /* @__PURE__ */ Facet.define({
  combine(input) {
    return {
      sources: input.map((i2) => i2.source).filter((x2) => x2 != null),
      ...combineConfig(input.map((i2) => i2.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: combineFilter,
        tooltipFilter: combineFilter,
        needsRefresh: (a2, b) => !a2 ? b : !b ? a2 : (u2) => a2(u2) || b(u2),
        hideOn: (a2, b) => !a2 ? b : !b ? a2 : (t2, x2, y2) => a2(t2, x2, y2) || b(t2, x2, y2),
        autoPanel: (a2, b) => a2 || b
      })
    };
  }
});
function combineFilter(a2, b) {
  return !a2 ? b : !b ? a2 : (d2, s2) => b(a2(d2, s2), s2);
}
function linter$1(source, config2 = {}) {
  return [
    lintConfig.of({ source, config: config2 }),
    lintPlugin,
    lintExtensions
  ];
}
function forceLinting(view) {
  let plugin2 = view.plugin(lintPlugin);
  if (plugin2)
    plugin2.force();
}
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name: name2 } of actions) {
      for (let i2 = 0; i2 < name2.length; i2++) {
        let ch = name2[i2];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c2) => c2.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a2;
  let keys2 = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i2) => {
    let fired = false, click = (e2) => {
      e2.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name: name2 } = action, keyIndex = keys2[i2] ? name2.indexOf(keys2[i2]) : -1;
    let nameElt = keyIndex < 0 ? name2 : [
      name2.slice(0, keyIndex),
      crelt("u", name2.slice(keyIndex, keyIndex + 1)),
      name2.slice(keyIndex + 1)
    ];
    let markClass = action.markClass ? " " + action.markClass : "";
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction" + markClass,
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name2}${keyIndex < 0 ? "" : ` (access key "${keys2[i2]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
class DiagnosticWidget extends WidgetType {
  constructor(sev) {
    super();
    this.sev = sev;
  }
  eq(other) {
    return other.sev == this.sev;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class PanelItem {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
}
class LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys2 = assignKeys(diagnostic.actions);
        for (let i2 = 0; i2 < keys2.length; i2++)
          if (keys2[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i2].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        if (this.items[i2].dom.contains(event.target))
          this.moveSelection(i2);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "×"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i2 = 0; i2 < this.items.length; i2++)
      if (this.items[i2].diagnostic == selected.diagnostic)
        return i2;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i2 = 0, needsSync = false, newSelectedItem = null;
    let seen = /* @__PURE__ */ new Set();
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      for (let diagnostic of spec.diagnostics) {
        if (seen.has(diagnostic))
          continue;
        seen.add(diagnostic);
        let found = -1, item;
        for (let j = i2; j < this.items.length; j++)
          if (this.items[j].diagnostic == diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, diagnostic);
          this.items.splice(i2, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i2) {
            this.items.splice(i2, found - i2);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i2++;
      }
    });
    while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm2() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm2();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm2();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection)
      return;
    this.view.dispatch({
      selection: { anchor: selection.from, head: selection.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection)
    });
  }
  static open(view) {
    return new LintPanel(view);
  }
}
function svg(content2, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
function maxSeverity(diagnostics) {
  let sev = "hint", weight = 1;
  for (let d2 of diagnostics) {
    let w = severityWeight(d2.severity);
    if (w > weight) {
      weight = w;
      sev = d2.severity;
    }
  }
  return sev;
}
class LintGutterMarker extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = maxSeverity(diagnostics);
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics, view.state);
    if (diagnostics.length)
      elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
}
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
      return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line.from,
        above: false,
        clip: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc2, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc2.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line in byLine) {
    markers.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers, true);
}
const lintGutterExtension = /* @__PURE__ */ gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers),
  widgetMarker: (view, widget, block) => {
    let diagnostics = [];
    view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value) => {
      if (from > block.from && from < block.to)
        diagnostics.push(...value.diagnostics);
    });
    return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
  }
});
const lintGutterMarkers = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr) {
    markers = markers.map(tr.changes);
    let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || [], tr.state);
        markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
const setLintGutterTooltip = /* @__PURE__ */ StateEffect.define();
const lintGutterTooltip = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr) {
    if (tooltip && tr.docChanged)
      tooltip = hideTooltip(tr, tooltip) ? null : { ...tooltip, pos: tr.changes.mapPos(tooltip.pos) };
    return tr.effects.reduce((t2, e2) => e2.is(setLintGutterTooltip) ? e2.value : t2, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
const lintGutterTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: /* @__PURE__ */ svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: /* @__PURE__ */ svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: /* @__PURE__ */ svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
const lintExtensions = [
  lintState,
  /* @__PURE__ */ EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  /* @__PURE__ */ hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme
];
const lintGutterConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});
function lintGutter(config2 = {}) {
  return [lintGutterConfig.of(config2), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
}
function forEachDiagnostic(state, f2) {
  let lState = state.field(lintState, false);
  if (lState && lState.diagnostics.size) {
    let pending = [], pendingStart = [], lastEnd = -1;
    for (let iter = RangeSet.iter([lState.diagnostics]); ; iter.next()) {
      for (let i2 = 0; i2 < pending.length; i2++)
        if (!iter.value || iter.value.spec.diagnostics.indexOf(pending[i2]) < 0) {
          f2(pending[i2], pendingStart[i2], lastEnd);
          pending.splice(i2, 1);
          pendingStart.splice(i2--, 1);
        }
      if (!iter.value)
        break;
      for (let d2 of iter.value.spec.diagnostics)
        if (pending.indexOf(d2) < 0) {
          pending.push(d2);
          pendingStart.push(iter.from);
        }
      lastEnd = iter.to;
    }
  }
}
const Lint = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closeLintPanel,
  diagnosticCount,
  forEachDiagnostic,
  forceLinting,
  lintGutter,
  lintKeymap,
  linter: linter$1,
  nextDiagnostic,
  openLintPanel,
  previousDiagnostic,
  setDiagnostics,
  setDiagnosticsEffect
}, Symbol.toStringTag, { value: "Module" }));
const basicSetup = /* @__PURE__ */ (() => [
  lineNumbers(),
  highlightActiveLineGutter(),
  highlightSpecialChars(),
  history(),
  foldGutter(),
  drawSelection(),
  dropCursor(),
  EditorState.allowMultipleSelections.of(true),
  indentOnInput(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  bracketMatching(),
  closeBrackets(),
  autocompletion(),
  rectangularSelection(),
  crosshairCursor(),
  highlightActiveLine(),
  highlightSelectionMatches(),
  keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...searchKeymap,
    ...historyKeymap,
    ...foldKeymap,
    ...completionKeymap,
    ...lintKeymap
  ])
])();
const minimalSetup = /* @__PURE__ */ (() => [
  highlightSpecialChars(),
  history(),
  drawSelection(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  keymap.of([
    ...defaultKeymap,
    ...historyKeymap
  ])
])();
const C = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EditorView,
  basicSetup,
  minimalSetup
}, Symbol.toStringTag, { value: "Module" }));
class Stack {
  /**
  @internal
  */
  constructor(p2, stack, state, reducePos, pos, score2, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p2;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_, i2) => i2 % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p2, state, pos = 0) {
    let cx = p2.parser.context;
    return new Stack(p2, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a2;
    let depth2 = action >> 19, type2 = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type2);
    if (dPrec)
      this.score += dPrec;
    if (depth2 == 0) {
      this.pushState(parser2.getGoto(this.state, type2, true), this.reducePos);
      if (type2 < parser2.minRepeatTerm)
        this.storeNode(type2, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type2, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth2 - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base2 ? this.stack[base2 - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a2 = this.p.parser.nodeSet.types[type2]) === null || _a2 === void 0 ? void 0 : _a2.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base2 ? this.stack[base2 - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type2 < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type2, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type2, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type2, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start == end)
          return;
        if (cur2.buffer[top2 - 2] >= start) {
          cur2.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && (this.buffer[index - 4] != 0 || this.buffer[index - 1] < 0)) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type2, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (end > this.pos || type2 <= parser2.maxNode) {
        this.pos = end;
        if (!parser2.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        ))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type2, start);
      if (type2 <= parser2.maxNode)
        this.buffer.push(type2, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type2, start);
      if (type2 <= this.p.parser.maxNode)
        this.buffer.push(type2, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off2 = parent.buffer.length;
    while (off2 > 0 && parent.buffer[off2 - 2] > parent.reducePos)
      off2 -= 4;
    let buffer = parent.buffer.slice(off2), base2 = parent.bufferBase + off2;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i2 = 0, s2; i2 < nextStates.length; i2 += 2) {
        if ((s2 = nextStates[i2 + 1]) != this.state && this.p.parser.hasAction(s2, next))
          best.push(nextStates[i2], s2);
      }
      if (this.stack.length < 120)
        for (let i2 = 0; best.length < 4 << 1 && i2 < nextStates.length; i2 += 2) {
          let s2 = nextStates[i2 + 1];
          if (!best.some((v2, i3) => i3 & 1 && v2 == s2))
            best.push(nextStates[i2], s2);
        }
      nextStates = best;
    }
    let result = [];
    for (let i2 = 0; i2 < nextStates.length && result.length < 4; i2 += 2) {
      let s2 = nextStates[i2 + 1];
      if (s2 == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s2, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i2], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce)) {
      let depth2 = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth2 * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state, depth2) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072)) ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth2;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth2 + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser2.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i2 = 0; i2 < this.stack.length; i2 += 3)
      if (this.stack[i2] != other.stack[i2])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead <= this.lookAhead)
      return false;
    this.emitLookAhead();
    this.lookAhead = lookAhead;
    return true;
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
}
class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
}
class SimulatedStack {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth2 = action >> 19;
    if (depth2 == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth2 - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
}
class StackBufferCursor {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
}
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
class CachedToken {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
}
const nullToken = new CachedToken();
class InputStream {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i2 = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i2];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n2 = 1) {
    this.chunkOff += n2;
    while (this.pos + n2 >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n2 -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n2;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r2 of this.ranges) {
      if (r2.from >= to)
        break;
      if (r2.to > from)
        result += this.input.read(Math.max(r2.from, from), Math.min(r2.to, to));
    }
    return result;
  }
}
class TokenGroup {
  constructor(data2, id2) {
    this.data = data2;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class LocalTokenGroup {
  constructor(data2, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data2 == "string" ? decodeArray(data2) : data2;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
}
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class ExternalTokenizer {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
}
function readToken(data2, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan: for (; ; ) {
    if ((groupMask & data2[state]) == 0)
      break;
    let accEnd = data2[state + 1];
    for (let i2 = state + 3; i2 < accEnd; i2 += 2)
      if ((data2[i2 + 1] & groupMask) > 0) {
        let term = data2[i2];
        if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
          input.acceptToken(term);
          break;
        }
      }
    let next = input.next, low = 0, high = data2[state + 2];
    if (input.next < 0 && high > low && data2[accEnd + high * 3 - 3] == 65535) {
      state = data2[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high; ) {
      let mid = low + high >> 1;
      let index = accEnd + mid + (mid << 1);
      let from = data2[index], to = data2[index + 1] || 65536;
      if (next < from)
        high = mid;
      else if (next >= to)
        low = mid + 1;
      else {
        state = data2[index + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data2, start, term) {
  for (let i2 = start, next; (next = data2[i2]) != 65535; i2++)
    if (next == term)
      return i2 - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor2 = tree.cursor(IterMode.IncludeAnonymous);
  cursor2.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor2.childBefore(pos) : cursor2.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor2.to < pos : cursor2.from > pos) && !cursor2.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor2.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor2.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor2.prevSibling() : cursor2.nextSibling())
          break;
        if (!cursor2.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
class FragmentCursor {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index = this.index[last];
      if (index == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index];
      let start = this.start[last] + top2.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
}
class TokenCache {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i2 = 0; i2 < tokenizers.length; i2++) {
      if ((1 << i2 & mask) == 0)
        continue;
      let tokenizer = tokenizers[i2], token = this.tokens[i2];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p: p2 } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p2.stream.end);
    main.value = pos == p2.stream.end ? p2.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i2 = 0; i2 < parser2.specialized.length; i2++)
        if (parser2.specialized[i2] == token.value) {
          let result = parser2.specializers[i2](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i2 = 0; i2 < index; i2 += 3)
      if (this.actions[i2] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data: data2 } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i2 = parser2.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i2 += 3) {
        if (data2[i2] == 65535) {
          if (data2[i2 + 1] == 1) {
            i2 = pair(data2, i2 + 2);
          } else {
            if (index == 0 && data2[i2 + 1] == 2)
              index = this.putAction(pair(data2, i2 + 2), token, end, index);
            break;
          }
        }
        if (data2[i2] == token)
          index = this.putAction(pair(data2, i2 + 1), token, end, index);
      }
    }
    return index;
  }
}
class Parse {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s2] = stacks;
      while (s2.forceReduce() && s2.stack.length && s2.stack[s2.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i2 = 0; i2 < stacks.length; i2++) {
      let stack = stacks[i2];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a2, b) => b.score - a2.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s2) => s2.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i2 = 0; i2 < newStacks.length - 1; i2++) {
        let stack = newStacks[i2];
        for (let j = i2 + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i2--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12) {
        newStacks.sort((a2, b) => b.score - a2.score);
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
      }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i2 = 1; i2 < newStacks.length; i2++)
      if (newStacks[i2].pos < this.minStackPos)
        this.minStackPos = newStacks[i2].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i2 = 0; i2 < actions.length; ) {
      let action = actions[i2++], term = actions[i2++], end = actions[i2++];
      let last = i2 == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i2 = 0; i2 < stacks.length; i2++) {
      let stack = stacks[i2], token = tokens[i2 << 1], tokenEnd = tokens[(i2 << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; j < 10 && force.forceReduce(); j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
}
function pushStackDedup(stack, newStacks) {
  for (let i2 = 0; i2 < newStacks.length; i2++) {
    let other = newStacks[i2];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i2].score < stack.score)
        newStacks[i2] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
class Dialect {
  constructor(source, flags2, disabled) {
    this.source = source;
    this.flags = flags2;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
}
const id$1 = (x2) => x2;
class ContextTracker {
  /**
  Define a context tracker.
  */
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id$1;
    this.reduce = spec.reduce || id$1;
    this.reuse = spec.reuse || id$1;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
}
class LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i2 = 0; i2 < spec.repeatNodeCount; i2++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r2) => spec.topRules[r2][1]);
    let nodeProps = [];
    for (let i2 = 0; i2 < nodeNames.length; i2++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i2 = 1; i2 < propSpec.length; ) {
          let next = propSpec[i2++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i2++]);
          } else {
            let value = propSpec[i2 + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i2++], prop, value);
            i2++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i2) => NodeType.define({
      name: i2 >= this.minRepeatTerm ? void 0 : name2,
      id: i2,
      props: nodeProps[i2],
      top: topTerms.indexOf(i2) > -1,
      error: i2 == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i2) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i2 = 0; i2 < this.specializerSpecs.length; i2++)
      this.specialized[i2] = this.specializerSpecs[i2].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data2 = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i2 = this.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i2 += 3) {
        if ((next = data2[i2]) == 65535) {
          if (data2[i2 + 1] == 1)
            next = data2[i2 = pair(data2, i2 + 2)];
          else if (data2[i2 + 1] == 2)
            return pair(data2, i2 + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data2, i2 + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a2) => a2 == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i2 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i2 += 3) {
      if (this.data[i2] == 65535) {
        if (this.data[i2 + 1] == 1)
          i2 = pair(this.data, i2 + 2);
        else
          break;
      }
      result = action(pair(this.data, i2 + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i2 = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i2 += 3) {
      if (this.data[i2] == 65535) {
        if (this.data[i2 + 1] == 1)
          i2 = pair(this.data, i2 + 2);
        else
          break;
      }
      if ((this.data[i2 + 2] & 65536 >> 16) == 0) {
        let value = this.data[i2 + 1];
        if (!result.some((v2, i3) => i3 & 1 && v2 == value))
          result.push(this.data[i2], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config2) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config2.props)
      copy.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info = this.topRules[config2.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy.top = info;
    }
    if (config2.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config2.tokenizers.find((r2) => r2.from == t2);
        return found ? found.to : t2;
      });
    if (config2.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s2, i2) => {
        let found = config2.specializers.find((r2) => r2.from == s2.external);
        if (!found)
          return s2;
        let spec = Object.assign(Object.assign({}, s2), { external: found.to });
        copy.specializers[i2] = getSpecializer(spec);
        return spec;
      });
    }
    if (config2.contextTracker)
      copy.context = config2.contextTracker;
    if (config2.dialect)
      copy.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null)
      copy.strict = config2.strict;
    if (config2.wrap)
      copy.wrappers = copy.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null)
      copy.bufferLength = config2.bufferLength;
    return copy;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags2 = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags2[id2] = true;
      }
    let disabled = null;
    for (let i2 = 0; i2 < values.length; i2++)
      if (!flags2[i2]) {
        for (let j = this.dialects[values[i2]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags2, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new LRParser(spec);
  }
}
function pair(data2, off2) {
  return data2[off2] | data2[off2 + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}
const noSemi = 316, noSemiType = 317, incdec = 1, incdecPrefix = 2, questionDot = 3, JSXStartTag = 4, insertSemi = 318, spaces = 320, newline = 321, LineComment = 5, BlockComment = 6, Dialect_jsx = 0;
const space = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
const braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44, question = 63, dot = 46, bracketL = 91;
const trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;
  },
  strict: false
});
const insertSemicolon = new ExternalTokenizer((input, stack) => {
  let { next } = input;
  if (next == braceR || next == -1 || stack.context)
    input.acceptToken(insertSemi);
}, { contextual: true, fallback: true });
const noSemicolon = new ExternalTokenizer((input, stack) => {
  let { next } = input, after;
  if (space.indexOf(next) > -1) return;
  if (next == slash && ((after = input.peek(1)) == slash || after == star)) return;
  if (next != braceR && next != semicolon && next != -1 && !stack.context)
    input.acceptToken(noSemi);
}, { contextual: true });
const noSemicolonType = new ExternalTokenizer((input, stack) => {
  if (input.next == bracketL && !stack.context) input.acceptToken(noSemiType);
}, { contextual: true });
const operatorToken = new ExternalTokenizer((input, stack) => {
  let { next } = input;
  if (next == plus || next == minus) {
    input.advance();
    if (next == input.next) {
      input.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  } else if (next == question && input.peek(1) == dot) {
    input.advance();
    input.advance();
    if (input.next < 48 || input.next > 57)
      input.acceptToken(questionDot);
  }
}, { contextual: true });
function identifierChar(ch, start) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start && ch >= 48 && ch <= 57;
}
const jsx = new ExternalTokenizer((input, stack) => {
  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;
  input.advance();
  if (input.next == slash) return;
  let back = 0;
  while (space.indexOf(input.next) > -1) {
    input.advance();
    back++;
  }
  if (identifierChar(input.next, true)) {
    input.advance();
    back++;
    while (identifierChar(input.next, false)) {
      input.advance();
      back++;
    }
    while (space.indexOf(input.next) > -1) {
      input.advance();
      back++;
    }
    if (input.next == comma) return;
    for (let i2 = 0; ; i2++) {
      if (i2 == 7) {
        if (!identifierChar(input.next, true)) return;
        break;
      }
      if (input.next != "extends".charCodeAt(i2)) break;
      input.advance();
      back++;
    }
  }
  input.acceptToken(JSXStartTag, -back);
});
const jsHighlight = styleTags({
  "get set async static": tags.modifier,
  "for while do if else switch try catch finally return throw break continue default case defer": tags.controlKeyword,
  "in of await yield void typeof delete instanceof as satisfies": tags.operatorKeyword,
  "let var const using function class extends": tags.definitionKeyword,
  "import export from": tags.moduleKeyword,
  "with debugger new": tags.keyword,
  TemplateString: tags.special(tags.string),
  super: tags.atom,
  BooleanLiteral: tags.bool,
  this: tags.self,
  null: tags.null,
  Star: tags.modifier,
  VariableName: tags.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
  VariableDefinition: tags.definition(tags.variableName),
  Label: tags.labelName,
  PropertyName: tags.propertyName,
  PrivatePropertyName: tags.special(tags.propertyName),
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
  "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
  "NewExpression/VariableName": tags.className,
  PropertyDefinition: tags.definition(tags.propertyName),
  PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
  UpdateOp: tags.updateOperator,
  "LineComment Hashbang": tags.lineComment,
  BlockComment: tags.blockComment,
  Number: tags.number,
  String: tags.string,
  Escape: tags.escape,
  ArithOp: tags.arithmeticOperator,
  LogicOp: tags.logicOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  RegExp: tags.regexp,
  Equals: tags.definitionOperator,
  Arrow: tags.function(tags.punctuation),
  ": Spread": tags.punctuation,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  "InterpolationStart InterpolationEnd": tags.special(tags.brace),
  ".": tags.derefOperator,
  ", ;": tags.separator,
  "@": tags.meta,
  TypeName: tags.typeName,
  TypeDefinition: tags.definition(tags.typeName),
  "type enum interface implements namespace module declare": tags.definitionKeyword,
  "abstract global Privacy readonly override": tags.modifier,
  "is keyof unique infer asserts": tags.operatorKeyword,
  JSXAttributeValue: tags.attributeValue,
  JSXText: tags.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
  "JSXIdentifier JSXNameSpacedName": tags.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName,
  "JSXBuiltin/JSXIdentifier": tags.standard(tags.tagName)
});
const spec_identifier = { __proto__: null, export: 20, as: 25, from: 33, default: 36, async: 41, function: 42, in: 52, out: 55, const: 56, extends: 60, this: 64, true: 72, false: 72, null: 84, void: 88, typeof: 92, super: 108, new: 142, delete: 154, yield: 163, await: 167, class: 172, public: 235, private: 235, protected: 235, readonly: 237, instanceof: 256, satisfies: 259, import: 292, keyof: 349, unique: 353, infer: 359, asserts: 395, is: 397, abstract: 417, implements: 419, type: 421, let: 424, var: 426, using: 429, interface: 435, enum: 439, namespace: 445, module: 447, declare: 451, global: 455, defer: 471, for: 476, of: 485, while: 488, with: 492, do: 496, if: 500, else: 502, switch: 506, case: 512, try: 518, catch: 522, finally: 526, return: 530, throw: 534, break: 538, continue: 542, debugger: 546 };
const spec_word = { __proto__: null, async: 129, get: 131, set: 133, declare: 195, public: 197, private: 197, protected: 197, static: 199, abstract: 201, override: 203, readonly: 209, accessor: 211, new: 401 };
const spec_LessThan = { __proto__: null, "<": 193 };
const parser = LRParser.deserialize({
  version: 14,
  states: "$F|Q%TQlOOO%[QlOOO'_QpOOP(lO`OOO*zQ!0MxO'#CiO+RO#tO'#CjO+aO&jO'#CjO+oO#@ItO'#DaO.QQlO'#DgO.bQlO'#DrO%[QlO'#DzO0fQlO'#ESOOQ!0Lf'#E['#E[O1PQ`O'#EXOOQO'#Ep'#EpOOQO'#Il'#IlO1XQ`O'#GsO1dQ`O'#EoO1iQ`O'#EoO3hQ!0MxO'#JrO6[Q!0MxO'#JsO6uQ`O'#F]O6zQ,UO'#FtOOQ!0Lf'#Ff'#FfO7VO7dO'#FfO9XQMhO'#F|O9`Q`O'#F{OOQ!0Lf'#Js'#JsOOQ!0Lb'#Jr'#JrO9eQ`O'#GwOOQ['#K_'#K_O9pQ`O'#IYO9uQ!0LrO'#IZOOQ['#J`'#J`OOQ['#I_'#I_Q`QlOOQ`QlOOO9}Q!L^O'#DvO:UQlO'#EOO:]QlO'#EQO9kQ`O'#GsO:dQMhO'#CoO:rQ`O'#EnO:}Q`O'#EyO;hQMhO'#FeO;xQ`O'#GsOOQO'#K`'#K`O;}Q`O'#K`O<]Q`O'#G{O<]Q`O'#G|O<]Q`O'#HOO9kQ`O'#HRO=SQ`O'#HUO>kQ`O'#CeO>{Q`O'#HcO?TQ`O'#HiO?TQ`O'#HkO`QlO'#HmO?TQ`O'#HoO?TQ`O'#HrO?YQ`O'#HxO?_Q!0LsO'#IOO%[QlO'#IQO?jQ!0LsO'#ISO?uQ!0LsO'#IUO9uQ!0LrO'#IWO@QQ!0MxO'#CiOASQpO'#DlQOQ`OOO%[QlO'#EQOAjQ`O'#ETO:dQMhO'#EnOAuQ`O'#EnOBQQ!bO'#FeOOQ['#Cg'#CgOOQ!0Lb'#Dq'#DqOOQ!0Lb'#Jv'#JvO%[QlO'#JvOOQO'#Jy'#JyOOQO'#Ih'#IhOCQQpO'#EgOOQ!0Lb'#Ef'#EfOOQ!0Lb'#J}'#J}OC|Q!0MSO'#EgODWQpO'#EWOOQO'#Jx'#JxODlQpO'#JyOEyQpO'#EWODWQpO'#EgPFWO&2DjO'#CbPOOO)CD})CD}OOOO'#I`'#I`OFcO#tO,59UOOQ!0Lh,59U,59UOOOO'#Ia'#IaOFqO&jO,59UOGPQ!L^O'#DcOOOO'#Ic'#IcOGWO#@ItO,59{OOQ!0Lf,59{,59{OGfQlO'#IdOGyQ`O'#JtOIxQ!fO'#JtO+}QlO'#JtOJPQ`O,5:ROJgQ`O'#EpOJtQ`O'#KTOKPQ`O'#KSOKPQ`O'#KSOKXQ`O,5;^OK^Q`O'#KROOQ!0Ln,5:^,5:^OKeQlO,5:^OMcQ!0MxO,5:fONSQ`O,5:nONmQ!0LrO'#KQONtQ`O'#KPO9eQ`O'#KPO! YQ`O'#KPO! bQ`O,5;]O! gQ`O'#KPO!#lQ!fO'#JsOOQ!0Lh'#Ci'#CiO%[QlO'#ESO!$[Q!fO,5:sOOQS'#Jz'#JzOOQO-E<j-E<jO9kQ`O,5=_O!$rQ`O,5=_O!$wQlO,5;ZO!&zQMhO'#EkO!(eQ`O,5;ZO!(jQlO'#DyO!(tQpO,5;dO!(|QpO,5;dO%[QlO,5;dOOQ['#FT'#FTOOQ['#FV'#FVO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eO%[QlO,5;eOOQ['#FZ'#FZO!)[QlO,5;tOOQ!0Lf,5;y,5;yOOQ!0Lf,5;z,5;zOOQ!0Lf,5;|,5;|O%[QlO'#IpO!+_Q!0LrO,5<iO%[QlO,5;eO!&zQMhO,5;eO!+|QMhO,5;eO!-nQMhO'#E^O%[QlO,5;wOOQ!0Lf,5;{,5;{O!-uQ,UO'#FjO!.rQ,UO'#KXO!.^Q,UO'#KXO!.yQ,UO'#KXOOQO'#KX'#KXO!/_Q,UO,5<SOOOW,5<`,5<`O!/pQlO'#FvOOOW'#Io'#IoO7VO7dO,5<QO!/wQ,UO'#FxOOQ!0Lf,5<Q,5<QO!0hQ$IUO'#CyOOQ!0Lh'#C}'#C}O!0{O#@ItO'#DRO!1iQMjO,5<eO!1pQ`O,5<hO!3YQ(CWO'#GXO!3jQ`O'#GYO!3oQ`O'#GYO!5_Q(CWO'#G^O!6dQpO'#GbOOQO'#Gn'#GnO!,TQMhO'#GmOOQO'#Gp'#GpO!,TQMhO'#GoO!7VQ$IUO'#JlOOQ!0Lh'#Jl'#JlO!7aQ`O'#JkO!7oQ`O'#JjO!7wQ`O'#CuOOQ!0Lh'#C{'#C{O!8YQ`O'#C}OOQ!0Lh'#DV'#DVOOQ!0Lh'#DX'#DXO!8_Q`O,5<eO1SQ`O'#DZO!,TQMhO'#GPO!,TQMhO'#GRO!8gQ`O'#GTO!8lQ`O'#GUO!3oQ`O'#G[O!,TQMhO'#GaO<]Q`O'#JkO!8qQ`O'#EqO!9`Q`O,5<gOOQ!0Lb'#Cr'#CrO!9hQ`O'#ErO!:bQpO'#EsOOQ!0Lb'#KR'#KRO!:iQ!0LrO'#KaO9uQ!0LrO,5=cO`QlO,5>tOOQ['#Jh'#JhOOQ[,5>u,5>uOOQ[-E<]-E<]O!<hQ!0MxO,5:bO!:]QpO,5:`O!?RQ!0MxO,5:jO%[QlO,5:jO!AiQ!0MxO,5:lOOQO,5@z,5@zO!BYQMhO,5=_O!BhQ!0LrO'#JiO9`Q`O'#JiO!ByQ!0LrO,59ZO!CUQpO,59ZO!C^QMhO,59ZO:dQMhO,59ZO!CiQ`O,5;ZO!CqQ`O'#HbO!DVQ`O'#KdO%[QlO,5;}O!:]QpO,5<PO!D_Q`O,5=zO!DdQ`O,5=zO!DiQ`O,5=zO!DwQ`O,5=zO9uQ!0LrO,5=zO<]Q`O,5=jOOQO'#Cy'#CyO!EOQpO,5=gO!EWQMhO,5=hO!EcQ`O,5=jO!EhQ!bO,5=mO!EpQ`O'#K`O?YQ`O'#HWO9kQ`O'#HYO!EuQ`O'#HYO:dQMhO'#H[O!EzQ`O'#H[OOQ[,5=p,5=pO!FPQ`O'#H]O!FbQ`O'#CoO!FgQ`O,59PO!FqQ`O,59PO!HvQlO,59POOQ[,59P,59PO!IWQ!0LrO,59PO%[QlO,59PO!KcQlO'#HeOOQ['#Hf'#HfOOQ['#Hg'#HgO`QlO,5=}O!KyQ`O,5=}O`QlO,5>TO`QlO,5>VO!LOQ`O,5>XO`QlO,5>ZO!LTQ`O,5>^O!LYQlO,5>dOOQ[,5>j,5>jO%[QlO,5>jO9uQ!0LrO,5>lOOQ[,5>n,5>nO#!dQ`O,5>nOOQ[,5>p,5>pO#!dQ`O,5>pOOQ[,5>r,5>rO##QQpO'#D_O%[QlO'#JvO##sQpO'#JvO##}QpO'#DmO#$`QpO'#DmO#&qQlO'#DmO#&xQ`O'#JuO#'QQ`O,5:WO#'VQ`O'#EtO#'eQ`O'#KUO#'mQ`O,5;_O#'rQpO'#DmO#(PQpO'#EVOOQ!0Lf,5:o,5:oO%[QlO,5:oO#(WQ`O,5:oO?YQ`O,5;YO!CUQpO,5;YO!C^QMhO,5;YO:dQMhO,5;YO#(`Q`O,5@bO#(eQ07dO,5:sOOQO-E<f-E<fO#)kQ!0MSO,5;RODWQpO,5:rO#)uQpO,5:rODWQpO,5;RO!ByQ!0LrO,5:rOOQ!0Lb'#Ej'#EjOOQO,5;R,5;RO%[QlO,5;RO#*SQ!0LrO,5;RO#*_Q!0LrO,5;RO!CUQpO,5:rOOQO,5;X,5;XO#*mQ!0LrO,5;RPOOO'#I^'#I^P#+RO&2DjO,58|POOO,58|,58|OOOO-E<^-E<^OOQ!0Lh1G.p1G.pOOOO-E<_-E<_OOOO,59},59}O#+^Q!bO,59}OOOO-E<a-E<aOOQ!0Lf1G/g1G/gO#+cQ!fO,5?OO+}QlO,5?OOOQO,5?U,5?UO#+mQlO'#IdOOQO-E<b-E<bO#+zQ`O,5@`O#,SQ!fO,5@`O#,ZQ`O,5@nOOQ!0Lf1G/m1G/mO%[QlO,5@oO#,cQ`O'#IjOOQO-E<h-E<hO#,ZQ`O,5@nOOQ!0Lb1G0x1G0xOOQ!0Ln1G/x1G/xOOQ!0Ln1G0Y1G0YO%[QlO,5@lO#,wQ!0LrO,5@lO#-YQ!0LrO,5@lO#-aQ`O,5@kO9eQ`O,5@kO#-iQ`O,5@kO#-wQ`O'#ImO#-aQ`O,5@kOOQ!0Lb1G0w1G0wO!(tQpO,5:uO!)PQpO,5:uOOQS,5:w,5:wO#.iQdO,5:wO#.qQMhO1G2yO9kQ`O1G2yOOQ!0Lf1G0u1G0uO#/PQ!0MxO1G0uO#0UQ!0MvO,5;VOOQ!0Lh'#GW'#GWO#0rQ!0MzO'#JlO!$wQlO1G0uO#2}Q!fO'#JwO%[QlO'#JwO#3XQ`O,5:eOOQ!0Lh'#D_'#D_OOQ!0Lf1G1O1G1OO%[QlO1G1OOOQ!0Lf1G1f1G1fO#3^Q`O1G1OO#5rQ!0MxO1G1PO#5yQ!0MxO1G1PO#8aQ!0MxO1G1PO#8hQ!0MxO1G1PO#;OQ!0MxO1G1PO#=fQ!0MxO1G1PO#=mQ!0MxO1G1PO#=tQ!0MxO1G1PO#@[Q!0MxO1G1PO#@cQ!0MxO1G1PO#BpQ?MtO'#CiO#DkQ?MtO1G1`O#DrQ?MtO'#JsO#EVQ!0MxO,5?[OOQ!0Lb-E<n-E<nO#GdQ!0MxO1G1PO#HaQ!0MzO1G1POOQ!0Lf1G1P1G1PO#IdQMjO'#J|O#InQ`O,5:xO#IsQ!0MxO1G1cO#JgQ,UO,5<WO#JoQ,UO,5<XO#JwQ,UO'#FoO#K`Q`O'#FnOOQO'#KY'#KYOOQO'#In'#InO#KeQ,UO1G1nOOQ!0Lf1G1n1G1nOOOW1G1y1G1yO#KvQ?MtO'#JrO#LQQ`O,5<bO!)[QlO,5<bOOOW-E<m-E<mOOQ!0Lf1G1l1G1lO#LVQpO'#KXOOQ!0Lf,5<d,5<dO#L_QpO,5<dO#LdQMhO'#DTOOOO'#Ib'#IbO#LkO#@ItO,59mOOQ!0Lh,59m,59mO%[QlO1G2PO!8lQ`O'#IrO#LvQ`O,5<zOOQ!0Lh,5<w,5<wO!,TQMhO'#IuO#MdQMjO,5=XO!,TQMhO'#IwO#NVQMjO,5=ZO!&zQMhO,5=]OOQO1G2S1G2SO#NaQ!dO'#CrO#NtQ(CWO'#ErO$ |QpO'#GbO$!dQ!dO,5<sO$!kQ`O'#K[O9eQ`O'#K[O$!yQ`O,5<uO$#aQ!dO'#C{O!,TQMhO,5<tO$#kQ`O'#GZO$$PQ`O,5<tO$$UQ!dO'#GWO$$cQ!dO'#K]O$$mQ`O'#K]O!&zQMhO'#K]O$$rQ`O,5<xO$$wQlO'#JvO$%RQpO'#GcO#$`QpO'#GcO$%dQ`O'#GgO!3oQ`O'#GkO$%iQ!0LrO'#ItO$%tQpO,5<|OOQ!0Lp,5<|,5<|O$%{QpO'#GcO$&YQpO'#GdO$&kQpO'#GdO$&pQMjO,5=XO$'QQMjO,5=ZOOQ!0Lh,5=^,5=^O!,TQMhO,5@VO!,TQMhO,5@VO$'bQ`O'#IyO$'vQ`O,5@UO$(OQ`O,59aOOQ!0Lh,59i,59iO$(TQ`O,5@VO$)TQ$IYO,59uOOQ!0Lh'#Jp'#JpO$)vQMjO,5<kO$*iQMjO,5<mO@zQ`O,5<oOOQ!0Lh,5<p,5<pO$*sQ`O,5<vO$*xQMjO,5<{O$+YQ`O'#KPO!$wQlO1G2RO$+_Q`O1G2RO9eQ`O'#KSO9eQ`O'#EtO%[QlO'#EtO9eQ`O'#I{O$+dQ!0LrO,5@{OOQ[1G2}1G2}OOQ[1G4`1G4`OOQ!0Lf1G/|1G/|OOQ!0Lf1G/z1G/zO$-fQ!0MxO1G0UOOQ[1G2y1G2yO!&zQMhO1G2yO%[QlO1G2yO#.tQ`O1G2yO$/jQMhO'#EkOOQ!0Lb,5@T,5@TO$/wQ!0LrO,5@TOOQ[1G.u1G.uO!ByQ!0LrO1G.uO!CUQpO1G.uO!C^QMhO1G.uO$0YQ`O1G0uO$0_Q`O'#CiO$0jQ`O'#KeO$0rQ`O,5=|O$0wQ`O'#KeO$0|Q`O'#KeO$1[Q`O'#JRO$1jQ`O,5AOO$1rQ!fO1G1iOOQ!0Lf1G1k1G1kO9kQ`O1G3fO@zQ`O1G3fO$1yQ`O1G3fO$2OQ`O1G3fO!DiQ`O1G3fO9uQ!0LrO1G3fOOQ[1G3f1G3fO!EcQ`O1G3UO!&zQMhO1G3RO$2TQ`O1G3ROOQ[1G3S1G3SO!&zQMhO1G3SO$2YQ`O1G3SO$2bQpO'#HQOOQ[1G3U1G3UO!6_QpO'#I}O!EhQ!bO1G3XOOQ[1G3X1G3XOOQ[,5=r,5=rO$2jQMhO,5=tO9kQ`O,5=tO$%dQ`O,5=vO9`Q`O,5=vO!CUQpO,5=vO!C^QMhO,5=vO:dQMhO,5=vO$2xQ`O'#KcO$3TQ`O,5=wOOQ[1G.k1G.kO$3YQ!0LrO1G.kO@zQ`O1G.kO$3eQ`O1G.kO9uQ!0LrO1G.kO$5mQ!fO,5AQO$5zQ`O,5AQO9eQ`O,5AQO$6VQlO,5>PO$6^Q`O,5>POOQ[1G3i1G3iO`QlO1G3iOOQ[1G3o1G3oOOQ[1G3q1G3qO?TQ`O1G3sO$6cQlO1G3uO$:gQlO'#HtOOQ[1G3x1G3xO$:tQ`O'#HzO?YQ`O'#H|OOQ[1G4O1G4OO$:|QlO1G4OO9uQ!0LrO1G4UOOQ[1G4W1G4WOOQ!0Lb'#G_'#G_O9uQ!0LrO1G4YO9uQ!0LrO1G4[O$?TQ`O,5@bO!)[QlO,5;`O9eQ`O,5;`O?YQ`O,5:XO!)[QlO,5:XO!CUQpO,5:XO$?YQ?MtO,5:XOOQO,5;`,5;`O$?dQpO'#IeO$?zQ`O,5@aOOQ!0Lf1G/r1G/rO$@SQpO'#IkO$@^Q`O,5@pOOQ!0Lb1G0y1G0yO#$`QpO,5:XOOQO'#Ig'#IgO$@fQpO,5:qOOQ!0Ln,5:q,5:qO#(ZQ`O1G0ZOOQ!0Lf1G0Z1G0ZO%[QlO1G0ZOOQ!0Lf1G0t1G0tO?YQ`O1G0tO!CUQpO1G0tO!C^QMhO1G0tOOQ!0Lb1G5|1G5|O!ByQ!0LrO1G0^OOQO1G0m1G0mO%[QlO1G0mO$@mQ!0LrO1G0mO$@xQ!0LrO1G0mO!CUQpO1G0^ODWQpO1G0^O$AWQ!0LrO1G0mOOQO1G0^1G0^O$AlQ!0MxO1G0mPOOO-E<[-E<[POOO1G.h1G.hOOOO1G/i1G/iO$AvQ!bO,5<iO$BOQ!fO1G4jOOQO1G4p1G4pO%[QlO,5?OO$BYQ`O1G5zO$BbQ`O1G6YO$BjQ!fO1G6ZO9eQ`O,5?UO$BtQ!0MxO1G6WO%[QlO1G6WO$CUQ!0LrO1G6WO$CgQ`O1G6VO$CgQ`O1G6VO9eQ`O1G6VO$CoQ`O,5?XO9eQ`O,5?XOOQO,5?X,5?XO$DTQ`O,5?XO$+YQ`O,5?XOOQO-E<k-E<kOOQS1G0a1G0aOOQS1G0c1G0cO#.lQ`O1G0cOOQ[7+(e7+(eO!&zQMhO7+(eO%[QlO7+(eO$DcQ`O7+(eO$DnQMhO7+(eO$D|Q!0MzO,5=XO$GXQ!0MzO,5=ZO$IdQ!0MzO,5=XO$KuQ!0MzO,5=ZO$NWQ!0MzO,59uO%!]Q!0MzO,5<kO%$hQ!0MzO,5<mO%&sQ!0MzO,5<{OOQ!0Lf7+&a7+&aO%)UQ!0MxO7+&aO%)xQlO'#IfO%*VQ`O,5@cO%*_Q!fO,5@cOOQ!0Lf1G0P1G0PO%*iQ`O7+&jOOQ!0Lf7+&j7+&jO%*nQ?MtO,5:fO%[QlO7+&zO%*xQ?MtO,5:bO%+VQ?MtO,5:jO%+aQ?MtO,5:lO%+kQMhO'#IiO%+uQ`O,5@hOOQ!0Lh1G0d1G0dOOQO1G1r1G1rOOQO1G1s1G1sO%+}Q!jO,5<ZO!)[QlO,5<YOOQO-E<l-E<lOOQ!0Lf7+'Y7+'YOOOW7+'e7+'eOOOW1G1|1G1|O%,YQ`O1G1|OOQ!0Lf1G2O1G2OOOOO,59o,59oO%,_Q!dO,59oOOOO-E<`-E<`OOQ!0Lh1G/X1G/XO%,fQ!0MxO7+'kOOQ!0Lh,5?^,5?^O%-YQMhO1G2fP%-aQ`O'#IrPOQ!0Lh-E<p-E<pO%-}QMjO,5?aOOQ!0Lh-E<s-E<sO%.pQMjO,5?cOOQ!0Lh-E<u-E<uO%.zQ!dO1G2wO%/RQ!dO'#CrO%/iQMhO'#KSO$$wQlO'#JvOOQ!0Lh1G2_1G2_O%/sQ`O'#IqO%0[Q`O,5@vO%0[Q`O,5@vO%0dQ`O,5@vO%0oQ`O,5@vOOQO1G2a1G2aO%0}QMjO1G2`O$+YQ`O'#K[O!,TQMhO1G2`O%1_Q(CWO'#IsO%1lQ`O,5@wO!&zQMhO,5@wO%1tQ!dO,5@wOOQ!0Lh1G2d1G2dO%4UQ!fO'#CiO%4`Q`O,5=POOQ!0Lb,5<},5<}O%4hQpO,5<}OOQ!0Lb,5=O,5=OOCwQ`O,5<}O%4sQpO,5<}OOQ!0Lb,5=R,5=RO$+YQ`O,5=VOOQO,5?`,5?`OOQO-E<r-E<rOOQ!0Lp1G2h1G2hO#$`QpO,5<}O$$wQlO,5=PO%5RQ`O,5=OO%5^QpO,5=OO!,TQMhO'#IuO%6WQMjO1G2sO!,TQMhO'#IwO%6yQMjO1G2uO%7TQMjO1G5qO%7_QMjO1G5qOOQO,5?e,5?eOOQO-E<w-E<wOOQO1G.{1G.{O!,TQMhO1G5qO!,TQMhO1G5qO!:]QpO,59wO%[QlO,59wOOQ!0Lh,5<j,5<jO%7lQ`O1G2ZO!,TQMhO1G2bO%7qQ!0MxO7+'mOOQ!0Lf7+'m7+'mO!$wQlO7+'mO%8eQ`O,5;`OOQ!0Lb,5?g,5?gOOQ!0Lb-E<y-E<yO%8jQ!dO'#K^O#(ZQ`O7+(eO4UQ!fO7+(eO$DfQ`O7+(eO%8tQ!0MvO'#CiO%9XQ!0MvO,5=SO%9lQ`O,5=SO%9tQ`O,5=SOOQ!0Lb1G5o1G5oOOQ[7+$a7+$aO!ByQ!0LrO7+$aO!CUQpO7+$aO!$wQlO7+&aO%9yQ`O'#JQO%:bQ`O,5APOOQO1G3h1G3hO9kQ`O,5APO%:bQ`O,5APO%:jQ`O,5APOOQO,5?m,5?mOOQO-E=P-E=POOQ!0Lf7+'T7+'TO%:oQ`O7+)QO9uQ!0LrO7+)QO9kQ`O7+)QO@zQ`O7+)QO%:tQ`O7+)QOOQ[7+)Q7+)QOOQ[7+(p7+(pO%:yQ!0MvO7+(mO!&zQMhO7+(mO!E^Q`O7+(nOOQ[7+(n7+(nO!&zQMhO7+(nO%;TQ`O'#KbO%;`Q`O,5=lOOQO,5?i,5?iOOQO-E<{-E<{OOQ[7+(s7+(sO%<rQpO'#HZOOQ[1G3`1G3`O!&zQMhO1G3`O%[QlO1G3`O%<yQ`O1G3`O%=UQMhO1G3`O9uQ!0LrO1G3bO$%dQ`O1G3bO9`Q`O1G3bO!CUQpO1G3bO!C^QMhO1G3bO%=dQ`O'#JPO%=xQ`O,5@}O%>QQpO,5@}OOQ!0Lb1G3c1G3cOOQ[7+$V7+$VO@zQ`O7+$VO9uQ!0LrO7+$VO%>]Q`O7+$VO%[QlO1G6lO%[QlO1G6mO%>bQ!0LrO1G6lO%>lQlO1G3kO%>sQ`O1G3kO%>xQlO1G3kOOQ[7+)T7+)TO9uQ!0LrO7+)_O`QlO7+)aOOQ['#Kh'#KhOOQ['#JS'#JSO%?PQlO,5>`OOQ[,5>`,5>`O%[QlO'#HuO%?^Q`O'#HwOOQ[,5>f,5>fO9eQ`O,5>fOOQ[,5>h,5>hOOQ[7+)j7+)jOOQ[7+)p7+)pOOQ[7+)t7+)tOOQ[7+)v7+)vO%?cQpO1G5|O%?}Q?MtO1G0zO%@XQ`O1G0zOOQO1G/s1G/sO%@dQ?MtO1G/sO?YQ`O1G/sO!)[QlO'#DmOOQO,5?P,5?POOQO-E<c-E<cOOQO,5?V,5?VOOQO-E<i-E<iO!CUQpO1G/sOOQO-E<e-E<eOOQ!0Ln1G0]1G0]OOQ!0Lf7+%u7+%uO#(ZQ`O7+%uOOQ!0Lf7+&`7+&`O?YQ`O7+&`O!CUQpO7+&`OOQO7+%x7+%xO$AlQ!0MxO7+&XOOQO7+&X7+&XO%[QlO7+&XO%@nQ!0LrO7+&XO!ByQ!0LrO7+%xO!CUQpO7+%xO%@yQ!0LrO7+&XO%AXQ!0MxO7++rO%[QlO7++rO%AiQ`O7++qO%AiQ`O7++qOOQO1G4s1G4sO9eQ`O1G4sO%AqQ`O1G4sOOQS7+%}7+%}O#(ZQ`O<<LPO4UQ!fO<<LPO%BPQ`O<<LPOOQ[<<LP<<LPO!&zQMhO<<LPO%[QlO<<LPO%BXQ`O<<LPO%BdQ!0MzO,5?aO%DoQ!0MzO,5?cO%FzQ!0MzO1G2`O%I]Q!0MzO1G2sO%KhQ!0MzO1G2uO%MsQ!fO,5?QO%[QlO,5?QOOQO-E<d-E<dO%M}Q`O1G5}OOQ!0Lf<<JU<<JUO%NVQ?MtO1G0uO&!^Q?MtO1G1PO&!eQ?MtO1G1PO&$fQ?MtO1G1PO&$mQ?MtO1G1PO&&nQ?MtO1G1PO&(oQ?MtO1G1PO&(vQ?MtO1G1PO&(}Q?MtO1G1PO&+OQ?MtO1G1PO&+VQ?MtO1G1PO&+^Q!0MxO<<JfO&-UQ?MtO1G1PO&.RQ?MvO1G1PO&/UQ?MvO'#JlO&1[Q?MtO1G1cO&1iQ?MtO1G0UO&1sQMjO,5?TOOQO-E<g-E<gO!)[QlO'#FqOOQO'#KZ'#KZOOQO1G1u1G1uO&1}Q`O1G1tO&2SQ?MtO,5?[OOOW7+'h7+'hOOOO1G/Z1G/ZO&2^Q!dO1G4xOOQ!0Lh7+(Q7+(QP!&zQMhO,5?^O!,TQMhO7+(cO&2eQ`O,5?]O9eQ`O,5?]O$+YQ`O,5?]OOQO-E<o-E<oO&2sQ`O1G6bO&2sQ`O1G6bO&2{Q`O1G6bO&3WQMjO7+'zO&3hQ!dO,5?_O&3rQ`O,5?_O!&zQMhO,5?_OOQO-E<q-E<qO&3wQ!dO1G6cO&4RQ`O1G6cO&4ZQ`O1G2kO!&zQMhO1G2kOOQ!0Lb1G2i1G2iOOQ!0Lb1G2j1G2jO%4hQpO1G2iO!CUQpO1G2iOCwQ`O1G2iOOQ!0Lb1G2q1G2qO&4`QpO1G2iO&4nQ`O1G2kO$+YQ`O1G2jOCwQ`O1G2jO$$wQlO1G2kO&4vQ`O1G2jO&5jQMjO,5?aOOQ!0Lh-E<t-E<tO&6]QMjO,5?cOOQ!0Lh-E<v-E<vO!,TQMhO7++]O&6gQMjO7++]O&6qQMjO7++]OOQ!0Lh1G/c1G/cO&7OQ`O1G/cOOQ!0Lh7+'u7+'uO&7TQMjO7+'|O&7eQ!0MxO<<KXOOQ!0Lf<<KX<<KXO&8XQ`O1G0zO!&zQMhO'#IzO&8^Q`O,5@xO&:`Q!fO<<LPO!&zQMhO1G2nO&:gQ!0LrO1G2nOOQ[<<G{<<G{O!ByQ!0LrO<<G{O&:xQ!0MxO<<I{OOQ!0Lf<<I{<<I{OOQO,5?l,5?lO&;lQ`O,5?lO&;qQ`O,5?lOOQO-E=O-E=OO&<PQ`O1G6kO&<PQ`O1G6kO9kQ`O1G6kO@zQ`O<<LlOOQ[<<Ll<<LlO&<XQ`O<<LlO9uQ!0LrO<<LlO9kQ`O<<LlOOQ[<<LX<<LXO%:yQ!0MvO<<LXOOQ[<<LY<<LYO!E^Q`O<<LYO&<^QpO'#I|O&<iQ`O,5@|O!)[QlO,5@|OOQ[1G3W1G3WOOQO'#JO'#JOO9uQ!0LrO'#JOO&<qQpO,5=uOOQ[,5=u,5=uO&<xQpO'#EgO&=PQpO'#GeO&=UQ`O7+(zO&=ZQ`O7+(zOOQ[7+(z7+(zO!&zQMhO7+(zO%[QlO7+(zO&=cQ`O7+(zOOQ[7+(|7+(|O9uQ!0LrO7+(|O$%dQ`O7+(|O9`Q`O7+(|O!CUQpO7+(|O&=nQ`O,5?kOOQO-E<}-E<}OOQO'#H^'#H^O&=yQ`O1G6iO9uQ!0LrO<<GqOOQ[<<Gq<<GqO@zQ`O<<GqO&>RQ`O7+,WO&>WQ`O7+,XO%[QlO7+,WO%[QlO7+,XOOQ[7+)V7+)VO&>]Q`O7+)VO&>bQlO7+)VO&>iQ`O7+)VOOQ[<<Ly<<LyOOQ[<<L{<<L{OOQ[-E=Q-E=QOOQ[1G3z1G3zO&>nQ`O,5>aOOQ[,5>c,5>cO&>sQ`O1G4QO9eQ`O7+&fO!)[QlO7+&fOOQO7+%_7+%_O&>xQ?MtO1G6ZO?YQ`O7+%_OOQ!0Lf<<Ia<<IaOOQ!0Lf<<Iz<<IzO?YQ`O<<IzOOQO<<Is<<IsO$AlQ!0MxO<<IsO%[QlO<<IsOOQO<<Id<<IdO!ByQ!0LrO<<IdO&?SQ!0LrO<<IsO&?_Q!0MxO<= ^O&?oQ`O<= ]OOQO7+*_7+*_O9eQ`O7+*_OOQ[ANAkANAkO&?wQ!fOANAkO!&zQMhOANAkO#(ZQ`OANAkO4UQ!fOANAkO&@OQ`OANAkO%[QlOANAkO&@WQ!0MzO7+'zO&BiQ!0MzO,5?aO&DtQ!0MzO,5?cO&GPQ!0MzO7+'|O&IbQ!fO1G4lO&IlQ?MtO7+&aO&KpQ?MvO,5=XO&MwQ?MvO,5=ZO&NXQ?MvO,5=XO&NiQ?MvO,5=ZO&NyQ?MvO,59uO'#PQ?MvO,5<kO'%SQ?MvO,5<mO''hQ?MvO,5<{O')^Q?MtO7+'kO')kQ?MtO7+'mO')xQ`O,5<]OOQO7+'`7+'`OOQ!0Lh7+*d7+*dO')}QMjO<<K}OOQO1G4w1G4wO'*UQ`O1G4wO'*aQ`O1G4wO'*oQ`O7++|O'*oQ`O7++|O!&zQMhO1G4yO'*wQ!dO1G4yO'+RQ`O7++}O'+ZQ`O7+(VO'+fQ!dO7+(VOOQ!0Lb7+(T7+(TOOQ!0Lb7+(U7+(UO!CUQpO7+(TOCwQ`O7+(TO'+pQ`O7+(VO!&zQMhO7+(VO$+YQ`O7+(UO'+uQ`O7+(VOCwQ`O7+(UO'+}QMjO<<NwO!,TQMhO<<NwOOQ!0Lh7+$}7+$}O',XQ!dO,5?fOOQO-E<x-E<xO',cQ!0MvO7+(YO!&zQMhO7+(YOOQ[AN=gAN=gO9kQ`O1G5WOOQO1G5W1G5WO',sQ`O1G5WO',xQ`O7+,VO',xQ`O7+,VO9uQ!0LrOANBWO@zQ`OANBWOOQ[ANBWANBWO'-QQ`OANBWOOQ[ANAsANAsOOQ[ANAtANAtO'-VQ`O,5?hOOQO-E<z-E<zO'-bQ?MtO1G6hOOQO,5?j,5?jOOQO-E<|-E<|OOQ[1G3a1G3aO'-lQ`O,5=POOQ[<<Lf<<LfO!&zQMhO<<LfO&=UQ`O<<LfO'-qQ`O<<LfO%[QlO<<LfOOQ[<<Lh<<LhO9uQ!0LrO<<LhO$%dQ`O<<LhO9`Q`O<<LhO'-yQpO1G5VO'.UQ`O7+,TOOQ[AN=]AN=]O9uQ!0LrOAN=]OOQ[<= r<= rOOQ[<= s<= sO'.^Q`O<= rO'.cQ`O<= sOOQ[<<Lq<<LqO'.hQ`O<<LqO'.mQlO<<LqOOQ[1G3{1G3{O?YQ`O7+)lO'.tQ`O<<JQO'/PQ?MtO<<JQOOQO<<Hy<<HyOOQ!0LfAN?fAN?fOOQOAN?_AN?_O$AlQ!0MxOAN?_OOQOAN?OAN?OO%[QlOAN?_OOQO<<My<<MyOOQ[G27VG27VO!&zQMhOG27VO#(ZQ`OG27VO'/ZQ!fOG27VO4UQ!fOG27VO'/bQ`OG27VO'/jQ?MtO<<JfO'/wQ?MvO1G2`O'1mQ?MvO,5?aO'3pQ?MvO,5?cO'5sQ?MvO1G2sO'7vQ?MvO1G2uO'9yQ?MtO<<KXO':WQ?MtO<<I{OOQO1G1w1G1wO!,TQMhOANAiOOQO7+*c7+*cO':eQ`O7+*cO':pQ`O<= hO':xQ!dO7+*eOOQ!0Lb<<Kq<<KqO$+YQ`O<<KqOCwQ`O<<KqO';SQ`O<<KqO!&zQMhO<<KqOOQ!0Lb<<Ko<<KoO!CUQpO<<KoO';_Q!dO<<KqOOQ!0Lb<<Kp<<KpO';iQ`O<<KqO!&zQMhO<<KqO$+YQ`O<<KpO';nQMjOANDcO';xQ!0MvO<<KtOOQO7+*r7+*rO9kQ`O7+*rO'<YQ`O<= qOOQ[G27rG27rO9uQ!0LrOG27rO@zQ`OG27rO!)[QlO1G5SO'<bQ`O7+,SO'<jQ`O1G2kO&=UQ`OANBQOOQ[ANBQANBQO!&zQMhOANBQO'<oQ`OANBQOOQ[ANBSANBSO9uQ!0LrOANBSO$%dQ`OANBSOOQO'#H_'#H_OOQO7+*q7+*qOOQ[G22wG22wOOQ[ANE^ANE^OOQ[ANE_ANE_OOQ[ANB]ANB]O'<wQ`OANB]OOQ[<<MW<<MWO!)[QlOAN?lOOQOG24yG24yO$AlQ!0MxOG24yO#(ZQ`OLD,qOOQ[LD,qLD,qO!&zQMhOLD,qO'<|Q!fOLD,qO'=TQ?MvO7+'zO'>yQ?MvO,5?aO'@|Q?MvO,5?cO'CPQ?MvO7+'|O'DuQMjOG27TOOQO<<M}<<M}OOQ!0LbANA]ANA]O$+YQ`OANA]OCwQ`OANA]O'EVQ!dOANA]OOQ!0LbANAZANAZO'E^Q`OANA]O!&zQMhOANA]O'EiQ!dOANA]OOQ!0LbANA[ANA[OOQO<<N^<<N^OOQ[LD-^LD-^O9uQ!0LrOLD-^O'EsQ?MtO7+*nOOQO'#Gf'#GfOOQ[G27lG27lO&=UQ`OG27lO!&zQMhOG27lOOQ[G27nG27nO9uQ!0LrOG27nOOQ[G27wG27wO'E}Q?MtOG25WOOQOLD*eLD*eOOQ[!$(!]!$(!]O#(ZQ`O!$(!]O!&zQMhO!$(!]O'FXQ!0MzOG27TOOQ!0LbG26wG26wO$+YQ`OG26wO'HjQ`OG26wOCwQ`OG26wO'HuQ!dOG26wO!&zQMhOG26wOOQ[!$(!x!$(!xOOQ[LD-WLD-WO&=UQ`OLD-WOOQ[LD-YLD-YOOQ[!)9Ew!)9EwO#(ZQ`O!)9EwOOQ!0LbLD,cLD,cO$+YQ`OLD,cOCwQ`OLD,cO'H|Q`OLD,cO'IXQ!dOLD,cOOQ[!$(!r!$(!rOOQ[!.K;c!.K;cO'I`Q?MvOG27TOOQ!0Lb!$( }!$( }O$+YQ`O!$( }OCwQ`O!$( }O'KUQ`O!$( }OOQ!0Lb!)9Ei!)9EiO$+YQ`O!)9EiOCwQ`O!)9EiOOQ!0Lb!.K;T!.K;TO$+YQ`O!.K;TOOQ!0Lb!4/0o!4/0oO!)[QlO'#DzO1PQ`O'#EXO'KaQ!fO'#JrO'KhQ!L^O'#DvO'KoQlO'#EOO'KvQ!fO'#CiO'N^Q!fO'#CiO!)[QlO'#EQO'NnQlO,5;ZO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO,5;eO!)[QlO'#IpO(!qQ`O,5<iO!)[QlO,5;eO(!yQMhO,5;eO($dQMhO,5;eO!)[QlO,5;wO!&zQMhO'#GmO(!yQMhO'#GmO!&zQMhO'#GoO(!yQMhO'#GoO1SQ`O'#DZO1SQ`O'#DZO!&zQMhO'#GPO(!yQMhO'#GPO!&zQMhO'#GRO(!yQMhO'#GRO!&zQMhO'#GaO(!yQMhO'#GaO!)[QlO,5:jO($kQpO'#D_O($uQpO'#JvO!)[QlO,5@oO'NnQlO1G0uO(%PQ?MtO'#CiO!)[QlO1G2PO!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO(%ZQ!dO'#CrO!&zQMhO,5<tO(!yQMhO,5<tO'NnQlO1G2RO!)[QlO7+&zO!&zQMhO1G2`O(!yQMhO1G2`O!&zQMhO'#IuO(!yQMhO'#IuO!&zQMhO'#IwO(!yQMhO'#IwO!&zQMhO1G2bO(!yQMhO1G2bO'NnQlO7+'mO'NnQlO7+&aO!&zQMhOANAiO(!yQMhOANAiO(%nQ`O'#EoO(%sQ`O'#EoO(%{Q`O'#F]O(&QQ`O'#EyO(&VQ`O'#KTO(&bQ`O'#KRO(&mQ`O,5;ZO(&rQMjO,5<eO(&yQ`O'#GYO('OQ`O'#GYO('TQ`O,5<eO(']Q`O,5<gO('eQ`O,5;ZO('mQ?MtO1G1`O('tQ`O,5<tO('yQ`O,5<tO((OQ`O,5<vO((TQ`O,5<vO((YQ`O1G2RO((_Q`O1G0uO((dQMjO<<K}O((kQMjO<<K}O((rQMhO'#F|O9`Q`O'#F{OAuQ`O'#EnO!)[QlO,5;tO!3oQ`O'#GYO!3oQ`O'#GYO!3oQ`O'#G[O!3oQ`O'#G[O!,TQMhO7+(cO!,TQMhO7+(cO%.zQ!dO1G2wO%.zQ!dO1G2wO!&zQMhO,5=]O!&zQMhO,5=]",
  stateData: "()x~O'|OS'}OSTOS(ORQ~OPYOQYOSfOY!VOaqOdzOeyOl!POpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O$W|O$niO%h}O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO&W!WO&^!XO&`!YO&b!ZO&d![O&g!]O&m!^O&s!_O&u!`O&w!aO&y!bO&{!cO(TSO(VTO(YUO(aVO(o[O~OWtO~P`OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa!wOs!nO!S!oO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!xO#W!pO#X!pO#[!zO#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O(O!{O~OP]XR]X[]Xa]Xj]Xr]X!Q]X!S]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X'z]X(a]X(r]X(y]X(z]X~O!g%RX~P(qO_!}O(V#PO(W!}O(X#PO~O_#QO(X#PO(Y#PO(Z#QO~Ox#SO!U#TO(b#TO(c#VO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T<ZO(VTO(YUO(aVO(o[O~O![#ZO!]#WO!Y(hP!Y(vP~P+}O!^#cO~P`OPYOQYOSfOd!jOe!iOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(VTO(YUO(aVO(o[O~Op#mO![#iO!|]O#i#lO#j#iO(T<[O!k(sP~P.iO!l#oO(T#nO~O!x#sO!|]O%h#tO~O#k#uO~O!g#vO#k#uO~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!]$_O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa(fX'z(fX'w(fX!k(fX!Y(fX!_(fX%i(fX!g(fX~P1qO#S$dO#`$eO$Q$eOP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX!_(gX%i(gX~Oa(gX'z(gX'w(gX!Y(gX!k(gXv(gX!g(gX~P4UO#`$eO~O$]$hO$_$gO$f$mO~OSfO!_$nO$i$oO$k$qO~Oh%VOj%dOk%dOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T$sO(VTO(YUO(a$uO(y$}O(z%POg(^P~Ol%[O~P7eO!l%eO~O!S%hO!_%iO(T%gO~O!g%mO~Oa%nO'z%nO~O!Q%rO~P%[O(U!lO~P%[O%n%vO~P%[Oh%VO!l%eO(T%gO(U!lO~Oe%}O!l%eO(T%gO~Oj$RO~O!_&PO(T%gO(U!lO(VTO(YUO`)WP~O!Q&SO!l&RO%j&VO&T&WO~P;SO!x#sO~O%s&YO!S)SX!_)SX(T)SX~O(T&ZO~Ol!PO!u&`O%j!QO%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO~Od&eOe&dO!x&bO%h&cO%{&aO~P<bOd&hOeyOl!PO!_&gO!u&`O!xxO!|]O%h}O%l!OO%m!OO%n!OO%q!RO%s!SO%v!TO%w!TO%y!UO~Ob&kO#`&nO%j&iO(U!lO~P=gO!l&oO!u&sO~O!l#oO~O!_XO~Oa%nO'x&{O'z%nO~Oa%nO'x'OO'z%nO~Oa%nO'x'QO'z%nO~O'w]X!Y]Xv]X!k]X&[]X!_]X%i]X!g]X~P(qO!b'_O!c'WO!d'WO(U!lO(VTO(YUO~Os'UO!S'TO!['XO(e'SO!^(iP!^(xP~P@nOn'bO!_'`O(T%gO~Oe'gO!l%eO(T%gO~O!Q&SO!l&RO~Os!nO!S!oO!|<VO#T!pO#U!pO#W!pO#X!pO(U!lO(VTO(YUO(e!mO(o!sO~O!b'mO!c'lO!d'lO#V!pO#['nO#]'nO~PBYOa%nOh%VO!g#vO!l%eO'z%nO(r'pO~O!p'tO#`'rO~PChOs!nO!S!oO(VTO(YUO(e!mO(o!sO~O!_XOs(mX!S(mX!b(mX!c(mX!d(mX!|(mX#T(mX#U(mX#V(mX#W(mX#X(mX#[(mX#](mX(U(mX(V(mX(Y(mX(e(mX(o(mX~O!c'lO!d'lO(U!lO~PDWO(P'xO(Q'xO(R'zO~O_!}O(V'|O(W!}O(X'|O~O_#QO(X'|O(Y'|O(Z#QO~Ov(OO~P%[Ox#SO!U#TO(b#TO(c(RO~O![(TO!Y'WX!Y'^X!]'WX!]'^X~P+}O!](VO!Y(hX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!](VO!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~O!Y(hX~PHRO!Y([O~O!Y(uX!](uX!g(uX!k(uX(r(uX~O#`(uX#k#dX!^(uX~PJUO#`(]O!Y(wX!](wX~O!](^O!Y(vX~O!Y(aO~O#`$eO~PJUO!^(bO~P`OR#zO!Q#yO!S#{O!l#xO(aVOP!na[!naj!nar!na!]!na!p!na#R!na#n!na#o!na#p!na#q!na#r!na#s!na#t!na#u!na#v!na#x!na#z!na#{!na(r!na(y!na(z!na~Oa!na'z!na'w!na!Y!na!k!nav!na!_!na%i!na!g!na~PKlO!k(cO~O!g#vO#`(dO(r'pO!](tXa(tX'z(tX~O!k(tX~PNXO!S%hO!_%iO!|]O#i(iO#j(hO(T%gO~O!](jO!k(sX~O!k(lO~O!S%hO!_%iO#j(hO(T%gO~OP(gXR(gX[(gXj(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~O!g#vO!k(gX~P! uOR(nO!Q(mO!l#xO#S$dO!|!{a!S!{a~O!x!{a%h!{a!_!{a#i!{a#j!{a(T!{a~P!#vO!x(rO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_XO!iuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~O#k(xO~O![(zO!k(kP~P%[O(e(|O(o[O~O!S)OO!l#xO(e(|O(o[O~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]$_Oa$qa'z$qa'w$qa!k$qa!Y$qa!_$qa%i$qa!g$qa~Ol)dO~P!&zOh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O%]O!S${O!_$|O!i%bO!l$xO#j%cO$W%`O$t%^O$v%_O$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Og(pP~P!,TO!Q)iO!g)hO!_$^X$Z$^X$]$^X$_$^X$f$^X~O!g)hO!_({X$Z({X$]({X$_({X$f({X~O!Q)iO~P!.^O!Q)iO!_({X$Z({X$]({X$_({X$f({X~O!_)kO$Z)oO$])jO$_)jO$f)pO~O![)sO~P!)[O$]$hO$_$gO$f)wO~On$zX!Q$zX#S$zX'y$zX(y$zX(z$zX~OgmXg$zXnmX!]mX#`mX~P!0SOx)yO(b)zO(c)|O~On*VO!Q*OO'y*PO(y$}O(z%PO~Og)}O~P!1WOg*WO~Oh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S*YO!_*ZO!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op*`O![*^O(T*XO!k)OP~P!1uO#k*aO~O!l*bO~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(T*dO(VTO(YUO(a$uO(y$}O(z%PO~O![*gO!Y)PP~P!3tOr*sOs!nO!S*iO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO(e!mO~O!^*pO~P!5iO#S$dOn(`X!Q(`X'y(`X(y(`X(z(`X!](`X#`(`X~Og(`X$O(`X~P!6kOn*xO#`*wOg(_X!](_X~O!]*yOg(^X~Oj%dOk%dOl%dO(T&ZOg(^P~Os*|O~Og)}O(T&ZO~O!l+SO~O(T(vO~Op+WO!S%hO![#iO!_%iO!|]O#i#lO#j#iO(T%gO!k(sP~O!g#vO#k+XO~O!S%hO![+ZO!](^O!_%iO(T%gO!Y(vP~Os'[O!S+]O![+[O(VTO(YUO(e(|O~O!^(xP~P!9|O!]+^Oa)TX'z)TX~OP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO#z$WO#{$XO(aVO(r$YO(y#|O(z#}O~Oa!ja!]!ja'z!ja'w!ja!Y!ja!k!jav!ja!_!ja%i!ja!g!ja~P!:tOR#zO!Q#yO!S#{O!l#xO(aVOP!ra[!raj!rar!ra!]!ra!p!ra#R!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#t!ra#u!ra#v!ra#x!ra#z!ra#{!ra(r!ra(y!ra(z!ra~Oa!ra'z!ra'w!ra!Y!ra!k!rav!ra!_!ra%i!ra!g!ra~P!=[OR#zO!Q#yO!S#{O!l#xO(aVOP!ta[!taj!tar!ta!]!ta!p!ta#R!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#t!ta#u!ta#v!ta#x!ta#z!ta#{!ta(r!ta(y!ta(z!ta~Oa!ta'z!ta'w!ta!Y!ta!k!tav!ta!_!ta%i!ta!g!ta~P!?rOh%VOn+gO!_'`O%i+fO~O!g+iOa(]X!_(]X'z(]X!](]X~Oa%nO!_XO'z%nO~Oh%VO!l%eO~Oh%VO!l%eO(T%gO~O!g#vO#k(xO~Ob+tO%j+uO(T+qO(VTO(YUO!^)XP~O!]+vO`)WX~O[+zO~O`+{O~O!_&PO(T%gO(U!lO`)WP~O%j,OO~P;SOh%VO#`,SO~Oh%VOn,VO!_$|O~O!_,XO~O!Q,ZO!_XO~O%n%vO~O!x,`O~Oe,eO~Ob,fO(T#nO(VTO(YUO!^)VP~Oe%}O~O%j!QO(T&ZO~P=gO[,kO`,jO~OPYOQYOSfOdzOeyOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!iuO!lZO!oYO!pYO!qYO!svO!xxO!|]O$niO%h}O(VTO(YUO(aVO(o[O~O!_!eO!u!gO$W!kO(T!dO~P!FyO`,jOa%nO'z%nO~OPYOQYOSfOd!jOe!iOpkOrYOskOtkOzkO|YO!OYO!SWO!WkO!XkO!_!eO!iuO!lZO!oYO!pYO!qYO!svO!x!hO$W!kO$niO(T!dO(VTO(YUO(aVO(o[O~Oa,pOl!OO!uwO%l!OO%m!OO%n!OO~P!IcO!l&oO~O&^,vO~O!_,xO~O&o,zO&q,{OP&laQ&laS&laY&laa&lad&lae&lal&lap&lar&las&lat&laz&la|&la!O&la!S&la!W&la!X&la!_&la!i&la!l&la!o&la!p&la!q&la!s&la!u&la!x&la!|&la$W&la$n&la%h&la%j&la%l&la%m&la%n&la%q&la%s&la%v&la%w&la%y&la&W&la&^&la&`&la&b&la&d&la&g&la&m&la&s&la&u&la&w&la&y&la&{&la'w&la(T&la(V&la(Y&la(a&la(o&la!^&la&e&lab&la&j&la~O(T-QO~Oh!eX!]!RX!^!RX!g!RX!g!eX!l!eX#`!RX~O!]!eX!^!eX~P#!iO!g-VO#`-UOh(jX!]#hX!^#hX!g(jX!l(jX~O!](jX!^(jX~P##[Oh%VO!g-XO!l%eO!]!aX!^!aX~Os!nO!S!oO(VTO(YUO(e!mO~OP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_!eO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(VTO(YUO(aVO(o[O~O(T=QO~P#$qO!]-]O!^(iX~O!^-_O~O!g-VO#`-UO!]#hX!^#hX~O!]-`O!^(xX~O!^-bO~O!c-cO!d-cO(U!lO~P#$`O!^-fO~P'_On-iO!_'`O~O!Y-nO~Os!{a!b!{a!c!{a!d!{a#T!{a#U!{a#V!{a#W!{a#X!{a#[!{a#]!{a(U!{a(V!{a(Y!{a(e!{a(o!{a~P!#vO!p-sO#`-qO~PChO!c-uO!d-uO(U!lO~PDWOa%nO#`-qO'z%nO~Oa%nO!g#vO#`-qO'z%nO~Oa%nO!g#vO!p-sO#`-qO'z%nO(r'pO~O(P'xO(Q'xO(R-zO~Ov-{O~O!Y'Wa!]'Wa~P!:tO![.PO!Y'WX!]'WX~P%[O!](VO!Y(ha~O!Y(ha~PHRO!](^O!Y(va~O!S%hO![.TO!_%iO(T%gO!Y'^X!]'^X~O#`.VO!](ta!k(taa(ta'z(ta~O!g#vO~P#,wO!](jO!k(sa~O!S%hO!_%iO#j.ZO(T%gO~Op.`O!S%hO![.]O!_%iO!|]O#i._O#j.]O(T%gO!]'aX!k'aX~OR.dO!l#xO~Oh%VOn.gO!_'`O%i.fO~Oa#ci!]#ci'z#ci'w#ci!Y#ci!k#civ#ci!_#ci%i#ci!g#ci~P!:tOn>]O!Q*OO'y*PO(y$}O(z%PO~O#k#_aa#_a#`#_a'z#_a!]#_a!k#_a!_#_a!Y#_a~P#/sO#k(`XP(`XR(`X[(`Xa(`Xj(`Xr(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X'z(`X(a(`X(r(`X!k(`X!Y(`X'w(`Xv(`X!_(`X%i(`X!g(`X~P!6kO!].tO!k(kX~P!:tO!k.wO~O!Y.yO~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mia#mij#mir#mi!]#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#n#mi~P#3cO#n$OO~P#3cOP$[OR#zOr$aO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO[#mia#mij#mi!]#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#r#mi~P#6QO#r$QO~P#6QOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO(aVOa#mi!]#mi#x#mi#z#mi#{#mi'z#mi(r#mi(y#mi(z#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#v#mi~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO(aVO(z#}Oa#mi!]#mi#z#mi#{#mi'z#mi(r#mi(y#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#x$UO~P#;VO#x#mi~P#;VO#v$SO~P#8oOP$[OR#zO[$cOj$ROr$aO!Q#yO!S#{O!l#xO!p$[O#R$RO#n$OO#o$PO#p$PO#q$PO#r$QO#s$RO#t$RO#u$bO#v$SO#x$UO(aVO(y#|O(z#}Oa#mi!]#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~O#z#mi~P#={O#z$WO~P#={OP]XR]X[]Xj]Xr]X!Q]X!S]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X!]]X!^]X~O$O]X~P#@jOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO#z<gO#{<hO(aVO(r$YO(y#|O(z#}O~O$O.{O~P#BwO#S$dO#`<nO$Q<nO$O(gX!^(gX~P! uOa'da!]'da'z'da'w'da!k'da!Y'dav'da!_'da%i'da!g'da~P!:tO[#mia#mij#mir#mi!]#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi'z#mi(r#mi'w#mi!Y#mi!k#miv#mi!_#mi%i#mi!g#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n$OO#o$PO#p$PO#q$PO(aVO(y#mi(z#mi~P#EyOn>]O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P#EyO!]/POg(pX~P!1WOg/RO~Oa$Pi!]$Pi'z$Pi'w$Pi!Y$Pi!k$Piv$Pi!_$Pi%i$Pi!g$Pi~P!:tO$]/SO$_/SO~O$]/TO$_/TO~O!g)hO#`/UO!_$cX$Z$cX$]$cX$_$cX$f$cX~O![/VO~O!_)kO$Z/XO$])jO$_)jO$f/YO~O!]<iO!^(fX~P#BwO!^/ZO~O!g)hO$f({X~O$f/]O~Ov/^O~P!&zOx)yO(b)zO(c/aO~O!S/dO~O(y$}On%aa!Q%aa'y%aa(z%aa!]%aa#`%aa~Og%aa$O%aa~P#L{O(z%POn%ca!Q%ca'y%ca(y%ca!]%ca#`%ca~Og%ca$O%ca~P#MnO!]fX!gfX!kfX!k$zX(rfX~P!0SOp%WO![/mO!](^O(T/lO!Y(vP!Y)PP~P!1uOr*sO!b*qO!c*kO!d*kO!l*bO#[*rO%`*mO(U!lO(VTO(YUO~Os<}O!S/nO![+[O!^*pO(e<|O!^(xP~P$ [O!k/oO~P#/sO!]/pO!g#vO(r'pO!k)OX~O!k/uO~OnoX!QoX'yoX(yoX(zoX~O!g#vO!koX~P$#OOp/wO!S%hO![*^O!_%iO(T%gO!k)OP~O#k/xO~O!Y$zX!]$zX!g%RX~P!0SO!]/yO!Y)PX~P#/sO!g/{O~O!Y/}O~OpkO(T0OO~P.iOh%VOr0TO!g#vO!l%eO(r'pO~O!g+iO~Oa%nO!]0XO'z%nO~O!^0ZO~P!5iO!c0[O!d0[O(U!lO~P#$`Os!nO!S0]O(VTO(YUO(e!mO~O#[0_O~Og%aa!]%aa#`%aa$O%aa~P!1WOg%ca!]%ca#`%ca$O%ca~P!1WOj%dOk%dOl%dO(T&ZOg'mX!]'mX~O!]*yOg(^a~Og0hO~On0jO#`0iOg(_a!](_a~OR0kO!Q0kO!S0lO#S$dOn}a'y}a(y}a(z}a!]}a#`}a~Og}a$O}a~P$(cO!Q*OO'y*POn$sa(y$sa(z$sa!]$sa#`$sa~Og$sa$O$sa~P$)_O!Q*OO'y*POn$ua(y$ua(z$ua!]$ua#`$ua~Og$ua$O$ua~P$*QO#k0oO~Og%Ta!]%Ta#`%Ta$O%Ta~P!1WO!g#vO~O#k0rO~O!]+^Oa)Ta'z)Ta~OR#zO!Q#yO!S#{O!l#xO(aVOP!ri[!rij!rir!ri!]!ri!p!ri#R!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#t!ri#u!ri#v!ri#x!ri#z!ri#{!ri(r!ri(y!ri(z!ri~Oa!ri'z!ri'w!ri!Y!ri!k!riv!ri!_!ri%i!ri!g!ri~P$+oOh%VOr%XOs$tOt$tOz%YO|%ZO!O<sO!S${O!_$|O!i>VO!l$xO#j<yO$W%`O$t<uO$v<wO$y%aO(VTO(YUO(a$uO(y$}O(z%PO~Op0{O%]0|O(T0zO~P$.VO!g+iOa(]a!_(]a'z(]a!](]a~O#k1SO~O[]X!]fX!^fX~O!]1TO!^)XX~O!^1VO~O[1WO~Ob1YO(T+qO(VTO(YUO~O!_&PO(T%gO`'uX!]'uX~O!]+vO`)Wa~O!k1]O~P!:tO[1`O~O`1aO~O#`1fO~On1iO!_$|O~O(e(|O!^)UP~Oh%VOn1rO!_1oO%i1qO~O[1|O!]1zO!^)VX~O!^1}O~O`2POa%nO'z%nO~O(T#nO(VTO(YUO~O#S$dO#`$eO$Q$eOP(gXR(gX[(gXr(gX!Q(gX!S(gX!](gX!l(gX!p(gX#R(gX#n(gX#o(gX#p(gX#q(gX#r(gX#s(gX#t(gX#u(gX#v(gX#x(gX#z(gX#{(gX(a(gX(r(gX(y(gX(z(gX~Oj2SO&[2TOa(gX~P$3pOj2SO#`$eO&[2TO~Oa2VO~P%[Oa2XO~O&e2[OP&ciQ&ciS&ciY&cia&cid&cie&cil&cip&cir&cis&cit&ciz&ci|&ci!O&ci!S&ci!W&ci!X&ci!_&ci!i&ci!l&ci!o&ci!p&ci!q&ci!s&ci!u&ci!x&ci!|&ci$W&ci$n&ci%h&ci%j&ci%l&ci%m&ci%n&ci%q&ci%s&ci%v&ci%w&ci%y&ci&W&ci&^&ci&`&ci&b&ci&d&ci&g&ci&m&ci&s&ci&u&ci&w&ci&y&ci&{&ci'w&ci(T&ci(V&ci(Y&ci(a&ci(o&ci!^&cib&ci&j&ci~Ob2bO!^2`O&j2aO~P`O!_XO!l2dO~O&q,{OP&liQ&liS&liY&lia&lid&lie&lil&lip&lir&lis&lit&liz&li|&li!O&li!S&li!W&li!X&li!_&li!i&li!l&li!o&li!p&li!q&li!s&li!u&li!x&li!|&li$W&li$n&li%h&li%j&li%l&li%m&li%n&li%q&li%s&li%v&li%w&li%y&li&W&li&^&li&`&li&b&li&d&li&g&li&m&li&s&li&u&li&w&li&y&li&{&li'w&li(T&li(V&li(Y&li(a&li(o&li!^&li&e&lib&li&j&li~O!Y2jO~O!]!aa!^!aa~P#BwOs!nO!S!oO![2pO(e!mO!]'XX!^'XX~P@nO!]-]O!^(ia~O!]'_X!^'_X~P!9|O!]-`O!^(xa~O!^2wO~P'_Oa%nO#`3QO'z%nO~Oa%nO!g#vO#`3QO'z%nO~Oa%nO!g#vO!p3UO#`3QO'z%nO(r'pO~Oa%nO'z%nO~P!:tO!]$_Ov$qa~O!Y'Wi!]'Wi~P!:tO!](VO!Y(hi~O!](^O!Y(vi~O!Y(wi!](wi~P!:tO!](ti!k(tia(ti'z(ti~P!:tO#`3WO!](ti!k(tia(ti'z(ti~O!](jO!k(si~O!S%hO!_%iO!|]O#i3]O#j3[O(T%gO~O!S%hO!_%iO#j3[O(T%gO~On3dO!_'`O%i3cO~Oh%VOn3dO!_'`O%i3cO~O#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aav%aa!_%aa%i%aa!g%aa~P#L{O#k%caP%caR%ca[%caa%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%cav%ca!_%ca%i%ca!g%ca~P#MnO#k%aaP%aaR%aa[%aaa%aaj%aar%aa!S%aa!]%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa'z%aa(a%aa(r%aa!k%aa!Y%aa'w%aa#`%aav%aa!_%aa%i%aa!g%aa~P#/sO#k%caP%caR%ca[%caa%caj%car%ca!S%ca!]%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca'z%ca(a%ca(r%ca!k%ca!Y%ca'w%ca#`%cav%ca!_%ca%i%ca!g%ca~P#/sO#k}aP}a[}aa}aj}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a'z}a(a}a(r}a!k}a!Y}a'w}av}a!_}a%i}a!g}a~P$(cO#k$saP$saR$sa[$saa$saj$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa'z$sa(a$sa(r$sa!k$sa!Y$sa'w$sav$sa!_$sa%i$sa!g$sa~P$)_O#k$uaP$uaR$ua[$uaa$uaj$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua'z$ua(a$ua(r$ua!k$ua!Y$ua'w$uav$ua!_$ua%i$ua!g$ua~P$*QO#k%TaP%TaR%Ta[%Taa%Taj%Tar%Ta!S%Ta!]%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta'z%Ta(a%Ta(r%Ta!k%Ta!Y%Ta'w%Ta#`%Tav%Ta!_%Ta%i%Ta!g%Ta~P#/sOa#cq!]#cq'z#cq'w#cq!Y#cq!k#cqv#cq!_#cq%i#cq!g#cq~P!:tO![3lO!]'YX!k'YX~P%[O!].tO!k(ka~O!].tO!k(ka~P!:tO!Y3oO~O$O!na!^!na~PKlO$O!ja!]!ja!^!ja~P#BwO$O!ra!^!ra~P!=[O$O!ta!^!ta~P!?rOg']X!]']X~P!,TO!]/POg(pa~OSfO!_4TO$d4UO~O!^4YO~Ov4ZO~P#/sOa$mq!]$mq'z$mq'w$mq!Y$mq!k$mqv$mq!_$mq%i$mq!g$mq~P!:tO!Y4]O~P!&zO!S4^O~O!Q*OO'y*PO(z%POn'ia(y'ia!]'ia#`'ia~Og'ia$O'ia~P%-fO!Q*OO'y*POn'ka(y'ka(z'ka!]'ka#`'ka~Og'ka$O'ka~P%.XO(r$YO~P#/sO!YfX!Y$zX!]fX!]$zX!g%RX#`fX~P!0SOp%WO(T=WO~P!1uOp4bO!S%hO![4aO!_%iO(T%gO!]'eX!k'eX~O!]/pO!k)Oa~O!]/pO!g#vO!k)Oa~O!]/pO!g#vO(r'pO!k)Oa~Og$|i!]$|i#`$|i$O$|i~P!1WO![4jO!Y'gX!]'gX~P!3tO!]/yO!Y)Pa~O!]/yO!Y)Pa~P#/sOP]XR]X[]Xj]Xr]X!Q]X!S]X!Y]X!]]X!l]X!p]X#R]X#S]X#`]X#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~Oj%YX!g%YX~P%2OOj4oO!g#vO~Oh%VO!g#vO!l%eO~Oh%VOr4tO!l%eO(r'pO~Or4yO!g#vO(r'pO~Os!nO!S4zO(VTO(YUO(e!mO~O(y$}On%ai!Q%ai'y%ai(z%ai!]%ai#`%ai~Og%ai$O%ai~P%5oO(z%POn%ci!Q%ci'y%ci(y%ci!]%ci#`%ci~Og%ci$O%ci~P%6bOg(_i!](_i~P!1WO#`5QOg(_i!](_i~P!1WO!k5VO~Oa$oq!]$oq'z$oq'w$oq!Y$oq!k$oqv$oq!_$oq%i$oq!g$oq~P!:tO!Y5ZO~O!]5[O!_)QX~P#/sOa$zX!_$zX%^]X'z$zX!]$zX~P!0SO%^5_OaoX!_oX'zoX!]oX~P$#OOp5`O(T#nO~O%^5_O~Ob5fO%j5gO(T+qO(VTO(YUO!]'tX!^'tX~O!]1TO!^)Xa~O[5kO~O`5lO~O[5pO~Oa%nO'z%nO~P#/sO!]5uO#`5wO!^)UX~O!^5xO~Or6OOs!nO!S*iO!b!yO!c!vO!d!vO!|<VO#T!pO#U!pO#V!pO#W!pO#X!pO#[5}O#]!zO(U!lO(VTO(YUO(e!mO(o!sO~O!^5|O~P%;eOn6TO!_1oO%i6SO~Oh%VOn6TO!_1oO%i6SO~Ob6[O(T#nO(VTO(YUO!]'sX!^'sX~O!]1zO!^)Va~O(VTO(YUO(e6^O~O`6bO~Oj6eO&[6fO~PNXO!k6gO~P%[Oa6iO~Oa6iO~P%[Ob2bO!^6nO&j2aO~P`O!g6pO~O!g6rOh(ji!](ji!^(ji!g(ji!l(jir(ji(r(ji~O!]#hi!^#hi~P#BwO#`6sO!]#hi!^#hi~O!]!ai!^!ai~P#BwOa%nO#`6|O'z%nO~Oa%nO!g#vO#`6|O'z%nO~O!](tq!k(tqa(tq'z(tq~P!:tO!](jO!k(sq~O!S%hO!_%iO#j7TO(T%gO~O!_'`O%i7WO~On7[O!_'`O%i7WO~O#k'iaP'iaR'ia['iaa'iaj'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia'z'ia(a'ia(r'ia!k'ia!Y'ia'w'iav'ia!_'ia%i'ia!g'ia~P%-fO#k'kaP'kaR'ka['kaa'kaj'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka'z'ka(a'ka(r'ka!k'ka!Y'ka'w'kav'ka!_'ka%i'ka!g'ka~P%.XO#k$|iP$|iR$|i[$|ia$|ij$|ir$|i!S$|i!]$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i'z$|i(a$|i(r$|i!k$|i!Y$|i'w$|i#`$|iv$|i!_$|i%i$|i!g$|i~P#/sO#k%aiP%aiR%ai[%aia%aij%air%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai'z%ai(a%ai(r%ai!k%ai!Y%ai'w%aiv%ai!_%ai%i%ai!g%ai~P%5oO#k%ciP%ciR%ci[%cia%cij%cir%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci'z%ci(a%ci(r%ci!k%ci!Y%ci'w%civ%ci!_%ci%i%ci!g%ci~P%6bO!]'Ya!k'Ya~P!:tO!].tO!k(ki~O$O#ci!]#ci!^#ci~P#BwOP$[OR#zO!Q#yO!S#{O!l#xO!p$[O(aVO[#mij#mir#mi#R#mi#o#mi#p#mi#q#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#n#mi~P%NdO#n<_O~P%NdOP$[OR#zOr<kO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO[#mij#mi#R#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#r#mi~P&!lO#r<aO~P&!lOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO(aVO#x#mi#z#mi#{#mi$O#mi(r#mi(y#mi(z#mi!]#mi!^#mi~O#v#mi~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO(aVO(z#}O#z#mi#{#mi$O#mi(r#mi(y#mi!]#mi!^#mi~O#x<eO~P&&uO#x#mi~P&&uO#v<cO~P&$tOP$[OR#zO[<mOj<bOr<kO!Q#yO!S#{O!l#xO!p$[O#R<bO#n<_O#o<`O#p<`O#q<`O#r<aO#s<bO#t<bO#u<lO#v<cO#x<eO(aVO(y#|O(z#}O#{#mi$O#mi(r#mi!]#mi!^#mi~O#z#mi~P&)UO#z<gO~P&)UOa#|y!]#|y'z#|y'w#|y!Y#|y!k#|yv#|y!_#|y%i#|y!g#|y~P!:tO[#mij#mir#mi#R#mi#r#mi#s#mi#t#mi#u#mi#v#mi#x#mi#z#mi#{#mi$O#mi(r#mi!]#mi!^#mi~OP$[OR#zO!Q#yO!S#{O!l#xO!p$[O#n<_O#o<`O#p<`O#q<`O(aVO(y#mi(z#mi~P&,QOn>^O!Q*OO'y*PO(y$}O(z%POP#miR#mi!S#mi!l#mi!p#mi#n#mi#o#mi#p#mi#q#mi(a#mi~P&,QO#S$dOP(`XR(`X[(`Xj(`Xn(`Xr(`X!Q(`X!S(`X!l(`X!p(`X#R(`X#n(`X#o(`X#p(`X#q(`X#r(`X#s(`X#t(`X#u(`X#v(`X#x(`X#z(`X#{(`X$O(`X'y(`X(a(`X(r(`X(y(`X(z(`X!](`X!^(`X~O$O$Pi!]$Pi!^$Pi~P#BwO$O!ri!^!ri~P$+oOg']a!]']a~P!1WO!^7nO~O!]'da!^'da~P#BwO!Y7oO~P#/sO!g#vO(r'pO!]'ea!k'ea~O!]/pO!k)Oi~O!]/pO!g#vO!k)Oi~Og$|q!]$|q#`$|q$O$|q~P!1WO!Y'ga!]'ga~P#/sO!g7vO~O!]/yO!Y)Pi~P#/sO!]/yO!Y)Pi~O!Y7yO~Oh%VOr8OO!l%eO(r'pO~Oj8QO!g#vO~Or8TO!g#vO(r'pO~O!Q*OO'y*PO(z%POn'ja(y'ja!]'ja#`'ja~Og'ja$O'ja~P&5RO!Q*OO'y*POn'la(y'la(z'la!]'la#`'la~Og'la$O'la~P&5tOg(_q!](_q~P!1WO#`8VOg(_q!](_q~P!1WO!Y8WO~Og%Oq!]%Oq#`%Oq$O%Oq~P!1WOa$oy!]$oy'z$oy'w$oy!Y$oy!k$oyv$oy!_$oy%i$oy!g$oy~P!:tO!g6rO~O!]5[O!_)Qa~O!_'`OP$TaR$Ta[$Taj$Tar$Ta!Q$Ta!S$Ta!]$Ta!l$Ta!p$Ta#R$Ta#n$Ta#o$Ta#p$Ta#q$Ta#r$Ta#s$Ta#t$Ta#u$Ta#v$Ta#x$Ta#z$Ta#{$Ta(a$Ta(r$Ta(y$Ta(z$Ta~O%i7WO~P&8fO%^8[Oa%[i!_%[i'z%[i!]%[i~Oa#cy!]#cy'z#cy'w#cy!Y#cy!k#cyv#cy!_#cy%i#cy!g#cy~P!:tO[8^O~Ob8`O(T+qO(VTO(YUO~O!]1TO!^)Xi~O`8dO~O(e(|O!]'pX!^'pX~O!]5uO!^)Ua~O!^8nO~P%;eO(o!sO~P$&YO#[8oO~O!_1oO~O!_1oO%i8qO~On8tO!_1oO%i8qO~O[8yO!]'sa!^'sa~O!]1zO!^)Vi~O!k8}O~O!k9OO~O!k9RO~O!k9RO~P%[Oa9TO~O!g9UO~O!k9VO~O!](wi!^(wi~P#BwOa%nO#`9_O'z%nO~O!](ty!k(tya(ty'z(ty~P!:tO!](jO!k(sy~O%i9bO~P&8fO!_'`O%i9bO~O#k$|qP$|qR$|q[$|qa$|qj$|qr$|q!S$|q!]$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q'z$|q(a$|q(r$|q!k$|q!Y$|q'w$|q#`$|qv$|q!_$|q%i$|q!g$|q~P#/sO#k'jaP'jaR'ja['jaa'jaj'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja'z'ja(a'ja(r'ja!k'ja!Y'ja'w'jav'ja!_'ja%i'ja!g'ja~P&5RO#k'laP'laR'la['laa'laj'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la'z'la(a'la(r'la!k'la!Y'la'w'lav'la!_'la%i'la!g'la~P&5tO#k%OqP%OqR%Oq[%Oqa%Oqj%Oqr%Oq!S%Oq!]%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq'z%Oq(a%Oq(r%Oq!k%Oq!Y%Oq'w%Oq#`%Oqv%Oq!_%Oq%i%Oq!g%Oq~P#/sO!]'Yi!k'Yi~P!:tO$O#cq!]#cq!^#cq~P#BwO(y$}OP%aaR%aa[%aaj%aar%aa!S%aa!l%aa!p%aa#R%aa#n%aa#o%aa#p%aa#q%aa#r%aa#s%aa#t%aa#u%aa#v%aa#x%aa#z%aa#{%aa$O%aa(a%aa(r%aa!]%aa!^%aa~On%aa!Q%aa'y%aa(z%aa~P&IyO(z%POP%caR%ca[%caj%car%ca!S%ca!l%ca!p%ca#R%ca#n%ca#o%ca#p%ca#q%ca#r%ca#s%ca#t%ca#u%ca#v%ca#x%ca#z%ca#{%ca$O%ca(a%ca(r%ca!]%ca!^%ca~On%ca!Q%ca'y%ca(y%ca~P&LQOn>^O!Q*OO'y*PO(z%PO~P&IyOn>^O!Q*OO'y*PO(y$}O~P&LQOR0kO!Q0kO!S0lO#S$dOP}a[}aj}an}ar}a!l}a!p}a#R}a#n}a#o}a#p}a#q}a#r}a#s}a#t}a#u}a#v}a#x}a#z}a#{}a$O}a'y}a(a}a(r}a(y}a(z}a!]}a!^}a~O!Q*OO'y*POP$saR$sa[$saj$san$sar$sa!S$sa!l$sa!p$sa#R$sa#n$sa#o$sa#p$sa#q$sa#r$sa#s$sa#t$sa#u$sa#v$sa#x$sa#z$sa#{$sa$O$sa(a$sa(r$sa(y$sa(z$sa!]$sa!^$sa~O!Q*OO'y*POP$uaR$ua[$uaj$uan$uar$ua!S$ua!l$ua!p$ua#R$ua#n$ua#o$ua#p$ua#q$ua#r$ua#s$ua#t$ua#u$ua#v$ua#x$ua#z$ua#{$ua$O$ua(a$ua(r$ua(y$ua(z$ua!]$ua!^$ua~On>^O!Q*OO'y*PO(y$}O(z%PO~OP%TaR%Ta[%Taj%Tar%Ta!S%Ta!l%Ta!p%Ta#R%Ta#n%Ta#o%Ta#p%Ta#q%Ta#r%Ta#s%Ta#t%Ta#u%Ta#v%Ta#x%Ta#z%Ta#{%Ta$O%Ta(a%Ta(r%Ta!]%Ta!^%Ta~P''VO$O$mq!]$mq!^$mq~P#BwO$O$oq!]$oq!^$oq~P#BwO!^9oO~O$O9pO~P!1WO!g#vO!]'ei!k'ei~O!g#vO(r'pO!]'ei!k'ei~O!]/pO!k)Oq~O!Y'gi!]'gi~P#/sO!]/yO!Y)Pq~Or9wO!g#vO(r'pO~O[9yO!Y9xO~P#/sO!Y9xO~Oj:PO!g#vO~Og(_y!](_y~P!1WO!]'na!_'na~P#/sOa%[q!_%[q'z%[q!]%[q~P#/sO[:UO~O!]1TO!^)Xq~O`:YO~O#`:ZO!]'pa!^'pa~O!]5uO!^)Ui~P#BwO!S:]O~O!_1oO%i:`O~O(VTO(YUO(e:eO~O!]1zO!^)Vq~O!k:hO~O!k:iO~O!k:jO~O!k:jO~P%[O#`:mO!]#hy!^#hy~O!]#hy!^#hy~P#BwO%i:rO~P&8fO!_'`O%i:rO~O$O#|y!]#|y!^#|y~P#BwOP$|iR$|i[$|ij$|ir$|i!S$|i!l$|i!p$|i#R$|i#n$|i#o$|i#p$|i#q$|i#r$|i#s$|i#t$|i#u$|i#v$|i#x$|i#z$|i#{$|i$O$|i(a$|i(r$|i!]$|i!^$|i~P''VO!Q*OO'y*PO(z%POP'iaR'ia['iaj'ian'iar'ia!S'ia!l'ia!p'ia#R'ia#n'ia#o'ia#p'ia#q'ia#r'ia#s'ia#t'ia#u'ia#v'ia#x'ia#z'ia#{'ia$O'ia(a'ia(r'ia(y'ia!]'ia!^'ia~O!Q*OO'y*POP'kaR'ka['kaj'kan'kar'ka!S'ka!l'ka!p'ka#R'ka#n'ka#o'ka#p'ka#q'ka#r'ka#s'ka#t'ka#u'ka#v'ka#x'ka#z'ka#{'ka$O'ka(a'ka(r'ka(y'ka(z'ka!]'ka!^'ka~O(y$}OP%aiR%ai[%aij%ain%air%ai!Q%ai!S%ai!l%ai!p%ai#R%ai#n%ai#o%ai#p%ai#q%ai#r%ai#s%ai#t%ai#u%ai#v%ai#x%ai#z%ai#{%ai$O%ai'y%ai(a%ai(r%ai(z%ai!]%ai!^%ai~O(z%POP%ciR%ci[%cij%cin%cir%ci!Q%ci!S%ci!l%ci!p%ci#R%ci#n%ci#o%ci#p%ci#q%ci#r%ci#s%ci#t%ci#u%ci#v%ci#x%ci#z%ci#{%ci$O%ci'y%ci(a%ci(r%ci(y%ci!]%ci!^%ci~O$O$oy!]$oy!^$oy~P#BwO$O#cy!]#cy!^#cy~P#BwO!g#vO!]'eq!k'eq~O!]/pO!k)Oy~O!Y'gq!]'gq~P#/sOr:|O!g#vO(r'pO~O[;QO!Y;PO~P#/sO!Y;PO~Og(_!R!](_!R~P!1WOa%[y!_%[y'z%[y!]%[y~P#/sO!]1TO!^)Xy~O!]5uO!^)Uq~O(T;XO~O!_1oO%i;[O~O!k;_O~O%i;dO~P&8fOP$|qR$|q[$|qj$|qr$|q!S$|q!l$|q!p$|q#R$|q#n$|q#o$|q#p$|q#q$|q#r$|q#s$|q#t$|q#u$|q#v$|q#x$|q#z$|q#{$|q$O$|q(a$|q(r$|q!]$|q!^$|q~P''VO!Q*OO'y*PO(z%POP'jaR'ja['jaj'jan'jar'ja!S'ja!l'ja!p'ja#R'ja#n'ja#o'ja#p'ja#q'ja#r'ja#s'ja#t'ja#u'ja#v'ja#x'ja#z'ja#{'ja$O'ja(a'ja(r'ja(y'ja!]'ja!^'ja~O!Q*OO'y*POP'laR'la['laj'lan'lar'la!S'la!l'la!p'la#R'la#n'la#o'la#p'la#q'la#r'la#s'la#t'la#u'la#v'la#x'la#z'la#{'la$O'la(a'la(r'la(y'la(z'la!]'la!^'la~OP%OqR%Oq[%Oqj%Oqr%Oq!S%Oq!l%Oq!p%Oq#R%Oq#n%Oq#o%Oq#p%Oq#q%Oq#r%Oq#s%Oq#t%Oq#u%Oq#v%Oq#x%Oq#z%Oq#{%Oq$O%Oq(a%Oq(r%Oq!]%Oq!^%Oq~P''VOg%e!Z!]%e!Z#`%e!Z$O%e!Z~P!1WO!Y;hO~P#/sOr;iO!g#vO(r'pO~O[;kO!Y;hO~P#/sO!]'pq!^'pq~P#BwO!]#h!Z!^#h!Z~P#BwO#k%e!ZP%e!ZR%e!Z[%e!Za%e!Zj%e!Zr%e!Z!S%e!Z!]%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z'z%e!Z(a%e!Z(r%e!Z!k%e!Z!Y%e!Z'w%e!Z#`%e!Zv%e!Z!_%e!Z%i%e!Z!g%e!Z~P#/sOr;tO!g#vO(r'pO~O!Y;uO~P#/sOr;|O!g#vO(r'pO~O!Y;}O~P#/sOP%e!ZR%e!Z[%e!Zj%e!Zr%e!Z!S%e!Z!l%e!Z!p%e!Z#R%e!Z#n%e!Z#o%e!Z#p%e!Z#q%e!Z#r%e!Z#s%e!Z#t%e!Z#u%e!Z#v%e!Z#x%e!Z#z%e!Z#{%e!Z$O%e!Z(a%e!Z(r%e!Z!]%e!Z!^%e!Z~P''VOr<QO!g#vO(r'pO~Ov(fX~P1qO!Q%rO~P!)[O(U!lO~P!)[O!YfX!]fX#`fX~P%2OOP]XR]X[]Xj]Xr]X!Q]X!S]X!]]X!]fX!l]X!p]X#R]X#S]X#`]X#`fX#kfX#n]X#o]X#p]X#q]X#r]X#s]X#t]X#u]X#v]X#x]X#z]X#{]X$Q]X(a]X(r]X(y]X(z]X~O!gfX!k]X!kfX(rfX~P'LTOP<UOQ<UOSfOd>ROe!iOpkOr<UOskOtkOzkO|<UO!O<UO!SWO!WkO!XkO!_XO!i<XO!lZO!o<UO!p<UO!q<UO!s<YO!u<]O!x!hO$W!kO$n>PO(T)]O(VTO(YUO(aVO(o[O~O!]<iO!^$qa~Oh%VOp%WOr%XOs$tOt$tOz%YO|%ZO!O<tO!S${O!_$|O!i>WO!l$xO#j<zO$W%`O$t<vO$v<xO$y%aO(T(vO(VTO(YUO(a$uO(y$}O(z%PO~Ol)dO~P(!yOr!eX(r!eX~P#!iOr(jX(r(jX~P##[O!^]X!^fX~P'LTO!YfX!Y$zX!]fX!]$zX#`fX~P!0SO#k<^O~O!g#vO#k<^O~O#`<nO~Oj<bO~O#`=OO!](wX!^(wX~O#`<nO!](uX!^(uX~O#k=PO~Og=RO~P!1WO#k=XO~O#k=YO~Og=RO(T&ZO~O!g#vO#k=ZO~O!g#vO#k=PO~O$O=[O~P#BwO#k=]O~O#k=^O~O#k=cO~O#k=dO~O#k=eO~O#k=fO~O$O=gO~P!1WO$O=hO~P!1WOl=sO~P7eOk#S#T#U#W#X#[#i#j#u$n$t$v$y%]%^%h%i%j%q%s%v%w%y%{~(OT#o!X'|(U#ps#n#qr!Q'}$]'}(T$_(e~",
  goto: "$9Y)]PPPPPP)^PP)aP)rP+W/]PPPP6mPP7TPP=QPPP@tPA^PA^PPPA^PCfPA^PA^PA^PCjPCoPD^PIWPPPI[PPPPI[L_PPPLeMVPI[PI[PP! eI[PPPI[PI[P!#lI[P!'S!(X!(bP!)U!)Y!)U!,gPPPPPPP!-W!(XPP!-h!/YP!2iI[I[!2n!5z!:h!:h!>gPPP!>oI[PPPPPPPPP!BOP!C]PPI[!DnPI[PI[I[I[I[I[PI[!FQP!I[P!LbP!Lf!Lp!Lt!LtP!IXP!Lx!LxP#!OP#!SI[PI[#!Y#%_CjA^PA^PA^A^P#&lA^A^#)OA^#+vA^#.SA^A^#.r#1W#1W#1]#1f#1W#1qPP#1WPA^#2ZA^#6YA^A^6mPPP#:_PPP#:x#:xP#:xP#;`#:xPP#;fP#;]P#;]#;y#;]#<e#<k#<n)aP#<q)aP#<z#<z#<zP)aP)aP)aP)aPP)aP#=Q#=TP#=T)aP#=XP#=[P)aP)aP)aP)aP)aP)a)aPP#=b#=h#=s#=y#>P#>V#>]#>k#>q#>{#?R#?]#?c#?s#?y#@k#@}#AT#AZ#Ai#BO#Cs#DR#DY#Et#FS#Gt#HS#HY#H`#Hf#Hp#Hv#H|#IW#Ij#IpPPPPPPPPPPP#IvPPPPPPP#Jk#Mx$ b$ i$ qPPP$']P$'f$*_$0x$0{$1O$1}$2Q$2X$2aP$2g$2jP$3W$3[$4S$5b$5g$5}PP$6S$6Y$6^$6a$6e$6i$7e$7|$8e$8i$8l$8o$8y$8|$9Q$9UR!|RoqOXst!Z#d%m&r&t&u&w,s,x2[2_Y!vQ'`-e1o5{Q%tvQ%|yQ&T|Q&j!VS'W!e-]Q'f!iS'l!r!yU*k$|*Z*oQ+o%}S+|&V&WQ,d&dQ-c'_Q-m'gQ-u'mQ0[*qQ1b,OQ1y,eR<{<Y%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_S#q]<V!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU+P%]<s<tQ+t&PQ,f&gQ,m&oQ0x+gQ0}+iQ1Y+uQ2R,kQ3`.gQ5`0|Q5f1TQ6[1zQ7Y3dQ8`5gR9e7['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S!S!nQ!r!v!y!z$|'W'_'`'l'm'n*k*o*q*r-]-c-e-u0[0_1o5{5}%[$ti#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q&X|Q'U!eS'[%i-`Q+t&PQ,P&WQ,f&gQ0n+SQ1Y+uQ1_+{Q2Q,jQ2R,kQ5f1TQ5o1aQ6[1zQ6_1|Q6`2PQ8`5gQ8c5lQ8|6bQ:X8dQ:f8yQ;V:YR<}*ZrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R,h&k&z^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'b'r(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>R>S[#]WZ#W#Z'X(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ%wxQ%{yW&Q|&V&W,OQ&_!TQ'c!hQ'e!iQ(q#sS+n%|%}Q+r&PQ,_&bQ,c&dS-l'f'gQ.i(rQ1R+oQ1X+uQ1Z+vQ1^+zQ1t,`S1x,d,eQ2|-mQ5e1TQ5i1WQ5n1`Q6Z1yQ8_5gQ8b5kQ8f5pQ:T8^R;T:U!U$zi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y!^%yy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{Q+h%wQ,T&[Q,W&]Q,b&dQ.h(qQ1s,_U1w,c,d,eQ3e.iQ6U1tS6Y1x1yQ8x6Z#f>T#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o>U<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hW%Ti%V*y>PS&[!Q&iQ&]!RQ&^!SU*}%[%d=sR,R&Y%]%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^T)z$u){V+P%]<s<tW'[!e%i*Z-`S(}#y#zQ+c%rQ+y&SS.b(m(nQ1j,XQ5T0kR8i5u'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S$i$^c#Y#e%q%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.|.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vT#TV#U'RkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ'Y!eR2q-]!W!nQ!e!r!v!y!z$|'W'_'`'l'm'n*Z*k*o*q*r-]-c-e-u0[0_1o5{5}R1l,ZnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&y!^Q'v!xS(s#u<^Q+l%zQ,]&_Q,^&aQ-j'dQ-w'oS.r(x=PS0q+X=ZQ1P+mQ1n,[Q2c,zQ2e,{Q2m-WQ2z-kQ2}-oS5Y0r=eQ5a1QS5d1S=fQ6t2oQ6x2{Q6}3SQ8]5bQ9Y6vQ9Z6yQ9^7OR:l9V$d$]c#Y#e%s%u(S(Y(t(y)R)S)T)U)V)W)X)Y)Z)[)^)`)b)g)q+d+x-Z-x-}.S.U.s.v.z.}/O/b0p2k2n3O3V3k3p3q3r3s3t3u3v3w3x3y3z3{3|4P4Q4X5X5c6u6{7Q7a7b7k7l8k9X9]9g9m9n:o;W;`<W=vS(o#p'iQ)P#zS+b%q.|S.c(n(pR3^.d'QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS#q]<VQ&t!XQ&u!YQ&w![Q&x!]R2Z,vQ'a!hQ+e%wQ-h'cS.e(q+hQ2x-gW3b.h.i0w0yQ6w2yW7U3_3a3e5^U9a7V7X7ZU:q9c9d9fS;b:p:sQ;p;cR;x;qU!wQ'`-eT5y1o5{!Q_OXZ`st!V!Z#d#h%e%m&i&k&r&t&u&w(j,s,x.[2[2_]!pQ!r'`-e1o5{T#q]<V%^{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S(}#y#zS.b(m(n!s=l$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SU$fd)_,mS(p#p'iU*v%R(w4OU0m+O.n7gQ5^0xQ7V3`Q9d7YR:s9em!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}Q't!uS(f#g2US-s'k'wQ/s*]Q0R*jQ3U-vQ4f/tQ4r0TQ4s0UQ4x0^Q7r4`S7}4t4vS8R4y4{Q9r7sQ9v7yQ9{8OQ:Q8TS:{9w9xS;g:|;PS;s;h;iS;{;t;uS<P;|;}R<S<QQ#wbQ's!uS(e#g2US(g#m+WQ+Y%fQ+j%xQ+p&OU-r'k't'wQ.W(fU/r*]*`/wQ0S*jQ0V*lQ1O+kQ1u,aS3R-s-vQ3Z.`S4e/s/tQ4n0PS4q0R0^Q4u0WQ6W1vQ7P3US7q4`4bQ7u4fU7|4r4x4{Q8P4wQ8v6XS9q7r7sQ9u7yQ9}8RQ:O8SQ:c8wQ:y9rS:z9v9xQ;S:QQ;^:dS;f:{;PS;r;g;hS;z;s;uS<O;{;}Q<R<PQ<T<SQ=o=jQ={=tR=|=uV!wQ'`-e%^aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_S#wz!j!r=i$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=o>R%^bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Q%fj!^%xy!i!u%{%|%}'V'e'f'g'k'u*j+n+o-Y-l-m-t0R0U1R2u2|3T4r4s4v7}9{S&Oz!jQ+k%yQ,a&dW1v,b,c,d,eU6X1w1x1yS8w6Y6ZQ:d8x!r=j$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ=t>QR=u>R%QeOPXYstuvw!Z!`!g!o#S#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_Y#bWZ#W#Z(T!b%jm#h#i#l$x%e%h(^(h(i(j*Y*^*b+Z+[+^,o-V.T.Z.[.]._/m/p2d3[3]4a6r7TQ,n&o!p=k$Z$n)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SR=n'XU']!e%i*ZR2s-`%SdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+],p,s,x-i-q.P.V.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3l4z6T6e6f6i6|8t9T9_!r)_$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SQ,m&oQ0x+gQ3`.gQ7Y3dR9e7[!b$Tc#Y%q(S(Y(t(y)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!P<d)^)q-Z.|2k2n3p3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!f$Vc#Y%q(S(Y(t(y)W)X)Z)[)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<W!T<f)^)q-Z.|2k2n3p3v3w3y3z4P4X6u7b7k7l8k9X9g9m9n;W;`=v!^$Zc#Y%q(S(Y(t(y)`)g+x-x-}.S.U.s.v/b0p3O3V3k3{5X5c6{7Q7a9]:o<WQ4_/kz>S)^)q-Z.|2k2n3p4P4X6u7b7k7l8k9X9g9m9n;W;`=vQ>X>ZR>Y>['QkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>SS$oh$pR4U/U'XgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$kf$qQ$ifS)j$l)nR)v$qT$jf$qT)l$l)n'XhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$Z$_$a$e$n$p%m%t&R&k&n&o&r&t&u&w&{'T'X'b'r(T(V(](d(x(z)O)s)}*i+X+]+g,p,s,x-U-X-i-q.P.V.g.t.{/U/V/n0]0l0r1S1r2S2T2V2X2[2_2a2p3Q3W3d3l4T4z5w6T6e6f6i6s6|7[8t9T9_:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>ST$oh$pQ$rhR)u$p%^jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#x#{$O$P$Q$R$S$T$U$V$W$X$_$a$e%m%t&R&k&n&o&r&t&u&w&{'T'b'r(T(V(](d(x(z)O)}*i+X+]+g,p,s,x-i-q.P.V.g.t.{/n0]0l0r1S1r2S2T2V2X2[2_2a3Q3W3d3l4z6T6e6f6i6|7[8t9T9_!s>Q$Z$n'X)s-U-X/V2p4T5w6s:Z:m<U<X<Y<]<^<_<`<a<b<c<d<e<f<g<h<i<k<n<{=O=P=R=Z=[=e=f>S#glOPXZst!Z!`!o#S#d#o#{$n%m&k&n&o&r&t&u&w&{'T'b)O)s*i+]+g,p,s,x-i.g/V/n0]0l1r2S2T2V2X2[2_2a3d4T4z6T6e6f6i7[8t9T!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^Q+T%aQ/c*Oo4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!U$yi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>YQ*c$zU*l$|*Z*oQ+U%bQ0W*m#f=q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n=r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hQ=w>TQ=x>UQ=y>VR=z>W!U%Ri$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y#f(w#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^o4O<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=hnoOXst!Z#d%m&r&t&u&w,s,x2[2_S*f${*YQ-R'OQ-S'QR4i/y%[%Si#v$b$c$d$x${%O%Q%^%_%c)y*R*T*V*Y*a*g*w*x+f+i,S,V.f/P/d/m/x/y/{0`0b0i0j0o1f1i1q3c4^4_4j4o5Q5[5_6S7W7v8Q8V8[8q9b9p9y:P:`:r;Q;[;d;k<l<m<o<p<q<r<u<v<w<x<y<z=S=T=U=V=X=Y=]=^=_=`=a=b=c=d=g=h>P>X>Y>]>^Q,U&]Q1h,WQ5s1gR8h5tV*n$|*Z*oU*n$|*Z*oT5z1o5{S0P*i/nQ4w0]T8S4z:]Q+j%xQ0V*lQ1O+kQ1u,aQ6W1vQ8v6XQ:c8wR;^:d!U%Oi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Yx*R$v)e*S*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>OS0`*t0a#f<o#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<p<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!d=S(u)c*[*e.j.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[`=T3}7c7f7j9h:t:w;yS=_.l3iT=`7e9k!U%Qi$d%O%Q%^%_%c*R*T*a*w*x/P/x0`0b0i0j0o4_5Q8V9p>P>X>Y|*T$v)e*U*t+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>OS0b*u0c#f<q#v$b$c$x${)y*V*Y*g+f+i,S,V.f/d/m/y/{1f1i1q3c4^4j4o5[5_6S7W7v8Q8[8q9b9y:P:`:r;Q;[;d;k<o<q<u<w<y=S=U=X=]=_=a=c=g>]>^n<r<l<m<p<r<v<x<z=T=V=Y=^=`=b=d=h!h=U(u)c*[*e.k.l.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[d=V3}7d7e7j9h9i:t:u:w;yS=a.m3jT=b7f9lrnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q&f!UR,p&ornOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_R&f!UQ,Y&^R1d,RsnOXst!V!Z#d%m&i&r&t&u&w,s,x2[2_Q1p,_S6R1s1tU8p6P6Q6US:_8r8sS;Y:^:aQ;m;ZR;w;nQ&m!VR,i&iR6_1|R:f8yW&Q|&V&W,OR1Z+vQ&r!WR,s&sR,y&xT2],x2_R,}&yQ,|&yR2f,}Q'y!{R-y'ySsOtQ#dXT%ps#dQ#OTR'{#OQ#RUR'}#RQ){$uR/`){Q#UVR(Q#UQ#XWU(W#X(X.QQ(X#YR.Q(YQ-^'YR2r-^Q.u(yS3m.u3nR3n.vQ-e'`R2v-eY!rQ'`-e1o5{R'j!rQ/Q)eR4S/QU#_W%h*YU(_#_(`.RQ(`#`R.R(ZQ-a']R2t-at`OXst!V!Z#d%m&i&k&r&t&u&w,s,x2[2_S#hZ%eU#r`#h.[R.[(jQ(k#jQ.X(gW.a(k.X3X7RQ3X.YR7R3YQ)n$lR/W)nQ$phR)t$pQ$`cU)a$`-|<jQ-|<WR<j)qQ/q*]W4c/q4d7t9sU4d/r/s/tS7t4e4fR9s7u$e*Q$v(u)c)e*[*e*t*u+Q+R+V.l.m.o.p.q/_/g/i/k/v/|0d0e0v1e3f3g3h3}4R4[4g4h4l4|5O5R5S5W5r7]7^7_7`7e7f7h7i7j7p7w7z8U8X8Z9h9i9j9t9|:R:S:t:u:v:w:x:};R;e;j;v;y=p=}>O>Z>[Q/z*eU4k/z4m7xQ4m/|R7x4lS*o$|*ZR0Y*ox*S$v)e*t*u+V/v0d0e4R4g5R5S5W7p8U:R:x=p=}>O!d.j(u)c*[*e.l.m.q/_/k/|0v1e3h4[4h4l5r7]7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/h*S.j7ca7c3}7e7f7j9h:t:w;yQ0a*tQ3i.lU4}0a3i9kR9k7e|*U$v)e*t*u+V/g/v0d0e4R4g4|5R5S5W7p8U:R:x=p=}>O!h.k(u)c*[*e.l.m.q/_/k/|0v1e3f3h4[4h4l5r7]7^7`7w7z8X8Z9t9|:S:};R;e;j;v>Z>[U/j*U.k7de7d3}7e7f7j9h9i:t:u:w;yQ0c*uQ3j.mU5P0c3j9lR9l7fQ*z%UR0g*zQ5]0vR8Y5]Q+_%kR0u+_Q5v1jS8j5v:[R:[8kQ,[&_R1m,[Q5{1oR8m5{Q1{,fS6]1{8zR8z6_Q1U+rW5h1U5j8a:VQ5j1XQ8a5iR:V8bQ+w&QR1[+wQ2_,xR6m2_YrOXst#dQ&v!ZQ+a%mQ,r&rQ,t&tQ,u&uQ,w&wQ2Y,sS2],x2_R6l2[Q%opQ&z!_Q&}!aQ'P!bQ'R!cQ'q!uQ+`%lQ+l%zQ,Q&XQ,h&mQ-P&|W-p'k's't'wQ-w'oQ0X*nQ1P+mQ1c,PS2O,i,lQ2g-OQ2h-RQ2i-SQ2}-oW3P-r-s-v-xQ5a1QQ5m1_Q5q1eQ6V1uQ6a2QQ6k2ZU6z3O3R3UQ6}3SQ8]5bQ8e5oQ8g5rQ8l5zQ8u6WQ8{6`S9[6{7PQ9^7OQ:W8cQ:b8vQ:g8|Q:n9]Q;U:XQ;]:cQ;a:oQ;l;VR;o;^Q%zyQ'd!iQ'o!uU+m%{%|%}Q-W'VU-k'e'f'gS-o'k'uQ0Q*jS1Q+n+oQ2o-YS2{-l-mQ3S-tS4p0R0UQ5b1RQ6v2uQ6y2|Q7O3TU7{4r4s4vQ9z7}R;O9{S$wi>PR*{%VU%Ui%V>PR0f*yQ$viS(u#v+iS)c$b$cQ)e$dQ*[$xS*e${*YQ*t%OQ*u%QQ+Q%^Q+R%_Q+V%cQ.l<oQ.m<qQ.o<uQ.p<wQ.q<yQ/_)yQ/g*RQ/i*TQ/k*VQ/v*aS/|*g/mQ0d*wQ0e*xl0v+f,V.f1i1q3c6S7W8q9b:`:r;[;dQ1e,SQ3f=SQ3g=UQ3h=XS3}<l<mQ4R/PS4[/d4^Q4g/xQ4h/yQ4l/{Q4|0`Q5O0bQ5R0iQ5S0jQ5W0oQ5r1fQ7]=]Q7^=_Q7_=aQ7`=cQ7e<pQ7f<rQ7h<vQ7i<xQ7j<zQ7p4_Q7w4jQ7z4oQ8U5QQ8X5[Q8Z5_Q9h=YQ9i=TQ9j=VQ9t7vQ9|8QQ:R8VQ:S8[Q:t=^Q:u=`Q:v=bQ:w=dQ:x9pQ:}9yQ;R:PQ;e=gQ;j;QQ;v;kQ;y=hQ=p>PQ=}>XQ>O>YQ>Z>]R>[>^Q+O%]Q.n<sR7g<tnpOXst!Z#d%m&r&t&u&w,s,x2[2_Q!fPS#fZ#oQ&|!`W'h!o*i0]4zQ(P#SQ)Q#{Q)r$nS,l&k&nQ,q&oQ-O&{S-T'T/nQ-g'bQ.x)OQ/[)sQ0s+]Q0y+gQ2W,pQ2y-iQ3a.gQ4W/VQ5U0lQ6Q1rQ6c2SQ6d2TQ6h2VQ6j2XQ6o2aQ7Z3dQ7m4TQ8s6TQ9P6eQ9Q6fQ9S6iQ9f7[Q:a8tR:k9T#[cOPXZst!Z!`!o#d#o#{%m&k&n&o&r&t&u&w&{'T'b)O*i+]+g,p,s,x-i.g/n0]0l1r2S2T2V2X2[2_2a3d4z6T6e6f6i7[8t9TQ#YWQ#eYQ%quQ%svS%uw!gS(S#W(VQ(Y#ZQ(t#uQ(y#xQ)R$OQ)S$PQ)T$QQ)U$RQ)V$SQ)W$TQ)X$UQ)Y$VQ)Z$WQ)[$XQ)^$ZQ)`$_Q)b$aQ)g$eW)q$n)s/V4TQ+d%tQ+x&RS-Z'X2pQ-x'rS-}(T.PQ.S(]Q.U(dQ.s(xQ.v(zQ.z<UQ.|<XQ.}<YQ/O<]Q/b)}Q0p+XQ2k-UQ2n-XQ3O-qQ3V.VQ3k.tQ3p<^Q3q<_Q3r<`Q3s<aQ3t<bQ3u<cQ3v<dQ3w<eQ3x<fQ3y<gQ3z<hQ3{.{Q3|<kQ4P<nQ4Q<{Q4X<iQ5X0rQ5c1SQ6u=OQ6{3QQ7Q3WQ7a3lQ7b=PQ7k=RQ7l=ZQ8k5wQ9X6sQ9]6|Q9g=[Q9m=eQ9n=fQ:o9_Q;W:ZQ;`:mQ<W#SR=v>SR#[WR'Z!el!tQ!r!v!y!z'`'l'm'n-e-u1o5{5}S'V!e-]U*j$|*Z*oS-Y'W'_S0U*k*qQ0^*rQ2u-cQ4v0[R4{0_R({#xQ!fQT-d'`-e]!qQ!r'`-e1o5{Q#p]R'i<VR)f$dY!uQ'`-e1o5{Q'k!rS'u!v!yS'w!z5}S-t'l'mQ-v'nR3T-uT#kZ%eS#jZ%eS%km,oU(g#h#i#lS.Y(h(iQ.^(jQ0t+^Q3Y.ZU3Z.[.]._S7S3[3]R9`7Td#^W#W#Z%h(T(^*Y+Z.T/mr#gZm#h#i#l%e(h(i(j+^.Z.[.]._3[3]7TS*]$x*bQ/t*^Q2U,oQ2l-VQ4`/pQ6q2dQ7s4aQ9W6rT=m'X+[V#aW%h*YU#`W%h*YS(U#W(^U(Z#Z+Z/mS-['X+[T.O(T.TV'^!e%i*ZQ$lfR)x$qT)m$l)nR4V/UT*_$x*bT*h${*YQ0w+fQ1g,VQ3_.fQ5t1iQ6P1qQ7X3cQ8r6SQ9c7WQ:^8qQ:p9bQ;Z:`Q;c:rQ;n;[R;q;dnqOXst!Z#d%m&r&t&u&w,s,x2[2_Q&l!VR,h&itmOXst!U!V!Z#d%m&i&r&t&u&w,s,x2[2_R,o&oT%lm,oR1k,XR,g&gQ&U|S+}&V&WR1^,OR+s&PT&p!W&sT&q!W&sT2^,x2_",
  nodeNames: "⚠ ArithOp ArithOp ?. JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList in out const TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression TypeArgList CompareOp < declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression InstantiationExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast < ArrowFunction TypeParamList SequenceExpression InstantiationExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate asserts is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration defer ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 380,
  context: trackNewline,
  nodeProps: [
    ["isolate", -8, 5, 6, 14, 37, 39, 51, 53, 55, ""],
    ["group", -26, 9, 17, 19, 68, 207, 211, 215, 216, 218, 221, 224, 234, 237, 243, 245, 247, 249, 252, 258, 264, 266, 268, 270, 272, 274, 275, "Statement", -34, 13, 14, 32, 35, 36, 42, 51, 54, 55, 57, 62, 70, 72, 76, 80, 82, 84, 85, 110, 111, 120, 121, 136, 139, 141, 142, 143, 144, 145, 147, 148, 167, 169, 171, "Expression", -23, 31, 33, 37, 41, 43, 45, 173, 175, 177, 178, 180, 181, 182, 184, 185, 186, 188, 189, 190, 201, 203, 205, 206, "Type", -3, 88, 103, 109, "ClassItem"],
    ["openedBy", 23, "<", 38, "InterpolationStart", 56, "[", 60, "{", 73, "(", 160, "JSXStartCloseTag"],
    ["closedBy", -2, 24, 168, ">", 40, "InterpolationEnd", 50, "]", 61, "}", 74, ")", 165, "JSXEndTag"]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0, 5, 6, 278],
  repeatNodeCount: 37,
  tokenData: "$Fq07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$,r!c!}Er!}#O$-|#O#P$/W#P#Q$4o#Q#R$5y#R#SEr#S#T$7W#T#o$8b#o#p$<r#p#q$=h#q#r$>x#r#s$@U#s$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$I|Er$I|$I}$Dk$I}$JO$Dk$JO$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr(n%d_$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$i&j(Wp(Z!b'|0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(X#S$i&j'}0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$i&j(Wp(Z!b'}0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$i&j!p),Q(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#v(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(V':f$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$i&j(Z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$i&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$d`$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$d``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$d`$i&j(Z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(Z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$d`(Z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$i&j(Wp(Z!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__WS$i&j(Wp(Z!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]WS$i&j(Z!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXWS$i&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSWSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWWS(Z!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]WS$i&j(WpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWWS(WpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYWS(Wp(Z!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$i&j(o%1l(Wp(Z!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$i&j(Wp(Z!b$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$i&j(Wp(Z!b$]#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$i&j(Wp(Z!b#p(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$i&j$Q(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(z+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$i&j#z(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(Y';W$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$i&j(WpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$i&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$d`$i&j(WpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(WpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$d`(WpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$i&j(Wp(Z!b(U%&f#q(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$i&j(Wp(Z!b#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$i&j(Wp(Z!br+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!]+Jf$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$i&j(Wp(Z!b!Q.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_![!L^$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$i&j(Wp(Z!b#o(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$i&j(Z!b!X7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$i&j!X7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$i&j!X7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!X7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!X7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$i&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$i&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$i&j(Z!b!X7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(Z!b!X7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(Z!b!X7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(Z!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$i&j(Z!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$i&j(Wp!X7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$i&j(Wp!X7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Wp!X7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Wp!X7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(WpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$i&j(WpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$i&j(Wp(Z!b!X7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Wp(Z!b!X7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Wp(Z!b!X7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Wp(Z!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$i&j(Wp(Z!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$i&j(Wp(Z!b(O0/l!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$i&j(Wp(Z!bT0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$i&j(Z!bT0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$i&jT0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iST0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(Z!bT0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$i&j(WpT0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(WpT0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Wp(Z!bT0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$i&j$Q(Ch(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$Z#t$i&j(Wp(Z!b!X7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$i&j(Wp(Z!bs'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!g$b$i&j$O)Lv(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_al$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^h#)`#R-<U(Wp(Z!b$n7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$k&j(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#r(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$Q(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#s(Ch(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#`*!Y$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#k(Cl$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vag!*r#s(Ch$f#|$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#s(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#r(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(Kd$*`a(r(Ct$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!a%Z!a!b$+e!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$+p`$i&j#{(Ch(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$,}_!|$Ip$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$.X_!S0,v$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/]Z$i&jO!^$0O!^!_$0f!_#i$0O#i#j$0k#j#l$0O#l#m$2^#m#o$0O#o#p$0f#p;'S$0O;'S;=`$4i<%lO$0O(n$0VT_#S$i&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0kO_#S(n$0p[$i&jO!Q&c!Q![$1f![!^&c!_!c&c!c!i$1f!i#T&c#T#Z$1f#Z#o&c#o#p$3|#p;'S&c;'S;=`&w<%lO&c(n$1kZ$i&jO!Q&c!Q![$2^![!^&c!_!c&c!c!i$2^!i#T&c#T#Z$2^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2cZ$i&jO!Q&c!Q![$3U![!^&c!_!c&c!c!i$3U!i#T&c#T#Z$3U#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3ZZ$i&jO!Q&c!Q![$0O![!^&c!_!c&c!c!i$0O!i#T&c#T#Z$0O#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$4PR!Q![$4Y!c!i$4Y#T#Z$4Y#S$4]S!Q![$4Y!c!i$4Y#T#Z$4Y#q#r$0f(n$4lP;=`<%l$0O#1[$4z_!Y#)l$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$6U`#x(Ch$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$7c_$i&j(Wp(Z!b(a+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$8qk$i&j(Wp(Z!b(T,2j$_#t(e$I[OY%ZYZ&cZr%Zrs&}st%Ztu$8buw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$8b![!^%Z!^!_*g!_!c%Z!c!}$8b!}#O%Z#O#P&c#P#R%Z#R#S$8b#S#T%Z#T#o$8b#o#p*g#p$g%Z$g;'S$8b;'S;=`$<l<%lO$8b+d$:qk$i&j(Wp(Z!b$_#tOY%ZYZ&cZr%Zrs&}st%Ztu$:fuw%Zwx(rx}%Z}!O$:f!O!Q%Z!Q![$:f![!^%Z!^!_*g!_!c%Z!c!}$:f!}#O%Z#O#P&c#P#R%Z#R#S$:f#S#T%Z#T#o$:f#o#p*g#p$g%Z$g;'S$:f;'S;=`$<f<%lO$:f+d$<iP;=`<%l$:f07[$<oP;=`<%l$8b#Jf$<{X!_#Hb(Wp(Z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$=sa(y+JY$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+e#q;'S%Z;'S;=`+a<%lO%Z)>v$?V_!^(CdvBr$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$@a_!q7`$i&j(Wp(Z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$Aq|$i&j(Wp(Z!b'|0/l$]#t(T,2j(e$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$A`#BZ$ISEr$IS$I_$A`$I_$JTEr$JT$JU$A`$JU$KVEr$KV$KW$A`$KW&FUEr&FU&FV$A`&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$A`?HUOEr07[$D|k$i&j(Wp(Z!b'}0/l$]#t(T,2j(e$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [noSemicolon, noSemicolonType, operatorToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, insertSemicolon, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOx~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!U~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(c~~", 141, 340), new LocalTokenGroup("j~RQYZXz{^~^O(Q~~aP!P!Qd~iO(R~~", 25, 323)],
  topRules: { "Script": [0, 7], "SingleExpression": [1, 276], "SingleClassItem": [2, 277] },
  dialects: { jsx: 0, ts: 15175 },
  dynamicPrecedences: { "80": 1, "82": 1, "94": 1, "169": 1, "199": 1 },
  specialized: [{ term: 327, get: (value) => spec_identifier[value] || -1 }, { term: 343, get: (value) => spec_word[value] || -1 }, { term: 95, get: (value) => spec_LessThan[value] || -1 }],
  tokenPrec: 15201
});
const snippets = [
  /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
const typescriptSnippets = /* @__PURE__ */ snippets.concat([
  /* @__PURE__ */ snippetCompletion("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]);
const cache$1 = /* @__PURE__ */ new NodeWeakMap();
const ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function defID(type2) {
  return (node2, def) => {
    let id2 = node2.node.getChild("VariableDefinition");
    if (id2)
      def(id2, type2);
    return true;
  };
}
const functionContext = ["FunctionDeclaration"];
const gatherCompletions = {
  FunctionDeclaration: /* @__PURE__ */ defID("function"),
  ClassDeclaration: /* @__PURE__ */ defID("class"),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ defID("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
  NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
  VariableDefinition(node2, def) {
    if (!node2.matchContext(functionContext))
      def(node2, "variable");
  },
  TypeDefinition(node2, def) {
    def(node2, "type");
  },
  __proto__: null
};
function getScope(doc2, node2) {
  let cached = cache$1.get(node2);
  if (cached)
    return cached;
  let completions = [], top2 = true;
  function def(node3, type2) {
    let name2 = doc2.sliceString(node3.from, node3.to);
    completions.push({ label: name2, type: type2 });
  }
  node2.cursor(IterMode.IncludeAnonymous).iterate((node3) => {
    if (top2) {
      top2 = false;
    } else if (node3.name) {
      let gather = gatherCompletions[node3.name];
      if (gather && gather(node3, def) || ScopeNodes.has(node3.name))
        return false;
    } else if (node3.to - node3.from > 8192) {
      for (let c2 of getScope(doc2, node3.node))
        completions.push(c2);
      return false;
    }
  });
  cache$1.set(node2, completions);
  return completions;
}
const Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
const dontComplete = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  "JSXText",
  "JSXAttributeValue",
  "JSXOpenTag",
  "JSXCloseTag",
  "JSXSelfClosingTag",
  ".",
  "?."
];
function localCompletionSource(context) {
  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options = options.concat(getScope(context.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
function pathFor(read, member, name2) {
  var _a2;
  let path = [];
  for (; ; ) {
    let obj = member.firstChild, prop;
    if ((obj === null || obj === void 0 ? void 0 : obj.name) == "VariableName") {
      path.push(read(obj));
      return { path: path.reverse(), name: name2 };
    } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == "MemberExpression" && ((_a2 = prop = obj.lastChild) === null || _a2 === void 0 ? void 0 : _a2.name) == "PropertyName") {
      path.push(read(prop));
      member = obj;
    } else {
      return null;
    }
  }
}
function completionPath(context) {
  let read = (node2) => context.state.doc.sliceString(node2.from, node2.to);
  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
  if (inner.name == "PropertyName") {
    return pathFor(read, inner.parent, read(inner));
  } else if ((inner.name == "." || inner.name == "?.") && inner.parent.name == "MemberExpression") {
    return pathFor(read, inner.parent, "");
  } else if (dontComplete.indexOf(inner.name) > -1) {
    return null;
  } else if (inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {
    return { path: [], name: read(inner) };
  } else if (inner.name == "MemberExpression") {
    return pathFor(read, inner, "");
  } else {
    return context.explicit ? { path: [], name: "" } : null;
  }
}
function enumeratePropertyCompletions(obj, top2) {
  let options = [], seen = /* @__PURE__ */ new Set();
  for (let depth2 = 0; ; depth2++) {
    for (let name2 of (Object.getOwnPropertyNames || Object.keys)(obj)) {
      if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(name2) || seen.has(name2))
        continue;
      seen.add(name2);
      let value;
      try {
        value = obj[name2];
      } catch (_) {
        continue;
      }
      options.push({
        label: name2,
        type: typeof value == "function" ? /^[A-Z]/.test(name2) ? "class" : top2 ? "function" : "method" : top2 ? "variable" : "property",
        boost: -depth2
      });
    }
    let next = Object.getPrototypeOf(obj);
    if (!next)
      return options;
    obj = next;
  }
}
function scopeCompletionSource(scope) {
  let cache2 = /* @__PURE__ */ new Map();
  return (context) => {
    let path = completionPath(context);
    if (!path)
      return null;
    let target = scope;
    for (let step of path.path) {
      target = target[step];
      if (!target)
        return null;
    }
    let options = cache2.get(target);
    if (!options)
      cache2.set(target, options = enumeratePropertyCompletions(target, !path.path.length));
    return {
      from: context.pos - path.name.length,
      options,
      validFor: Identifier
    };
  };
}
const javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
  name: "javascript",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        },
        Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^\s*{/ }),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": foldInside,
        BlockComment(tree) {
          return { from: tree.from + 2, to: tree.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
const jsxSublanguage = {
  test: (node2) => /^JSX/.test(node2.name),
  facet: /* @__PURE__ */ defineLanguageFacet({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
const typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" }, "typescript");
const jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ sublanguageProp.add((n2) => n2.isTop ? [jsxSublanguage] : void 0)]
});
const tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ sublanguageProp.add((n2) => n2.isTop ? [jsxSublanguage] : void 0)]
}, "typescript");
let kwCompletion = (name2) => ({ label: name2, type: "keyword" });
const keywords$1 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
const typescriptKeywords = /* @__PURE__ */ keywords$1.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(kwCompletion));
function javascript(config2 = {}) {
  let lang = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
  let completions = config2.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords$1);
  return new LanguageSupport(lang, [
    javascriptLanguage.data.of({
      autocomplete: ifNotIn(dontComplete, completeFromList(completions))
    }),
    javascriptLanguage.data.of({
      autocomplete: localCompletionSource
    }),
    config2.jsx ? autoCloseTags : []
  ]);
}
function findOpenTag(node2) {
  for (; ; ) {
    if (node2.name == "JSXOpenTag" || node2.name == "JSXSelfClosingTag" || node2.name == "JSXFragmentTag")
      return node2;
    if (node2.name == "JSXEscape" || !node2.parent)
      return null;
    node2 = node2.parent;
  }
}
function elementName(doc2, tree, max = doc2.length) {
  for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
    if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" || ch.name == "JSXMemberExpression")
      return doc2.sliceString(ch.from, Math.min(ch.to, max));
  }
  return "";
}
const android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
const autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != ">" && text != "/" || !javascriptLanguage.isActiveAt(view.state, from, -1))
    return false;
  let base2 = defaultInsert(), { state } = base2;
  let closeTags = state.changeByRange((range) => {
    var _a2;
    let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name2;
    if (around.name == "JSXStartTag")
      around = around.parent;
    if (state.doc.sliceString(head - 1, head) != text || around.name == "JSXAttributeValue" && around.to > head) ;
    else if (text == ">" && around.name == "JSXFragmentTag") {
      return { range, changes: { from: head, insert: `</>` } };
    } else if (text == "/" && around.name == "JSXStartCloseTag") {
      let empty2 = around.parent, base3 = empty2.parent;
      if (base3 && empty2.from == head - 2 && ((name2 = elementName(state.doc, base3.firstChild, head)) || ((_a2 = base3.firstChild) === null || _a2 === void 0 ? void 0 : _a2.name) == "JSXFragmentTag")) {
        let insert2 = `${name2}>`;
        return { range: EditorSelection.cursor(head + insert2.length, -1), changes: { from: head, insert: insert2 } };
      }
    } else if (text == ">") {
      let openTag = findOpenTag(around);
      if (openTag && openTag.name == "JSXOpenTag" && !/^\/?>|^<\//.test(state.doc.sliceString(head, head + 2)) && (name2 = elementName(state.doc, openTag, head)))
        return { range, changes: { from: head, insert: `</${name2}>` } };
    }
    return { range };
  });
  if (closeTags.changes.empty)
    return false;
  view.dispatch([
    base2,
    state.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
  ]);
  return true;
});
function esLint(eslint2, config2) {
  if (!config2) {
    config2 = {
      parserOptions: { ecmaVersion: 2019, sourceType: "module" },
      env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
      rules: {}
    };
    eslint2.getRules().forEach((desc, name2) => {
      var _a2;
      if ((_a2 = desc.meta.docs) === null || _a2 === void 0 ? void 0 : _a2.recommended)
        config2.rules[name2] = 2;
    });
  }
  return (view) => {
    let { state } = view, found = [];
    for (let { from, to } of javascriptLanguage.findRegions(state)) {
      let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };
      for (let d2 of eslint2.verify(state.sliceDoc(from, to), config2))
        found.push(translateDiagnostic(d2, state.doc, offset));
    }
    return found;
  };
}
function mapPos(line, col, doc2, offset) {
  return doc2.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);
}
function translateDiagnostic(input, doc2, offset) {
  let start = mapPos(input.line, input.column, doc2, offset);
  let result = {
    from: start,
    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc2, offset) : start,
    message: input.message,
    source: input.ruleId ? "eslint:" + input.ruleId : "eslint",
    severity: input.severity == 1 ? "warning" : "error"
  };
  if (input.fix) {
    let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;
    result.actions = [{
      name: "fix",
      apply(view, start2) {
        view.dispatch({ changes: { from: start2 + from, to: start2 + to, insert: text }, scrollIntoView: true });
      }
    }];
  }
  return result;
}
const Lang_J = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  autoCloseTags,
  completionPath,
  esLint,
  javascript,
  javascriptLanguage,
  jsxLanguage,
  localCompletionSource,
  scopeCompletionSource,
  snippets,
  tsxLanguage,
  typescriptLanguage,
  typescriptSnippets
}, Symbol.toStringTag, { value: "Module" }));
class LocalUpdate {
  constructor(origin, changes, effects, clientID) {
    this.origin = origin;
    this.changes = changes;
    this.effects = effects;
    this.clientID = clientID;
  }
}
class CollabState {
  constructor(version2, unconfirmed) {
    this.version = version2;
    this.unconfirmed = unconfirmed;
  }
}
const collabConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let combined = combineConfig(configs, { startVersion: 0, clientID: null, sharedEffects: () => [] }, {
      generatedID: (a2) => a2
    });
    if (combined.clientID == null)
      combined.clientID = configs.length && configs[0].generatedID || "";
    return combined;
  }
});
const collabReceive = /* @__PURE__ */ Annotation.define();
const collabField = /* @__PURE__ */ StateField.define({
  create(state) {
    return new CollabState(state.facet(collabConfig).startVersion, []);
  },
  update(collab2, tr) {
    let isSync = tr.annotation(collabReceive);
    if (isSync)
      return isSync;
    let { sharedEffects, clientID } = tr.startState.facet(collabConfig);
    let effects = sharedEffects(tr);
    if (effects.length || !tr.changes.empty)
      return new CollabState(collab2.version, collab2.unconfirmed.concat(new LocalUpdate(tr, tr.changes, effects, clientID)));
    return collab2;
  }
});
function collab(config2 = {}) {
  return [collabField, collabConfig.of(Object.assign({ generatedID: Math.floor(Math.random() * 1e9).toString(36) }, config2))];
}
function receiveUpdates(state, updates) {
  let { version: version2, unconfirmed } = state.field(collabField);
  let { clientID } = state.facet(collabConfig);
  version2 += updates.length;
  let effects = [], changes = null;
  let own = 0;
  for (let update of updates) {
    let ours = own < unconfirmed.length ? unconfirmed[own] : null;
    if (ours && ours.clientID == update.clientID) {
      if (changes)
        changes = changes.map(ours.changes, true);
      effects = StateEffect.mapEffects(effects, update.changes);
      own++;
    } else {
      effects = StateEffect.mapEffects(effects, update.changes);
      if (update.effects)
        effects = effects.concat(update.effects);
      changes = changes ? changes.compose(update.changes) : update.changes;
    }
  }
  if (own)
    unconfirmed = unconfirmed.slice(own);
  if (unconfirmed.length) {
    if (changes)
      unconfirmed = unconfirmed.map((update) => {
        let updateChanges = update.changes.map(changes);
        changes = changes.map(update.changes, true);
        return new LocalUpdate(update.origin, updateChanges, StateEffect.mapEffects(update.effects, changes), clientID);
      });
    if (effects.length) {
      let composed = unconfirmed.reduce((ch, u2) => ch.compose(u2.changes), ChangeSet.empty(unconfirmed[0].changes.length));
      effects = StateEffect.mapEffects(effects, composed);
    }
  }
  if (!changes)
    return state.update({ annotations: [collabReceive.of(new CollabState(version2, unconfirmed))] });
  return state.update({
    changes,
    effects,
    annotations: [
      Transaction.addToHistory.of(false),
      Transaction.remote.of(true),
      collabReceive.of(new CollabState(version2, unconfirmed))
    ],
    filter: false
  });
}
function sendableUpdates(state) {
  return state.field(collabField).unconfirmed;
}
function getSyncedVersion(state) {
  return state.field(collabField).version;
}
function getClientID(state) {
  return state.facet(collabConfig).clientID;
}
function rebaseUpdates(updates, over) {
  if (!over.length || !updates.length)
    return updates;
  let changes = null, skip = 0;
  for (let update of over) {
    let other = skip < updates.length ? updates[skip] : null;
    if (other && other.clientID == update.clientID) {
      if (changes)
        changes = changes.mapDesc(other.changes, true);
      skip++;
    } else {
      changes = changes ? changes.composeDesc(update.changes) : update.changes;
    }
  }
  if (skip)
    updates = updates.slice(skip);
  return !changes ? updates : updates.map((update) => {
    let updateChanges = update.changes.map(changes);
    changes = changes.mapDesc(update.changes, true);
    return {
      changes: updateChanges,
      effects: update.effects && StateEffect.mapEffects(update.effects, changes),
      clientID: update.clientID
    };
  });
}
const Collab = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  collab,
  getClientID,
  getSyncedVersion,
  rebaseUpdates,
  receiveUpdates,
  sendableUpdates
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$3 = {};
if (!global) {
  var global = globalThis || window;
}
function getDefaultExportFromNamespaceIfPresent(n2) {
  return n2 && Object.prototype.hasOwnProperty.call(n2, "default") ? n2["default"] : n2;
}
var eslintLinterBrowserify = {};
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title$1 = "browser";
var platform = "browser";
var browser$2 = true;
var env = {};
var argv = [];
var version$2 = "";
var versions = {};
var release = {};
var config$1 = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name2) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick,
  title: title$1,
  browser: browser$2,
  env,
  argv,
  version: version$2,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config: config$1,
  uptime
};
var eslintScope = {};
var estraverse = {};
var hasRequiredEstraverse;
function requireEstraverse() {
  if (hasRequiredEstraverse) return estraverse;
  hasRequiredEstraverse = 1;
  (function(exports$1) {
    (function clone(exports$12) {
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i2, current;
        len = array.length;
        i2 = 0;
        while (len) {
          diff = len >>> 1;
          current = i2 + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i2 = current + 1;
            len -= diff + 1;
          }
        }
        return i2;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace3(node2) {
        this.parent[this.key] = node2;
      };
      Reference.prototype.remove = function remove2() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node2, path, wrap, ref2) {
        this.node = node2;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref2;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i2, iz, j, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2)) {
            for (j = 0, jz = path2.length; j < jz; ++j) {
              result2.push(path2[j]);
            }
          } else {
            result2.push(path2);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i2 = 2, iz = this.__leavelist.length; i2 < iz; ++i2) {
          element = this.__leavelist[i2];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node2 = this.current();
        return node2.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i2, iz, result;
        result = [];
        for (i2 = 1, iz = this.__leavelist.length; i2 < iz; ++i2) {
          result.push(this.__leavelist[i2].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node2) {
        if (node2 == null) {
          return false;
        }
        return typeof node2 === "object" && typeof node2.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i2 = leavelist.length - 1; i2 >= 0; --i2) {
          if (leavelist[i2].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node2, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node2 = element.node;
            nodeType = node2.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node2);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node2[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace3(root, visitor) {
        var worklist, leavelist, node2, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i2, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i2 = worklist.length;
            while (i2--) {
              nextElem = worklist[i2];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node2 = element.node;
          if (!node2) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node2.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node2);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node2[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node2, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace2(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment2, tokens) {
        var target;
        target = upperBound(tokens, function search2(token) {
          return token.range[0] > comment2.range[0];
        });
        comment2.extendedRange = [comment2.range[0], comment2.range[1]];
        if (target !== tokens.length) {
          comment2.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment2.extendedRange[0] = tokens[target].range[1];
        }
        return comment2;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment2, len, i2, cursor2;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i2 = 0, len = providedComments.length; i2 < len; i2 += 1) {
              comment2 = deepCopy(providedComments[i2]);
              comment2.extendedRange = [0, tree.range[0]];
              comments.push(comment2);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i2 = 0, len = providedComments.length; i2 < len; i2 += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i2]), tokens));
        }
        cursor2 = 0;
        traverse(tree, {
          enter: function(node2) {
            var comment3;
            while (cursor2 < comments.length) {
              comment3 = comments[cursor2];
              if (comment3.extendedRange[1] > node2.range[0]) {
                break;
              }
              if (comment3.extendedRange[1] === node2.range[0]) {
                if (!node2.leadingComments) {
                  node2.leadingComments = [];
                }
                node2.leadingComments.push(comment3);
                comments.splice(cursor2, 1);
              } else {
                cursor2 += 1;
              }
            }
            if (cursor2 === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor2].extendedRange[0] > node2.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor2 = 0;
        traverse(tree, {
          leave: function(node2) {
            var comment3;
            while (cursor2 < comments.length) {
              comment3 = comments[cursor2];
              if (node2.range[1] < comment3.extendedRange[0]) {
                break;
              }
              if (node2.range[1] === comment3.extendedRange[0]) {
                if (!node2.trailingComments) {
                  node2.trailingComments = [];
                }
                node2.trailingComments.push(comment3);
                comments.splice(cursor2, 1);
              } else {
                cursor2 += 1;
              }
            }
            if (cursor2 === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor2].extendedRange[0] > node2.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports$12.Syntax = Syntax;
      exports$12.traverse = traverse;
      exports$12.replace = replace2;
      exports$12.attachComments = attachComments;
      exports$12.VisitorKeys = VisitorKeys;
      exports$12.VisitorOption = VisitorOption;
      exports$12.Controller = Controller;
      exports$12.cloneEnvironment = function() {
        return clone({});
      };
      return exports$12;
    })(exports$1);
  })(estraverse);
  return estraverse;
}
var esrecurse = {};
var version$1 = "4.3.0";
var require$$1$1 = {
  version: version$1
};
var hasRequiredEsrecurse;
function requireEsrecurse() {
  if (hasRequiredEsrecurse) return esrecurse;
  hasRequiredEsrecurse = 1;
  (function() {
    var estraverse2 = requireEstraverse();
    function isNode(node2) {
      if (node2 == null) {
        return false;
      }
      return typeof node2 === "object" && typeof node2.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === estraverse2.Syntax.ObjectExpression || nodeType === estraverse2.Syntax.ObjectPattern) && key === "properties";
    }
    function Visitor(visitor, options) {
      options = options || {};
      this.__visitor = visitor || this;
      this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse2.VisitorKeys, options.childVisitorKeys) : estraverse2.VisitorKeys;
      if (options.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof options.fallback === "function") {
        this.__fallback = options.fallback;
      }
    }
    Visitor.prototype.visitChildren = function(node2) {
      var type2, children, i2, iz, j, jz, child;
      if (node2 == null) {
        return;
      }
      type2 = node2.type || estraverse2.Syntax.Property;
      children = this.__childVisitorKeys[type2];
      if (!children) {
        if (this.__fallback) {
          children = this.__fallback(node2);
        } else {
          throw new Error("Unknown node type " + type2 + ".");
        }
      }
      for (i2 = 0, iz = children.length; i2 < iz; ++i2) {
        child = node2[children[i2]];
        if (child) {
          if (Array.isArray(child)) {
            for (j = 0, jz = child.length; j < jz; ++j) {
              if (child[j]) {
                if (isNode(child[j]) || isProperty(type2, children[i2])) {
                  this.visit(child[j]);
                }
              }
            }
          } else if (isNode(child)) {
            this.visit(child);
          }
        }
      }
    };
    Visitor.prototype.visit = function(node2) {
      var type2;
      if (node2 == null) {
        return;
      }
      type2 = node2.type || estraverse2.Syntax.Property;
      if (this.__visitor[type2]) {
        this.__visitor[type2].call(this, node2);
        return;
      }
      this.visitChildren(node2);
    };
    esrecurse.version = require$$1$1.version;
    esrecurse.Visitor = Visitor;
    esrecurse.visit = function(node2, visitor, options) {
      var v2 = new Visitor(visitor, options);
      v2.visit(node2);
    };
  })();
  return esrecurse;
}
var hasRequiredEslintScope;
function requireEslintScope() {
  if (hasRequiredEslintScope) return eslintScope;
  hasRequiredEslintScope = 1;
  Object.defineProperty(eslintScope, "__esModule", { value: true });
  var estraverse2 = requireEstraverse();
  var esrecurse2 = requireEsrecurse();
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
  }
  var estraverse__default = /* @__PURE__ */ _interopDefaultLegacy(estraverse2);
  var esrecurse__default = /* @__PURE__ */ _interopDefaultLegacy(esrecurse2);
  function assert2(condition, message = "Assertion failed.") {
    if (!condition) {
      throw new Error(message);
    }
  }
  const READ = 1;
  const WRITE = 2;
  const RW = READ | WRITE;
  class Reference {
    constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
      this.identifier = ident;
      this.from = scope;
      this.tainted = false;
      this.resolved = null;
      this.flag = flag;
      if (this.isWrite()) {
        this.writeExpr = writeExpr;
        this.partial = partial;
        this.init = init;
      }
      this.__maybeImplicitGlobal = maybeImplicitGlobal;
    }
    /**
     * Whether the reference is static.
     * @function Reference#isStatic
     * @returns {boolean} static
     */
    isStatic() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }
    /**
     * Whether the reference is writeable.
     * @function Reference#isWrite
     * @returns {boolean} write
     */
    isWrite() {
      return !!(this.flag & Reference.WRITE);
    }
    /**
     * Whether the reference is readable.
     * @function Reference#isRead
     * @returns {boolean} read
     */
    isRead() {
      return !!(this.flag & Reference.READ);
    }
    /**
     * Whether the reference is read-only.
     * @function Reference#isReadOnly
     * @returns {boolean} read only
     */
    isReadOnly() {
      return this.flag === Reference.READ;
    }
    /**
     * Whether the reference is write-only.
     * @function Reference#isWriteOnly
     * @returns {boolean} write only
     */
    isWriteOnly() {
      return this.flag === Reference.WRITE;
    }
    /**
     * Whether the reference is read-write.
     * @function Reference#isReadWrite
     * @returns {boolean} read write
     */
    isReadWrite() {
      return this.flag === Reference.RW;
    }
  }
  Reference.READ = READ;
  Reference.WRITE = WRITE;
  Reference.RW = RW;
  class Variable {
    constructor(name2, scope) {
      this.name = name2;
      this.identifiers = [];
      this.references = [];
      this.defs = [];
      this.tainted = false;
      this.stack = true;
      this.scope = scope;
    }
  }
  Variable.CatchClause = "CatchClause";
  Variable.Parameter = "Parameter";
  Variable.FunctionName = "FunctionName";
  Variable.ClassName = "ClassName";
  Variable.Variable = "Variable";
  Variable.ImportBinding = "ImportBinding";
  Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
  class Definition {
    constructor(type2, name2, node2, parent, index, kind) {
      this.type = type2;
      this.name = name2;
      this.node = node2;
      this.parent = parent;
      this.index = index;
      this.kind = kind;
    }
  }
  class ParameterDefinition extends Definition {
    constructor(name2, node2, index, rest) {
      super(Variable.Parameter, name2, node2, null, index, null);
      this.rest = rest;
    }
  }
  const { Syntax: Syntax$2 } = estraverse__default["default"];
  function isStrictScope(scope, block, isMethodDefinition) {
    let body;
    if (scope.upper && scope.upper.isStrict) {
      return true;
    }
    if (isMethodDefinition) {
      return true;
    }
    if (scope.type === "class" || scope.type === "module") {
      return true;
    }
    if (scope.type === "block" || scope.type === "switch") {
      return false;
    }
    if (scope.type === "function") {
      if (block.type === Syntax$2.ArrowFunctionExpression && block.body.type !== Syntax$2.BlockStatement) {
        return false;
      }
      if (block.type === Syntax$2.Program) {
        body = block;
      } else {
        body = block.body;
      }
      if (!body) {
        return false;
      }
    } else if (scope.type === "global") {
      body = block;
    } else {
      return false;
    }
    for (let i2 = 0, iz = body.body.length; i2 < iz; ++i2) {
      const stmt = body.body[i2];
      if (typeof stmt.directive !== "string") {
        break;
      }
      if (stmt.directive === "use strict") {
        return true;
      }
    }
    return false;
  }
  function registerScope(scopeManager, scope) {
    scopeManager.scopes.push(scope);
    const scopes = scopeManager.__nodeToScope.get(scope.block);
    if (scopes) {
      scopes.push(scope);
    } else {
      scopeManager.__nodeToScope.set(scope.block, [scope]);
    }
  }
  function shouldBeStatically(def) {
    return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
  }
  class Scope {
    constructor(scopeManager, type2, upperScope, block, isMethodDefinition) {
      this.type = type2;
      this.set = /* @__PURE__ */ new Map();
      this.taints = /* @__PURE__ */ new Map();
      this.dynamic = this.type === "global" || this.type === "with";
      this.block = block;
      this.through = [];
      this.variables = [];
      this.references = [];
      this.variableScope = this.type === "global" || this.type === "module" || this.type === "function" || this.type === "class-field-initializer" || this.type === "class-static-block" ? this : upperScope.variableScope;
      this.functionExpressionScope = false;
      this.directCallToEvalScope = false;
      this.thisFound = false;
      this.__left = [];
      this.upper = upperScope;
      this.isStrict = scopeManager.isStrictModeSupported() ? isStrictScope(this, block, isMethodDefinition) : false;
      this.childScopes = [];
      if (this.upper) {
        this.upper.childScopes.push(this);
      }
      this.__declaredVariables = scopeManager.__declaredVariables;
      registerScope(scopeManager, this);
    }
    __shouldStaticallyClose(scopeManager) {
      return !this.dynamic || scopeManager.__isOptimistic();
    }
    __shouldStaticallyCloseForGlobal(ref2) {
      const name2 = ref2.identifier.name;
      if (!this.set.has(name2)) {
        return false;
      }
      const variable = this.set.get(name2);
      const defs = variable.defs;
      return defs.length > 0 && defs.every(shouldBeStatically);
    }
    __staticCloseRef(ref2) {
      if (!this.__resolve(ref2)) {
        this.__delegateToUpperScope(ref2);
      }
    }
    __dynamicCloseRef(ref2) {
      let current = this;
      do {
        current.through.push(ref2);
        current = current.upper;
      } while (current);
    }
    __globalCloseRef(ref2) {
      if (this.__shouldStaticallyCloseForGlobal(ref2)) {
        this.__staticCloseRef(ref2);
      } else {
        this.__dynamicCloseRef(ref2);
      }
    }
    __close(scopeManager) {
      let closeRef;
      if (this.__shouldStaticallyClose(scopeManager)) {
        closeRef = this.__staticCloseRef;
      } else if (this.type !== "global") {
        closeRef = this.__dynamicCloseRef;
      } else {
        closeRef = this.__globalCloseRef;
      }
      for (let i2 = 0, iz = this.__left.length; i2 < iz; ++i2) {
        const ref2 = this.__left[i2];
        closeRef.call(this, ref2);
      }
      this.__left = null;
      return this.upper;
    }
    // To override by function scopes.
    // References in default parameters isn't resolved to variables which are in their function body.
    __isValidResolution(ref2, variable) {
      return true;
    }
    __resolve(ref2) {
      const name2 = ref2.identifier.name;
      if (!this.set.has(name2)) {
        return false;
      }
      const variable = this.set.get(name2);
      if (!this.__isValidResolution(ref2, variable)) {
        return false;
      }
      variable.references.push(ref2);
      variable.stack = variable.stack && ref2.from.variableScope === this.variableScope;
      if (ref2.tainted) {
        variable.tainted = true;
        this.taints.set(variable.name, true);
      }
      ref2.resolved = variable;
      return true;
    }
    __delegateToUpperScope(ref2) {
      if (this.upper) {
        this.upper.__left.push(ref2);
      }
      this.through.push(ref2);
    }
    __addDeclaredVariablesOfNode(variable, node2) {
      if (node2 === null || node2 === void 0) {
        return;
      }
      let variables = this.__declaredVariables.get(node2);
      if (variables === null || variables === void 0) {
        variables = [];
        this.__declaredVariables.set(node2, variables);
      }
      if (!variables.includes(variable)) {
        variables.push(variable);
      }
    }
    __defineGeneric(name2, set, variables, node2, def) {
      let variable;
      variable = set.get(name2);
      if (!variable) {
        variable = new Variable(name2, this);
        set.set(name2, variable);
        variables.push(variable);
      }
      if (def) {
        variable.defs.push(def);
        this.__addDeclaredVariablesOfNode(variable, def.node);
        this.__addDeclaredVariablesOfNode(variable, def.parent);
      }
      if (node2) {
        variable.identifiers.push(node2);
      }
    }
    __define(node2, def) {
      if (node2 && node2.type === Syntax$2.Identifier) {
        this.__defineGeneric(
          node2.name,
          this.set,
          this.variables,
          node2,
          def
        );
      }
    }
    __referencing(node2, assign, writeExpr, maybeImplicitGlobal, partial, init) {
      if (!node2 || node2.type !== Syntax$2.Identifier && node2.type !== "JSXIdentifier") {
        return;
      }
      if (node2.name === "super") {
        return;
      }
      const ref2 = new Reference(node2, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
      this.references.push(ref2);
      this.__left.push(ref2);
    }
    __detectEval() {
      let current = this;
      this.directCallToEvalScope = true;
      do {
        current.dynamic = true;
        current = current.upper;
      } while (current);
    }
    __detectThis() {
      this.thisFound = true;
    }
    __isClosed() {
      return this.__left === null;
    }
    /**
     * returns resolved {Reference}
     * @function Scope#resolve
     * @param {Espree.Identifier} ident identifier to be resolved.
     * @returns {Reference} reference
     */
    resolve(ident) {
      let ref2, i2, iz;
      assert2(this.__isClosed(), "Scope should be closed.");
      assert2(ident.type === Syntax$2.Identifier, "Target should be identifier.");
      for (i2 = 0, iz = this.references.length; i2 < iz; ++i2) {
        ref2 = this.references[i2];
        if (ref2.identifier === ident) {
          return ref2;
        }
      }
      return null;
    }
    /**
     * returns this scope is static
     * @function Scope#isStatic
     * @returns {boolean} static
     */
    isStatic() {
      return !this.dynamic;
    }
    /**
     * returns this scope has materialized arguments
     * @function Scope#isArgumentsMaterialized
     * @returns {boolean} arguemnts materialized
     */
    isArgumentsMaterialized() {
      return true;
    }
    /**
     * returns this scope has materialized `this` reference
     * @function Scope#isThisMaterialized
     * @returns {boolean} this materialized
     */
    isThisMaterialized() {
      return true;
    }
    isUsedName(name2) {
      if (this.set.has(name2)) {
        return true;
      }
      for (let i2 = 0, iz = this.through.length; i2 < iz; ++i2) {
        if (this.through[i2].identifier.name === name2) {
          return true;
        }
      }
      return false;
    }
  }
  class GlobalScope extends Scope {
    constructor(scopeManager, block) {
      super(scopeManager, "global", null, block, false);
      this.implicit = {
        set: /* @__PURE__ */ new Map(),
        variables: [],
        /**
         * List of {@link Reference}s that are left to be resolved (i.e. which
         * need to be linked to the variable they refer to).
         * @member {Reference[]} Scope#implicit#left
         */
        left: []
      };
    }
    __close(scopeManager) {
      const implicit = [];
      for (let i2 = 0, iz = this.__left.length; i2 < iz; ++i2) {
        const ref2 = this.__left[i2];
        if (ref2.__maybeImplicitGlobal && !this.set.has(ref2.identifier.name)) {
          implicit.push(ref2.__maybeImplicitGlobal);
        }
      }
      for (let i2 = 0, iz = implicit.length; i2 < iz; ++i2) {
        const info = implicit[i2];
        this.__defineImplicit(
          info.pattern,
          new Definition(
            Variable.ImplicitGlobalVariable,
            info.pattern,
            info.node,
            null,
            null,
            null
          )
        );
      }
      this.implicit.left = this.__left;
      return super.__close(scopeManager);
    }
    __defineImplicit(node2, def) {
      if (node2 && node2.type === Syntax$2.Identifier) {
        this.__defineGeneric(
          node2.name,
          this.implicit.set,
          this.implicit.variables,
          node2,
          def
        );
      }
    }
  }
  class ModuleScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "module", upperScope, block, false);
    }
  }
  class FunctionExpressionNameScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "function-expression-name", upperScope, block, false);
      this.__define(
        block.id,
        new Definition(
          Variable.FunctionName,
          block.id,
          block,
          null,
          null,
          null
        )
      );
      this.functionExpressionScope = true;
    }
  }
  class CatchScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "catch", upperScope, block, false);
    }
  }
  class WithScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "with", upperScope, block, false);
    }
    __close(scopeManager) {
      if (this.__shouldStaticallyClose(scopeManager)) {
        return super.__close(scopeManager);
      }
      for (let i2 = 0, iz = this.__left.length; i2 < iz; ++i2) {
        const ref2 = this.__left[i2];
        ref2.tainted = true;
        this.__delegateToUpperScope(ref2);
      }
      this.__left = null;
      return this.upper;
    }
  }
  class BlockScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "block", upperScope, block, false);
    }
  }
  class SwitchScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "switch", upperScope, block, false);
    }
  }
  class FunctionScope extends Scope {
    constructor(scopeManager, upperScope, block, isMethodDefinition) {
      super(scopeManager, "function", upperScope, block, isMethodDefinition);
      if (this.block.type !== Syntax$2.ArrowFunctionExpression) {
        this.__defineArguments();
      }
    }
    isArgumentsMaterialized() {
      if (this.block.type === Syntax$2.ArrowFunctionExpression) {
        return false;
      }
      if (!this.isStatic()) {
        return true;
      }
      const variable = this.set.get("arguments");
      assert2(variable, "Always have arguments variable.");
      return variable.tainted || variable.references.length !== 0;
    }
    isThisMaterialized() {
      if (!this.isStatic()) {
        return true;
      }
      return this.thisFound;
    }
    __defineArguments() {
      this.__defineGeneric(
        "arguments",
        this.set,
        this.variables,
        null,
        null
      );
      this.taints.set("arguments", true);
    }
    // References in default parameters isn't resolved to variables which are in their function body.
    //     const x = 1
    //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
    //         const x = 2
    //         console.log(a)
    //     }
    __isValidResolution(ref2, variable) {
      if (this.block.type === "Program") {
        return true;
      }
      const bodyStart = this.block.body.range[0];
      return !(variable.scope === this && ref2.identifier.range[0] < bodyStart && // the reference is in the parameter part.
      variable.defs.every((d2) => d2.name.range[0] >= bodyStart));
    }
  }
  class ForScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "for", upperScope, block, false);
    }
  }
  class ClassScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "class", upperScope, block, false);
    }
  }
  class ClassFieldInitializerScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "class-field-initializer", upperScope, block, true);
    }
  }
  class ClassStaticBlockScope extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "class-static-block", upperScope, block, true);
    }
  }
  class ScopeManager {
    constructor(options) {
      this.scopes = [];
      this.globalScope = null;
      this.__nodeToScope = /* @__PURE__ */ new WeakMap();
      this.__currentScope = null;
      this.__options = options;
      this.__declaredVariables = /* @__PURE__ */ new WeakMap();
    }
    __isOptimistic() {
      return this.__options.optimistic;
    }
    __ignoreEval() {
      return this.__options.ignoreEval;
    }
    __isJSXEnabled() {
      return this.__options.jsx === true;
    }
    isGlobalReturn() {
      return this.__options.nodejsScope || this.__options.sourceType === "commonjs";
    }
    isModule() {
      return this.__options.sourceType === "module";
    }
    isImpliedStrict() {
      return this.__options.impliedStrict;
    }
    isStrictModeSupported() {
      return this.__options.ecmaVersion >= 5;
    }
    // Returns appropriate scope for this node.
    __get(node2) {
      return this.__nodeToScope.get(node2);
    }
    /**
     * Get variables that are declared by the node.
     *
     * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
     * If the node declares nothing, this method returns an empty array.
     * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
     * @param {Espree.Node} node a node to get.
     * @returns {Variable[]} variables that declared by the node.
     */
    getDeclaredVariables(node2) {
      return this.__declaredVariables.get(node2) || [];
    }
    /**
     * acquire scope from node.
     * @function ScopeManager#acquire
     * @param {Espree.Node} node node for the acquired scope.
     * @param {?boolean} [inner=false] look up the most inner scope, default value is false.
     * @returns {Scope?} Scope from node
     */
    acquire(node2, inner) {
      function predicate(testScope) {
        if (testScope.type === "function" && testScope.functionExpressionScope) {
          return false;
        }
        return true;
      }
      const scopes = this.__get(node2);
      if (!scopes || scopes.length === 0) {
        return null;
      }
      if (scopes.length === 1) {
        return scopes[0];
      }
      if (inner) {
        for (let i2 = scopes.length - 1; i2 >= 0; --i2) {
          const scope = scopes[i2];
          if (predicate(scope)) {
            return scope;
          }
        }
      } else {
        for (let i2 = 0, iz = scopes.length; i2 < iz; ++i2) {
          const scope = scopes[i2];
          if (predicate(scope)) {
            return scope;
          }
        }
      }
      return null;
    }
    /**
     * acquire all scopes from node.
     * @function ScopeManager#acquireAll
     * @param {Espree.Node} node node for the acquired scope.
     * @returns {Scopes?} Scope array
     */
    acquireAll(node2) {
      return this.__get(node2);
    }
    /**
     * release the node.
     * @function ScopeManager#release
     * @param {Espree.Node} node releasing node.
     * @param {?boolean} [inner=false] look up the most inner scope, default value is false.
     * @returns {Scope?} upper scope for the node.
     */
    release(node2, inner) {
      const scopes = this.__get(node2);
      if (scopes && scopes.length) {
        const scope = scopes[0].upper;
        if (!scope) {
          return null;
        }
        return this.acquire(scope.block, inner);
      }
      return null;
    }
    attach() {
    }
    // eslint-disable-line class-methods-use-this -- Desired as instance method
    detach() {
    }
    // eslint-disable-line class-methods-use-this -- Desired as instance method
    __nestScope(scope) {
      if (scope instanceof GlobalScope) {
        assert2(this.__currentScope === null);
        this.globalScope = scope;
      }
      this.__currentScope = scope;
      return scope;
    }
    __nestGlobalScope(node2) {
      return this.__nestScope(new GlobalScope(this, node2));
    }
    __nestBlockScope(node2) {
      return this.__nestScope(new BlockScope(this, this.__currentScope, node2));
    }
    __nestFunctionScope(node2, isMethodDefinition) {
      return this.__nestScope(new FunctionScope(this, this.__currentScope, node2, isMethodDefinition));
    }
    __nestForScope(node2) {
      return this.__nestScope(new ForScope(this, this.__currentScope, node2));
    }
    __nestCatchScope(node2) {
      return this.__nestScope(new CatchScope(this, this.__currentScope, node2));
    }
    __nestWithScope(node2) {
      return this.__nestScope(new WithScope(this, this.__currentScope, node2));
    }
    __nestClassScope(node2) {
      return this.__nestScope(new ClassScope(this, this.__currentScope, node2));
    }
    __nestClassFieldInitializerScope(node2) {
      return this.__nestScope(new ClassFieldInitializerScope(this, this.__currentScope, node2));
    }
    __nestClassStaticBlockScope(node2) {
      return this.__nestScope(new ClassStaticBlockScope(this, this.__currentScope, node2));
    }
    __nestSwitchScope(node2) {
      return this.__nestScope(new SwitchScope(this, this.__currentScope, node2));
    }
    __nestModuleScope(node2) {
      return this.__nestScope(new ModuleScope(this, this.__currentScope, node2));
    }
    __nestFunctionExpressionNameScope(node2) {
      return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node2));
    }
    __isES6() {
      return this.__options.ecmaVersion >= 6;
    }
  }
  const { Syntax: Syntax$1 } = estraverse__default["default"];
  function getLast(xs) {
    return xs.at(-1) || null;
  }
  class PatternVisitor extends esrecurse__default["default"].Visitor {
    static isPattern(node2) {
      const nodeType = node2.type;
      return nodeType === Syntax$1.Identifier || nodeType === Syntax$1.ObjectPattern || nodeType === Syntax$1.ArrayPattern || nodeType === Syntax$1.SpreadElement || nodeType === Syntax$1.RestElement || nodeType === Syntax$1.AssignmentPattern;
    }
    constructor(options, rootPattern, callback) {
      super(null, options);
      this.rootPattern = rootPattern;
      this.callback = callback;
      this.assignments = [];
      this.rightHandNodes = [];
      this.restElements = [];
    }
    Identifier(pattern2) {
      const lastRestElement = getLast(this.restElements);
      this.callback(pattern2, {
        topLevel: pattern2 === this.rootPattern,
        rest: lastRestElement !== null && lastRestElement !== void 0 && lastRestElement.argument === pattern2,
        assignments: this.assignments
      });
    }
    Property(property) {
      if (property.computed) {
        this.rightHandNodes.push(property.key);
      }
      this.visit(property.value);
    }
    ArrayPattern(pattern2) {
      for (let i2 = 0, iz = pattern2.elements.length; i2 < iz; ++i2) {
        const element = pattern2.elements[i2];
        this.visit(element);
      }
    }
    AssignmentPattern(pattern2) {
      this.assignments.push(pattern2);
      this.visit(pattern2.left);
      this.rightHandNodes.push(pattern2.right);
      this.assignments.pop();
    }
    RestElement(pattern2) {
      this.restElements.push(pattern2);
      this.visit(pattern2.argument);
      this.restElements.pop();
    }
    MemberExpression(node2) {
      if (node2.computed) {
        this.rightHandNodes.push(node2.property);
      }
      this.rightHandNodes.push(node2.object);
    }
    //
    // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
    // By spec, LeftHandSideExpression is Pattern or MemberExpression.
    //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
    // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
    //
    SpreadElement(node2) {
      this.visit(node2.argument);
    }
    ArrayExpression(node2) {
      node2.elements.forEach(this.visit, this);
    }
    AssignmentExpression(node2) {
      this.assignments.push(node2);
      this.visit(node2.left);
      this.rightHandNodes.push(node2.right);
      this.assignments.pop();
    }
    CallExpression(node2) {
      node2.arguments.forEach((a2) => {
        this.rightHandNodes.push(a2);
      });
      this.visit(node2.callee);
    }
  }
  const { Syntax } = estraverse__default["default"];
  function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
    const visitor = new PatternVisitor(options, rootPattern, callback);
    visitor.visit(rootPattern);
    if (referencer !== null && referencer !== void 0) {
      visitor.rightHandNodes.forEach(referencer.visit, referencer);
    }
  }
  class Importer extends esrecurse__default["default"].Visitor {
    constructor(declaration, referencer) {
      super(null, referencer.options);
      this.declaration = declaration;
      this.referencer = referencer;
    }
    visitImport(id2, specifier) {
      this.referencer.visitPattern(id2, (pattern2) => {
        this.referencer.currentScope().__define(
          pattern2,
          new Definition(
            Variable.ImportBinding,
            pattern2,
            specifier,
            this.declaration,
            null,
            null
          )
        );
      });
    }
    ImportNamespaceSpecifier(node2) {
      const local = node2.local || node2.id;
      if (local) {
        this.visitImport(local, node2);
      }
    }
    ImportDefaultSpecifier(node2) {
      const local = node2.local || node2.id;
      this.visitImport(local, node2);
    }
    ImportSpecifier(node2) {
      const local = node2.local || node2.id;
      if (node2.name) {
        this.visitImport(node2.name, node2);
      } else {
        this.visitImport(local, node2);
      }
    }
  }
  class Referencer extends esrecurse__default["default"].Visitor {
    constructor(options, scopeManager) {
      super(null, options);
      this.options = options;
      this.scopeManager = scopeManager;
      this.parent = null;
      this.isInnerMethodDefinition = false;
    }
    currentScope() {
      return this.scopeManager.__currentScope;
    }
    close(node2) {
      while (this.currentScope() && node2 === this.currentScope().block) {
        this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
      }
    }
    pushInnerMethodDefinition(isInnerMethodDefinition) {
      const previous = this.isInnerMethodDefinition;
      this.isInnerMethodDefinition = isInnerMethodDefinition;
      return previous;
    }
    popInnerMethodDefinition(isInnerMethodDefinition) {
      this.isInnerMethodDefinition = isInnerMethodDefinition;
    }
    referencingDefaultValue(pattern2, assignments, maybeImplicitGlobal, init) {
      const scope = this.currentScope();
      assignments.forEach((assignment) => {
        scope.__referencing(
          pattern2,
          Reference.WRITE,
          assignment.right,
          maybeImplicitGlobal,
          pattern2 !== assignment.left,
          init
        );
      });
    }
    visitPattern(node2, options, callback) {
      let visitPatternOptions = options;
      let visitPatternCallback = callback;
      if (typeof options === "function") {
        visitPatternCallback = options;
        visitPatternOptions = { processRightHandNodes: false };
      }
      traverseIdentifierInPattern(
        this.options,
        node2,
        visitPatternOptions.processRightHandNodes ? this : null,
        visitPatternCallback
      );
    }
    visitFunction(node2) {
      let i2, iz;
      if (node2.type === Syntax.FunctionDeclaration) {
        this.currentScope().__define(
          node2.id,
          new Definition(
            Variable.FunctionName,
            node2.id,
            node2,
            null,
            null,
            null
          )
        );
      }
      if (node2.type === Syntax.FunctionExpression && node2.id) {
        this.scopeManager.__nestFunctionExpressionNameScope(node2);
      }
      this.scopeManager.__nestFunctionScope(node2, this.isInnerMethodDefinition);
      const that = this;
      function visitPatternCallback(pattern2, info) {
        that.currentScope().__define(
          pattern2,
          new ParameterDefinition(
            pattern2,
            node2,
            i2,
            info.rest
          )
        );
        that.referencingDefaultValue(pattern2, info.assignments, null, true);
      }
      for (i2 = 0, iz = node2.params.length; i2 < iz; ++i2) {
        this.visitPattern(node2.params[i2], { processRightHandNodes: true }, visitPatternCallback);
      }
      if (node2.rest) {
        this.visitPattern({
          type: "RestElement",
          argument: node2.rest
        }, (pattern2) => {
          this.currentScope().__define(
            pattern2,
            new ParameterDefinition(
              pattern2,
              node2,
              node2.params.length,
              true
            )
          );
        });
      }
      if (node2.body) {
        if (node2.body.type === Syntax.BlockStatement) {
          this.visitChildren(node2.body);
        } else {
          this.visit(node2.body);
        }
      }
      this.close(node2);
    }
    visitClass(node2) {
      if (node2.type === Syntax.ClassDeclaration) {
        this.currentScope().__define(
          node2.id,
          new Definition(
            Variable.ClassName,
            node2.id,
            node2,
            null,
            null,
            null
          )
        );
      }
      this.scopeManager.__nestClassScope(node2);
      if (node2.id) {
        this.currentScope().__define(
          node2.id,
          new Definition(
            Variable.ClassName,
            node2.id,
            node2
          )
        );
      }
      this.visit(node2.superClass);
      this.visit(node2.body);
      this.close(node2);
    }
    visitProperty(node2) {
      let previous;
      if (node2.computed) {
        this.visit(node2.key);
      }
      const isMethodDefinition = node2.type === Syntax.MethodDefinition;
      if (isMethodDefinition) {
        previous = this.pushInnerMethodDefinition(true);
      }
      this.visit(node2.value);
      if (isMethodDefinition) {
        this.popInnerMethodDefinition(previous);
      }
    }
    visitForIn(node2) {
      if (node2.left.type === Syntax.VariableDeclaration && node2.left.kind !== "var") {
        this.scopeManager.__nestForScope(node2);
      }
      if (node2.left.type === Syntax.VariableDeclaration) {
        this.visit(node2.left);
        this.visitPattern(node2.left.declarations[0].id, (pattern2) => {
          this.currentScope().__referencing(pattern2, Reference.WRITE, node2.right, null, true, true);
        });
      } else {
        this.visitPattern(node2.left, { processRightHandNodes: true }, (pattern2, info) => {
          let maybeImplicitGlobal = null;
          if (!this.currentScope().isStrict) {
            maybeImplicitGlobal = {
              pattern: pattern2,
              node: node2
            };
          }
          this.referencingDefaultValue(pattern2, info.assignments, maybeImplicitGlobal, false);
          this.currentScope().__referencing(pattern2, Reference.WRITE, node2.right, maybeImplicitGlobal, true, false);
        });
      }
      this.visit(node2.right);
      this.visit(node2.body);
      this.close(node2);
    }
    visitVariableDeclaration(variableTargetScope, type2, node2, index) {
      const decl = node2.declarations[index];
      const init = decl.init;
      this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern2, info) => {
        variableTargetScope.__define(
          pattern2,
          new Definition(
            type2,
            pattern2,
            decl,
            node2,
            index,
            node2.kind
          )
        );
        this.referencingDefaultValue(pattern2, info.assignments, null, true);
        if (init) {
          this.currentScope().__referencing(pattern2, Reference.WRITE, init, null, !info.topLevel, true);
        }
      });
    }
    AssignmentExpression(node2) {
      if (PatternVisitor.isPattern(node2.left)) {
        if (node2.operator === "=") {
          this.visitPattern(node2.left, { processRightHandNodes: true }, (pattern2, info) => {
            let maybeImplicitGlobal = null;
            if (!this.currentScope().isStrict) {
              maybeImplicitGlobal = {
                pattern: pattern2,
                node: node2
              };
            }
            this.referencingDefaultValue(pattern2, info.assignments, maybeImplicitGlobal, false);
            this.currentScope().__referencing(pattern2, Reference.WRITE, node2.right, maybeImplicitGlobal, !info.topLevel, false);
          });
        } else {
          this.currentScope().__referencing(node2.left, Reference.RW, node2.right);
        }
      } else {
        this.visit(node2.left);
      }
      this.visit(node2.right);
    }
    CatchClause(node2) {
      this.scopeManager.__nestCatchScope(node2);
      this.visitPattern(node2.param, { processRightHandNodes: true }, (pattern2, info) => {
        this.currentScope().__define(
          pattern2,
          new Definition(
            Variable.CatchClause,
            pattern2,
            node2,
            null,
            null,
            null
          )
        );
        this.referencingDefaultValue(pattern2, info.assignments, null, true);
      });
      this.visit(node2.body);
      this.close(node2);
    }
    Program(node2) {
      this.scopeManager.__nestGlobalScope(node2);
      if (this.scopeManager.isGlobalReturn()) {
        this.currentScope().isStrict = false;
        this.scopeManager.__nestFunctionScope(node2, false);
      }
      if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
        this.scopeManager.__nestModuleScope(node2);
      }
      if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
        this.currentScope().isStrict = true;
      }
      this.visitChildren(node2);
      this.close(node2);
    }
    Identifier(node2) {
      this.currentScope().__referencing(node2);
    }
    // eslint-disable-next-line class-methods-use-this -- Desired as instance method
    PrivateIdentifier() {
    }
    UpdateExpression(node2) {
      if (PatternVisitor.isPattern(node2.argument)) {
        this.currentScope().__referencing(node2.argument, Reference.RW, null);
      } else {
        this.visitChildren(node2);
      }
    }
    MemberExpression(node2) {
      this.visit(node2.object);
      if (node2.computed) {
        this.visit(node2.property);
      }
    }
    Property(node2) {
      this.visitProperty(node2);
    }
    PropertyDefinition(node2) {
      const { computed, key, value } = node2;
      if (computed) {
        this.visit(key);
      }
      if (value) {
        this.scopeManager.__nestClassFieldInitializerScope(value);
        this.visit(value);
        this.close(value);
      }
    }
    StaticBlock(node2) {
      this.scopeManager.__nestClassStaticBlockScope(node2);
      this.visitChildren(node2);
      this.close(node2);
    }
    MethodDefinition(node2) {
      this.visitProperty(node2);
    }
    BreakStatement() {
    }
    // eslint-disable-line class-methods-use-this -- Desired as instance method
    ContinueStatement() {
    }
    // eslint-disable-line class-methods-use-this -- Desired as instance method
    LabeledStatement(node2) {
      this.visit(node2.body);
    }
    ForStatement(node2) {
      if (node2.init && node2.init.type === Syntax.VariableDeclaration && node2.init.kind !== "var") {
        this.scopeManager.__nestForScope(node2);
      }
      this.visitChildren(node2);
      this.close(node2);
    }
    ClassExpression(node2) {
      this.visitClass(node2);
    }
    ClassDeclaration(node2) {
      this.visitClass(node2);
    }
    CallExpression(node2) {
      if (!this.scopeManager.__ignoreEval() && node2.callee.type === Syntax.Identifier && node2.callee.name === "eval") {
        this.currentScope().variableScope.__detectEval();
      }
      this.visitChildren(node2);
    }
    BlockStatement(node2) {
      if (this.scopeManager.__isES6()) {
        this.scopeManager.__nestBlockScope(node2);
      }
      this.visitChildren(node2);
      this.close(node2);
    }
    ThisExpression() {
      this.currentScope().variableScope.__detectThis();
    }
    WithStatement(node2) {
      this.visit(node2.object);
      this.scopeManager.__nestWithScope(node2);
      this.visit(node2.body);
      this.close(node2);
    }
    VariableDeclaration(node2) {
      const variableTargetScope = node2.kind === "var" ? this.currentScope().variableScope : this.currentScope();
      for (let i2 = 0, iz = node2.declarations.length; i2 < iz; ++i2) {
        const decl = node2.declarations[i2];
        this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node2, i2);
        if (decl.init) {
          this.visit(decl.init);
        }
      }
    }
    // sec 13.11.8
    SwitchStatement(node2) {
      this.visit(node2.discriminant);
      if (this.scopeManager.__isES6()) {
        this.scopeManager.__nestSwitchScope(node2);
      }
      for (let i2 = 0, iz = node2.cases.length; i2 < iz; ++i2) {
        this.visit(node2.cases[i2]);
      }
      this.close(node2);
    }
    FunctionDeclaration(node2) {
      this.visitFunction(node2);
    }
    FunctionExpression(node2) {
      this.visitFunction(node2);
    }
    ForOfStatement(node2) {
      this.visitForIn(node2);
    }
    ForInStatement(node2) {
      this.visitForIn(node2);
    }
    ArrowFunctionExpression(node2) {
      this.visitFunction(node2);
    }
    ImportDeclaration(node2) {
      assert2(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
      const importer = new Importer(node2, this);
      importer.visit(node2);
    }
    visitExportDeclaration(node2) {
      if (node2.source) {
        return;
      }
      if (node2.declaration) {
        this.visit(node2.declaration);
        return;
      }
      this.visitChildren(node2);
    }
    // TODO: ExportDeclaration doesn't exist. for bc?
    ExportDeclaration(node2) {
      this.visitExportDeclaration(node2);
    }
    ExportAllDeclaration(node2) {
      this.visitExportDeclaration(node2);
    }
    ExportDefaultDeclaration(node2) {
      this.visitExportDeclaration(node2);
    }
    ExportNamedDeclaration(node2) {
      this.visitExportDeclaration(node2);
    }
    ExportSpecifier(node2) {
      const local = node2.id || node2.local;
      this.visit(local);
    }
    MetaProperty() {
    }
    JSXIdentifier(node2) {
      if (this.scopeManager.__isJSXEnabled() && node2.name !== "this") {
        this.currentScope().__referencing(node2);
      }
    }
    JSXMemberExpression(node2) {
      this.visit(node2.object);
    }
    JSXElement(node2) {
      if (this.scopeManager.__isJSXEnabled()) {
        this.visit(node2.openingElement);
        node2.children.forEach(this.visit, this);
      } else {
        this.visitChildren(node2);
      }
    }
    JSXOpeningElement(node2) {
      if (this.scopeManager.__isJSXEnabled()) {
        const nameNode = node2.name;
        const isComponentName = nameNode.type === "JSXIdentifier" && nameNode.name[0].toUpperCase() === nameNode.name[0];
        const isComponent = isComponentName || nameNode.type === "JSXMemberExpression";
        if (isComponent) {
          this.visit(nameNode);
        }
      }
      node2.attributes.forEach(this.visit, this);
    }
    JSXAttribute(node2) {
      if (node2.value) {
        this.visit(node2.value);
      }
    }
    JSXExpressionContainer(node2) {
      this.visit(node2.expression);
    }
    JSXNamespacedName(node2) {
      this.visit(node2.namespace);
      this.visit(node2.name);
    }
  }
  const version2 = "8.4.0";
  function defaultOptions() {
    return {
      optimistic: false,
      nodejsScope: false,
      impliedStrict: false,
      sourceType: "script",
      // one of ['script', 'module', 'commonjs']
      ecmaVersion: 5,
      childVisitorKeys: null,
      fallback: "iteration"
    };
  }
  function updateDeeply(target, override) {
    function isHashObject(value) {
      return typeof value === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
    }
    for (const key in override) {
      if (Object.hasOwn(override, key)) {
        const val = override[key];
        if (isHashObject(val)) {
          if (isHashObject(target[key])) {
            updateDeeply(target[key], val);
          } else {
            target[key] = updateDeeply({}, val);
          }
        } else {
          target[key] = val;
        }
      }
    }
    return target;
  }
  function analyze(tree, providedOptions) {
    const options = updateDeeply(defaultOptions(), providedOptions);
    const scopeManager = new ScopeManager(options);
    const referencer = new Referencer(options, scopeManager);
    referencer.visit(tree);
    assert2(scopeManager.__currentScope === null, "currentScope should be null.");
    return scopeManager;
  }
  eslintScope.Definition = Definition;
  eslintScope.PatternVisitor = PatternVisitor;
  eslintScope.Reference = Reference;
  eslintScope.Referencer = Referencer;
  eslintScope.Scope = Scope;
  eslintScope.ScopeManager = ScopeManager;
  eslintScope.Variable = Variable;
  eslintScope.analyze = analyze;
  eslintScope.version = version2;
  return eslintScope;
}
var eslintVisitorKeys$2 = {};
var hasRequiredEslintVisitorKeys$2;
function requireEslintVisitorKeys$2() {
  if (hasRequiredEslintVisitorKeys$2) return eslintVisitorKeys$2;
  hasRequiredEslintVisitorKeys$2 = 1;
  const KEYS = {
    ArrayExpression: [
      "elements"
    ],
    ArrayPattern: [
      "elements"
    ],
    ArrowFunctionExpression: [
      "params",
      "body"
    ],
    AssignmentExpression: [
      "left",
      "right"
    ],
    AssignmentPattern: [
      "left",
      "right"
    ],
    AwaitExpression: [
      "argument"
    ],
    BinaryExpression: [
      "left",
      "right"
    ],
    BlockStatement: [
      "body"
    ],
    BreakStatement: [
      "label"
    ],
    CallExpression: [
      "callee",
      "arguments"
    ],
    CatchClause: [
      "param",
      "body"
    ],
    ChainExpression: [
      "expression"
    ],
    ClassBody: [
      "body"
    ],
    ClassDeclaration: [
      "id",
      "superClass",
      "body"
    ],
    ClassExpression: [
      "id",
      "superClass",
      "body"
    ],
    ConditionalExpression: [
      "test",
      "consequent",
      "alternate"
    ],
    ContinueStatement: [
      "label"
    ],
    DebuggerStatement: [],
    DoWhileStatement: [
      "body",
      "test"
    ],
    EmptyStatement: [],
    ExperimentalRestProperty: [
      "argument"
    ],
    ExperimentalSpreadProperty: [
      "argument"
    ],
    ExportAllDeclaration: [
      "exported",
      "source",
      "attributes"
    ],
    ExportDefaultDeclaration: [
      "declaration"
    ],
    ExportNamedDeclaration: [
      "declaration",
      "specifiers",
      "source",
      "attributes"
    ],
    ExportSpecifier: [
      "local",
      "exported"
    ],
    ExpressionStatement: [
      "expression"
    ],
    ForInStatement: [
      "left",
      "right",
      "body"
    ],
    ForOfStatement: [
      "left",
      "right",
      "body"
    ],
    ForStatement: [
      "init",
      "test",
      "update",
      "body"
    ],
    FunctionDeclaration: [
      "id",
      "params",
      "body"
    ],
    FunctionExpression: [
      "id",
      "params",
      "body"
    ],
    Identifier: [],
    IfStatement: [
      "test",
      "consequent",
      "alternate"
    ],
    ImportAttribute: [
      "key",
      "value"
    ],
    ImportDeclaration: [
      "specifiers",
      "source",
      "attributes"
    ],
    ImportDefaultSpecifier: [
      "local"
    ],
    ImportExpression: [
      "source",
      "options"
    ],
    ImportNamespaceSpecifier: [
      "local"
    ],
    ImportSpecifier: [
      "imported",
      "local"
    ],
    JSXAttribute: [
      "name",
      "value"
    ],
    JSXClosingElement: [
      "name"
    ],
    JSXClosingFragment: [],
    JSXElement: [
      "openingElement",
      "children",
      "closingElement"
    ],
    JSXEmptyExpression: [],
    JSXExpressionContainer: [
      "expression"
    ],
    JSXFragment: [
      "openingFragment",
      "children",
      "closingFragment"
    ],
    JSXIdentifier: [],
    JSXMemberExpression: [
      "object",
      "property"
    ],
    JSXNamespacedName: [
      "namespace",
      "name"
    ],
    JSXOpeningElement: [
      "name",
      "attributes"
    ],
    JSXOpeningFragment: [],
    JSXSpreadAttribute: [
      "argument"
    ],
    JSXSpreadChild: [
      "expression"
    ],
    JSXText: [],
    LabeledStatement: [
      "label",
      "body"
    ],
    Literal: [],
    LogicalExpression: [
      "left",
      "right"
    ],
    MemberExpression: [
      "object",
      "property"
    ],
    MetaProperty: [
      "meta",
      "property"
    ],
    MethodDefinition: [
      "key",
      "value"
    ],
    NewExpression: [
      "callee",
      "arguments"
    ],
    ObjectExpression: [
      "properties"
    ],
    ObjectPattern: [
      "properties"
    ],
    PrivateIdentifier: [],
    Program: [
      "body"
    ],
    Property: [
      "key",
      "value"
    ],
    PropertyDefinition: [
      "key",
      "value"
    ],
    RestElement: [
      "argument"
    ],
    ReturnStatement: [
      "argument"
    ],
    SequenceExpression: [
      "expressions"
    ],
    SpreadElement: [
      "argument"
    ],
    StaticBlock: [
      "body"
    ],
    Super: [],
    SwitchCase: [
      "test",
      "consequent"
    ],
    SwitchStatement: [
      "discriminant",
      "cases"
    ],
    TaggedTemplateExpression: [
      "tag",
      "quasi"
    ],
    TemplateElement: [],
    TemplateLiteral: [
      "quasis",
      "expressions"
    ],
    ThisExpression: [],
    ThrowStatement: [
      "argument"
    ],
    TryStatement: [
      "block",
      "handler",
      "finalizer"
    ],
    UnaryExpression: [
      "argument"
    ],
    UpdateExpression: [
      "argument"
    ],
    VariableDeclaration: [
      "declarations"
    ],
    VariableDeclarator: [
      "id",
      "init"
    ],
    WhileStatement: [
      "test",
      "body"
    ],
    WithStatement: [
      "object",
      "body"
    ],
    YieldExpression: [
      "argument"
    ]
  };
  const NODE_TYPES = Object.keys(KEYS);
  for (const type2 of NODE_TYPES) {
    Object.freeze(KEYS[type2]);
  }
  Object.freeze(KEYS);
  const KEY_BLACKLIST = /* @__PURE__ */ new Set([
    "parent",
    "leadingComments",
    "trailingComments"
  ]);
  function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
  }
  function getKeys(node2) {
    return Object.keys(node2).filter(filterKey);
  }
  function unionWith(additionalKeys) {
    const retv = (
      /** @type {{ [type: string]: ReadonlyArray<string> }} */
      Object.assign({}, KEYS)
    );
    for (const type2 of Object.keys(additionalKeys)) {
      if (Object.hasOwn(retv, type2)) {
        const keys2 = new Set(additionalKeys[type2]);
        for (const key of retv[type2]) {
          keys2.add(key);
        }
        retv[type2] = Object.freeze(Array.from(keys2));
      } else {
        retv[type2] = Object.freeze(Array.from(additionalKeys[type2]));
      }
    }
    return Object.freeze(retv);
  }
  eslintVisitorKeys$2.KEYS = KEYS;
  eslintVisitorKeys$2.getKeys = getKeys;
  eslintVisitorKeys$2.unionWith = unionWith;
  return eslintVisitorKeys$2;
}
var espree = {};
var acorn = { exports: {} };
var hasRequiredAcorn;
function requireAcorn() {
  if (hasRequiredAcorn) return acorn.exports;
  hasRequiredAcorn = 1;
  (function(module, exports$1) {
    (function(global, factory) {
      factory(exports$1);
    })(this, function(exports$12) {
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
      var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$12 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code2, set) {
        var pos = 65536;
        for (var i3 = 0; i3 < set.length; i3 += 2) {
          pos += set[i3];
          if (pos > code2) {
            return false;
          }
          pos += set[i3 + 1];
          if (pos >= code2) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code2, astral) {
        if (code2 < 65) {
          return code2 === 36;
        }
        if (code2 < 91) {
          return true;
        }
        if (code2 < 97) {
          return code2 === 95;
        }
        if (code2 < 123) {
          return true;
        }
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code2, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code2, astral) {
        if (code2 < 48) {
          return code2 === 36;
        }
        if (code2 < 58) {
          return true;
        }
        if (code2 < 65) {
          return false;
        }
        if (code2 < 91) {
          return true;
        }
        if (code2 < 97) {
          return code2 === 95;
        }
        if (code2 < 123) {
          return true;
        }
        if (code2 <= 65535) {
          return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name2, prec2) {
        return new TokenType(name2, { beforeExpr: true, binop: prec2 });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords2 = {};
      function kw(name2, options) {
        if (options === void 0) options = {};
        options.keyword = name2;
        return keywords2[name2] = new TokenType(name2, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code2) {
        return code2 === 10 || code2 === 13 || code2 === 8232 || code2 === 8233;
      }
      function nextLineBreak(code2, from, end) {
        if (end === void 0) end = code2.length;
        for (var i3 = from; i3 < end; i3++) {
          var next = code2.charCodeAt(i3);
          if (isNewLine(next)) {
            return i3 < end - 1 && next === 13 && code2.charCodeAt(i3 + 1) === 10 ? i3 + 2 : i3 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref2 = Object.prototype;
      var hasOwnProperty = ref2.hasOwnProperty;
      var toString = ref2.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      var regexpCache = /* @__PURE__ */ Object.create(null);
      function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
      }
      function codePointToString(code2) {
        if (code2 <= 65535) {
          return String.fromCharCode(code2);
        }
        code2 -= 65536;
        return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n2) {
        return new Position(this.line, this.column + n2);
      };
      var SourceLocation = function SourceLocation2(p2, start, end) {
        this.start = start;
        this.end = end;
        if (p2.sourceFile !== null) {
          this.source = p2.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur2 = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur2, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur2);
          }
          ++line;
          cur2 = nextBreak;
        }
      }
      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment2 = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment2.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment2.range = [start, end];
          }
          array.push(comment2);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async2, generator) {
        return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser2 = function Parser3(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser2.prototype.parse = function parse2() {
        var node2 = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node2);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i3 = this.scopeStack.length - 1; i3 >= 0; i3--) {
          var ref3 = this.scopeStack[i3];
          var flags2 = ref3.flags;
          if (flags2 & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
            return false;
          }
          if (flags2 & SCOPE_FUNCTION) {
            return (flags2 & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref3 = this.currentThisScope();
        var flags2 = ref3.flags;
        return (flags2 & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        for (var i3 = this.scopeStack.length - 1; i3 >= 0; i3--) {
          var ref3 = this.scopeStack[i3];
          var flags2 = ref3.flags;
          if (flags2 & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags2 & SCOPE_FUNCTION && !(flags2 & SCOPE_ARROW)) {
            return true;
          }
        }
        return false;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser2.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i3 = 0; i3 < plugins.length; i3++) {
          cls = plugins[i3](cls);
        }
        return cls;
      };
      Parser2.parse = function parse2(input, options) {
        return new this(options, input).parse();
      };
      Parser2.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser2 = new this(options, input, pos);
        parser2.nextToken();
        return parser2.parseExpression();
      };
      Parser2.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser2.prototype, prototypeAccessors);
      var pp$9 = Parser2.prototype;
      var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal2.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type2) {
        if (this.type === type2) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name2) {
        return this.type === types$1.name && this.value === name2 && !this.containsEsc;
      };
      pp$9.eatContextual = function(name2) {
        if (!this.isContextual(name2)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name2) {
        if (!this.eatContextual(name2)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type2) {
        this.eat(type2) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser2.prototype;
      pp$8.parseTopLevel = function(node2) {
        var exports$13 = /* @__PURE__ */ Object.create(null);
        if (!node2.body) {
          node2.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports$13);
          node2.body.push(stmt);
        }
        if (this.inModule) {
          for (var i3 = 0, list2 = Object.keys(this.undefinedExports); i3 < list2.length; i3 += 1) {
            var name2 = list2[i3];
            this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node2.body);
        this.next();
        node2.sourceType = this.options.sourceType;
        return this.finishNode(node2, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
        if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        if (lineBreak.test(this.input.slice(this.pos, next))) {
          return false;
        }
        if (isAwaitUsing) {
          var awaitEndPos = next + 5, after;
          if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
            return false;
          }
          skipWhiteSpace.lastIndex = awaitEndPos;
          var skipAfterUsing = skipWhiteSpace.exec(this.input);
          if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
            return false;
          }
        }
        if (isFor) {
          var ofEndPos = next + 2, after$1;
          if (this.input.slice(next, ofEndPos) === "of") {
            if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
              return false;
            }
          }
        }
        var ch = this.input.charCodeAt(next);
        return isIdentifierStart(ch, true) || ch === 92;
      };
      pp$8.isAwaitUsing = function(isFor) {
        return this.isUsingKeyword(true, isFor);
      };
      pp$8.isUsing = function(isFor) {
        return this.isUsingKeyword(false, isFor);
      };
      pp$8.parseStatement = function(context, topLevel, exports$13) {
        var starttype = this.type, node2 = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node2, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node2);
          case types$1._do:
            return this.parseDoStatement(node2);
          case types$1._for:
            return this.parseForStatement(node2);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node2, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node2, true);
          case types$1._if:
            return this.parseIfStatement(node2);
          case types$1._return:
            return this.parseReturnStatement(node2);
          case types$1._switch:
            return this.parseSwitchStatement(node2);
          case types$1._throw:
            return this.parseThrowStatement(node2);
          case types$1._try:
            return this.parseTryStatement(node2);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node2, kind);
          case types$1._while:
            return this.parseWhileStatement(node2);
          case types$1._with:
            return this.parseWithStatement(node2);
          case types$1.braceL:
            return this.parseBlock(true, node2);
          case types$1.semi:
            return this.parseEmptyStatement(node2);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node2, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports$13);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node2, true, !context);
            }
            var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
            if (usingKind) {
              if (topLevel && this.options.sourceType === "script") {
                this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
              }
              if (usingKind === "await using") {
                if (!this.canAwait) {
                  this.raise(this.start, "Await using cannot appear outside of async function");
                }
                this.next();
              }
              this.next();
              this.parseVar(node2, false, usingKind);
              this.semicolon();
              return this.finishNode(node2, "VariableDeclaration");
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node2, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node2, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node2, keyword2) {
        var isBreak = keyword2 === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node2.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node2.label = this.parseIdent();
          this.semicolon();
        }
        var i3 = 0;
        for (; i3 < this.labels.length; ++i3) {
          var lab = this.labels[i3];
          if (node2.label == null || lab.name === node2.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node2.label && isBreak) {
              break;
            }
          }
        }
        if (i3 === this.labels.length) {
          this.raise(node2.start, "Unsyntactic " + keyword2);
        }
        return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node2) {
        this.next();
        this.semicolon();
        return this.finishNode(node2, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node2) {
        this.next();
        this.labels.push(loopLabel);
        node2.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node2.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node2, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node2) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          return this.parseForAfterInit(node2, init$1, awaitAt);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
        if (usingKind) {
          var init$2 = this.startNode();
          this.next();
          if (usingKind === "await using") {
            this.next();
          }
          this.parseVar(init$2, true, usingKind);
          this.finishNode(init$2, "VariableDeclaration");
          return this.parseForAfterInit(node2, init$2, awaitAt);
        }
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors();
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (awaitAt > -1) {
            if (this.type === types$1._in) {
              this.unexpected(awaitAt);
            }
            node2.await = true;
          } else if (isForOf && this.options.ecmaVersion >= 8) {
            if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
              this.unexpected();
            } else if (this.options.ecmaVersion >= 9) {
              node2.await = false;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node2, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init);
      };
      pp$8.parseForAfterInit = function(node2, init, awaitAt) {
        if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          return this.parseForIn(node2, init);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init);
      };
      pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        node2.consequent = this.parseStatement("if");
        node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node2, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node2) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node2.argument = null;
        } else {
          node2.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node2, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node2) {
        this.next();
        node2.discriminant = this.parseParenExpression();
        node2.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur2;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur2) {
              this.finishNode(cur2, "SwitchCase");
            }
            node2.cases.push(cur2 = this.startNode());
            cur2.consequent = [];
            this.next();
            if (isCase) {
              cur2.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur2.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur2) {
              this.unexpected();
            }
            cur2.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur2) {
          this.finishNode(cur2, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node2, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node2) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node2.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node2, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node2) {
        this.next();
        node2.block = this.parseBlock();
        node2.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node2.handler = this.finishNode(clause, "CatchClause");
        }
        node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node2.handler && !node2.finalizer) {
          this.raise(node2.start, "Missing catch or finally clause");
        }
        return this.finishNode(node2, "TryStatement");
      };
      pp$8.parseVarStatement = function(node2, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node2, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node2, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node2.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node2, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node2) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node2.object = this.parseParenExpression();
        node2.body = this.parseStatement("with");
        return this.finishNode(node2, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node2) {
        this.next();
        return this.finishNode(node2, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i3 = this.labels.length - 1; i3 >= 0; i3--) {
          var label$1 = this.labels[i3];
          if (label$1.statementStart === node2.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node2.label = expr;
        return this.finishNode(node2, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node2, expr) {
        node2.expression = expr;
        this.semicolon();
        return this.finishNode(node2, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node2 === void 0) node2 = this.startNode();
        node2.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node2, "BlockStatement");
      };
      pp$8.parseFor = function(node2, init) {
        node2.init = init;
        this.expect(types$1.semi);
        node2.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node2.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, "ForStatement");
      };
      pp$8.parseForIn = function(node2, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node2.left = init;
        node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node2, isFor, kind, allowMissingInitializer) {
        node2.declarations = [];
        node2.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
            this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node2;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node2.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node2.async, node2.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node2.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node2);
        this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node2) {
        this.expect(types$1.parenL);
        node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node2, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node2, isStatement);
        this.parseClassSuper(node2);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node2.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node2.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion3 = this.options.ecmaVersion;
        var node2 = this.startNode();
        var keyName2 = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion3 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node2);
            return node2;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName2 = "static";
          }
        }
        node2.static = isStatic;
        if (!keyName2 && ecmaVersion3 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName2 = "async";
          }
        }
        if (!keyName2 && (ecmaVersion3 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName2 && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName2 = lastValue;
            }
          }
        }
        if (keyName2) {
          node2.computed = false;
          node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node2.key.name = keyName2;
          this.finishNode(node2.key, "Identifier");
        } else {
          this.parseClassElementName(node2);
        }
        if (ecmaVersion3 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node2.static && checkKeyName(node2, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node2.key.start, "Constructor can't have get/set modifier");
          }
          node2.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node2);
        }
        return node2;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
          field.value = this.parseMaybeAssign();
          this.exitScope();
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node2) {
        node2.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node2, "StaticBlock");
      };
      pp$8.parseClassId = function(node2, isStatement) {
        if (this.type === types$1.name) {
          node2.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node2.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node2.id = null;
        }
      };
      pp$8.parseClassSuper = function(node2) {
        node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref3 = this.privateNameStack.pop();
        var declared = ref3.declared;
        var used = ref3.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i3 = 0; i3 < used.length; ++i3) {
          var id2 = used[i3];
          if (!hasOwn(declared, id2.name)) {
            if (parent) {
              parent.used.push(id2);
            } else {
              this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name2 = element.key.name;
        var curr = privateNameMap[name2];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name2] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name2] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node2, name2) {
        var computed = node2.computed;
        var key = node2.key;
        return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
      }
      pp$8.parseExportAllDeclaration = function(node2, exports$13) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node2.exported = this.parseModuleExportName();
            this.checkExport(exports$13, node2.exported, this.lastTokStart);
          } else {
            node2.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node2, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node2, exports$13) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node2, exports$13);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports$13, "default", this.lastTokStart);
          node2.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node2.declaration = this.parseExportDeclaration(node2);
          if (node2.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports$13, node2.declaration.declarations);
          } else {
            this.checkExport(exports$13, node2.declaration.id, node2.declaration.id.start);
          }
          node2.specifiers = [];
          node2.source = null;
          if (this.options.ecmaVersion >= 16) {
            node2.attributes = [];
          }
        } else {
          node2.declaration = null;
          node2.specifiers = this.parseExportSpecifiers(exports$13);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node2.source = this.parseExprAtom();
            if (this.options.ecmaVersion >= 16) {
              node2.attributes = this.parseWithClause();
            }
          } else {
            for (var i3 = 0, list2 = node2.specifiers; i3 < list2.length; i3 += 1) {
              var spec = list2[i3];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node2.source = null;
            if (this.options.ecmaVersion >= 16) {
              node2.attributes = [];
            }
          }
          this.semicolon();
        }
        return this.finishNode(node2, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node2) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports$13, name2, pos) {
        if (!exports$13) {
          return;
        }
        if (typeof name2 !== "string") {
          name2 = name2.type === "Identifier" ? name2.name : name2.value;
        }
        if (hasOwn(exports$13, name2)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
        }
        exports$13[name2] = true;
      };
      pp$8.checkPatternExport = function(exports$13, pat) {
        var type2 = pat.type;
        if (type2 === "Identifier") {
          this.checkExport(exports$13, pat, pat.start);
        } else if (type2 === "ObjectPattern") {
          for (var i3 = 0, list2 = pat.properties; i3 < list2.length; i3 += 1) {
            var prop = list2[i3];
            this.checkPatternExport(exports$13, prop);
          }
        } else if (type2 === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports$13, elt);
            }
          }
        } else if (type2 === "Property") {
          this.checkPatternExport(exports$13, pat.value);
        } else if (type2 === "AssignmentPattern") {
          this.checkPatternExport(exports$13, pat.left);
        } else if (type2 === "RestElement") {
          this.checkPatternExport(exports$13, pat.argument);
        }
      };
      pp$8.checkVariableExport = function(exports$13, decls) {
        if (!exports$13) {
          return;
        }
        for (var i3 = 0, list2 = decls; i3 < list2.length; i3 += 1) {
          var decl = list2[i3];
          this.checkPatternExport(exports$13, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports$13) {
        var node2 = this.startNode();
        node2.local = this.parseModuleExportName();
        node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
        this.checkExport(
          exports$13,
          node2.exported,
          node2.exported.start
        );
        return this.finishNode(node2, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports$13) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports$13));
        }
        return nodes;
      };
      pp$8.parseImport = function(node2) {
        this.next();
        if (this.type === types$1.string) {
          node2.specifiers = empty$1;
          node2.source = this.parseExprAtom();
        } else {
          node2.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
          node2.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node2 = this.startNode();
        node2.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node2.local = this.parseIdent();
        } else {
          this.checkUnreserved(node2.imported);
          node2.local = node2.imported;
        }
        this.checkLValSimple(node2.local, BIND_LEXICAL);
        return this.finishNode(node2, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node2 = this.startNode();
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL);
        return this.finishNode(node2, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node2 = this.startNode();
        this.next();
        this.expectContextual("as");
        node2.local = this.parseIdent();
        this.checkLValSimple(node2.local, BIND_LEXICAL);
        return this.finishNode(node2, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
          return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var attr = this.parseImportAttribute();
          var keyName2 = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
          if (hasOwn(attributeKeys, keyName2)) {
            this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName2 + "'");
          }
          attributeKeys[keyName2] = true;
          nodes.push(attr);
        }
        return nodes;
      };
      pp$8.parseImportAttribute = function() {
        var node2 = this.startNode();
        node2.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node2.value = this.parseExprAtom();
        return this.finishNode(node2, "ImportAttribute");
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i3 = 0; i3 < statements.length && this.isDirectiveCandidate(statements[i3]); ++i3) {
          statements[i3].directive = statements[i3].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser2.prototype;
      pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node2) {
          switch (node2.type) {
            case "Identifier":
              if (this.inAsync && node2.name === "await") {
                this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node2.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i3 = 0, list2 = node2.properties; i3 < list2.length; i3 += 1) {
                var prop = list2[i3];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node2.kind !== "init") {
                this.raise(node2.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node2.value, isBinding);
              break;
            case "ArrayExpression":
              node2.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node2.elements, isBinding);
              break;
            case "SpreadElement":
              node2.type = "RestElement";
              this.toAssignable(node2.argument, isBinding);
              if (node2.argument.type === "AssignmentPattern") {
                this.raise(node2.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node2.operator !== "=") {
                this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node2.type = "AssignmentPattern";
              delete node2.operator;
              this.toAssignable(node2.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node2.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node2;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i3 = 0; i3 < end; i3++) {
          var elt = exprList[i3];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node2, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node2 = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node2.argument = this.parseBindingAtom();
        return this.finishNode(node2, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node2 = this.startNode();
              this.next();
              node2.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node2, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.right = this.parseMaybeAssign();
        return this.finishNode(node2, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i3 = 0, list2 = expr.properties; i3 < list2.length; i3 += 1) {
              var prop = list2[i3];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types2 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p2) {
          return p2.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser2.prototype;
      pp$6.initialContext = function() {
        return [types2.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types2.f_expr || parent === types2.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types2.b_stat || parent === types2.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types2.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i3 = this.context.length - 1; i3 >= 1; i3--) {
          var context = this.context[i3];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update, type2 = this.type;
        if (type2.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type2.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type2.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types2.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types2.b_stat : types2.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types2.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types2.p_stat : types2.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types2.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types2.b_stat)) {
          this.context.push(types2.f_expr);
        } else {
          this.context.push(types2.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
          this.context.pop();
        }
        this.exprAllowed = true;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types2.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types2.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types2.f_expr) {
            this.context[index] = types2.f_expr_gen;
          } else {
            this.context[index] = types2.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser2.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name2;
        switch (key.type) {
          case "Identifier":
            name2 = key.name;
            break;
          case "Literal":
            name2 = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name2 === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name2 = "$" + name2;
        var other = propHash[name2];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name2] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node2, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node2.left = left;
          this.next();
          node2.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node2, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.test = expr;
          node2.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node2.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node2, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec2 = this.type.binop;
        if (prec2 != null && (!forInit || this.type !== types$1._in)) {
          if (prec2 > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec2 = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec2, forInit);
            var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.operator = op;
        node2.right = right;
        return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node2 = this.startNode(), update = this.type === types$1.incDec;
          node2.operator = this.value;
          node2.prefix = true;
          this.next();
          node2.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node2.argument);
          } else if (this.strict && node2.operator === "delete" && isLocalVariableAccess(node2.argument)) {
            this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
          } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
            this.raiseRecoverable(node2.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isLocalVariableAccess(node2) {
        return node2.type === "Identifier" || node2.type === "ParenthesizedExpression" && isLocalVariableAccess(node2.expression);
      }
      function isPrivateFieldAccess(node2) {
        return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression) || node2.type === "ParenthesizedExpression" && isPrivateFieldAccess(node2.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base2 || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base2 = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base2;
          if (computed) {
            node2.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base2.type !== "Super") {
            node2.property = this.parsePrivateIdent();
          } else {
            node2.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node2.computed = !!computed;
          if (optionalSupported) {
            node2.optional = optional;
          }
          base2 = this.finishNode(node2, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base2;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base2 = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base2;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base2 = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base2;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node2, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node2 = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node2.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node2, "Super");
          case types$1._this:
            node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id2 = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types2.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id2 = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
              }
            }
            return id2;
          case types$1.regexp:
            var value = this.value;
            node2 = this.parseLiteral(value.value);
            node2.regex = { pattern: value.pattern, flags: value.flags };
            return node2;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node2 = this.startNode();
            node2.value = this.type === types$1._null ? null : this.type === types$1._true;
            node2.raw = this.type.keyword;
            this.next();
            return this.finishNode(node2, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node2 = this.startNode();
            this.next();
            node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node2, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types2.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node2 = this.startNode();
            this.next();
            return this.parseFunction(node2, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node2 = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node2);
        } else if (this.type === types$1.dot) {
          var meta2 = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
          meta2.name = "import";
          node2.meta = this.finishNode(meta2, "Identifier");
          return this.parseImportMeta(node2);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node2) {
        this.next();
        node2.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
          if (!this.eat(types$1.parenR)) {
            this.expect(types$1.comma);
            if (!this.afterTrailingComma(types$1.parenR)) {
              node2.options = this.parseMaybeAssign();
              if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                  this.unexpected();
                }
              }
            } else {
              node2.options = null;
            }
          } else {
            node2.options = null;
          }
        } else {
          if (!this.eat(types$1.parenR)) {
            var errorPos = this.start;
            if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
        }
        return this.finishNode(node2, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node2) {
        this.next();
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "meta") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node2, "MetaProperty");
      };
      pp$5.parseLiteral = function(value) {
        var node2 = this.startNode();
        node2.value = value;
        node2.raw = this.input.slice(this.start, this.end);
        if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
          node2.bigint = node2.value != null ? node2.value.toString() : node2.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node2, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty2 = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node2 = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
          var meta2 = this.startNodeAt(node2.start, node2.loc && node2.loc.start);
          meta2.name = "new";
          node2.meta = this.finishNode(meta2, "Identifier");
          this.next();
          var containsEsc = this.containsEsc;
          node2.property = this.parseIdent(true);
          if (node2.property.name !== "target") {
            this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node2, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node2.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node2.arguments = empty2;
        }
        return this.finishNode(node2, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref3) {
        var isTagged = ref3.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value.replace(/\r\n?/g, "\n"),
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref3) {
        if (ref3 === void 0) ref3 = {};
        var isTagged = ref3.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node2 = this.startNode();
        this.next();
        node2.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node2.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node2.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node2, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node2 = this.startNode(), first = true, propHash = {};
        node2.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node2.properties.push(prop);
        }
        return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
          prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.kind = "init";
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node2) {
        node2.id = null;
        if (this.options.ecmaVersion >= 6) {
          node2.generator = node2.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 6) {
          node2.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node2, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node2.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node2, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node2.body = this.parseMaybeAssign(forInit);
          node2.expression = true;
          this.checkParams(node2, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
          if (this.strict && node2.id) {
            this.checkLValSimple(node2.id, BIND_OUTSIDE);
          }
          node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node2.expression = false;
          this.adaptDirectivePrologue(node2.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i3 = 0, list2 = params; i3 < list2.length; i3 += 1) {
          var param = list2[i3];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node2, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i3 = 0, list2 = node2.params; i3 < list2.length; i3 += 1) {
          var param = list2[i3];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref3) {
        var start = ref3.start;
        var end = ref3.end;
        var name2 = ref3.name;
        if (this.inGenerator && name2 === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name2 === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR) && name2 === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
          this.raise(start, "Cannot use " + name2 + " in class static initialization block");
        }
        if (this.keywords.test(name2)) {
          this.raise(start, "Unexpected keyword '" + name2 + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name2)) {
          if (!this.inAsync && name2 === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node2 = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node2, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node2);
          if (node2.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node2.start;
          }
        }
        return node2;
      };
      pp$5.parseIdentNode = function() {
        var node2 = this.startNode();
        if (this.type === types$1.name) {
          node2.name = this.value;
        } else if (this.type.keyword) {
          node2.name = this.type.keyword;
          if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
          this.type = types$1.name;
        } else {
          this.unexpected();
        }
        return node2;
      };
      pp$5.parsePrivateIdent = function() {
        var node2 = this.startNode();
        if (this.type === types$1.privateId) {
          node2.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node2, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
          }
        }
        return node2;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node2.delegate = false;
          node2.argument = null;
        } else {
          node2.delegate = this.eat(types$1.star);
          node2.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node2, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node2, "AwaitExpression");
      };
      var pp$4 = Parser2.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
          message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser2.prototype;
      var Scope = function Scope2(flags2) {
        this.flags = flags2;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };
      pp$3.enterScope = function(flags2) {
        this.scopeStack.push(new Scope(flags2));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name2, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
          scope.lexical.push(name2);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name2];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name2);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name2) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
          }
          scope$2.functions.push(name2);
        } else {
          for (var i3 = this.scopeStack.length - 1; i3 >= 0; --i3) {
            var scope$3 = this.scopeStack[i3];
            if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name2);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name2];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id2) {
        if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
          this.undefinedExports[id2.name] = id2;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i3 = this.scopeStack.length - 1; ; i3--) {
          var scope = this.scopeStack[i3];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i3 = this.scopeStack.length - 1; ; i3--) {
          var scope = this.scopeStack[i3];
          if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser2, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser2.options.locations) {
          this.loc = new SourceLocation(parser2, loc);
        }
        if (parser2.options.directSourceFile) {
          this.sourceFile = parser2.options.directSourceFile;
        }
        if (parser2.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser2.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node2, type2, pos, loc) {
        node2.type = type2;
        node2.end = pos;
        if (this.options.locations) {
          node2.loc.end = loc;
        }
        if (this.options.ranges) {
          node2.range[1] = pos;
        }
        return node2;
      }
      pp$2.finishNode = function(node2, type2) {
        return finishNodeAt.call(this, node2, type2, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node2, type2, pos, loc) {
        return finishNodeAt.call(this, node2, type2, pos, loc);
      };
      pp$2.copyNode = function(node2) {
        var newNode = new Node(this, node2.start, this.startLoc);
        for (var prop in node2) {
          newNode[prop] = node2[prop];
        }
        return newNode;
      };
      var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data2 = {};
      function buildUnicodeData(ecmaVersion3) {
        var d2 = data2[ecmaVersion3] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion3] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion3]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion3])
          }
        };
        d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
        d2.nonBinary.gc = d2.nonBinary.General_Category;
        d2.nonBinary.sc = d2.nonBinary.Script;
        d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
      }
      for (var i2 = 0, list = [9, 10, 11, 12, 13, 14]; i2 < list.length; i2 += 1) {
        var ecmaVersion2 = list[i2];
        buildUnicodeData(ecmaVersion2);
      }
      var pp$1 = Parser2.prototype;
      var BranchID = function BranchID2(parent, base2) {
        this.parent = parent;
        this.base = base2 || this;
      };
      BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        for (var self2 = this; self2; self2 = self2.parent) {
          for (var other = alt; other; other = other.parent) {
            if (self2.base === other.base && self2 !== other) {
              return true;
            }
          }
        }
        return false;
      };
      BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
      };
      var RegExpValidationState = function RegExpValidationState2(parser2) {
        this.parser = parser2;
        this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "") + (parser2.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data2[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = /* @__PURE__ */ Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern2, flags2) {
        var unicodeSets = flags2.indexOf("v") !== -1;
        var unicode2 = flags2.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern2 + "";
        this.flags = flags2;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode2 && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode2 && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i3, forceU) {
        if (forceU === void 0) forceU = false;
        var s2 = this.source;
        var l2 = s2.length;
        if (i3 >= l2) {
          return -1;
        }
        var c2 = s2.charCodeAt(i3);
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i3 + 1 >= l2) {
          return c2;
        }
        var next = s2.charCodeAt(i3 + 1);
        return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i3, forceU) {
        if (forceU === void 0) forceU = false;
        var s2 = this.source;
        var l2 = s2.length;
        if (i3 >= l2) {
          return l2;
        }
        var c2 = s2.charCodeAt(i3), next;
        if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i3 + 1 >= l2 || (next = s2.charCodeAt(i3 + 1)) < 56320 || next > 57343) {
          return i3 + 1;
        }
        return i3 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for (var i3 = 0, list2 = chs; i3 < list2.length; i3 += 1) {
          var ch = list2[i3];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags2 = state.flags;
        var u2 = false;
        var v2 = false;
        for (var i3 = 0; i3 < flags2.length; i3++) {
          var flag = flags2.charAt(i3);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags2.indexOf(flag, i3 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u2 = true;
          }
          if (flag === "v") {
            v2 = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u2 && v2) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      function hasProp(obj) {
        for (var _ in obj) {
          return true;
        }
        return false;
      }
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = /* @__PURE__ */ Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i3 = 0, list2 = state.backReferenceNames; i3 < list2.length; i3 += 1) {
          var name2 = list2[i3];
          if (!state.groupNames[name2]) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
          state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (trackDisjunction) {
            state.branchID = state.branchID.sibling();
          }
          this.regexp_alternative(state);
        }
        if (trackDisjunction) {
          state.branchID = state.branchID.parent;
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var addModifiers = this.regexp_eatModifiers(state);
              var hasHyphen = state.eat(
                45
                /* - */
              );
              if (addModifiers || hasHyphen) {
                for (var i3 = 0; i3 < addModifiers.length; i3++) {
                  var modifier = addModifiers.charAt(i3);
                  if (addModifiers.indexOf(modifier, i3 + 1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
                if (hasHyphen) {
                  var removeModifiers = this.regexp_eatModifiers(state);
                  if (!addModifiers && !removeModifiers && state.current() === 58) {
                    state.raise("Invalid regular expression modifiers");
                  }
                  for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                    var modifier$1 = removeModifiers.charAt(i$1);
                    if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                      state.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
            }
            if (state.eat(
              58
              /* : */
            )) {
              this.regexp_disjunction(state);
              if (state.eat(
                41
                /* ) */
              )) {
                return true;
              }
              state.raise("Unterminated group");
            }
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatModifiers = function(state) {
        var modifiers2 = "";
        var ch = 0;
        while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
          modifiers2 += codePointToString(ch);
          state.advance();
        }
        return modifiers2;
      };
      function isRegularExpressionModifier(ch) {
        return ch === 105 || ch === 109 || ch === 115;
      }
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (!this.regexp_eatGroupName(state)) {
            state.raise("Invalid group");
          }
          var trackDisjunction = this.options.ecmaVersion >= 16;
          var known = state.groupNames[state.lastStringValue];
          if (known) {
            if (trackDisjunction) {
              for (var i3 = 0, list2 = known; i3 < list2.length; i3 += 1) {
                var altID = list2[i3];
                if (!altID.separatedFrom(state.branchID)) {
                  state.raise("Duplicate capture group name");
                }
              }
            } else {
              state.raise("Duplicate capture group name");
            }
          }
          if (trackDisjunction) {
            (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
          } else {
            state.groupNames[state.lastStringValue] = true;
          }
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n2 = state.lastIntValue;
          if (state.switchU) {
            if (n2 > state.maxBackReference) {
              state.maxBackReference = n2;
            }
            return true;
          }
          if (n2 <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name2 = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name2].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i3 = 0; i3 < length; ++i3) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p2) {
        this.type = p2.type;
        this.value = p2.value;
        this.start = p2.start;
        this.end = p2.end;
        if (p2.options.locations) {
          this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
        }
        if (p2.options.ranges) {
          this.range = [p2.start, p2.end];
        }
      };
      var pp = Parser2.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code2) {
        if (isIdentifierStart(code2, this.options.ecmaVersion >= 6) || code2 === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code2);
      };
      pp.fullCharCodeAtPos = function() {
        var code2 = this.input.charCodeAt(this.pos);
        if (code2 <= 55295 || code2 >= 56320) {
          return code2;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code2 : (code2 << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp.finishToken = function(type2, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type2;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code2 === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code2 === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code2) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code2 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code2 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code2) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code2) {
          size = code2 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code2 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code2) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code2 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code2 === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion3 = this.options.ecmaVersion;
        if (ecmaVersion3 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion3 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion3 = this.options.ecmaVersion;
        var code2 = 35;
        if (ecmaVersion3 >= 13) {
          ++this.pos;
          code2 = this.fullCharCodeAtPos();
          if (isIdentifierStart(code2, true) || code2 === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
      };
      pp.getTokenFromCode = function(code2) {
        switch (code2) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code2);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code2);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code2);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code2);
          case 60:
          case 62:
            return this.readToken_lt_gt(code2);
          case 61:
          case 33:
            return this.readToken_eq_excl(code2);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code2) + "'");
      };
      pp.finishOp = function(type2, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type2, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern2 = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags2 = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern2, flags2);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern2, flags2);
        } catch (e2) {
        }
        return this.finishToken(types$1.regexp, { pattern: pattern2, flags: flags2, value });
      };
      pp.readInt = function(radix2, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i3 = 0, e2 = len == null ? Infinity : len; i3 < e2; ++i3, ++this.pos) {
          var code2 = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code2 === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i3 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code2;
            continue;
          }
          if (code2 >= 97) {
            val = code2 - 97 + 10;
          } else if (code2 >= 65) {
            val = code2 - 65 + 10;
          } else if (code2 >= 48 && code2 <= 57) {
            val = code2 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix2) {
            break;
          }
          lastCode = code2;
          total = total * radix2 + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix2) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix2);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix2);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code2;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code2 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code2 > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code2 = this.readHexChar(4);
        }
        return code2;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              if (this.input[this.pos + 1] === "\n") {
                ++this.pos;
              }
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine;
              this.lineStart = this.pos + 1;
              break;
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              if (this.options.locations) {
                this.lineStart = this.pos;
                ++this.curLine;
              }
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n2 = this.readInt(16, len);
        if (n2 === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n2;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type2 = types$1.name;
        if (this.keywords.test(word)) {
          type2 = keywords2[word];
        }
        return this.finishToken(type2, word);
      };
      var version2 = "8.15.0";
      Parser2.acorn = {
        Parser: Parser2,
        version: version2,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords2,
        TokContext,
        tokContexts: types2,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse(input, options) {
        return Parser2.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser2.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser2.tokenizer(input, options);
      }
      exports$12.Node = Node;
      exports$12.Parser = Parser2;
      exports$12.Position = Position;
      exports$12.SourceLocation = SourceLocation;
      exports$12.TokContext = TokContext;
      exports$12.Token = Token;
      exports$12.TokenType = TokenType;
      exports$12.defaultOptions = defaultOptions;
      exports$12.getLineInfo = getLineInfo;
      exports$12.isIdentifierChar = isIdentifierChar;
      exports$12.isIdentifierStart = isIdentifierStart;
      exports$12.isNewLine = isNewLine;
      exports$12.keywordTypes = keywords2;
      exports$12.lineBreak = lineBreak;
      exports$12.lineBreakG = lineBreakG;
      exports$12.nonASCIIwhitespace = nonASCIIwhitespace;
      exports$12.parse = parse;
      exports$12.parseExpressionAt = parseExpressionAt;
      exports$12.tokContexts = types2;
      exports$12.tokTypes = types$1;
      exports$12.tokenizer = tokenizer;
      exports$12.version = version2;
    });
  })(acorn, acorn.exports);
  return acorn.exports;
}
var acornJsx = { exports: {} };
var xhtml;
var hasRequiredXhtml;
function requireXhtml() {
  if (hasRequiredXhtml) return xhtml;
  hasRequiredXhtml = 1;
  xhtml = {
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    "int": "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦"
  };
  return xhtml;
}
var hasRequiredAcornJsx;
function requireAcornJsx() {
  if (hasRequiredAcornJsx) return acornJsx.exports;
  hasRequiredAcornJsx = 1;
  (function(module) {
    const XHTMLEntities = requireXhtml();
    const hexNumber = /^[\da-fA-F]+$/;
    const decimalNumber = /^\d+$/;
    const acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn2) {
      acorn2 = acorn2.Parser.acorn || acorn2;
      let acornJsx2 = acornJsxMap.get(acorn2);
      if (!acornJsx2) {
        const tt = acorn2.tokTypes;
        const TokContext = acorn2.TokContext;
        const TokenType = acorn2.TokenType;
        const tc_oTag = new TokContext("<tag", false);
        const tc_cTag = new TokContext("</tag", false);
        const tc_expr = new TokContext("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType("jsxName"),
          jsxText: new TokenType("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx2 = { tokContexts, tokTypes };
        acornJsxMap.set(acorn2, acornJsx2);
      }
      return acornJsx2;
    }
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    module.exports = function(options) {
      options = options || {};
      return function(Parser2) {
        return plugin2({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser2);
      };
    };
    Object.defineProperty(module.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(requireAcorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin2(options, Parser2) {
      const acorn2 = Parser2.acorn || requireAcorn();
      const acornJsx2 = getJsxTokens(acorn2);
      const tt = acorn2.tokTypes;
      const tok = acornJsx2.tokTypes;
      const tokContexts = acorn2.tokContexts;
      const tc_oTag = acornJsx2.tokContexts.tc_oTag;
      const tc_cTag = acornJsx2.tokContexts.tc_cTag;
      const tc_expr = acornJsx2.tokContexts.tc_expr;
      const isNewLine = acorn2.isNewLine;
      const isIdentifierStart = acorn2.isIdentifierStart;
      const isIdentifierChar = acorn2.isIdentifierChar;
      return class extends Parser2 {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx2;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        }
        jsx_readEntity() {
          let str = "", count = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);
                  if (hexNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node2 = this.startNode();
          if (this.type === tok.jsxName)
            node2.name = this.value;
          else if (this.type.keyword)
            node2.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node2, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name2 = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt.colon)) return name2;
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.namespace = name2;
          node2.name = this.jsx_parseIdentifier();
          return this.finishNode(node2, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd) return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node2 = this.jsx_parseNamespacedName();
          if (this.type === tt.dot && node2.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node2;
            newNode.property = this.jsx_parseIdentifier();
            node2 = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node2;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt.braceL:
              let node2 = this.jsx_parseExpressionContainer();
              if (node2.expression.type === "JSXEmptyExpression")
                this.raise(node2.start, "JSX attributes must only be assigned a non-empty expression");
              return node2;
            case tok.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node2 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node2, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node2 = this.startNode();
          this.next();
          node2.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt.braceR);
          return this.finishNode(node2, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node2 = this.startNode();
          if (this.eat(tt.braceL)) {
            this.expect(tt.ellipsis);
            node2.argument = this.parseMaybeAssign();
            this.expect(tt.braceR);
            return this.finishNode(node2, "JSXSpreadAttribute");
          }
          node2.name = this.jsx_parseNamespacedName();
          node2.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node2, "JSXAttribute");
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          node2.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node2.name = nodeName;
          while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
            node2.attributes.push(this.jsx_parseAttribute());
          node2.selfClosing = this.eat(tt.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node2, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node2.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node2, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; ) {
              switch (this.type) {
                case tok.jsxTagStart:
                  startPos = this.start;
                  startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(
                closingElement.start,
                "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
              );
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node2["opening" + fragmentOrElement] = openingElement;
          node2["closing" + fragmentOrElement] = closingElement;
          node2.children = children;
          if (this.type === tt.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node2, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node2 = this.parseLiteral(this.value);
          node2.type = "JSXText";
          return node2;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code2) {
          let context = this.curContext();
          if (context === tc_expr) return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart(code2)) return this.jsx_readWord();
            if (code2 == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code2 === 34 || code2 === 39) && context == tc_oTag)
              return this.jsx_readString(code2);
          }
          if (code2 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code2);
        }
        updateContext(prevType) {
          if (this.type == tt.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);
            else super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  })(acornJsx);
  return acornJsx.exports;
}
var eslintVisitorKeys$1 = {};
var hasRequiredEslintVisitorKeys$1;
function requireEslintVisitorKeys$1() {
  if (hasRequiredEslintVisitorKeys$1) return eslintVisitorKeys$1;
  hasRequiredEslintVisitorKeys$1 = 1;
  const KEYS = {
    ArrayExpression: [
      "elements"
    ],
    ArrayPattern: [
      "elements"
    ],
    ArrowFunctionExpression: [
      "params",
      "body"
    ],
    AssignmentExpression: [
      "left",
      "right"
    ],
    AssignmentPattern: [
      "left",
      "right"
    ],
    AwaitExpression: [
      "argument"
    ],
    BinaryExpression: [
      "left",
      "right"
    ],
    BlockStatement: [
      "body"
    ],
    BreakStatement: [
      "label"
    ],
    CallExpression: [
      "callee",
      "arguments"
    ],
    CatchClause: [
      "param",
      "body"
    ],
    ChainExpression: [
      "expression"
    ],
    ClassBody: [
      "body"
    ],
    ClassDeclaration: [
      "id",
      "superClass",
      "body"
    ],
    ClassExpression: [
      "id",
      "superClass",
      "body"
    ],
    ConditionalExpression: [
      "test",
      "consequent",
      "alternate"
    ],
    ContinueStatement: [
      "label"
    ],
    DebuggerStatement: [],
    DoWhileStatement: [
      "body",
      "test"
    ],
    EmptyStatement: [],
    ExperimentalRestProperty: [
      "argument"
    ],
    ExperimentalSpreadProperty: [
      "argument"
    ],
    ExportAllDeclaration: [
      "exported",
      "source",
      "attributes"
    ],
    ExportDefaultDeclaration: [
      "declaration"
    ],
    ExportNamedDeclaration: [
      "declaration",
      "specifiers",
      "source",
      "attributes"
    ],
    ExportSpecifier: [
      "local",
      "exported"
    ],
    ExpressionStatement: [
      "expression"
    ],
    ForInStatement: [
      "left",
      "right",
      "body"
    ],
    ForOfStatement: [
      "left",
      "right",
      "body"
    ],
    ForStatement: [
      "init",
      "test",
      "update",
      "body"
    ],
    FunctionDeclaration: [
      "id",
      "params",
      "body"
    ],
    FunctionExpression: [
      "id",
      "params",
      "body"
    ],
    Identifier: [],
    IfStatement: [
      "test",
      "consequent",
      "alternate"
    ],
    ImportAttribute: [
      "key",
      "value"
    ],
    ImportDeclaration: [
      "specifiers",
      "source",
      "attributes"
    ],
    ImportDefaultSpecifier: [
      "local"
    ],
    ImportExpression: [
      "source",
      "options"
    ],
    ImportNamespaceSpecifier: [
      "local"
    ],
    ImportSpecifier: [
      "imported",
      "local"
    ],
    JSXAttribute: [
      "name",
      "value"
    ],
    JSXClosingElement: [
      "name"
    ],
    JSXClosingFragment: [],
    JSXElement: [
      "openingElement",
      "children",
      "closingElement"
    ],
    JSXEmptyExpression: [],
    JSXExpressionContainer: [
      "expression"
    ],
    JSXFragment: [
      "openingFragment",
      "children",
      "closingFragment"
    ],
    JSXIdentifier: [],
    JSXMemberExpression: [
      "object",
      "property"
    ],
    JSXNamespacedName: [
      "namespace",
      "name"
    ],
    JSXOpeningElement: [
      "name",
      "attributes"
    ],
    JSXOpeningFragment: [],
    JSXSpreadAttribute: [
      "argument"
    ],
    JSXSpreadChild: [
      "expression"
    ],
    JSXText: [],
    LabeledStatement: [
      "label",
      "body"
    ],
    Literal: [],
    LogicalExpression: [
      "left",
      "right"
    ],
    MemberExpression: [
      "object",
      "property"
    ],
    MetaProperty: [
      "meta",
      "property"
    ],
    MethodDefinition: [
      "key",
      "value"
    ],
    NewExpression: [
      "callee",
      "arguments"
    ],
    ObjectExpression: [
      "properties"
    ],
    ObjectPattern: [
      "properties"
    ],
    PrivateIdentifier: [],
    Program: [
      "body"
    ],
    Property: [
      "key",
      "value"
    ],
    PropertyDefinition: [
      "key",
      "value"
    ],
    RestElement: [
      "argument"
    ],
    ReturnStatement: [
      "argument"
    ],
    SequenceExpression: [
      "expressions"
    ],
    SpreadElement: [
      "argument"
    ],
    StaticBlock: [
      "body"
    ],
    Super: [],
    SwitchCase: [
      "test",
      "consequent"
    ],
    SwitchStatement: [
      "discriminant",
      "cases"
    ],
    TaggedTemplateExpression: [
      "tag",
      "quasi"
    ],
    TemplateElement: [],
    TemplateLiteral: [
      "quasis",
      "expressions"
    ],
    ThisExpression: [],
    ThrowStatement: [
      "argument"
    ],
    TryStatement: [
      "block",
      "handler",
      "finalizer"
    ],
    UnaryExpression: [
      "argument"
    ],
    UpdateExpression: [
      "argument"
    ],
    VariableDeclaration: [
      "declarations"
    ],
    VariableDeclarator: [
      "id",
      "init"
    ],
    WhileStatement: [
      "test",
      "body"
    ],
    WithStatement: [
      "object",
      "body"
    ],
    YieldExpression: [
      "argument"
    ]
  };
  const NODE_TYPES = Object.keys(KEYS);
  for (const type2 of NODE_TYPES) {
    Object.freeze(KEYS[type2]);
  }
  Object.freeze(KEYS);
  const KEY_BLACKLIST = /* @__PURE__ */ new Set([
    "parent",
    "leadingComments",
    "trailingComments"
  ]);
  function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
  }
  function getKeys(node2) {
    return Object.keys(node2).filter(filterKey);
  }
  function unionWith(additionalKeys) {
    const retv = (
      /** @type {{ [type: string]: ReadonlyArray<string> }} */
      Object.assign({}, KEYS)
    );
    for (const type2 of Object.keys(additionalKeys)) {
      if (Object.hasOwn(retv, type2)) {
        const keys2 = new Set(additionalKeys[type2]);
        for (const key of retv[type2]) {
          keys2.add(key);
        }
        retv[type2] = Object.freeze(Array.from(keys2));
      } else {
        retv[type2] = Object.freeze(Array.from(additionalKeys[type2]));
      }
    }
    return Object.freeze(retv);
  }
  eslintVisitorKeys$1.KEYS = KEYS;
  eslintVisitorKeys$1.getKeys = getKeys;
  eslintVisitorKeys$1.unionWith = unionWith;
  return eslintVisitorKeys$1;
}
var hasRequiredEspree;
function requireEspree() {
  if (hasRequiredEspree) return espree;
  hasRequiredEspree = 1;
  Object.defineProperty(espree, "__esModule", { value: true });
  var acorn2 = requireAcorn();
  var jsx2 = requireAcornJsx();
  var visitorKeys = requireEslintVisitorKeys$1();
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
  }
  function _interopNamespace(e2) {
    if (e2 && e2.__esModule) return e2;
    var n2 = /* @__PURE__ */ Object.create(null);
    if (e2) {
      Object.keys(e2).forEach(function(k) {
        if (k !== "default") {
          var d2 = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n2, k, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return e2[k];
            }
          });
        }
      });
    }
    n2["default"] = e2;
    return Object.freeze(n2);
  }
  var acorn__namespace = /* @__PURE__ */ _interopNamespace(acorn2);
  var jsx__default = /* @__PURE__ */ _interopDefaultLegacy(jsx2);
  var visitorKeys__namespace = /* @__PURE__ */ _interopNamespace(visitorKeys);
  const Token = {
    Boolean: "Boolean",
    Identifier: "Identifier",
    PrivateIdentifier: "PrivateIdentifier",
    Keyword: "Keyword",
    Null: "Null",
    Numeric: "Numeric",
    Punctuator: "Punctuator",
    String: "String",
    RegularExpression: "RegularExpression",
    Template: "Template",
    JSXIdentifier: "JSXIdentifier",
    JSXText: "JSXText"
  };
  function convertTemplatePart(tokens, code2) {
    const firstToken = tokens[0], lastTemplateToken = tokens.at(-1);
    const token = {
      type: Token.Template,
      value: code2.slice(firstToken.start, lastTemplateToken.end)
    };
    if (firstToken.loc) {
      token.loc = {
        start: firstToken.loc.start,
        end: lastTemplateToken.loc.end
      };
    }
    if (firstToken.range) {
      token.start = firstToken.range[0];
      token.end = lastTemplateToken.range[1];
      token.range = [token.start, token.end];
    }
    return token;
  }
  function TokenTranslator(acornTokTypes, code2) {
    this._acornTokTypes = acornTokTypes;
    this._tokens = [];
    this._curlyBrace = null;
    this._code = code2;
  }
  TokenTranslator.prototype = {
    constructor: TokenTranslator,
    /**
     * Translates a single Esprima token to a single Acorn token. This may be
     * inaccurate due to how templates are handled differently in Esprima and
     * Acorn, but should be accurate for all other tokens.
     * @param {AcornToken} token The Acorn token to translate.
     * @param {Object} extra Espree extra object.
     * @returns {EsprimaToken} The Esprima version of the token.
     */
    translate(token, extra) {
      const type2 = token.type, tt = this._acornTokTypes;
      if (type2 === tt.name) {
        token.type = Token.Identifier;
        if (token.value === "static") {
          token.type = Token.Keyword;
        }
        if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
          token.type = Token.Keyword;
        }
      } else if (type2 === tt.privateId) {
        token.type = Token.PrivateIdentifier;
      } else if (type2 === tt.semi || type2 === tt.comma || type2 === tt.parenL || type2 === tt.parenR || type2 === tt.braceL || type2 === tt.braceR || type2 === tt.dot || type2 === tt.bracketL || type2 === tt.colon || type2 === tt.question || type2 === tt.bracketR || type2 === tt.ellipsis || type2 === tt.arrow || type2 === tt.jsxTagStart || type2 === tt.incDec || type2 === tt.starstar || type2 === tt.jsxTagEnd || type2 === tt.prefix || type2 === tt.questionDot || type2.binop && !type2.keyword || type2.isAssign) {
        token.type = Token.Punctuator;
        token.value = this._code.slice(token.start, token.end);
      } else if (type2 === tt.jsxName) {
        token.type = Token.JSXIdentifier;
      } else if (type2.label === "jsxText" || type2 === tt.jsxAttrValueToken) {
        token.type = Token.JSXText;
      } else if (type2.keyword) {
        if (type2.keyword === "true" || type2.keyword === "false") {
          token.type = Token.Boolean;
        } else if (type2.keyword === "null") {
          token.type = Token.Null;
        } else {
          token.type = Token.Keyword;
        }
      } else if (type2 === tt.num) {
        token.type = Token.Numeric;
        token.value = this._code.slice(token.start, token.end);
      } else if (type2 === tt.string) {
        if (extra.jsxAttrValueToken) {
          extra.jsxAttrValueToken = false;
          token.type = Token.JSXText;
        } else {
          token.type = Token.String;
        }
        token.value = this._code.slice(token.start, token.end);
      } else if (type2 === tt.regexp) {
        token.type = Token.RegularExpression;
        const value = token.value;
        token.regex = {
          flags: value.flags,
          pattern: value.pattern
        };
        token.value = `/${value.pattern}/${value.flags}`;
      }
      return token;
    },
    /**
     * Function to call during Acorn's onToken handler.
     * @param {AcornToken} token The Acorn token.
     * @param {Object} extra The Espree extra object.
     * @returns {void}
     */
    onToken(token, extra) {
      const tt = this._acornTokTypes, tokens = extra.tokens, templateTokens = this._tokens;
      const translateTemplateTokens = () => {
        tokens.push(convertTemplatePart(this._tokens, this._code));
        this._tokens = [];
      };
      if (token.type === tt.eof) {
        if (this._curlyBrace) {
          tokens.push(this.translate(this._curlyBrace, extra));
        }
        return;
      }
      if (token.type === tt.backQuote) {
        if (this._curlyBrace) {
          tokens.push(this.translate(this._curlyBrace, extra));
          this._curlyBrace = null;
        }
        templateTokens.push(token);
        if (templateTokens.length > 1) {
          translateTemplateTokens();
        }
        return;
      }
      if (token.type === tt.dollarBraceL) {
        templateTokens.push(token);
        translateTemplateTokens();
        return;
      }
      if (token.type === tt.braceR) {
        if (this._curlyBrace) {
          tokens.push(this.translate(this._curlyBrace, extra));
        }
        this._curlyBrace = token;
        return;
      }
      if (token.type === tt.template || token.type === tt.invalidTemplate) {
        if (this._curlyBrace) {
          templateTokens.push(this._curlyBrace);
          this._curlyBrace = null;
        }
        templateTokens.push(token);
        return;
      }
      if (this._curlyBrace) {
        tokens.push(this.translate(this._curlyBrace, extra));
        this._curlyBrace = null;
      }
      tokens.push(this.translate(token, extra));
    }
  };
  const SUPPORTED_VERSIONS = [
    3,
    5,
    6,
    // 2015
    7,
    // 2016
    8,
    // 2017
    9,
    // 2018
    10,
    // 2019
    11,
    // 2020
    12,
    // 2021
    13,
    // 2022
    14,
    // 2023
    15,
    // 2024
    16,
    // 2025
    17
    // 2026
  ];
  function getLatestEcmaVersion() {
    return SUPPORTED_VERSIONS.at(-1);
  }
  function getSupportedEcmaVersions() {
    return [...SUPPORTED_VERSIONS];
  }
  function normalizeEcmaVersion(ecmaVersion2 = 5) {
    let version3 = ecmaVersion2 === "latest" ? getLatestEcmaVersion() : ecmaVersion2;
    if (typeof version3 !== "number") {
      throw new Error(`ecmaVersion must be a number or "latest". Received value of type ${typeof ecmaVersion2} instead.`);
    }
    if (version3 >= 2015) {
      version3 -= 2009;
    }
    if (!SUPPORTED_VERSIONS.includes(version3)) {
      throw new Error("Invalid ecmaVersion.");
    }
    return version3;
  }
  function normalizeSourceType(sourceType = "script") {
    if (sourceType === "script" || sourceType === "module") {
      return sourceType;
    }
    if (sourceType === "commonjs") {
      return "script";
    }
    throw new Error("Invalid sourceType.");
  }
  function normalizeOptions(options) {
    const ecmaVersion2 = normalizeEcmaVersion(options.ecmaVersion);
    const sourceType = normalizeSourceType(options.sourceType);
    const ranges = options.range === true;
    const locations = options.loc === true;
    if (ecmaVersion2 !== 3 && options.allowReserved) {
      throw new Error("`allowReserved` is only supported when ecmaVersion is 3");
    }
    if (typeof options.allowReserved !== "undefined" && typeof options.allowReserved !== "boolean") {
      throw new Error("`allowReserved`, when present, must be `true` or `false`");
    }
    const allowReserved = ecmaVersion2 === 3 ? options.allowReserved || "never" : false;
    const ecmaFeatures = options.ecmaFeatures || {};
    const allowReturnOutsideFunction = options.sourceType === "commonjs" || Boolean(ecmaFeatures.globalReturn);
    if (sourceType === "module" && ecmaVersion2 < 6) {
      throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
    }
    return Object.assign({}, options, {
      ecmaVersion: ecmaVersion2,
      sourceType,
      ranges,
      locations,
      allowReserved,
      allowReturnOutsideFunction
    });
  }
  const STATE = Symbol("espree's internal state");
  const ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");
  function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code2) {
    let type2;
    if (block) {
      type2 = "Block";
    } else if (code2.slice(start, start + 2) === "#!") {
      type2 = "Hashbang";
    } else {
      type2 = "Line";
    }
    const comment2 = {
      type: type2,
      value: text
    };
    if (typeof start === "number") {
      comment2.start = start;
      comment2.end = end;
      comment2.range = [start, end];
    }
    if (typeof startLoc === "object") {
      comment2.loc = {
        start: startLoc,
        end: endLoc
      };
    }
    return comment2;
  }
  var espree$1 = () => (Parser2) => {
    const tokTypes = Object.assign({}, Parser2.acorn.tokTypes);
    if (Parser2.acornJsx) {
      Object.assign(tokTypes, Parser2.acornJsx.tokTypes);
    }
    return class Espree extends Parser2 {
      constructor(opts, code2) {
        if (typeof opts !== "object" || opts === null) {
          opts = {};
        }
        if (typeof code2 !== "string" && !(code2 instanceof String)) {
          code2 = String(code2);
        }
        const originalSourceType = opts.sourceType;
        const options = normalizeOptions(opts);
        const ecmaFeatures = options.ecmaFeatures || {};
        const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code2) : null;
        const state = {
          originalSourceType: originalSourceType || options.sourceType,
          tokens: tokenTranslator ? [] : null,
          comments: options.comment === true ? [] : null,
          impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,
          ecmaVersion: options.ecmaVersion,
          jsxAttrValueToken: false,
          lastToken: null,
          templateElements: []
        };
        super({
          // do not use spread, because we don't want to pass any unknown options to acorn
          ecmaVersion: options.ecmaVersion,
          sourceType: options.sourceType,
          ranges: options.ranges,
          locations: options.locations,
          allowReserved: options.allowReserved,
          // Truthy value is true for backward compatibility.
          allowReturnOutsideFunction: options.allowReturnOutsideFunction,
          // Collect tokens
          onToken(token) {
            if (tokenTranslator) {
              tokenTranslator.onToken(token, state);
            }
            if (token.type !== tokTypes.eof) {
              state.lastToken = token;
            }
          },
          // Collect comments
          onComment(block, text, start, end, startLoc, endLoc) {
            if (state.comments) {
              const comment2 = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code2);
              state.comments.push(comment2);
            }
          }
        }, code2);
        this[STATE] = state;
      }
      tokenize() {
        do {
          this.next();
        } while (this.type !== tokTypes.eof);
        this.next();
        const extra = this[STATE];
        const tokens = extra.tokens;
        if (extra.comments) {
          tokens.comments = extra.comments;
        }
        return tokens;
      }
      finishNode(...args) {
        const result = super.finishNode(...args);
        return this[ESPRIMA_FINISH_NODE](result);
      }
      finishNodeAt(...args) {
        const result = super.finishNodeAt(...args);
        return this[ESPRIMA_FINISH_NODE](result);
      }
      parse() {
        const extra = this[STATE];
        const program = super.parse();
        program.sourceType = extra.originalSourceType;
        if (extra.comments) {
          program.comments = extra.comments;
        }
        if (extra.tokens) {
          program.tokens = extra.tokens;
        }
        if (program.body.length) {
          const [firstNode] = program.body;
          if (program.range) {
            program.range[0] = firstNode.range[0];
          }
          if (program.loc) {
            program.loc.start = firstNode.loc.start;
          }
          program.start = firstNode.start;
        }
        if (extra.lastToken) {
          if (program.range) {
            program.range[1] = extra.lastToken.range[1];
          }
          if (program.loc) {
            program.loc.end = extra.lastToken.loc.end;
          }
          program.end = extra.lastToken.end;
        }
        this[STATE].templateElements.forEach((templateElement) => {
          const startOffset = -1;
          const endOffset = templateElement.tail ? 1 : 2;
          templateElement.start += startOffset;
          templateElement.end += endOffset;
          if (templateElement.range) {
            templateElement.range[0] += startOffset;
            templateElement.range[1] += endOffset;
          }
          if (templateElement.loc) {
            templateElement.loc.start.column += startOffset;
            templateElement.loc.end.column += endOffset;
          }
        });
        return program;
      }
      parseTopLevel(node2) {
        if (this[STATE].impliedStrict) {
          this.strict = true;
        }
        return super.parseTopLevel(node2);
      }
      /**
       * Overwrites the default raise method to throw Esprima-style errors.
       * @param {int} pos The position of the error.
       * @param {string} message The error message.
       * @throws {SyntaxError} A syntax error.
       * @returns {void}
       */
      raise(pos, message) {
        const loc = Parser2.acorn.getLineInfo(this.input, pos);
        const err = new SyntaxError(message);
        err.index = pos;
        err.lineNumber = loc.line;
        err.column = loc.column + 1;
        throw err;
      }
      /**
       * Overwrites the default raise method to throw Esprima-style errors.
       * @param {int} pos The position of the error.
       * @param {string} message The error message.
       * @throws {SyntaxError} A syntax error.
       * @returns {void}
       */
      raiseRecoverable(pos, message) {
        this.raise(pos, message);
      }
      /**
       * Overwrites the default unexpected method to throw Esprima-style errors.
       * @param {int} pos The position of the error.
       * @throws {SyntaxError} A syntax error.
       * @returns {void}
       */
      unexpected(pos) {
        let message = "Unexpected token";
        if (pos !== null && pos !== void 0) {
          this.pos = pos;
          if (this.options.locations) {
            while (this.pos < this.lineStart) {
              this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
              --this.curLine;
            }
          }
          this.nextToken();
        }
        if (this.end > this.start) {
          message += ` ${this.input.slice(this.start, this.end)}`;
        }
        this.raise(this.start, message);
      }
      /*
      * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
      * uses regular tt.string without any distinction between this and regular JS
      * strings. As such, we intercept an attempt to read a JSX string and set a flag
      * on extra so that when tokens are converted, the next token will be switched
      * to JSXText via onToken.
      */
      jsx_readString(quote) {
        const result = super.jsx_readString(quote);
        if (this.type === tokTypes.string) {
          this[STATE].jsxAttrValueToken = true;
        }
        return result;
      }
      /**
       * Performs last-minute Esprima-specific compatibility checks and fixes.
       * @param {ASTNode} result The node to check.
       * @returns {ASTNode} The finished node.
       */
      [ESPRIMA_FINISH_NODE](result) {
        if (result.type === "TemplateElement") {
          this[STATE].templateElements.push(result);
        }
        if (result.type.includes("Function") && !result.generator) {
          result.generator = false;
        }
        return result;
      }
    };
  };
  const version$12 = "10.4.0";
  const parsers = {
    _regular: null,
    _jsx: null,
    get regular() {
      if (this._regular === null) {
        this._regular = acorn__namespace.Parser.extend(espree$1());
      }
      return this._regular;
    },
    get jsx() {
      if (this._jsx === null) {
        this._jsx = acorn__namespace.Parser.extend(jsx__default["default"](), espree$1());
      }
      return this._jsx;
    },
    get(options) {
      const useJsx = Boolean(
        options && options.ecmaFeatures && options.ecmaFeatures.jsx
      );
      return useJsx ? this.jsx : this.regular;
    }
  };
  function tokenize(code2, options) {
    const Parser2 = parsers.get(options);
    if (!options || options.tokens !== true) {
      options = Object.assign({}, options, { tokens: true });
    }
    return new Parser2(options, code2).tokenize();
  }
  function parse(code2, options) {
    const Parser2 = parsers.get(options);
    return new Parser2(options, code2).parse();
  }
  const version2 = version$12;
  const name2 = "espree";
  const VisitorKeys = function() {
    return visitorKeys__namespace.KEYS;
  }();
  const Syntax = function() {
    let key, types2 = {};
    if (typeof Object.create === "function") {
      types2 = /* @__PURE__ */ Object.create(null);
    }
    for (key in VisitorKeys) {
      if (Object.hasOwn(VisitorKeys, key)) {
        types2[key] = key;
      }
    }
    if (typeof Object.freeze === "function") {
      Object.freeze(types2);
    }
    return types2;
  }();
  const latestEcmaVersion = getLatestEcmaVersion();
  const supportedEcmaVersions = getSupportedEcmaVersions();
  espree.Syntax = Syntax;
  espree.VisitorKeys = VisitorKeys;
  espree.latestEcmaVersion = latestEcmaVersion;
  espree.name = name2;
  espree.parse = parse;
  espree.supportedEcmaVersions = supportedEcmaVersions;
  espree.tokenize = tokenize;
  espree.version = version2;
  return espree;
}
var lodash_merge = { exports: {} };
lodash_merge.exports;
var hasRequiredLodash_merge;
function requireLodash_merge() {
  if (hasRequiredLodash_merge) return lodash_merge.exports;
  hasRequiredLodash_merge = 1;
  (function(module, exports$1) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global$1 == "object" && global$1 && global$1.Object === Object && global$1;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports$1 && !exports$1.nodeType && exports$1;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array;
    Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
    var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
    }
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack2(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    Stack2.prototype.clear = stackClear;
    Stack2.prototype["delete"] = stackDelete;
    Stack2.prototype.get = stackGet;
    Stack2.prototype.has = stackHas;
    Stack2.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack2());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string2) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      {
        return buffer.slice();
      }
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = cloneArrayBuffer(typedArray.buffer);
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type2 = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge;
  })(lodash_merge, lodash_merge.exports);
  return lodash_merge.exports;
}
var version = "9.39.1";
var require$$5 = {
  version
};
var eslintrcUniversal = {};
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
var hasRequiredUri_all;
function requireUri_all() {
  if (hasRequiredUri_all) return uri_all.exports;
  hasRequiredUri_all = 1;
  (function(module, exports$1) {
    (function(global, factory) {
      factory(exports$1);
    })(this, function(exports$12) {
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x2 = 1; x2 < xl; ++x2) {
            sets[x2] = sets[x2].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o2) {
        return o2 === void 0 ? "undefined" : o2 === null ? "null" : Object.prototype.toString.call(o2).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
        subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i2) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i2 && _arr.length === i2) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i2) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i2);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++) arr2[i2] = arr[i2];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base2 = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter2 = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base2 - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type2) {
        throw new RangeError(errors[type2]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string2, fn) {
        var parts = string2.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        var labels = string2.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string2) {
        var output = [];
        var counter = 0;
        var length = string2.length;
        while (counter < length) {
          var value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base2;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base2
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i2 = 0;
        var n2 = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter2);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i2;
          for (
            var w = 1, k = base2;
            ;
            /* no condition */
            k += base2
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base2 || digit > floor((maxInt - i2) / w)) {
              error$1("overflow");
            }
            i2 += digit * w;
            var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t2) {
              break;
            }
            var baseMinusT = base2 - t2;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i2 - oldi, out, oldi == 0);
          if (floor(i2 / out) > maxInt - n2) {
            error$1("overflow");
          }
          n2 += floor(i2 / out);
          i2 %= out;
          output.splice(i2++, 0, n2);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n2 = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter2);
        }
        while (handledCPCount < inputLength) {
          var m2 = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n2 && currentValue < m2) {
                m2 = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m2 - n2) * handledCPCountPlusOne;
          n2 = m2;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n2 && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n2) {
                var q = delta;
                for (
                  var k = base2;
                  ;
                  /* no condition */
                  k += base2
                ) {
                  var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t2) {
                    break;
                  }
                  var qMinusT = q - t2;
                  var baseMinusT = base2 - t2;
                  output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n2;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c2 = chr.charCodeAt(0);
        var e2 = void 0;
        if (c2 < 16) e2 = "%0" + c2.toString(16).toUpperCase();
        else if (c2 < 128) e2 = "%" + c2.toString(16).toUpperCase();
        else if (c2 < 2048) e2 = "%" + (c2 >> 6 | 192).toString(16).toUpperCase() + "%" + (c2 & 63 | 128).toString(16).toUpperCase();
        else e2 = "%" + (c2 >> 12 | 224).toString(16).toUpperCase() + "%" + (c2 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c2 & 63 | 128).toString(16).toUpperCase();
        return e2;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i2 = 0;
        var il = str.length;
        while (i2 < il) {
          var c2 = parseInt(str.substr(i2 + 1, 2), 16);
          if (c2 < 128) {
            newStr += String.fromCharCode(c2);
            i2 += 3;
          } else if (c2 >= 194 && c2 < 224) {
            if (il - i2 >= 6) {
              var c22 = parseInt(str.substr(i2 + 4, 2), 16);
              newStr += String.fromCharCode((c2 & 31) << 6 | c22 & 63);
            } else {
              newStr += str.substr(i2, 6);
            }
            i2 += 6;
          } else if (c2 >= 224) {
            if (il - i2 >= 9) {
              var _c = parseInt(str.substr(i2 + 4, 2), 16);
              var c3 = parseInt(str.substr(i2 + 7, 2), 16);
              newStr += String.fromCharCode((c2 & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i2, 9);
            }
            i2 += 9;
          } else {
            newStr += str.substr(i2, 3);
            i2 += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x2 = 0; x2 < fieldCount; ++x2) {
            fields[x2] = firstFields[x2] || lastFields[lastFieldsStart + x2] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a2, b) {
            return b.length - a2.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e2) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e2;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s2 = im[0];
              input = input.slice(s2.length);
              output.push(s2);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) ;
          else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e2) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e2;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s2 = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s2 = removeDotSegments(s2);
          }
          if (authority === void 0) {
            s2 = s2.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s2);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base3, relative2) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base3 = parse(serialize(base3, options), options);
          relative2 = parse(serialize(relative2, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative2.scheme) {
          target.scheme = relative2.scheme;
          target.userinfo = relative2.userinfo;
          target.host = relative2.host;
          target.port = relative2.port;
          target.path = removeDotSegments(relative2.path || "");
          target.query = relative2.query;
        } else {
          if (relative2.userinfo !== void 0 || relative2.host !== void 0 || relative2.port !== void 0) {
            target.userinfo = relative2.userinfo;
            target.host = relative2.host;
            target.port = relative2.port;
            target.path = removeDotSegments(relative2.path || "");
            target.query = relative2.query;
          } else {
            if (!relative2.path) {
              target.path = base3.path;
              if (relative2.query !== void 0) {
                target.query = relative2.query;
              } else {
                target.query = base3.query;
              }
            } else {
              if (relative2.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative2.path);
              } else {
                if ((base3.userinfo !== void 0 || base3.host !== void 0 || base3.port !== void 0) && !base3.path) {
                  target.path = "/" + relative2.path;
                } else if (!base3.path) {
                  target.path = relative2.path;
                } else {
                  target.path = base3.path.slice(0, base3.path.lastIndexOf("/") + 1) + relative2.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative2.query;
            }
            target.userinfo = base3.userinfo;
            target.host = base3.host;
            target.port = base3.port;
          }
          target.scheme = base3.scheme;
        }
        target.fragment = relative2.fragment;
        return target;
      }
      function resolve2(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize2(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x2 = 0, xl = hfields.length; x2 < xl; ++x2) {
              var hfield = hfields[x2].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e2) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e2;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x2 = 0, xl = to.length; x2 < xl; ++x2) {
              var toAddr = String(to[x2]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e2) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e2;
              }
              to[x2] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name2 in headers) {
            if (headers[name2] !== O[name2]) {
              fields.push(name2.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name2].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports$12.SCHEMES = SCHEMES;
      exports$12.pctEncChar = pctEncChar;
      exports$12.pctDecChars = pctDecChars;
      exports$12.parse = parse;
      exports$12.removeDotSegments = removeDotSegments;
      exports$12.serialize = serialize;
      exports$12.resolveComponents = resolveComponents;
      exports$12.resolve = resolve2;
      exports$12.normalize = normalize2;
      exports$12.equal = equal;
      exports$12.escapeComponent = escapeComponent;
      exports$12.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports$12, "__esModule", { value: true });
    });
  })(uri_all, uri_all.exports);
  return uri_all.exports;
}
var fastDeepEqual;
var hasRequiredFastDeepEqual;
function requireFastDeepEqual() {
  if (hasRequiredFastDeepEqual) return fastDeepEqual;
  hasRequiredFastDeepEqual = 1;
  fastDeepEqual = function equal(a2, b) {
    if (a2 === b) return true;
    if (a2 && b && typeof a2 == "object" && typeof b == "object") {
      if (a2.constructor !== b.constructor) return false;
      var length, i2, keys2;
      if (Array.isArray(a2)) {
        length = a2.length;
        if (length != b.length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!equal(a2[i2], b[i2])) return false;
        return true;
      }
      if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
      if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
      if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
      keys2 = Object.keys(a2);
      length = keys2.length;
      if (length !== Object.keys(b).length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys2[i2])) return false;
      for (i2 = length; i2-- !== 0; ) {
        var key = keys2[i2];
        if (!equal(a2[key], b[key])) return false;
      }
      return true;
    }
    return a2 !== a2 && b !== b;
  };
  return fastDeepEqual;
}
var ucs2length;
var hasRequiredUcs2length;
function requireUcs2length() {
  if (hasRequiredUcs2length) return ucs2length;
  hasRequiredUcs2length = 1;
  ucs2length = function ucs2length2(str) {
    var length = 0, len = str.length, pos = 0, value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320) pos++;
      }
    }
    return length;
  };
  return ucs2length;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  util = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: requireFastDeepEqual(),
    ucs2length: requireUcs2length(),
    varOccurences,
    varReplace,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer
  };
  function copy(o2, to) {
    to = to || {};
    for (var key in o2) to[key] = o2[key];
    return to;
  }
  function checkDataType(dataType, data2, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch (dataType) {
      case "null":
        return data2 + EQUAL + "null";
      case "array":
        return OK + "Array.isArray(" + data2 + ")";
      case "object":
        return "(" + OK + data2 + AND + "typeof " + data2 + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data2 + "))";
      case "integer":
        return "(typeof " + data2 + EQUAL + '"number"' + AND + NOT + "(" + data2 + " % 1)" + AND + data2 + EQUAL + data2 + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
      case "number":
        return "(typeof " + data2 + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data2 + ")" : "") + ")";
      default:
        return "typeof " + data2 + EQUAL + '"' + dataType + '"';
    }
  }
  function checkDataTypes(dataTypes, data2, strictNumbers) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data2, strictNumbers, true);
      default:
        var code2 = "";
        var types2 = toHash(dataTypes);
        if (types2.array && types2.object) {
          code2 = types2.null ? "(" : "(!" + data2 + " || ";
          code2 += "typeof " + data2 + ' !== "object")';
          delete types2.null;
          delete types2.array;
          delete types2.object;
        }
        if (types2.number) delete types2.integer;
        for (var t2 in types2)
          code2 += (code2 ? " && " : "") + checkDataType(t2, data2, strictNumbers, true);
        return code2;
    }
  }
  var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types2 = [];
      for (var i2 = 0; i2 < dataTypes.length; i2++) {
        var t2 = dataTypes[i2];
        if (COERCE_TO_TYPES[t2]) types2[types2.length] = t2;
        else if (optionCoerceTypes === "array" && t2 === "array") types2[types2.length] = t2;
      }
      if (types2.length) return types2;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === "array" && dataTypes === "array") {
      return ["array"];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i2 = 0; i2 < arr.length; i2++) hash[arr[i2]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
  }
  function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
  }
  function schemaHasRules(schema, rules2) {
    if (typeof schema == "boolean") return !schema;
    for (var key in schema) if (rules2[key]) return true;
  }
  function schemaHasRulesExcept(schema, rules2, exceptKeyword) {
    if (typeof schema == "boolean") return !schema && exceptKeyword != "not";
    for (var key in schema) if (key != exceptKeyword && rules2[key]) return true;
  }
  function schemaUnknownRules(schema, rules2) {
    if (typeof schema == "boolean") return;
    for (var key in schema) if (!rules2[key]) return key;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up, jsonPointer, data2, matches;
    if ($data === "") return "rootData";
    if ($data[0] == "/") {
      if (!JSON_POINTER.test($data)) throw new Error("Invalid JSON-pointer: " + $data);
      jsonPointer = $data;
      data2 = "rootData";
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches) throw new Error("Invalid JSON-pointer: " + $data);
      up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == "#") {
        if (up >= lvl) throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
        return paths[lvl - up];
      }
      if (up > lvl) throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
      data2 = "data" + (lvl - up || "");
      if (!jsonPointer) return data2;
    }
    var expr = data2;
    var segments = jsonPointer.split("/");
    for (var i2 = 0; i2 < segments.length; i2++) {
      var segment = segments[i2];
      if (segment) {
        data2 += getProperty(unescapeJsonPointer(segment));
        expr += " && " + data2;
      }
    }
    return expr;
  }
  function joinPaths(a2, b) {
    if (a2 == '""') return b;
    return (a2 + " + " + b).replace(/([^\\])' \+ '/g, "$1");
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  return util;
}
var schema_obj;
var hasRequiredSchema_obj;
function requireSchema_obj() {
  if (hasRequiredSchema_obj) return schema_obj;
  hasRequiredSchema_obj = 1;
  var util2 = requireUtil();
  schema_obj = SchemaObject;
  function SchemaObject(obj) {
    util2.copy(obj, this);
  }
  return schema_obj;
}
var jsonSchemaTraverse = { exports: {} };
var hasRequiredJsonSchemaTraverse;
function requireJsonSchemaTraverse() {
  if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
  hasRequiredJsonSchemaTraverse = 1;
  var traverse = jsonSchemaTraverse.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i2 = 0; i2 < sch.length; i2++)
              _traverse(opts, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema, i2);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return jsonSchemaTraverse.exports;
}
var resolve_1;
var hasRequiredResolve;
function requireResolve() {
  if (hasRequiredResolve) return resolve_1;
  hasRequiredResolve = 1;
  var URI = requireUri_all(), equal = requireFastDeepEqual(), util2 = requireUtil(), SchemaObject = requireSchema_obj(), traverse = requireJsonSchemaTraverse();
  resolve_1 = resolve2;
  resolve2.normalizeId = normalizeId;
  resolve2.fullPath = getFullPath;
  resolve2.url = resolveUrl;
  resolve2.ids = resolveIds;
  resolve2.inlineRef = inlineRef;
  resolve2.schema = resolveSchema;
  function resolve2(compile, root, ref2) {
    var refVal = this._refs[ref2];
    if (typeof refVal == "string") {
      if (this._refs[refVal]) refVal = this._refs[refVal];
      else return resolve2.call(this, compile, root, refVal);
    }
    refVal = refVal || this._schemas[ref2];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root, ref2);
    var schema, v2, baseId;
    if (res) {
      schema = res.schema;
      root = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v2 = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
    } else if (schema !== void 0) {
      v2 = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
    }
    return v2;
  }
  function resolveSchema(root, ref2) {
    var p2 = URI.parse(ref2), refPath = _getFullPath(p2), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
      var id2 = normalizeId(refPath);
      var refVal = this._refs[id2];
      if (typeof refVal == "string") {
        return resolveRecursive.call(this, root, refVal, p2);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        root = refVal;
      } else {
        refVal = this._schemas[id2];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          if (id2 == normalizeId(ref2))
            return { schema: refVal, root, baseId };
          root = refVal;
        } else {
          return;
        }
      }
      if (!root.schema) return;
      baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p2, baseId, root.schema, root);
  }
  function resolveRecursive(root, ref2, parsedRef) {
    var res = resolveSchema.call(this, root, ref2);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root = res.root;
      var id2 = this._getId(schema);
      if (id2) baseId = resolveUrl(baseId, id2);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
  }
  var PREVENT_SCOPE_CHANGE = util2.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function getJsonPointer(parsedRef, baseId, schema, root) {
    parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/") return;
    var parts = parsedRef.fragment.split("/");
    for (var i2 = 1; i2 < parts.length; i2++) {
      var part = parts[i2];
      if (part) {
        part = util2.unescapeFragment(part);
        schema = schema[part];
        if (schema === void 0) break;
        var id2;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id2 = this._getId(schema);
          if (id2) baseId = resolveUrl(baseId, id2);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root, $ref);
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== void 0 && schema !== root.schema)
      return { schema, root, baseId };
  }
  var SIMPLE_INLINED = util2.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function inlineRef(schema, limit) {
    if (limit === false) return false;
    if (limit === void 0 || limit === true) return checkNoRef(schema);
    else if (limit) return countKeys(schema) <= limit;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i2 = 0; i2 < schema.length; i2++) {
        item = schema[i2];
        if (typeof item == "object" && !checkNoRef(item)) return false;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref") return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item)) return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) {
      for (var i2 = 0; i2 < schema.length; i2++) {
        item = schema[i2];
        if (typeof item == "object") count += countKeys(item);
        if (count == Infinity) return Infinity;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref") return Infinity;
        if (SIMPLE_INLINED[key]) {
          count++;
        } else {
          item = schema[key];
          if (typeof item == "object") count += countKeys(item) + 1;
          if (count == Infinity) return Infinity;
        }
      }
    }
    return count;
  }
  function getFullPath(id2, normalize2) {
    if (normalize2 !== false) id2 = normalizeId(id2);
    var p2 = URI.parse(id2);
    return _getFullPath(p2);
  }
  function _getFullPath(p2) {
    return URI.serialize(p2).split("#")[0] + "#";
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id2) {
    return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
  }
  function resolveUrl(baseId, id2) {
    id2 = normalizeId(id2);
    return URI.resolve(baseId, id2);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = { "": schemaId };
    var fullPaths = { "": getFullPath(schemaId, false) };
    var localRefs = {};
    var self2 = this;
    traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (jsonPtr === "") return;
      var id2 = self2._getId(sch);
      var baseId = baseIds[parentJsonPtr];
      var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
      if (keyIndex !== void 0)
        fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util2.escapeFragment(keyIndex));
      if (typeof id2 == "string") {
        id2 = baseId = normalizeId(baseId ? URI.resolve(baseId, id2) : id2);
        var refVal = self2._refs[id2];
        if (typeof refVal == "string") refVal = self2._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(sch, refVal.schema))
            throw new Error('id "' + id2 + '" resolves to more than one schema');
        } else if (id2 != normalizeId(fullPath)) {
          if (id2[0] == "#") {
            if (localRefs[id2] && !equal(sch, localRefs[id2]))
              throw new Error('id "' + id2 + '" resolves to more than one schema');
            localRefs[id2] = sch;
          } else {
            self2._refs[id2] = fullPath;
          }
        }
      }
      baseIds[jsonPtr] = baseId;
      fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
  }
  return resolve_1;
}
var error_classes;
var hasRequiredError_classes;
function requireError_classes() {
  if (hasRequiredError_classes) return error_classes;
  hasRequiredError_classes = 1;
  var resolve2 = requireResolve();
  error_classes = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
  };
  function ValidationError(errors) {
    this.message = "validation failed";
    this.errors = errors;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function(baseId, ref2) {
    return "can't resolve reference " + ref2 + " from id " + baseId;
  };
  function MissingRefError(baseId, ref2, message) {
    this.message = message || MissingRefError.message(baseId, ref2);
    this.missingRef = resolve2.url(baseId, ref2);
    this.missingSchema = resolve2.normalizeId(resolve2.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
  return error_classes;
}
var fastJsonStableStringify;
var hasRequiredFastJsonStableStringify;
function requireFastJsonStableStringify() {
  if (hasRequiredFastJsonStableStringify) return fastJsonStableStringify;
  hasRequiredFastJsonStableStringify = 1;
  fastJsonStableStringify = function(data2, opts) {
    if (!opts) opts = {};
    if (typeof opts === "function") opts = { cmp: opts };
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && /* @__PURE__ */ function(f2) {
      return function(node2) {
        return function(a2, b) {
          var aobj = { key: a2, value: node2[a2] };
          var bobj = { key: b, value: node2[b] };
          return f2(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify(node2) {
      if (node2 && node2.toJSON && typeof node2.toJSON === "function") {
        node2 = node2.toJSON();
      }
      if (node2 === void 0) return;
      if (typeof node2 == "number") return isFinite(node2) ? "" + node2 : "null";
      if (typeof node2 !== "object") return JSON.stringify(node2);
      var i2, out;
      if (Array.isArray(node2)) {
        out = "[";
        for (i2 = 0; i2 < node2.length; i2++) {
          if (i2) out += ",";
          out += stringify(node2[i2]) || "null";
        }
        return out + "]";
      }
      if (node2 === null) return "null";
      if (seen.indexOf(node2) !== -1) {
        if (cycles) return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node2) - 1;
      var keys2 = Object.keys(node2).sort(cmp && cmp(node2));
      out = "";
      for (i2 = 0; i2 < keys2.length; i2++) {
        var key = keys2[i2];
        var value = stringify(node2[key]);
        if (!value) continue;
        if (out) out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data2);
  };
  return fastJsonStableStringify;
}
var validate;
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  validate = function generate_validate(it, $keyword, $ruleType) {
    var out = "";
    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id2 = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
      var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
      if ($unknownKwd) {
        var $keywordsMsg = "unknown keyword: " + $unknownKwd;
        if (it.opts.strictKeywords === "log") it.logger.warn($keywordsMsg);
        else throw new Error($keywordsMsg);
      }
    }
    if (it.isTop) {
      out += " var validate = ";
      if ($async) {
        it.async = true;
        out += "async ";
      }
      out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id2 && (it.opts.sourceCode || it.opts.processCode)) {
        out += " " + ("/*# sourceURL=" + $id2 + " */") + " ";
      }
    }
    if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
      var $keyword = "false schema";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema2 = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      if (it.schema === false) {
        if (it.isTop) {
          $breakOnError = true;
        } else {
          out += " var " + $valid + " = false; ";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        if (it.isTop) {
          if ($async) {
            out += " return data; ";
          } else {
            out += " validate.errors = null; return true; ";
          }
        } else {
          out += " var " + $valid + " = true; ";
        }
      }
      if (it.isTop) {
        out += " }; return validate; ";
      }
      return out;
    }
    if (it.isTop) {
      var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
      it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
      it.baseId = it.baseId || it.rootId;
      delete it.isTop;
      it.dataPathArr = [""];
      if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
        var $defaultMsg = "default is ignored in the schema root";
        if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
        else throw new Error($defaultMsg);
      }
      out += " var vErrors = null; ";
      out += " var errors = 0;     ";
      out += " if (rootData === undefined) rootData = data; ";
    } else {
      var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
      if ($id2) it.baseId = it.resolve.url(it.baseId, $id2);
      if ($async && !it.async) throw new Error("async schema in sync schema");
      out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf("null") == -1) $typeSchema = $typeSchema.concat("null");
      } else if ($typeSchema != "null") {
        $typeSchema = [$typeSchema, "null"];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
      if (it.opts.extendRefs == "fail") {
        throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
      } else if (it.opts.extendRefs !== true) {
        $refKeywords = false;
        it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
      }
    }
    if (it.schema.$comment && it.opts.$comment) {
      out += " " + it.RULES.all.$comment.code(it, "$comment");
    }
    if ($typeSchema) {
      if (it.opts.coerceTypes) {
        var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
      }
      var $rulesGroup = it.RULES.types[$typeSchema];
      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
        var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
        out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
        if ($coerceToTypes) {
          var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
          out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
          if (it.opts.coerceTypes == "array") {
            out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
          }
          out += " if (" + $coerced + " !== undefined) ; ";
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $type = arr1[$i += 1];
              if ($type == "string") {
                out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
              } else if ($type == "number" || $type == "integer") {
                out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                if ($type == "integer") {
                  out += " && !(" + $data + " % 1)";
                }
                out += ")) " + $coerced + " = +" + $data + "; ";
              } else if ($type == "boolean") {
                out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
              } else if ($type == "null") {
                out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
              } else if (it.opts.coerceTypes == "array" && $type == "array") {
                out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
              }
            }
          }
          out += " else {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } if (" + $coerced + " !== undefined) {  ";
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " " + $data + " = " + $coerced + "; ";
          if (!$dataLvl) {
            out += "if (" + $parentData + " !== undefined)";
          }
          out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        }
        out += " } ";
      }
    }
    if (it.schema.$ref && !$refKeywords) {
      out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
      if ($breakOnError) {
        out += " } if (errors === ";
        if ($top) {
          out += "0";
        } else {
          out += "errs_" + $lvl;
        }
        out += ") { ";
        $closingBraces2 += "}";
      }
    } else {
      var arr2 = it.RULES;
      if (arr2) {
        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[i2 += 1];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
            }
            if (it.opts.useDefaults) {
              if ($rulesGroup.type == "object" && it.schema.properties) {
                var $schema2 = it.schema.properties, $schemaKeys = Object.keys($schema2);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[i3 += 1];
                    var $sch = $schema2[$propertyKey];
                    if ($sch.default !== void 0) {
                      var $passData = $data + it.util.getProperty($propertyKey);
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                var arr4 = it.schema.items;
                if (arr4) {
                  var $sch, $i = -1, l4 = arr4.length - 1;
                  while ($i < l4) {
                    $sch = arr4[$i += 1];
                    if ($sch.default !== void 0) {
                      var $passData = $data + "[" + $i + "]";
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it.opts.strictDefaults === "log") it.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it.opts.useDefaults == "shared") {
                          out += " " + it.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule, i5 = -1, l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[i5 += 1];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += " " + $code + " ";
                    if ($breakOnError) {
                      $closingBraces1 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces1 + " ";
              $closingBraces1 = "";
            }
            if ($rulesGroup.type) {
              out += " } ";
              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                out += " else { ";
                var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
              }
            }
            if ($breakOnError) {
              out += " if (errors === ";
              if ($top) {
                out += "0";
              } else {
                out += "errs_" + $lvl;
              }
              out += ") { ";
              $closingBraces2 += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces2 + " ";
    }
    if ($top) {
      if ($async) {
        out += " if (errors === 0) return data;           ";
        out += " else throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; ";
        out += " return errors === 0;       ";
      }
      out += " }; return validate;";
    } else {
      out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules2 = $rulesGroup2.rules;
      for (var i4 = 0; i4 < rules2.length; i4++)
        if ($shouldUseRule(rules2[i4])) return true;
    }
    function $shouldUseRule($rule2) {
      return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i4 = 0; i4 < impl.length; i4++)
        if (it.schema[impl[i4]] !== void 0) return true;
    }
    return out;
  };
  return validate;
}
var compile_1;
var hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile_1;
  hasRequiredCompile = 1;
  var resolve2 = requireResolve(), util2 = requireUtil(), errorClasses = requireError_classes(), stableStringify = requireFastJsonStableStringify();
  var validateGenerator = requireValidate();
  var ucs2length2 = util2.ucs2length;
  var equal = requireFastDeepEqual();
  var ValidationError = errorClasses.Validation;
  compile_1 = compile;
  function compile(schema, root, localRefs, baseId) {
    var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults2 = [], defaultsHash = {}, customRules = [];
    root = root || { schema, refVal, refs };
    var c2 = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c2.index];
    if (c2.compiling) return compilation.callValidate = callValidate;
    var formats = this._formats;
    var RULES = this.RULES;
    try {
      var v2 = localCompile(schema, root, localRefs, baseId);
      compilation.validate = v2;
      var cv = compilation.callValidate;
      if (cv) {
        cv.schema = v2.schema;
        cv.errors = null;
        cv.refs = v2.refs;
        cv.refVal = v2.refVal;
        cv.root = v2.root;
        cv.$async = v2.$async;
        if (opts.sourceCode) cv.source = v2.source;
      }
      return v2;
    } finally {
      endCompiling.call(this, schema, root, baseId);
    }
    function callValidate() {
      var validate2 = compilation.validate;
      var result = validate2.apply(this, arguments);
      callValidate.errors = validate2.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || _root && _root.schema == _schema;
      if (_root.schema != root.schema)
        return compile.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode2 = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util: util2,
        resolve: resolve2,
        resolveRef,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats,
        logger: self2.logger,
        self: self2
      });
      sourceCode2 = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults2, defaultCode) + vars(customRules, customRuleCode) + sourceCode2;
      if (opts.processCode) sourceCode2 = opts.processCode(sourceCode2, _schema);
      var validate2;
      try {
        var makeValidate = new Function(
          "self",
          "RULES",
          "formats",
          "root",
          "refVal",
          "defaults",
          "customRules",
          "equal",
          "ucs2length",
          "ValidationError",
          sourceCode2
        );
        validate2 = makeValidate(
          self2,
          RULES,
          formats,
          root,
          refVal,
          defaults2,
          customRules,
          equal,
          ucs2length2,
          ValidationError
        );
        refVal[0] = validate2;
      } catch (e2) {
        self2.logger.error("Error compiling schema, function code:", sourceCode2);
        throw e2;
      }
      validate2.schema = _schema;
      validate2.errors = null;
      validate2.refs = refs;
      validate2.refVal = refVal;
      validate2.root = isRoot ? validate2 : _root;
      if ($async) validate2.$async = true;
      if (opts.sourceCode === true) {
        validate2.source = {
          code: sourceCode2,
          patterns,
          defaults: defaults2
        };
      }
      return validate2;
    }
    function resolveRef(baseId2, ref2, isRoot) {
      ref2 = resolve2.url(baseId2, ref2);
      var refIndex = refs[ref2];
      var _refVal, refCode;
      if (refIndex !== void 0) {
        _refVal = refVal[refIndex];
        refCode = "refVal[" + refIndex + "]";
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root.refs) {
        var rootRefId = root.refs[ref2];
        if (rootRefId !== void 0) {
          _refVal = root.refVal[rootRefId];
          refCode = addLocalRef(ref2, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref2);
      var v3 = resolve2.call(self2, localCompile, root, ref2);
      if (v3 === void 0) {
        var localSchema = localRefs && localRefs[ref2];
        if (localSchema) {
          v3 = resolve2.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
        }
      }
      if (v3 === void 0) {
        removeLocalRef(ref2);
      } else {
        replaceLocalRef(ref2, v3);
        return resolvedRef(v3, refCode);
      }
    }
    function addLocalRef(ref2, v3) {
      var refId = refVal.length;
      refVal[refId] = v3;
      refs[ref2] = refId;
      return "refVal" + refId;
    }
    function removeLocalRef(ref2) {
      delete refs[ref2];
    }
    function replaceLocalRef(ref2, v3) {
      var refId = refs[ref2];
      refVal[refId] = v3;
    }
    function resolvedRef(refVal2, code2) {
      return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code: code2, schema: refVal2, inline: true } : { code: code2, $async: refVal2 && !!refVal2.$async };
    }
    function usePattern(regexStr) {
      var index = patternsHash[regexStr];
      if (index === void 0) {
        index = patternsHash[regexStr] = patterns.length;
        patterns[index] = regexStr;
      }
      return "pattern" + index;
    }
    function useDefault(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
          return "" + value;
        case "string":
          return util2.toQuotedString(value);
        case "object":
          if (value === null) return "null";
          var valueStr = stableStringify(value);
          var index = defaultsHash[valueStr];
          if (index === void 0) {
            index = defaultsHash[valueStr] = defaults2.length;
            defaults2[index] = value;
          }
          return "default" + index;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (deps && !deps.every(function(keyword2) {
          return Object.prototype.hasOwnProperty.call(parentSchema, keyword2);
        }))
          throw new Error("parent schema must have all required keywords: " + deps.join(","));
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log") self2.logger.error(message);
            else throw new Error(message);
          }
        }
      }
      var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
      var validate2;
      if (compile2) {
        validate2 = compile2.call(self2, schema2, parentSchema, it);
      } else if (macro) {
        validate2 = macro.call(self2, schema2, parentSchema, it);
        if (opts.validateSchema !== false) self2.validateSchema(validate2, true);
      } else if (inline) {
        validate2 = inline.call(self2, it, rule.keyword, schema2, parentSchema);
      } else {
        validate2 = rule.definition.validate;
        if (!validate2) return;
      }
      if (validate2 === void 0)
        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
      var index = customRules.length;
      customRules[index] = validate2;
      return {
        code: "customRule" + index,
        validate: validate2
      };
    }
  }
  function checkCompiling(schema, root, baseId) {
    var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0) return { index, compiling: true };
    index = this._compilations.length;
    this._compilations[index] = {
      schema,
      root,
      baseId
    };
    return { index, compiling: false };
  }
  function endCompiling(schema, root, baseId) {
    var i2 = compIndex.call(this, schema, root, baseId);
    if (i2 >= 0) this._compilations.splice(i2, 1);
  }
  function compIndex(schema, root, baseId) {
    for (var i2 = 0; i2 < this._compilations.length; i2++) {
      var c2 = this._compilations[i2];
      if (c2.schema == schema && c2.root == root && c2.baseId == baseId) return i2;
    }
    return -1;
  }
  function patternCode(i2, patterns) {
    return "var pattern" + i2 + " = new RegExp(" + util2.toQuotedString(patterns[i2]) + ");";
  }
  function defaultCode(i2) {
    return "var default" + i2 + " = defaults[" + i2 + "];";
  }
  function refValCode(i2, refVal) {
    return refVal[i2] === void 0 ? "" : "var refVal" + i2 + " = refVal[" + i2 + "];";
  }
  function customRuleCode(i2) {
    return "var customRule" + i2 + " = customRules[" + i2 + "];";
  }
  function vars(arr, statement) {
    if (!arr.length) return "";
    var code2 = "";
    for (var i2 = 0; i2 < arr.length; i2++)
      code2 += statement(i2, arr);
    return code2;
  }
  return compile_1;
}
var cache = { exports: {} };
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache.exports;
  hasRequiredCache = 1;
  var Cache = cache.exports = function Cache2() {
    this._cache = {};
  };
  Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
  };
  Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
  };
  Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
  return cache.exports;
}
var formats_1;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats_1;
  hasRequiredFormats = 1;
  var util2 = requireUtil();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  formats_1 = formats;
  function formats(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util2.copy(formats[mode]);
  }
  formats.fast = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL2,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: UUID,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  formats.full = {
    date,
    time,
    "date-time": date_time,
    uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL2,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date(str) {
    var matches = str.match(DATE);
    if (!matches) return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function time(str, full) {
    var matches = str.match(TIME);
    if (!matches) return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
      new RegExp(str);
      return true;
    } catch (e2) {
      return false;
    }
  }
  return formats_1;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = function generate_ref(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema2 == "#" || $schema2 == "#/") {
      if (it.isRoot) {
        $async = it.async;
        $refCode = "validate";
      } else {
        $async = it.root.schema.$async === true;
        $refCode = "root.refVal[0]";
      }
    } else {
      var $refVal = it.resolveRef(it.baseId, $schema2, it.isRoot);
      if ($refVal === void 0) {
        var $message = it.MissingRefError.message(it.baseId, $schema2);
        if (it.opts.missingRefs == "fail") {
          it.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema2) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema2) + "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: " + it.util.toQuotedString($schema2) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          if ($breakOnError) {
            out += " if (false) { ";
          }
        } else if (it.opts.missingRefs == "ignore") {
          it.logger.warn($message);
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          throw new it.MissingRefError(it.baseId, $schema2, $message);
        }
      } else if ($refVal.inline) {
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = "";
        $it.errSchemaPath = $schema2;
        var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += " " + $code + " ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
        }
      } else {
        $async = $refVal.$async === true || it.async && $refVal.$async !== false;
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.opts.passContext) {
        out += " " + $refCode + ".call(this, ";
      } else {
        out += " " + $refCode + "( ";
      }
      out += " " + $data + ", (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it.async) throw new Error("async schema referenced by sync schema");
        if ($breakOnError) {
          out += " var " + $valid + "; ";
        }
        out += " try { await " + __callValidate + "; ";
        if ($breakOnError) {
          out += " " + $valid + " = true; ";
        }
        out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
        if ($breakOnError) {
          out += " " + $valid + " = false; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " if (" + $valid + ") { ";
        }
      } else {
        out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
    }
    return out;
  };
  return ref;
}
var allOf;
var hasRequiredAllOf;
function requireAllOf() {
  if (hasRequiredAllOf) return allOf;
  hasRequiredAllOf = 1;
  allOf = function generate_allOf(it, $keyword, $ruleType) {
    var out = " ";
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += " if (true) { ";
      } else {
        out += " " + $closingBraces.slice(0, -1) + " ";
      }
    }
    return out;
  };
  return allOf;
}
var anyOf;
var hasRequiredAnyOf;
function requireAnyOf() {
  if (hasRequiredAnyOf) return anyOf;
  hasRequiredAnyOf = 1;
  anyOf = function generate_anyOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema2.every(function($sch2) {
      return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema2;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
          $closingBraces += "}";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return anyOf;
}
var comment;
var hasRequiredComment;
function requireComment() {
  if (hasRequiredComment) return comment;
  hasRequiredComment = 1;
  comment = function generate_comment(it, $keyword, $ruleType) {
    var out = " ";
    var $schema2 = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema2);
    if (it.opts.$comment === true) {
      out += " console.log(" + $comment + ");";
    } else if (typeof it.opts.$comment == "function") {
      out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    }
    return out;
  };
  return comment;
}
var _const;
var hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const;
  hasRequired_const = 1;
  _const = function generate_const(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    }
    if (!$isData) {
      out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _const;
}
var contains;
var hasRequiredContains;
function requireContains() {
  if (hasRequiredContains) return contains;
  hasRequiredContains = 1;
  contains = function generate_contains(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      out += " if (" + $nextValid + ") break; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else {
      out += " if (" + $data + ".length == 0) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else { ";
    if ($nonEmptySchema) {
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    }
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
  return contains;
}
var dependencies$1;
var hasRequiredDependencies;
function requireDependencies() {
  if (hasRequiredDependencies) return dependencies$1;
  hasRequiredDependencies = 1;
  dependencies$1 = function generate_dependencies(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
    for ($property in $schema2) {
      if ($property == "__proto__") continue;
      var $sch = $schema2[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it.errorPath;
    out += "var missing" + $lvl + ";";
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        if ($breakOnError) {
          out += " && ( ";
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $propertyKey = arr1[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ")) {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += "property " + it.util.escapeQuotes($deps[0]);
              } else {
                out += "properties " + it.util.escapeQuotes($deps.join(", "));
              }
              out += " when property " + it.util.escapeQuotes($property) + " is present' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          out += " ) { ";
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[i2 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
        out += " }   ";
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
        out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
        }
        out += ") { ";
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it.util.getProperty($property);
        $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
    if ($breakOnError) {
      out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return dependencies$1;
}
var _enum;
var hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  hasRequired_enum = 1;
  _enum = function generate_enum(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    }
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) {
      out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + ";";
    if ($isData) {
      out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    }
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _enum;
}
var format;
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat) return format;
  hasRequiredFormat = 1;
  format = function generate_format(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it.opts.format === false) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
      out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
      if (it.async) {
        out += " var async" + $lvl + " = " + $format + ".async; ";
      }
      out += " " + $format + " = " + $format + ".validate; } if (  ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " (";
      if ($unknownFormats != "ignore") {
        out += " (" + $schemaValue + " && !" + $format + " ";
        if ($allowUnknown) {
          out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
        }
        out += ") || ";
      }
      out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
      if (it.async) {
        out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
      } else {
        out += " " + $format + "(" + $data + ") ";
      }
      out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
      var $format = it.formats[$schema2];
      if (!$format) {
        if ($unknownFormats == "ignore") {
          it.logger.warn('unknown format "' + $schema2 + '" ignored in schema at path "' + it.errSchemaPath + '"');
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema2) >= 0) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else {
          throw new Error('unknown format "' + $schema2 + '" is used in schema at path "' + it.errSchemaPath + '"');
        }
      }
      var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
      var $formatType = $isObject && $format.type || "string";
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      if ($async) {
        if (!it.async) throw new Error("async format in sync schema");
        var $formatRef = "formats" + it.util.getProperty($schema2) + ".validate";
        out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
      } else {
        out += " if (! ";
        var $formatRef = "formats" + it.util.getProperty($schema2);
        if ($isObject) $formatRef += ".validate";
        if (typeof $format == "function") {
          out += " " + $formatRef + "(" + $data + ") ";
        } else {
          out += " " + $formatRef + ".test(" + $data + ") ";
        }
        out += ") { ";
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema2);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema2);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return format;
}
var _if;
var hasRequired_if;
function require_if() {
  if (hasRequired_if) return _if;
  hasRequired_if = 1;
  _if = function generate_if(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      out += "  " + it.validate($it) + " ";
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
      it.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += " if (" + $nextValid + ") {  ";
        $it.schema = it.schema["then"];
        $it.schemaPath = it.schemaPath + ".then";
        $it.errSchemaPath = it.errSchemaPath + "/then";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += " } ";
        if ($elsePresent) {
          out += " else { ";
        }
      } else {
        out += " if (!" + $nextValid + ") { ";
      }
      if ($elsePresent) {
        $it.schema = it.schema["else"];
        $it.schemaPath = it.schemaPath + ".else";
        $it.errSchemaPath = it.errSchemaPath + "/else";
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += " } ";
      }
      out += " if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " }   ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return _if;
}
var items;
var hasRequiredItems;
function requireItems() {
  if (hasRequiredItems) return items;
  hasRequiredItems = 1;
  items = function generate_items(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema2)) {
      var $additionalItems = it.schema.additionalItems;
      if ($additionalItems === false) {
        out += " " + $valid + " = " + $data + ".length <= " + $schema2.length + "; ";
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema2.length + " } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have more than " + $schema2.length + " items' ";
          }
          if (it.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
      var arr1 = $schema2;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
            var $passData = $data + "[" + $i + "]";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
            $it.dataPathArr[$dataNxt] = $i;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
        $it.schema = $additionalItems;
        $it.schemaPath = it.schemaPath + ".additionalItems";
        $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
        out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema2.length + ") {  for (var " + $idx + " = " + $schema2.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " } }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    } else if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return items;
}
var _limit;
var hasRequired_limit;
function require_limit() {
  if (hasRequired_limit) return _limit;
  hasRequired_limit = 1;
  _limit = function generate__limit(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
    if (!($isData || typeof $schema2 == "number" || $schema2 === void 0)) {
      throw new Error($keyword + " must be number");
    }
    if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
      throw new Error($exclusiveKeyword + " must be number or boolean");
    }
    if ($isDataExcl) {
      var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
      $schemaValueExcl = "schemaExcl" + $lvl;
      out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
      if ($schema2 === void 0) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
      } else {
        if ($exclIsNumber && $schema2 === void 0) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += "=";
        } else {
          if ($exclIsNumber) $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema2);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $notOp += "=";
          } else {
            $exclusive = false;
            $opStr += "=";
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + " ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limit;
}
var _limitItems;
var hasRequired_limitItems;
function require_limitItems() {
  if (hasRequired_limitItems) return _limitItems;
  hasRequired_limitItems = 1;
  _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxItems") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " items' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitItems;
}
var _limitLength;
var hasRequired_limitLength;
function require_limitLength() {
  if (hasRequired_limitLength) return _limitLength;
  hasRequired_limitLength = 1;
  _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    if (it.opts.unicode === false) {
      out += " " + $data + ".length ";
    } else {
      out += " ucs2length(" + $data + ") ";
    }
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == "maxLength") {
          out += "longer";
        } else {
          out += "shorter";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " characters' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitLength;
}
var _limitProperties;
var hasRequired_limitProperties;
function require_limitProperties() {
  if (hasRequired_limitProperties) return _limitProperties;
  hasRequired_limitProperties = 1;
  _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxProperties") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema2;
        }
        out += " properties' ";
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return _limitProperties;
}
var multipleOf;
var hasRequiredMultipleOf;
function requireMultipleOf() {
  if (hasRequiredMultipleOf) return multipleOf;
  hasRequiredMultipleOf = 1;
  multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (!($isData || typeof $schema2 == "number")) {
      throw new Error($keyword + " must be number");
    }
    out += "var division" + $lvl + ";if (";
    if ($isData) {
      out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    }
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it.opts.multipleOfPrecision) {
      out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
    } else {
      out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    }
    out += " ) ";
    if ($isData) {
      out += "  )  ";
    }
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema2;
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return multipleOf;
}
var not;
var hasRequiredNot;
function requireNot() {
  if (hasRequiredNot) return not;
  hasRequiredNot = 1;
  not = function generate_not(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors;  ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += " " + it.validate($it) + " ";
      $it.createErrors = true;
      if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (" + $nextValid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it.opts.allErrors) {
        out += " } ";
      }
    } else {
      out += "  var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if ($breakOnError) {
        out += " if (false) { ";
      }
    }
    return out;
  };
  return not;
}
var oneOf;
var hasRequiredOneOf;
function requireOneOf() {
  if (hasRequiredOneOf) return oneOf;
  hasRequiredOneOf = 1;
  oneOf = function generate_oneOf(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema2;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
        } else {
          out += " var " + $nextValid + " = true; ";
        }
        if ($i) {
          out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
          $closingBraces += "}";
        }
        out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
    if (it.createErrors !== false) {
      out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
      if (it.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
  return oneOf;
}
var pattern;
var hasRequiredPattern;
function requirePattern() {
  if (hasRequiredPattern) return pattern;
  hasRequiredPattern = 1;
  pattern = function generate_pattern(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema2);
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it.createErrors !== false) {
      out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it.util.toQuotedString($schema2);
      }
      out += "  } ";
      if (it.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it.util.escapeQuotes($schema2);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it.util.toQuotedString($schema2);
        }
        out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
  return pattern;
}
var properties$3;
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties$3;
  hasRequiredProperties = 1;
  properties$3 = function generate_properties(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema2 || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
      var $requiredHash = it.util.toHash($required);
    }
    function notProto(p2) {
      return p2 !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined;";
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      if ($someProperties) {
        out += " var isAdditional" + $lvl + " = !(false ";
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[i1 += 1];
                out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $pProperty = arr2[$i += 1];
              out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
            }
          }
        }
        out += " ); if (isAdditional" + $lvl + ") { ";
      }
      if ($removeAdditional == "all") {
        out += " delete " + $data + "[" + $key + "]; ";
      } else {
        var $currentErrorPath = it.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            out += " " + $nextValid + " = false; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + "/additionalProperties";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is an invalid additional property";
                } else {
                  out += "should NOT have additional properties";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += " break; ";
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == "failing") {
            out += " var " + $errs + " = errors;  ";
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
            it.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
          }
        }
        it.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += " } ";
      }
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[i3 += 1];
          var $sch = $schema2[$propertyKey];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
            $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
            $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              $code = it.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += " var " + $nextData + " = " + $passData + "; ";
            }
            if ($hasDefault) {
              out += " " + $code + " ";
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = false; ";
                var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                $errSchemaPath = it.errSchemaPath + "/required";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                it.errorPath = $currentErrorPath;
                out += " } else { ";
              } else {
                if ($breakOnError) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = true; } else { ";
                } else {
                  out += " if (" + $useData + " !== undefined ";
                  if ($ownProperties) {
                    out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += " ) { ";
                }
              }
              out += " " + $code + " } ";
            }
          }
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty, i4 = -1, l4 = arr4.length - 1;
        while (i4 < l4) {
          $pProperty = arr4[i4 += 1];
          var $sch = $pProperties[$pProperty];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
            $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
            } else {
              out += " for (var " + $key + " in " + $data + ") { ";
            }
            out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
            $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else " + $nextValid + " = true; ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return properties$3;
}
var propertyNames;
var hasRequiredPropertyNames;
function requirePropertyNames() {
  if (hasRequiredPropertyNames) return propertyNames;
  hasRequiredPropertyNames = 1;
  propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it.opts.strictKeywords ? typeof $schema2 == "object" && Object.keys($schema2).length > 0 || $schema2 === false : it.util.schemaHasRules($schema2, it.RULES.all)) {
      $it.schema = $schema2;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined; ";
      }
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      out += " var startErrs" + $lvl + " = errors; ";
      var $passData = $key;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
        if (it.opts.messages !== false) {
          out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      if ($breakOnError) {
        out += " break; ";
      }
      out += " } }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
  return propertyNames;
}
var required$1;
var hasRequiredRequired;
function requireRequired() {
  if (hasRequiredRequired) return required$1;
  hasRequiredRequired = 1;
  required$1 = function generate_required(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
    }
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
      if ($schema2.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
        var $required = [];
        var arr1 = $schema2;
        if (arr1) {
          var $property, i1 = -1, l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[i1 += 1];
            var $propertySch = it.schema.properties[$property];
            if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema2;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
      if ($breakOnError) {
        out += " var missing" + $lvl + "; ";
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          out += " var " + $valid + " = true; ";
          if ($isData) {
            out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
          if ($ownProperties) {
            out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += "; if (!" + $valid + ") break; } ";
          if ($isData) {
            out += "  }  ";
          }
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        } else {
          out += " if ( ";
          var arr2 = $required;
          if (arr2) {
            var $propertyKey, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $propertyKey = arr2[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ") {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
          }
          if ($isData) {
            out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
          if ($ownProperties) {
            out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += ") {  var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
          if ($isData) {
            out += "  }  ";
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
      }
      it.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += " if (true) {";
    }
    return out;
  };
  return required$1;
}
var uniqueItems;
var hasRequiredUniqueItems;
function requireUniqueItems() {
  if (hasRequiredUniqueItems) return uniqueItems;
  hasRequiredUniqueItems = 1;
  uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    if (($schema2 || $isData) && it.opts.uniqueItems !== false) {
      if ($isData) {
        out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
      }
      out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
      var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
      if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
        out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
      } else {
        out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
        var $method = "checkDataType" + ($typeIsArray ? "s" : "");
        out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      out += " } ";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema2;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
  return uniqueItems;
}
var dotjs;
var hasRequiredDotjs;
function requireDotjs() {
  if (hasRequiredDotjs) return dotjs;
  hasRequiredDotjs = 1;
  dotjs = {
    "$ref": requireRef(),
    allOf: requireAllOf(),
    anyOf: requireAnyOf(),
    "$comment": requireComment(),
    const: require_const(),
    contains: requireContains(),
    dependencies: requireDependencies(),
    "enum": require_enum(),
    format: requireFormat(),
    "if": require_if(),
    items: requireItems(),
    maximum: require_limit(),
    minimum: require_limit(),
    maxItems: require_limitItems(),
    minItems: require_limitItems(),
    maxLength: require_limitLength(),
    minLength: require_limitLength(),
    maxProperties: require_limitProperties(),
    minProperties: require_limitProperties(),
    multipleOf: requireMultipleOf(),
    not: requireNot(),
    oneOf: requireOneOf(),
    pattern: requirePattern(),
    properties: requireProperties(),
    propertyNames: requirePropertyNames(),
    required: requireRequired(),
    uniqueItems: requireUniqueItems(),
    validate: requireValidate()
  };
  return dotjs;
}
var rules$3;
var hasRequiredRules$2;
function requireRules$2() {
  if (hasRequiredRules$2) return rules$3;
  hasRequiredRules$2 = 1;
  var ruleModules = requireDotjs(), toHash = requireUtil().toHash;
  rules$3 = function rules2() {
    var RULES = [
      {
        type: "number",
        rules: [
          { "maximum": ["exclusiveMaximum"] },
          { "minimum": ["exclusiveMinimum"] },
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          { "properties": ["additionalProperties", "patternProperties"] }
        ]
      },
      { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
    ];
    var ALL = ["type", "$comment"];
    var KEYWORDS = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ];
    var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
      group.rules = group.rules.map(function(keyword2) {
        var implKeywords;
        if (typeof keyword2 == "object") {
          var key = Object.keys(keyword2)[0];
          implKeywords = keyword2[key];
          keyword2 = key;
          implKeywords.forEach(function(k) {
            ALL.push(k);
            RULES.all[k] = true;
          });
        }
        ALL.push(keyword2);
        var rule = RULES.all[keyword2] = {
          keyword: keyword2,
          code: ruleModules[keyword2],
          implements: implKeywords
        };
        return rule;
      });
      RULES.all.$comment = {
        keyword: "$comment",
        code: ruleModules.$comment
      };
      if (group.type) RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
  return rules$3;
}
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData) return data;
  hasRequiredData = 1;
  var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  data = function(metaSchema, keywordsJsonPointers) {
    for (var i2 = 0; i2 < keywordsJsonPointers.length; i2++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i2].split("/");
      var keywords2 = metaSchema;
      var j;
      for (j = 1; j < segments.length; j++)
        keywords2 = keywords2[segments[j]];
      for (j = 0; j < KEYWORDS.length; j++) {
        var key = KEYWORDS[j];
        var schema = keywords2[key];
        if (schema) {
          keywords2[key] = {
            anyOf: [
              schema,
              { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
      }
    }
    return metaSchema;
  };
  return data;
}
var async;
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var MissingRefError = requireError_classes().MissingRef;
  async = compileAsync;
  function compileAsync(schema, meta2, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    if (typeof meta2 == "function") {
      callback = meta2;
      meta2 = void 0;
    }
    var p2 = loadMetaSchemaOf(schema).then(function() {
      var schemaObj = self2._addSchema(schema, void 0, meta2);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p2.then(
        function(v2) {
          callback(null, v2);
        },
        callback
      );
    }
    return p2;
    function loadMetaSchemaOf(sch) {
      var $schema2 = sch.$schema;
      return $schema2 && !self2.getSchema($schema2) ? compileAsync.call(self2, { $ref: $schema2 }, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e2) {
        if (e2 instanceof MissingRefError) return loadMissingSchema(e2);
        throw e2;
      }
      function loadMissingSchema(e2) {
        var ref2 = e2.missingSchema;
        if (added(ref2)) throw new Error("Schema " + ref2 + " is loaded but " + e2.missingRef + " cannot be resolved");
        var schemaPromise = self2._loadingSchemas[ref2];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref2] = self2._opts.loadSchema(ref2);
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise.then(function(sch) {
          if (!added(ref2)) {
            return loadMetaSchemaOf(sch).then(function() {
              if (!added(ref2)) self2.addSchema(sch, ref2, void 0, meta2);
            });
          }
        }).then(function() {
          return _compileAsync(schemaObj);
        });
        function removePromise() {
          delete self2._loadingSchemas[ref2];
        }
        function added(ref3) {
          return self2._refs[ref3] || self2._schemas[ref3];
        }
      }
    }
  }
  return async;
}
var custom;
var hasRequiredCustom;
function requireCustom() {
  if (hasRequiredCustom) return custom;
  hasRequiredCustom = 1;
  custom = function generate_custom(it, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema2 = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it.opts.$data && $schema2 && $schema2.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it.util.getData($schema2.$data, $dataLvl, it.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema2;
    }
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = "keywordValidate" + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
      $ruleValidate = it.useCustomRule($rule, $schema2, it.schema, it);
      if (!$ruleValidate) return;
      $schemaValue = "validate.schema" + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async) throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) {
      out += "" + $ruleErrs + " = null;";
    }
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
      $closingBraces += "}";
      out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
      if ($validateSchema) {
        $closingBraces += "}";
        out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += " " + $ruleValidate.validate + " ";
      } else {
        out += " " + $valid + " = " + $ruleValidate.validate + "; ";
      }
    } else if ($macro) {
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = "";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      out += "  " + $validateCode + ".call( ";
      if (it.opts.passContext) {
        out += "this";
      } else {
        out += "self";
      }
      if ($compile || $rDef.schema === false) {
        out += " , " + $data + " ";
      } else {
        out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
      }
      out += " , (dataPath || '')";
      if (it.errorPath != '""') {
        out += " + " + it.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += " " + $valid + " = ";
        if ($asyncKeyword) {
          out += "await ";
        }
        out += "" + def_callRuleValidate + "; ";
      } else {
        if ($asyncKeyword) {
          $ruleErrs = "customErrors" + $lvl;
          out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else {
          out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
        }
      }
    }
    if ($rDef.modifying) {
      out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    }
    out += "" + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    } else {
      out += " if ( ";
      if ($rDef.valid === void 0) {
        out += " !";
        if ($macro) {
          out += "" + $nextValid;
        } else {
          out += "" + $valid;
        }
      } else {
        out += " " + !$rDef.valid + " ";
      }
      out += ") { ";
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != "full") {
            out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } ";
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } ";
          }
        }
      } else if ($macro) {
        out += "   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
          if (it.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } else { " + def_customError + " } ";
        }
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
    return out;
  };
  return custom;
}
var $schema$2 = "http://json-schema.org/draft-07/schema#";
var $id$1 = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
var type$2 = [
  "object",
  "boolean"
];
var properties$2 = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var require$$13 = {
  $schema: $schema$2,
  $id: $id$1,
  title,
  definitions: definitions$1,
  type: type$2,
  properties: properties$2,
  "default": true
};
var definition_schema;
var hasRequiredDefinition_schema;
function requireDefinition_schema() {
  if (hasRequiredDefinition_schema) return definition_schema;
  hasRequiredDefinition_schema = 1;
  var metaSchema = require$$13;
  definition_schema = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: { not: { required: ["macro"] } }
    },
    properties: {
      type: metaSchema.properties.type,
      schema: { type: "boolean" },
      statements: { type: "boolean" },
      dependencies: {
        type: "array",
        items: { type: "string" }
      },
      metaSchema: { type: "object" },
      modifying: { type: "boolean" },
      valid: { type: "boolean" },
      $data: { type: "boolean" },
      async: { type: "boolean" },
      errors: {
        anyOf: [
          { type: "boolean" },
          { const: "full" }
        ]
      }
    }
  };
  return definition_schema;
}
var keyword$1;
var hasRequiredKeyword$1;
function requireKeyword$1() {
  if (hasRequiredKeyword$1) return keyword$1;
  hasRequiredKeyword$1 = 1;
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = requireCustom();
  var definitionSchema = requireDefinition_schema();
  keyword$1 = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
  };
  function addKeyword(keyword2, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword2])
      throw new Error("Keyword " + keyword2 + " is already defined");
    if (!IDENTIFIER.test(keyword2))
      throw new Error("Keyword " + keyword2 + " is not a valid identifier");
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType = definition.type;
      if (Array.isArray(dataType)) {
        for (var i2 = 0; i2 < dataType.length; i2++)
          _addRule(keyword2, dataType[i2], definition);
      } else {
        _addRule(keyword2, dataType, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
            ]
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword2] = RULES.all[keyword2] = true;
    function _addRule(keyword3, dataType2, definition2) {
      var ruleGroup;
      for (var i3 = 0; i3 < RULES.length; i3++) {
        var rg = RULES[i3];
        if (rg.type == dataType2) {
          ruleGroup = rg;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword3,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword3] = rule;
    }
    return this;
  }
  function getKeyword(keyword2) {
    var rule = this.RULES.custom[keyword2];
    return rule ? rule.definition : this.RULES.keywords[keyword2] || false;
  }
  function removeKeyword(keyword2) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword2];
    delete RULES.all[keyword2];
    delete RULES.custom[keyword2];
    for (var i2 = 0; i2 < RULES.length; i2++) {
      var rules2 = RULES[i2].rules;
      for (var j = 0; j < rules2.length; j++) {
        if (rules2[j].keyword == keyword2) {
          rules2.splice(j, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v2 = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v2(definition)) return true;
    validateKeyword.errors = v2.errors;
    if (throwError)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(v2.errors));
    else
      return false;
  }
  return keyword$1;
}
var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $id = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description$1 = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type$1 = "object";
var required = [
  "$data"
];
var properties$1 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
var additionalProperties = false;
var require$$12 = {
  $schema: $schema$1,
  $id,
  description: description$1,
  type: type$1,
  required,
  properties: properties$1,
  additionalProperties
};
var ajv$1;
var hasRequiredAjv$1;
function requireAjv$1() {
  if (hasRequiredAjv$1) return ajv$1;
  hasRequiredAjv$1 = 1;
  var compileSchema = requireCompile(), resolve2 = requireResolve(), Cache = requireCache(), SchemaObject = requireSchema_obj(), stableStringify = requireFastJsonStableStringify(), formats = requireFormats(), rules2 = requireRules$2(), $dataMetaSchema = requireData(), util2 = requireUtil();
  ajv$1 = Ajv;
  Ajv.prototype.validate = validate2;
  Ajv.prototype.compile = compile;
  Ajv.prototype.addSchema = addSchema;
  Ajv.prototype.addMetaSchema = addMetaSchema;
  Ajv.prototype.validateSchema = validateSchema;
  Ajv.prototype.getSchema = getSchema;
  Ajv.prototype.removeSchema = removeSchema;
  Ajv.prototype.addFormat = addFormat;
  Ajv.prototype.errorsText = errorsText;
  Ajv.prototype._addSchema = _addSchema;
  Ajv.prototype._compile = _compile;
  Ajv.prototype.compileAsync = requireAsync();
  var customKeyword = requireKeyword$1();
  Ajv.prototype.addKeyword = customKeyword.add;
  Ajv.prototype.getKeyword = customKeyword.get;
  Ajv.prototype.removeKeyword = customKeyword.remove;
  Ajv.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = requireError_classes();
  Ajv.ValidationError = errorClasses.Validation;
  Ajv.MissingRefError = errorClasses.MissingRef;
  Ajv.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
  var META_SUPPORT_DATA = ["/properties"];
  function Ajv(opts) {
    if (!(this instanceof Ajv)) return new Ajv(opts);
    opts = this._opts = util2.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache();
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules2();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property") opts._errorDataPathProperty = true;
    if (opts.serialize === void 0) opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats) addInitialFormats(this);
    if (opts.keywords) addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object") this.addMetaSchema(opts.meta);
    if (opts.nullable) this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
    addInitialSchemas(this);
  }
  function validate2(schemaKeyRef, data2) {
    var v2;
    if (typeof schemaKeyRef == "string") {
      v2 = this.getSchema(schemaKeyRef);
      if (!v2) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v2 = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v2(data2);
    if (v2.$async !== true) this.errors = v2.errors;
    return valid;
  }
  function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, void 0, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i2 = 0; i2 < schema.length; i2++) this.addSchema(schema[i2], void 0, _skipValidation, _meta);
      return this;
    }
    var id2 = this._getId(schema);
    if (id2 !== void 0 && typeof id2 != "string")
      throw new Error("schema id must be string");
    key = resolve2.normalizeId(key || id2);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema2 = schema.$schema;
    if ($schema2 !== void 0 && typeof $schema2 != "string")
      throw new Error("$schema must be a string");
    $schema2 = $schema2 || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema2) {
      this.logger.warn("meta-schema not available");
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema2, schema);
    if (!valid && throwOrLogError) {
      var message = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log") this.logger.error(message);
      else throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta2 = self2._opts.meta;
    self2._opts.defaultMeta = typeof meta2 == "object" ? self2._getId(meta2) || meta2 : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case "object":
        return schemaObj.validate || this._compile(schemaObj);
      case "string":
        return this.getSchema(schemaObj);
      case "undefined":
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref2) {
    var res = resolve2.schema.call(self2, { schema: {} }, ref2);
    if (res) {
      var schema = res.schema, root = res.root, baseId = res.baseId;
      var v2 = compileSchema.call(self2, schema, root, void 0, baseId);
      self2._fragments[ref2] = new SchemaObject({
        ref: ref2,
        fragment: true,
        schema,
        root,
        baseId,
        validate: v2
      });
      return v2;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve2.normalizeId(keyRef);
    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case "undefined":
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case "string":
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj) this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case "object":
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id2 = this._getId(schemaKeyRef);
        if (id2) {
          id2 = resolve2.normalizeId(id2);
          delete this._schemas[id2];
          delete this._refs[id2];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta2, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean")
      throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached) return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id2 = resolve2.normalizeId(this._getId(schema));
    if (id2 && shouldAddSchema) checkUnique(this, id2);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id2 && id2 == resolve2.normalizeId(schema.$schema)))
      this.validateSchema(schema, true);
    var localRefs = resolve2.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id: id2,
      schema,
      localRefs,
      cacheKey,
      meta: meta2
    });
    if (id2[0] != "#" && shouldAddSchema) this._refs[id2] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta) this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v2;
    try {
      v2 = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e2) {
      delete schemaObj.validate;
      throw e2;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) this._opts = currentOpts;
    }
    schemaObj.validate = v2;
    schemaObj.refs = v2.refs;
    schemaObj.refVal = v2.refVal;
    schemaObj.root = v2.root;
    return v2;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case "auto":
        return _get$IdOrId;
      case "id":
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id) this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id) this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
  }
  function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors) return "No errors";
    options = options || {};
    var separator = options.separator === void 0 ? ", " : options.separator;
    var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
    var text = "";
    for (var i2 = 0; i2 < errors.length; i2++) {
      var e2 = errors[i2];
      if (e2) text += dataVar + e2.dataPath + " " + e2.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name2, format2) {
    if (typeof format2 == "string") format2 = new RegExp(format2);
    this._formats[name2] = format2;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require$$12;
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false) return;
    var metaSchema = require$$13;
    if (self2._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
    else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats(self2) {
    for (var name2 in self2._opts.formats) {
      var format2 = self2._opts.formats[name2];
      self2.addFormat(name2, format2);
    }
  }
  function addInitialKeywords(self2) {
    for (var name2 in self2._opts.keywords) {
      var keyword2 = self2._opts.keywords[name2];
      self2.addKeyword(name2, keyword2);
    }
  }
  function checkUnique(self2, id2) {
    if (self2._schemas[id2] || self2._refs[id2])
      throw new Error('schema with key or id "' + id2 + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util2.copy(self2._opts);
    for (var i2 = 0; i2 < META_IGNORE_OPTIONS.length; i2++)
      delete metaOpts[META_IGNORE_OPTIONS[i2]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = { log: noop2, warn: noop2, error: noop2 };
    } else {
      if (logger === void 0) logger = console;
      if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
        throw new Error("logger must implement log, warn and error methods");
      self2.logger = logger;
    }
  }
  function noop2() {
  }
  return ajv$1;
}
var builtin = {
  AggregateError: false,
  "Array": false,
  "ArrayBuffer": false,
  Atomics: false,
  BigInt: false,
  BigInt64Array: false,
  BigUint64Array: false,
  "Boolean": false,
  constructor: false,
  "DataView": false,
  "Date": false,
  "decodeURI": false,
  "decodeURIComponent": false,
  "encodeURI": false,
  "encodeURIComponent": false,
  "Error": false,
  "escape": false,
  "eval": false,
  "EvalError": false,
  FinalizationRegistry: false,
  "Float32Array": false,
  "Float64Array": false,
  "Function": false,
  globalThis: false,
  hasOwnProperty: false,
  "Infinity": false,
  "Int16Array": false,
  "Int32Array": false,
  "Int8Array": false,
  "isFinite": false,
  "isNaN": false,
  isPrototypeOf: false,
  "JSON": false,
  "Map": false,
  "Math": false,
  "NaN": false,
  "Number": false,
  "Object": false,
  "parseFloat": false,
  "parseInt": false,
  "Promise": false,
  propertyIsEnumerable: false,
  "Proxy": false,
  "RangeError": false,
  "ReferenceError": false,
  "Reflect": false,
  "RegExp": false,
  "Set": false,
  SharedArrayBuffer: false,
  "String": false,
  "Symbol": false,
  "SyntaxError": false,
  toLocaleString: false,
  toString: false,
  "TypeError": false,
  "Uint16Array": false,
  "Uint32Array": false,
  "Uint8Array": false,
  "Uint8ClampedArray": false,
  "undefined": false,
  "unescape": false,
  "URIError": false,
  valueOf: false,
  "WeakMap": false,
  WeakRef: false,
  "WeakSet": false
};
var es5 = {
  "Array": false,
  "Boolean": false,
  constructor: false,
  "Date": false,
  "decodeURI": false,
  "decodeURIComponent": false,
  "encodeURI": false,
  "encodeURIComponent": false,
  "Error": false,
  "escape": false,
  "eval": false,
  "EvalError": false,
  "Function": false,
  hasOwnProperty: false,
  "Infinity": false,
  "isFinite": false,
  "isNaN": false,
  isPrototypeOf: false,
  "JSON": false,
  "Math": false,
  "NaN": false,
  "Number": false,
  "Object": false,
  "parseFloat": false,
  "parseInt": false,
  propertyIsEnumerable: false,
  "RangeError": false,
  "ReferenceError": false,
  "RegExp": false,
  "String": false,
  "SyntaxError": false,
  toLocaleString: false,
  toString: false,
  "TypeError": false,
  "undefined": false,
  "unescape": false,
  "URIError": false,
  valueOf: false
};
var es2015 = {
  "Array": false,
  "ArrayBuffer": false,
  "Boolean": false,
  constructor: false,
  "DataView": false,
  "Date": false,
  "decodeURI": false,
  "decodeURIComponent": false,
  "encodeURI": false,
  "encodeURIComponent": false,
  "Error": false,
  "escape": false,
  "eval": false,
  "EvalError": false,
  "Float32Array": false,
  "Float64Array": false,
  "Function": false,
  hasOwnProperty: false,
  "Infinity": false,
  "Int16Array": false,
  "Int32Array": false,
  "Int8Array": false,
  "isFinite": false,
  "isNaN": false,
  isPrototypeOf: false,
  "JSON": false,
  "Map": false,
  "Math": false,
  "NaN": false,
  "Number": false,
  "Object": false,
  "parseFloat": false,
  "parseInt": false,
  "Promise": false,
  propertyIsEnumerable: false,
  "Proxy": false,
  "RangeError": false,
  "ReferenceError": false,
  "Reflect": false,
  "RegExp": false,
  "Set": false,
  "String": false,
  "Symbol": false,
  "SyntaxError": false,
  toLocaleString: false,
  toString: false,
  "TypeError": false,
  "Uint16Array": false,
  "Uint32Array": false,
  "Uint8Array": false,
  "Uint8ClampedArray": false,
  "undefined": false,
  "unescape": false,
  "URIError": false,
  valueOf: false,
  "WeakMap": false,
  "WeakSet": false
};
var es2017 = {
  "Array": false,
  "ArrayBuffer": false,
  Atomics: false,
  "Boolean": false,
  constructor: false,
  "DataView": false,
  "Date": false,
  "decodeURI": false,
  "decodeURIComponent": false,
  "encodeURI": false,
  "encodeURIComponent": false,
  "Error": false,
  "escape": false,
  "eval": false,
  "EvalError": false,
  "Float32Array": false,
  "Float64Array": false,
  "Function": false,
  hasOwnProperty: false,
  "Infinity": false,
  "Int16Array": false,
  "Int32Array": false,
  "Int8Array": false,
  "isFinite": false,
  "isNaN": false,
  isPrototypeOf: false,
  "JSON": false,
  "Map": false,
  "Math": false,
  "NaN": false,
  "Number": false,
  "Object": false,
  "parseFloat": false,
  "parseInt": false,
  "Promise": false,
  propertyIsEnumerable: false,
  "Proxy": false,
  "RangeError": false,
  "ReferenceError": false,
  "Reflect": false,
  "RegExp": false,
  "Set": false,
  SharedArrayBuffer: false,
  "String": false,
  "Symbol": false,
  "SyntaxError": false,
  toLocaleString: false,
  toString: false,
  "TypeError": false,
  "Uint16Array": false,
  "Uint32Array": false,
  "Uint8Array": false,
  "Uint8ClampedArray": false,
  "undefined": false,
  "unescape": false,
  "URIError": false,
  valueOf: false,
  "WeakMap": false,
  "WeakSet": false
};
var es2020 = {
  "Array": false,
  "ArrayBuffer": false,
  Atomics: false,
  BigInt: false,
  BigInt64Array: false,
  BigUint64Array: false,
  "Boolean": false,
  constructor: false,
  "DataView": false,
  "Date": false,
  "decodeURI": false,
  "decodeURIComponent": false,
  "encodeURI": false,
  "encodeURIComponent": false,
  "Error": false,
  "escape": false,
  "eval": false,
  "EvalError": false,
  "Float32Array": false,
  "Float64Array": false,
  "Function": false,
  globalThis: false,
  hasOwnProperty: false,
  "Infinity": false,
  "Int16Array": false,
  "Int32Array": false,
  "Int8Array": false,
  "isFinite": false,
  "isNaN": false,
  isPrototypeOf: false,
  "JSON": false,
  "Map": false,
  "Math": false,
  "NaN": false,
  "Number": false,
  "Object": false,
  "parseFloat": false,
  "parseInt": false,
  "Promise": false,
  propertyIsEnumerable: false,
  "Proxy": false,
  "RangeError": false,
  "ReferenceError": false,
  "Reflect": false,
  "RegExp": false,
  "Set": false,
  SharedArrayBuffer: false,
  "String": false,
  "Symbol": false,
  "SyntaxError": false,
  toLocaleString: false,
  toString: false,
  "TypeError": false,
  "Uint16Array": false,
  "Uint32Array": false,
  "Uint8Array": false,
  "Uint8ClampedArray": false,
  "undefined": false,
  "unescape": false,
  "URIError": false,
  valueOf: false,
  "WeakMap": false,
  "WeakSet": false
};
var es2021 = {
  AggregateError: false,
  "Array": false,
  "ArrayBuffer": false,
  Atomics: false,
  BigInt: false,
  BigInt64Array: false,
  BigUint64Array: false,
  "Boolean": false,
  constructor: false,
  "DataView": false,
  "Date": false,
  "decodeURI": false,
  "decodeURIComponent": false,
  "encodeURI": false,
  "encodeURIComponent": false,
  "Error": false,
  "escape": false,
  "eval": false,
  "EvalError": false,
  FinalizationRegistry: false,
  "Float32Array": false,
  "Float64Array": false,
  "Function": false,
  globalThis: false,
  hasOwnProperty: false,
  "Infinity": false,
  "Int16Array": false,
  "Int32Array": false,
  "Int8Array": false,
  "isFinite": false,
  "isNaN": false,
  isPrototypeOf: false,
  "JSON": false,
  "Map": false,
  "Math": false,
  "NaN": false,
  "Number": false,
  "Object": false,
  "parseFloat": false,
  "parseInt": false,
  "Promise": false,
  propertyIsEnumerable: false,
  "Proxy": false,
  "RangeError": false,
  "ReferenceError": false,
  "Reflect": false,
  "RegExp": false,
  "Set": false,
  SharedArrayBuffer: false,
  "String": false,
  "Symbol": false,
  "SyntaxError": false,
  toLocaleString: false,
  toString: false,
  "TypeError": false,
  "Uint16Array": false,
  "Uint32Array": false,
  "Uint8Array": false,
  "Uint8ClampedArray": false,
  "undefined": false,
  "unescape": false,
  "URIError": false,
  valueOf: false,
  "WeakMap": false,
  WeakRef: false,
  "WeakSet": false
};
var browser$1 = {
  AbortController: false,
  AbortSignal: false,
  addEventListener: false,
  alert: false,
  AnalyserNode: false,
  Animation: false,
  AnimationEffectReadOnly: false,
  AnimationEffectTiming: false,
  AnimationEffectTimingReadOnly: false,
  AnimationEvent: false,
  AnimationPlaybackEvent: false,
  AnimationTimeline: false,
  applicationCache: false,
  ApplicationCache: false,
  ApplicationCacheErrorEvent: false,
  atob: false,
  Attr: false,
  Audio: false,
  AudioBuffer: false,
  AudioBufferSourceNode: false,
  AudioContext: false,
  AudioDestinationNode: false,
  AudioListener: false,
  AudioNode: false,
  AudioParam: false,
  AudioProcessingEvent: false,
  AudioScheduledSourceNode: false,
  AudioWorkletGlobalScope: false,
  AudioWorkletNode: false,
  AudioWorkletProcessor: false,
  BarProp: false,
  BaseAudioContext: false,
  BatteryManager: false,
  BeforeUnloadEvent: false,
  BiquadFilterNode: false,
  Blob: false,
  BlobEvent: false,
  blur: false,
  BroadcastChannel: false,
  btoa: false,
  BudgetService: false,
  ByteLengthQueuingStrategy: false,
  Cache: false,
  caches: false,
  CacheStorage: false,
  cancelAnimationFrame: false,
  cancelIdleCallback: false,
  CanvasCaptureMediaStreamTrack: false,
  CanvasGradient: false,
  CanvasPattern: false,
  CanvasRenderingContext2D: false,
  ChannelMergerNode: false,
  ChannelSplitterNode: false,
  CharacterData: false,
  clearInterval: false,
  clearTimeout: false,
  clientInformation: false,
  ClipboardEvent: false,
  ClipboardItem: false,
  close: false,
  closed: false,
  CloseEvent: false,
  Comment: false,
  CompositionEvent: false,
  CompressionStream: false,
  confirm: false,
  console: false,
  ConstantSourceNode: false,
  ConvolverNode: false,
  CountQueuingStrategy: false,
  createImageBitmap: false,
  Credential: false,
  CredentialsContainer: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CSS: false,
  CSSConditionRule: false,
  CSSFontFaceRule: false,
  CSSGroupingRule: false,
  CSSImportRule: false,
  CSSKeyframeRule: false,
  CSSKeyframesRule: false,
  CSSMatrixComponent: false,
  CSSMediaRule: false,
  CSSNamespaceRule: false,
  CSSPageRule: false,
  CSSPerspective: false,
  CSSRotate: false,
  CSSRule: false,
  CSSRuleList: false,
  CSSScale: false,
  CSSSkew: false,
  CSSSkewX: false,
  CSSSkewY: false,
  CSSStyleDeclaration: false,
  CSSStyleRule: false,
  CSSStyleSheet: false,
  CSSSupportsRule: false,
  CSSTransformValue: false,
  CSSTranslate: false,
  CustomElementRegistry: false,
  customElements: false,
  CustomEvent: false,
  DataTransfer: false,
  DataTransferItem: false,
  DataTransferItemList: false,
  DecompressionStream: false,
  defaultstatus: false,
  defaultStatus: false,
  DelayNode: false,
  DeviceMotionEvent: false,
  DeviceOrientationEvent: false,
  devicePixelRatio: false,
  dispatchEvent: false,
  document: false,
  Document: false,
  DocumentFragment: false,
  DocumentType: false,
  DOMError: false,
  DOMException: false,
  DOMImplementation: false,
  DOMMatrix: false,
  DOMMatrixReadOnly: false,
  DOMParser: false,
  DOMPoint: false,
  DOMPointReadOnly: false,
  DOMQuad: false,
  DOMRect: false,
  DOMRectList: false,
  DOMRectReadOnly: false,
  DOMStringList: false,
  DOMStringMap: false,
  DOMTokenList: false,
  DragEvent: false,
  DynamicsCompressorNode: false,
  Element: false,
  ErrorEvent: false,
  event: false,
  Event: false,
  EventSource: false,
  EventTarget: false,
  external: false,
  fetch: false,
  File: false,
  FileList: false,
  FileReader: false,
  find: false,
  focus: false,
  FocusEvent: false,
  FontFace: false,
  FontFaceSetLoadEvent: false,
  FormData: false,
  FormDataEvent: false,
  frameElement: false,
  frames: false,
  GainNode: false,
  Gamepad: false,
  GamepadButton: false,
  GamepadEvent: false,
  getComputedStyle: false,
  getSelection: false,
  HashChangeEvent: false,
  Headers: false,
  history: false,
  History: false,
  HTMLAllCollection: false,
  HTMLAnchorElement: false,
  HTMLAreaElement: false,
  HTMLAudioElement: false,
  HTMLBaseElement: false,
  HTMLBodyElement: false,
  HTMLBRElement: false,
  HTMLButtonElement: false,
  HTMLCanvasElement: false,
  HTMLCollection: false,
  HTMLContentElement: false,
  HTMLDataElement: false,
  HTMLDataListElement: false,
  HTMLDetailsElement: false,
  HTMLDialogElement: false,
  HTMLDirectoryElement: false,
  HTMLDivElement: false,
  HTMLDListElement: false,
  HTMLDocument: false,
  HTMLElement: false,
  HTMLEmbedElement: false,
  HTMLFieldSetElement: false,
  HTMLFontElement: false,
  HTMLFormControlsCollection: false,
  HTMLFormElement: false,
  HTMLFrameElement: false,
  HTMLFrameSetElement: false,
  HTMLHeadElement: false,
  HTMLHeadingElement: false,
  HTMLHRElement: false,
  HTMLHtmlElement: false,
  HTMLIFrameElement: false,
  HTMLImageElement: false,
  HTMLInputElement: false,
  HTMLLabelElement: false,
  HTMLLegendElement: false,
  HTMLLIElement: false,
  HTMLLinkElement: false,
  HTMLMapElement: false,
  HTMLMarqueeElement: false,
  HTMLMediaElement: false,
  HTMLMenuElement: false,
  HTMLMetaElement: false,
  HTMLMeterElement: false,
  HTMLModElement: false,
  HTMLObjectElement: false,
  HTMLOListElement: false,
  HTMLOptGroupElement: false,
  HTMLOptionElement: false,
  HTMLOptionsCollection: false,
  HTMLOutputElement: false,
  HTMLParagraphElement: false,
  HTMLParamElement: false,
  HTMLPictureElement: false,
  HTMLPreElement: false,
  HTMLProgressElement: false,
  HTMLQuoteElement: false,
  HTMLScriptElement: false,
  HTMLSelectElement: false,
  HTMLShadowElement: false,
  HTMLSlotElement: false,
  HTMLSourceElement: false,
  HTMLSpanElement: false,
  HTMLStyleElement: false,
  HTMLTableCaptionElement: false,
  HTMLTableCellElement: false,
  HTMLTableColElement: false,
  HTMLTableElement: false,
  HTMLTableRowElement: false,
  HTMLTableSectionElement: false,
  HTMLTemplateElement: false,
  HTMLTextAreaElement: false,
  HTMLTimeElement: false,
  HTMLTitleElement: false,
  HTMLTrackElement: false,
  HTMLUListElement: false,
  HTMLUnknownElement: false,
  HTMLVideoElement: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  IdleDeadline: false,
  IIRFilterNode: false,
  Image: false,
  ImageBitmap: false,
  ImageBitmapRenderingContext: false,
  ImageCapture: false,
  ImageData: false,
  indexedDB: false,
  innerHeight: false,
  innerWidth: false,
  InputEvent: false,
  IntersectionObserver: false,
  IntersectionObserverEntry: false,
  "Intl": false,
  isSecureContext: false,
  KeyboardEvent: false,
  KeyframeEffect: false,
  KeyframeEffectReadOnly: false,
  length: false,
  localStorage: false,
  location: true,
  Location: false,
  locationbar: false,
  matchMedia: false,
  MediaDeviceInfo: false,
  MediaDevices: false,
  MediaElementAudioSourceNode: false,
  MediaEncryptedEvent: false,
  MediaError: false,
  MediaKeyMessageEvent: false,
  MediaKeySession: false,
  MediaKeyStatusMap: false,
  MediaKeySystemAccess: false,
  MediaList: false,
  MediaMetadata: false,
  MediaQueryList: false,
  MediaQueryListEvent: false,
  MediaRecorder: false,
  MediaSettingsRange: false,
  MediaSource: false,
  MediaStream: false,
  MediaStreamAudioDestinationNode: false,
  MediaStreamAudioSourceNode: false,
  MediaStreamConstraints: false,
  MediaStreamEvent: false,
  MediaStreamTrack: false,
  MediaStreamTrackEvent: false,
  menubar: false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  MIDIAccess: false,
  MIDIConnectionEvent: false,
  MIDIInput: false,
  MIDIInputMap: false,
  MIDIMessageEvent: false,
  MIDIOutput: false,
  MIDIOutputMap: false,
  MIDIPort: false,
  MimeType: false,
  MimeTypeArray: false,
  MouseEvent: false,
  moveBy: false,
  moveTo: false,
  MutationEvent: false,
  MutationObserver: false,
  MutationRecord: false,
  name: false,
  NamedNodeMap: false,
  NavigationPreloadManager: false,
  navigator: false,
  Navigator: false,
  NavigatorUAData: false,
  NetworkInformation: false,
  Node: false,
  NodeFilter: false,
  NodeIterator: false,
  NodeList: false,
  Notification: false,
  OfflineAudioCompletionEvent: false,
  OfflineAudioContext: false,
  offscreenBuffering: false,
  OffscreenCanvas: true,
  OffscreenCanvasRenderingContext2D: false,
  onabort: true,
  onafterprint: true,
  onanimationend: true,
  onanimationiteration: true,
  onanimationstart: true,
  onappinstalled: true,
  onauxclick: true,
  onbeforeinstallprompt: true,
  onbeforeprint: true,
  onbeforeunload: true,
  onblur: true,
  oncancel: true,
  oncanplay: true,
  oncanplaythrough: true,
  onchange: true,
  onclick: true,
  onclose: true,
  oncontextmenu: true,
  oncuechange: true,
  ondblclick: true,
  ondevicemotion: true,
  ondeviceorientation: true,
  ondeviceorientationabsolute: true,
  ondrag: true,
  ondragend: true,
  ondragenter: true,
  ondragleave: true,
  ondragover: true,
  ondragstart: true,
  ondrop: true,
  ondurationchange: true,
  onemptied: true,
  onended: true,
  onerror: true,
  onfocus: true,
  ongotpointercapture: true,
  onhashchange: true,
  oninput: true,
  oninvalid: true,
  onkeydown: true,
  onkeypress: true,
  onkeyup: true,
  onlanguagechange: true,
  onload: true,
  onloadeddata: true,
  onloadedmetadata: true,
  onloadstart: true,
  onlostpointercapture: true,
  onmessage: true,
  onmessageerror: true,
  onmousedown: true,
  onmouseenter: true,
  onmouseleave: true,
  onmousemove: true,
  onmouseout: true,
  onmouseover: true,
  onmouseup: true,
  onmousewheel: true,
  onoffline: true,
  ononline: true,
  onpagehide: true,
  onpageshow: true,
  onpause: true,
  onplay: true,
  onplaying: true,
  onpointercancel: true,
  onpointerdown: true,
  onpointerenter: true,
  onpointerleave: true,
  onpointermove: true,
  onpointerout: true,
  onpointerover: true,
  onpointerup: true,
  onpopstate: true,
  onprogress: true,
  onratechange: true,
  onrejectionhandled: true,
  onreset: true,
  onresize: true,
  onscroll: true,
  onsearch: true,
  onseeked: true,
  onseeking: true,
  onselect: true,
  onstalled: true,
  onstorage: true,
  onsubmit: true,
  onsuspend: true,
  ontimeupdate: true,
  ontoggle: true,
  ontransitionend: true,
  onunhandledrejection: true,
  onunload: true,
  onvolumechange: true,
  onwaiting: true,
  onwheel: true,
  open: false,
  openDatabase: false,
  opener: false,
  Option: false,
  origin: false,
  OscillatorNode: false,
  outerHeight: false,
  outerWidth: false,
  OverconstrainedError: false,
  PageTransitionEvent: false,
  pageXOffset: false,
  pageYOffset: false,
  PannerNode: false,
  parent: false,
  Path2D: false,
  PaymentAddress: false,
  PaymentRequest: false,
  PaymentRequestUpdateEvent: false,
  PaymentResponse: false,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceLongTaskTiming: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceNavigationTiming: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformancePaintTiming: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  PeriodicWave: false,
  Permissions: false,
  PermissionStatus: false,
  personalbar: false,
  PhotoCapabilities: false,
  Plugin: false,
  PluginArray: false,
  PointerEvent: false,
  PopStateEvent: false,
  postMessage: false,
  Presentation: false,
  PresentationAvailability: false,
  PresentationConnection: false,
  PresentationConnectionAvailableEvent: false,
  PresentationConnectionCloseEvent: false,
  PresentationConnectionList: false,
  PresentationReceiver: false,
  PresentationRequest: false,
  print: false,
  ProcessingInstruction: false,
  ProgressEvent: false,
  PromiseRejectionEvent: false,
  prompt: false,
  PushManager: false,
  PushSubscription: false,
  PushSubscriptionOptions: false,
  queueMicrotask: false,
  RadioNodeList: false,
  Range: false,
  ReadableByteStreamController: false,
  ReadableStream: false,
  ReadableStreamBYOBReader: false,
  ReadableStreamBYOBRequest: false,
  ReadableStreamDefaultController: false,
  ReadableStreamDefaultReader: false,
  registerProcessor: false,
  RemotePlayback: false,
  removeEventListener: false,
  reportError: false,
  Request: false,
  requestAnimationFrame: false,
  requestIdleCallback: false,
  resizeBy: false,
  ResizeObserver: false,
  ResizeObserverEntry: false,
  resizeTo: false,
  Response: false,
  RTCCertificate: false,
  RTCDataChannel: false,
  RTCDataChannelEvent: false,
  RTCDtlsTransport: false,
  RTCIceCandidate: false,
  RTCIceGatherer: false,
  RTCIceTransport: false,
  RTCPeerConnection: false,
  RTCPeerConnectionIceEvent: false,
  RTCRtpContributingSource: false,
  RTCRtpReceiver: false,
  RTCRtpSender: false,
  RTCSctpTransport: false,
  RTCSessionDescription: false,
  RTCStatsReport: false,
  RTCTrackEvent: false,
  screen: false,
  Screen: false,
  screenLeft: false,
  ScreenOrientation: false,
  screenTop: false,
  screenX: false,
  screenY: false,
  ScriptProcessorNode: false,
  scroll: false,
  scrollbars: false,
  scrollBy: false,
  scrollTo: false,
  scrollX: false,
  scrollY: false,
  SecurityPolicyViolationEvent: false,
  Selection: false,
  self: false,
  ServiceWorker: false,
  ServiceWorkerContainer: false,
  ServiceWorkerRegistration: false,
  sessionStorage: false,
  setInterval: false,
  setTimeout: false,
  ShadowRoot: false,
  SharedWorker: false,
  SourceBuffer: false,
  SourceBufferList: false,
  speechSynthesis: false,
  SpeechSynthesisEvent: false,
  SpeechSynthesisUtterance: false,
  StaticRange: false,
  status: false,
  statusbar: false,
  StereoPannerNode: false,
  stop: false,
  Storage: false,
  StorageEvent: false,
  StorageManager: false,
  structuredClone: false,
  styleMedia: false,
  StyleSheet: false,
  StyleSheetList: false,
  SubmitEvent: false,
  SubtleCrypto: false,
  SVGAElement: false,
  SVGAngle: false,
  SVGAnimatedAngle: false,
  SVGAnimatedBoolean: false,
  SVGAnimatedEnumeration: false,
  SVGAnimatedInteger: false,
  SVGAnimatedLength: false,
  SVGAnimatedLengthList: false,
  SVGAnimatedNumber: false,
  SVGAnimatedNumberList: false,
  SVGAnimatedPreserveAspectRatio: false,
  SVGAnimatedRect: false,
  SVGAnimatedString: false,
  SVGAnimatedTransformList: false,
  SVGAnimateElement: false,
  SVGAnimateMotionElement: false,
  SVGAnimateTransformElement: false,
  SVGAnimationElement: false,
  SVGCircleElement: false,
  SVGClipPathElement: false,
  SVGComponentTransferFunctionElement: false,
  SVGDefsElement: false,
  SVGDescElement: false,
  SVGDiscardElement: false,
  SVGElement: false,
  SVGEllipseElement: false,
  SVGFEBlendElement: false,
  SVGFEColorMatrixElement: false,
  SVGFEComponentTransferElement: false,
  SVGFECompositeElement: false,
  SVGFEConvolveMatrixElement: false,
  SVGFEDiffuseLightingElement: false,
  SVGFEDisplacementMapElement: false,
  SVGFEDistantLightElement: false,
  SVGFEDropShadowElement: false,
  SVGFEFloodElement: false,
  SVGFEFuncAElement: false,
  SVGFEFuncBElement: false,
  SVGFEFuncGElement: false,
  SVGFEFuncRElement: false,
  SVGFEGaussianBlurElement: false,
  SVGFEImageElement: false,
  SVGFEMergeElement: false,
  SVGFEMergeNodeElement: false,
  SVGFEMorphologyElement: false,
  SVGFEOffsetElement: false,
  SVGFEPointLightElement: false,
  SVGFESpecularLightingElement: false,
  SVGFESpotLightElement: false,
  SVGFETileElement: false,
  SVGFETurbulenceElement: false,
  SVGFilterElement: false,
  SVGForeignObjectElement: false,
  SVGGElement: false,
  SVGGeometryElement: false,
  SVGGradientElement: false,
  SVGGraphicsElement: false,
  SVGImageElement: false,
  SVGLength: false,
  SVGLengthList: false,
  SVGLinearGradientElement: false,
  SVGLineElement: false,
  SVGMarkerElement: false,
  SVGMaskElement: false,
  SVGMatrix: false,
  SVGMetadataElement: false,
  SVGMPathElement: false,
  SVGNumber: false,
  SVGNumberList: false,
  SVGPathElement: false,
  SVGPatternElement: false,
  SVGPoint: false,
  SVGPointList: false,
  SVGPolygonElement: false,
  SVGPolylineElement: false,
  SVGPreserveAspectRatio: false,
  SVGRadialGradientElement: false,
  SVGRect: false,
  SVGRectElement: false,
  SVGScriptElement: false,
  SVGSetElement: false,
  SVGStopElement: false,
  SVGStringList: false,
  SVGStyleElement: false,
  SVGSVGElement: false,
  SVGSwitchElement: false,
  SVGSymbolElement: false,
  SVGTextContentElement: false,
  SVGTextElement: false,
  SVGTextPathElement: false,
  SVGTextPositioningElement: false,
  SVGTitleElement: false,
  SVGTransform: false,
  SVGTransformList: false,
  SVGTSpanElement: false,
  SVGUnitTypes: false,
  SVGUseElement: false,
  SVGViewElement: false,
  TaskAttributionTiming: false,
  Text: false,
  TextDecoder: false,
  TextDecoderStream: false,
  TextEncoder: false,
  TextEncoderStream: false,
  TextEvent: false,
  TextMetrics: false,
  TextTrack: false,
  TextTrackCue: false,
  TextTrackCueList: false,
  TextTrackList: false,
  TimeRanges: false,
  ToggleEvent: false,
  toolbar: false,
  top: false,
  Touch: false,
  TouchEvent: false,
  TouchList: false,
  TrackEvent: false,
  TransformStream: false,
  TransformStreamDefaultController: false,
  TransitionEvent: false,
  TreeWalker: false,
  UIEvent: false,
  URL: false,
  URLSearchParams: false,
  ValidityState: false,
  visualViewport: false,
  VisualViewport: false,
  VTTCue: false,
  WaveShaperNode: false,
  WebAssembly: false,
  WebGL2RenderingContext: false,
  WebGLActiveInfo: false,
  WebGLBuffer: false,
  WebGLContextEvent: false,
  WebGLFramebuffer: false,
  WebGLProgram: false,
  WebGLQuery: false,
  WebGLRenderbuffer: false,
  WebGLRenderingContext: false,
  WebGLSampler: false,
  WebGLShader: false,
  WebGLShaderPrecisionFormat: false,
  WebGLSync: false,
  WebGLTexture: false,
  WebGLTransformFeedback: false,
  WebGLUniformLocation: false,
  WebGLVertexArrayObject: false,
  WebSocket: false,
  WheelEvent: false,
  window: false,
  Window: false,
  Worker: false,
  WritableStream: false,
  WritableStreamDefaultController: false,
  WritableStreamDefaultWriter: false,
  XMLDocument: false,
  XMLHttpRequest: false,
  XMLHttpRequestEventTarget: false,
  XMLHttpRequestUpload: false,
  XMLSerializer: false,
  XPathEvaluator: false,
  XPathExpression: false,
  XPathResult: false,
  XRAnchor: false,
  XRBoundedReferenceSpace: false,
  XRCPUDepthInformation: false,
  XRDepthInformation: false,
  XRFrame: false,
  XRInputSource: false,
  XRInputSourceArray: false,
  XRInputSourceEvent: false,
  XRInputSourcesChangeEvent: false,
  XRPose: false,
  XRReferenceSpace: false,
  XRReferenceSpaceEvent: false,
  XRRenderState: false,
  XRRigidTransform: false,
  XRSession: false,
  XRSessionEvent: false,
  XRSpace: false,
  XRSystem: false,
  XRView: false,
  XRViewerPose: false,
  XRViewport: false,
  XRWebGLBinding: false,
  XRWebGLDepthInformation: false,
  XRWebGLLayer: false,
  XSLTProcessor: false
};
var worker = {
  addEventListener: false,
  applicationCache: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  ByteLengthQueuingStrategy: false,
  Cache: false,
  caches: false,
  clearInterval: false,
  clearTimeout: false,
  close: true,
  CompressionStream: false,
  console: false,
  CountQueuingStrategy: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CustomEvent: false,
  DecompressionStream: false,
  ErrorEvent: false,
  Event: false,
  fetch: false,
  File: false,
  FileReaderSync: false,
  FormData: false,
  Headers: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  ImageData: false,
  importScripts: true,
  indexedDB: false,
  location: false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  name: false,
  navigator: false,
  Notification: false,
  onclose: true,
  onconnect: true,
  onerror: true,
  onlanguagechange: true,
  onmessage: true,
  onoffline: true,
  ononline: true,
  onrejectionhandled: true,
  onunhandledrejection: true,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  postMessage: true,
  "Promise": false,
  queueMicrotask: false,
  ReadableByteStreamController: false,
  ReadableStream: false,
  ReadableStreamBYOBReader: false,
  ReadableStreamBYOBRequest: false,
  ReadableStreamDefaultController: false,
  ReadableStreamDefaultReader: false,
  removeEventListener: false,
  reportError: false,
  Request: false,
  Response: false,
  self: true,
  ServiceWorkerRegistration: false,
  setInterval: false,
  setTimeout: false,
  SubtleCrypto: false,
  TextDecoder: false,
  TextDecoderStream: false,
  TextEncoder: false,
  TextEncoderStream: false,
  TransformStream: false,
  TransformStreamDefaultController: false,
  URL: false,
  URLSearchParams: false,
  WebAssembly: false,
  WebSocket: false,
  Worker: false,
  WorkerGlobalScope: false,
  WritableStream: false,
  WritableStreamDefaultController: false,
  WritableStreamDefaultWriter: false,
  XMLHttpRequest: false
};
var node = {
  __dirname: false,
  __filename: false,
  AbortController: false,
  AbortSignal: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  Buffer: false,
  ByteLengthQueuingStrategy: false,
  clearImmediate: false,
  clearInterval: false,
  clearTimeout: false,
  CompressionStream: false,
  console: false,
  CountQueuingStrategy: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CustomEvent: false,
  DecompressionStream: false,
  DOMException: false,
  Event: false,
  EventTarget: false,
  exports: true,
  fetch: false,
  File: false,
  FormData: false,
  global: false,
  Headers: false,
  "Intl": false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  module: false,
  performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformanceResourceTiming: false,
  process: false,
  queueMicrotask: false,
  ReadableByteStreamController: false,
  ReadableStream: false,
  ReadableStreamBYOBReader: false,
  ReadableStreamBYOBRequest: false,
  ReadableStreamDefaultController: false,
  ReadableStreamDefaultReader: false,
  Request: false,
  require: false,
  Response: false,
  setImmediate: false,
  setInterval: false,
  setTimeout: false,
  structuredClone: false,
  SubtleCrypto: false,
  TextDecoder: false,
  TextDecoderStream: false,
  TextEncoder: false,
  TextEncoderStream: false,
  TransformStream: false,
  TransformStreamDefaultController: false,
  URL: false,
  URLSearchParams: false,
  WebAssembly: false,
  WritableStream: false,
  WritableStreamDefaultController: false,
  WritableStreamDefaultWriter: false
};
var nodeBuiltin = {
  AbortController: false,
  AbortSignal: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  Buffer: false,
  ByteLengthQueuingStrategy: false,
  clearImmediate: false,
  clearInterval: false,
  clearTimeout: false,
  CompressionStream: false,
  console: false,
  CountQueuingStrategy: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CustomEvent: false,
  DecompressionStream: false,
  DOMException: false,
  Event: false,
  EventTarget: false,
  fetch: false,
  File: false,
  FormData: false,
  global: false,
  Headers: false,
  "Intl": false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformanceResourceTiming: false,
  process: false,
  queueMicrotask: false,
  ReadableByteStreamController: false,
  ReadableStream: false,
  ReadableStreamBYOBReader: false,
  ReadableStreamBYOBRequest: false,
  ReadableStreamDefaultController: false,
  ReadableStreamDefaultReader: false,
  Request: false,
  Response: false,
  setImmediate: false,
  setInterval: false,
  setTimeout: false,
  structuredClone: false,
  SubtleCrypto: false,
  TextDecoder: false,
  TextDecoderStream: false,
  TextEncoder: false,
  TextEncoderStream: false,
  TransformStream: false,
  TransformStreamDefaultController: false,
  URL: false,
  URLSearchParams: false,
  WebAssembly: false,
  WritableStream: false,
  WritableStreamDefaultController: false,
  WritableStreamDefaultWriter: false
};
var commonjs = {
  exports: true,
  global: false,
  module: false,
  require: false
};
var amd = {
  define: false,
  require: false
};
var mocha = {
  after: false,
  afterEach: false,
  before: false,
  beforeEach: false,
  context: false,
  describe: false,
  it: false,
  mocha: false,
  run: false,
  setup: false,
  specify: false,
  suite: false,
  suiteSetup: false,
  suiteTeardown: false,
  teardown: false,
  test: false,
  xcontext: false,
  xdescribe: false,
  xit: false,
  xspecify: false
};
var jasmine = {
  afterAll: false,
  afterEach: false,
  beforeAll: false,
  beforeEach: false,
  describe: false,
  expect: false,
  expectAsync: false,
  fail: false,
  fdescribe: false,
  fit: false,
  it: false,
  jasmine: false,
  pending: false,
  runs: false,
  spyOn: false,
  spyOnAllFunctions: false,
  spyOnProperty: false,
  waits: false,
  waitsFor: false,
  xdescribe: false,
  xit: false
};
var jest = {
  afterAll: false,
  afterEach: false,
  beforeAll: false,
  beforeEach: false,
  describe: false,
  expect: false,
  fdescribe: false,
  fit: false,
  it: false,
  jest: false,
  pit: false,
  require: false,
  test: false,
  xdescribe: false,
  xit: false,
  xtest: false
};
var qunit = {
  asyncTest: false,
  deepEqual: false,
  equal: false,
  expect: false,
  module: false,
  notDeepEqual: false,
  notEqual: false,
  notOk: false,
  notPropEqual: false,
  notStrictEqual: false,
  ok: false,
  propEqual: false,
  QUnit: false,
  raises: false,
  start: false,
  stop: false,
  strictEqual: false,
  test: false,
  throws: false
};
var phantomjs = {
  console: true,
  exports: true,
  phantom: true,
  require: true,
  WebPage: true
};
var couch = {
  emit: false,
  exports: false,
  getRow: false,
  log: false,
  module: false,
  provides: false,
  require: false,
  respond: false,
  send: false,
  start: false,
  sum: false
};
var rhino = {
  defineClass: false,
  deserialize: false,
  gc: false,
  help: false,
  importClass: false,
  importPackage: false,
  java: false,
  load: false,
  loadClass: false,
  Packages: false,
  print: false,
  quit: false,
  readFile: false,
  readUrl: false,
  runCommand: false,
  seal: false,
  serialize: false,
  spawn: false,
  sync: false,
  toint32: false,
  version: false
};
var nashorn = {
  __DIR__: false,
  __FILE__: false,
  __LINE__: false,
  com: false,
  edu: false,
  exit: false,
  java: false,
  Java: false,
  javafx: false,
  JavaImporter: false,
  javax: false,
  JSAdapter: false,
  load: false,
  loadWithNewGlobal: false,
  org: false,
  Packages: false,
  print: false,
  quit: false
};
var wsh = {
  ActiveXObject: false,
  CollectGarbage: false,
  Debug: false,
  Enumerator: false,
  GetObject: false,
  RuntimeObject: false,
  ScriptEngine: false,
  ScriptEngineBuildVersion: false,
  ScriptEngineMajorVersion: false,
  ScriptEngineMinorVersion: false,
  VBArray: false,
  WScript: false,
  WSH: false
};
var jquery = {
  $: false,
  jQuery: false
};
var yui = {
  YAHOO: false,
  YAHOO_config: false,
  YUI: false,
  YUI_config: false
};
var shelljs = {
  cat: false,
  cd: false,
  chmod: false,
  config: false,
  cp: false,
  dirs: false,
  echo: false,
  env: false,
  error: false,
  exec: false,
  exit: false,
  find: false,
  grep: false,
  ln: false,
  ls: false,
  mkdir: false,
  mv: false,
  popd: false,
  pushd: false,
  pwd: false,
  rm: false,
  sed: false,
  set: false,
  target: false,
  tempdir: false,
  test: false,
  touch: false,
  which: false
};
var prototypejs = {
  $: false,
  $$: false,
  $A: false,
  $break: false,
  $continue: false,
  $F: false,
  $H: false,
  $R: false,
  $w: false,
  Abstract: false,
  Ajax: false,
  Autocompleter: false,
  Builder: false,
  Class: false,
  Control: false,
  Draggable: false,
  Draggables: false,
  Droppables: false,
  Effect: false,
  Element: false,
  Enumerable: false,
  Event: false,
  Field: false,
  Form: false,
  Hash: false,
  Insertion: false,
  ObjectRange: false,
  PeriodicalExecuter: false,
  Position: false,
  Prototype: false,
  Scriptaculous: false,
  Selector: false,
  Sortable: false,
  SortableObserver: false,
  Sound: false,
  Template: false,
  Toggle: false,
  Try: false
};
var meteor = {
  $: false,
  Accounts: false,
  AccountsClient: false,
  AccountsCommon: false,
  AccountsServer: false,
  App: false,
  Assets: false,
  Blaze: false,
  check: false,
  Cordova: false,
  DDP: false,
  DDPRateLimiter: false,
  DDPServer: false,
  Deps: false,
  EJSON: false,
  Email: false,
  HTTP: false,
  Log: false,
  Match: false,
  Meteor: false,
  Mongo: false,
  MongoInternals: false,
  Npm: false,
  Package: false,
  Plugin: false,
  process: false,
  Random: false,
  ReactiveDict: false,
  ReactiveVar: false,
  Router: false,
  ServiceConfiguration: false,
  Session: false,
  share: false,
  Spacebars: false,
  Template: false,
  Tinytest: false,
  Tracker: false,
  UI: false,
  Utils: false,
  WebApp: false,
  WebAppInternals: false
};
var mongo = {
  _isWindows: false,
  _rand: false,
  BulkWriteResult: false,
  cat: false,
  cd: false,
  connect: false,
  db: false,
  getHostName: false,
  getMemInfo: false,
  hostname: false,
  ISODate: false,
  listFiles: false,
  load: false,
  ls: false,
  md5sumFile: false,
  mkdir: false,
  Mongo: false,
  NumberInt: false,
  NumberLong: false,
  ObjectId: false,
  PlanCache: false,
  print: false,
  printjson: false,
  pwd: false,
  quit: false,
  removeFile: false,
  rs: false,
  sh: false,
  UUID: false,
  version: false,
  WriteResult: false
};
var applescript = {
  $: false,
  Application: false,
  Automation: false,
  console: false,
  delay: false,
  Library: false,
  ObjC: false,
  ObjectSpecifier: false,
  Path: false,
  Progress: false,
  Ref: false
};
var serviceworker = {
  addEventListener: false,
  applicationCache: false,
  atob: false,
  Blob: false,
  BroadcastChannel: false,
  btoa: false,
  ByteLengthQueuingStrategy: false,
  Cache: false,
  caches: false,
  CacheStorage: false,
  clearInterval: false,
  clearTimeout: false,
  Client: false,
  clients: false,
  Clients: false,
  close: true,
  CompressionStream: false,
  console: false,
  CountQueuingStrategy: false,
  crypto: false,
  Crypto: false,
  CryptoKey: false,
  CustomEvent: false,
  DecompressionStream: false,
  ErrorEvent: false,
  Event: false,
  ExtendableEvent: false,
  ExtendableMessageEvent: false,
  fetch: false,
  FetchEvent: false,
  File: false,
  FileReaderSync: false,
  FormData: false,
  Headers: false,
  IDBCursor: false,
  IDBCursorWithValue: false,
  IDBDatabase: false,
  IDBFactory: false,
  IDBIndex: false,
  IDBKeyRange: false,
  IDBObjectStore: false,
  IDBOpenDBRequest: false,
  IDBRequest: false,
  IDBTransaction: false,
  IDBVersionChangeEvent: false,
  ImageData: false,
  importScripts: false,
  indexedDB: false,
  location: false,
  MessageChannel: false,
  MessageEvent: false,
  MessagePort: false,
  name: false,
  navigator: false,
  Notification: false,
  onclose: true,
  onconnect: true,
  onerror: true,
  onfetch: true,
  oninstall: true,
  onlanguagechange: true,
  onmessage: true,
  onmessageerror: true,
  onnotificationclick: true,
  onnotificationclose: true,
  onoffline: true,
  ononline: true,
  onpush: true,
  onpushsubscriptionchange: true,
  onrejectionhandled: true,
  onsync: true,
  onunhandledrejection: true,
  performance: false,
  Performance: false,
  PerformanceEntry: false,
  PerformanceMark: false,
  PerformanceMeasure: false,
  PerformanceNavigation: false,
  PerformanceObserver: false,
  PerformanceObserverEntryList: false,
  PerformanceResourceTiming: false,
  PerformanceTiming: false,
  postMessage: true,
  "Promise": false,
  queueMicrotask: false,
  ReadableByteStreamController: false,
  ReadableStream: false,
  ReadableStreamBYOBReader: false,
  ReadableStreamBYOBRequest: false,
  ReadableStreamDefaultController: false,
  ReadableStreamDefaultReader: false,
  registration: false,
  removeEventListener: false,
  Request: false,
  Response: false,
  self: false,
  ServiceWorker: false,
  ServiceWorkerContainer: false,
  ServiceWorkerGlobalScope: false,
  ServiceWorkerMessageEvent: false,
  ServiceWorkerRegistration: false,
  setInterval: false,
  setTimeout: false,
  skipWaiting: false,
  SubtleCrypto: false,
  TextDecoder: false,
  TextDecoderStream: false,
  TextEncoder: false,
  TextEncoderStream: false,
  TransformStream: false,
  TransformStreamDefaultController: false,
  URL: false,
  URLSearchParams: false,
  WebAssembly: false,
  WebSocket: false,
  WindowClient: false,
  Worker: false,
  WorkerGlobalScope: false,
  WritableStream: false,
  WritableStreamDefaultController: false,
  WritableStreamDefaultWriter: false,
  XMLHttpRequest: false
};
var atomtest = {
  advanceClock: false,
  atom: false,
  fakeClearInterval: false,
  fakeClearTimeout: false,
  fakeSetInterval: false,
  fakeSetTimeout: false,
  resetTimeouts: false,
  waitsForPromise: false
};
var embertest = {
  andThen: false,
  click: false,
  currentPath: false,
  currentRouteName: false,
  currentURL: false,
  fillIn: false,
  find: false,
  findAll: false,
  findWithAssert: false,
  keyEvent: false,
  pauseTest: false,
  resumeTest: false,
  triggerEvent: false,
  visit: false,
  wait: false
};
var protractor = {
  $: false,
  $$: false,
  browser: false,
  by: false,
  By: false,
  DartObject: false,
  element: false,
  protractor: false
};
var webextensions = {
  browser: false,
  chrome: false,
  opr: false
};
var greasemonkey = {
  cloneInto: false,
  createObjectIn: false,
  exportFunction: false,
  GM: false,
  GM_addElement: false,
  GM_addStyle: false,
  GM_addValueChangeListener: false,
  GM_deleteValue: false,
  GM_download: false,
  GM_getResourceText: false,
  GM_getResourceURL: false,
  GM_getTab: false,
  GM_getTabs: false,
  GM_getValue: false,
  GM_info: false,
  GM_listValues: false,
  GM_log: false,
  GM_notification: false,
  GM_openInTab: false,
  GM_registerMenuCommand: false,
  GM_removeValueChangeListener: false,
  GM_saveTab: false,
  GM_setClipboard: false,
  GM_setValue: false,
  GM_unregisterMenuCommand: false,
  GM_xmlhttpRequest: false,
  unsafeWindow: false
};
var devtools = {
  $: false,
  $_: false,
  $$: false,
  $0: false,
  $1: false,
  $2: false,
  $3: false,
  $4: false,
  $x: false,
  chrome: false,
  clear: false,
  copy: false,
  debug: false,
  dir: false,
  dirxml: false,
  getEventListeners: false,
  inspect: false,
  keys: false,
  monitor: false,
  monitorEvents: false,
  profile: false,
  profileEnd: false,
  queryObjects: false,
  table: false,
  undebug: false,
  unmonitor: false,
  unmonitorEvents: false,
  values: false
};
var require$$0$1 = {
  builtin,
  es5,
  es2015,
  es2017,
  es2020,
  es2021,
  browser: browser$1,
  worker,
  node,
  nodeBuiltin,
  commonjs,
  amd,
  mocha,
  jasmine,
  jest,
  qunit,
  phantomjs,
  couch,
  rhino,
  nashorn,
  wsh,
  jquery,
  yui,
  shelljs,
  prototypejs,
  meteor,
  mongo,
  applescript,
  serviceworker,
  atomtest,
  embertest,
  protractor,
  "shared-node-browser": {
    AbortController: false,
    AbortSignal: false,
    atob: false,
    Blob: false,
    BroadcastChannel: false,
    btoa: false,
    ByteLengthQueuingStrategy: false,
    clearInterval: false,
    clearTimeout: false,
    CompressionStream: false,
    console: false,
    CountQueuingStrategy: false,
    crypto: false,
    Crypto: false,
    CryptoKey: false,
    CustomEvent: false,
    DecompressionStream: false,
    DOMException: false,
    Event: false,
    EventTarget: false,
    fetch: false,
    File: false,
    FormData: false,
    Headers: false,
    "Intl": false,
    MessageChannel: false,
    MessageEvent: false,
    MessagePort: false,
    performance: false,
    PerformanceEntry: false,
    PerformanceMark: false,
    PerformanceMeasure: false,
    PerformanceObserver: false,
    PerformanceObserverEntryList: false,
    PerformanceResourceTiming: false,
    queueMicrotask: false,
    ReadableByteStreamController: false,
    ReadableStream: false,
    ReadableStreamBYOBReader: false,
    ReadableStreamBYOBRequest: false,
    ReadableStreamDefaultController: false,
    ReadableStreamDefaultReader: false,
    Request: false,
    Response: false,
    setInterval: false,
    setTimeout: false,
    structuredClone: false,
    SubtleCrypto: false,
    TextDecoder: false,
    TextDecoderStream: false,
    TextEncoder: false,
    TextEncoderStream: false,
    TransformStream: false,
    TransformStreamDefaultController: false,
    URL: false,
    URLSearchParams: false,
    WebAssembly: false,
    WritableStream: false,
    WritableStreamDefaultController: false,
    WritableStreamDefaultWriter: false
  },
  webextensions,
  greasemonkey,
  devtools
};
var globals$1;
var hasRequiredGlobals$1;
function requireGlobals$1() {
  if (hasRequiredGlobals$1) return globals$1;
  hasRequiredGlobals$1 = 1;
  globals$1 = require$$0$1;
  return globals$1;
}
var hasRequiredEslintrcUniversal;
function requireEslintrcUniversal() {
  if (hasRequiredEslintrcUniversal) return eslintrcUniversal;
  hasRequiredEslintrcUniversal = 1;
  Object.defineProperty(eslintrcUniversal, "__esModule", { value: true });
  var util2 = require$$0$3;
  var path = require$$0$3;
  var Ajv = requireAjv$1();
  var globals2 = /* @__PURE__ */ requireGlobals$1();
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
  }
  var util__default = /* @__PURE__ */ _interopDefaultLegacy(util2);
  var path__default = /* @__PURE__ */ _interopDefaultLegacy(path);
  var Ajv__default = /* @__PURE__ */ _interopDefaultLegacy(Ajv);
  var globals__default = /* @__PURE__ */ _interopDefaultLegacy(globals2);
  const RULE_SEVERITY_STRINGS = ["off", "warn", "error"], RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
    map[value] = index;
    return map;
  }, {}), VALID_SEVERITIES = /* @__PURE__ */ new Set([0, 1, 2, "off", "warn", "error"]);
  function getRuleSeverity(ruleConfig) {
    const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
    if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
      return severityValue;
    }
    if (typeof severityValue === "string") {
      return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
    }
    return 0;
  }
  function normalizeToStrings(config2) {
    if (config2.rules) {
      Object.keys(config2.rules).forEach((ruleId) => {
        const ruleConfig = config2.rules[ruleId];
        if (typeof ruleConfig === "number") {
          config2.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
        } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
          ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
        }
      });
    }
  }
  function isErrorSeverity(ruleConfig) {
    return getRuleSeverity(ruleConfig) === 2;
  }
  function isValidSeverity(ruleConfig) {
    let severity2 = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
    if (typeof severity2 === "string") {
      severity2 = severity2.toLowerCase();
    }
    return VALID_SEVERITIES.has(severity2);
  }
  function isEverySeverityValid(config2) {
    return Object.keys(config2).every((ruleId) => isValidSeverity(config2[ruleId]));
  }
  function normalizeConfigGlobal(configuredValue) {
    switch (configuredValue) {
      case "off":
        return "off";
      case true:
      case "true":
      case "writeable":
      case "writable":
        return "writable";
      case null:
      case false:
      case "false":
      case "readable":
      case "readonly":
        return "readonly";
      default:
        throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
    }
  }
  var ConfigOps = {
    __proto__: null,
    getRuleSeverity,
    normalizeToStrings,
    isErrorSeverity,
    isValidSeverity,
    isEverySeverityValid,
    normalizeConfigGlobal
  };
  const deprecationWarningMessages = {
    ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
    ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
    ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
  };
  const sourceFileErrorCache = /* @__PURE__ */ new Set();
  function emitDeprecationWarning(source, errorCode) {
    const cacheKey = JSON.stringify({ source, errorCode });
    if (sourceFileErrorCache.has(cacheKey)) {
      return;
    }
    sourceFileErrorCache.add(cacheKey);
    const rel = path__default["default"].relative(process.cwd(), source);
    const message = deprecationWarningMessages[errorCode];
    process.emitWarning(
      `${message} (found in "${rel}")`,
      "DeprecationWarning",
      errorCode
    );
  }
  const metaSchema = {
    id: "http://json-schema.org/draft-04/schema#",
    $schema: "http://json-schema.org/draft-04/schema#",
    description: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      positiveInteger: {
        type: "integer",
        minimum: 0
      },
      positiveIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        minItems: 1,
        uniqueItems: true
      }
    },
    type: "object",
    properties: {
      id: {
        type: "string"
      },
      $schema: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: {},
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: true
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: false
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: false
      },
      maxLength: { $ref: "#/definitions/positiveInteger" },
      minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {
        anyOf: [
          { type: "boolean" },
          { $ref: "#" }
        ],
        default: {}
      },
      items: {
        anyOf: [
          { $ref: "#" },
          { $ref: "#/definitions/schemaArray" }
        ],
        default: {}
      },
      maxItems: { $ref: "#/definitions/positiveInteger" },
      minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      maxProperties: { $ref: "#/definitions/positiveInteger" },
      minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: {
        anyOf: [
          { type: "boolean" },
          { $ref: "#" }
        ],
        default: {}
      },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/stringArray" }
          ]
        }
      },
      enum: {
        type: "array",
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    dependencies: {
      exclusiveMaximum: ["maximum"],
      exclusiveMinimum: ["minimum"]
    },
    default: {}
  };
  var ajvOrig = (additionalOptions = {}) => {
    const ajv3 = new Ajv__default["default"]({
      meta: false,
      useDefaults: true,
      validateSchema: false,
      missingRefs: "ignore",
      verbose: true,
      schemaId: "auto",
      ...additionalOptions
    });
    ajv3.addMetaSchema(metaSchema);
    ajv3._opts.defaultMeta = metaSchema.id;
    return ajv3;
  };
  function isObjectNotArray(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
  function deepMergeObjects(first, second) {
    if (second === void 0) {
      return first;
    }
    if (!isObjectNotArray(first) || !isObjectNotArray(second)) {
      return second;
    }
    const result = { ...first, ...second };
    for (const key of Object.keys(second)) {
      if (Object.prototype.propertyIsEnumerable.call(first, key)) {
        result[key] = deepMergeObjects(first[key], second[key]);
      }
    }
    return result;
  }
  function deepMergeArrays(first, second) {
    if (!first || !second) {
      return second || first || [];
    }
    return [
      ...first.map((value, i2) => deepMergeObjects(value, second[i2])),
      ...second.slice(first.length)
    ];
  }
  const baseConfigProperties = {
    $schema: { type: "string" },
    env: { type: "object" },
    extends: { $ref: "#/definitions/stringOrStrings" },
    globals: { type: "object" },
    overrides: {
      type: "array",
      items: { $ref: "#/definitions/overrideConfig" },
      additionalItems: false
    },
    parser: { type: ["string", "null"] },
    parserOptions: { type: "object" },
    plugins: { type: "array" },
    processor: { type: "string" },
    rules: { type: "object" },
    settings: { type: "object" },
    noInlineConfig: { type: "boolean" },
    reportUnusedDisableDirectives: { type: "boolean" },
    ecmaFeatures: { type: "object" }
    // deprecated; logs a warning when used
  };
  const configSchema = {
    definitions: {
      stringOrStrings: {
        oneOf: [
          { type: "string" },
          {
            type: "array",
            items: { type: "string" },
            additionalItems: false
          }
        ]
      },
      stringOrStringsRequired: {
        oneOf: [
          { type: "string" },
          {
            type: "array",
            items: { type: "string" },
            additionalItems: false,
            minItems: 1
          }
        ]
      },
      // Config at top-level.
      objectConfig: {
        type: "object",
        properties: {
          root: { type: "boolean" },
          ignorePatterns: { $ref: "#/definitions/stringOrStrings" },
          ...baseConfigProperties
        },
        additionalProperties: false
      },
      // Config in `overrides`.
      overrideConfig: {
        type: "object",
        properties: {
          excludedFiles: { $ref: "#/definitions/stringOrStrings" },
          files: { $ref: "#/definitions/stringOrStringsRequired" },
          ...baseConfigProperties
        },
        required: ["files"],
        additionalProperties: false
      }
    },
    $ref: "#/definitions/objectConfig"
  };
  function getDiff(current, prev) {
    const retv = {};
    for (const [key, value] of Object.entries(current)) {
      if (!Object.hasOwn(prev, key)) {
        retv[key] = value;
      }
    }
    return retv;
  }
  const newGlobals2015 = getDiff(globals__default["default"].es2015, globals__default["default"].es5);
  const newGlobals2017 = {
    Atomics: false,
    SharedArrayBuffer: false
  };
  const newGlobals2020 = {
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    globalThis: false
  };
  const newGlobals2021 = {
    AggregateError: false,
    FinalizationRegistry: false,
    WeakRef: false
  };
  var environments = new Map(Object.entries({
    // Language
    builtin: {
      globals: globals__default["default"].es5
    },
    es6: {
      globals: newGlobals2015,
      parserOptions: {
        ecmaVersion: 6
      }
    },
    es2015: {
      globals: newGlobals2015,
      parserOptions: {
        ecmaVersion: 6
      }
    },
    es2016: {
      globals: newGlobals2015,
      parserOptions: {
        ecmaVersion: 7
      }
    },
    es2017: {
      globals: { ...newGlobals2015, ...newGlobals2017 },
      parserOptions: {
        ecmaVersion: 8
      }
    },
    es2018: {
      globals: { ...newGlobals2015, ...newGlobals2017 },
      parserOptions: {
        ecmaVersion: 9
      }
    },
    es2019: {
      globals: { ...newGlobals2015, ...newGlobals2017 },
      parserOptions: {
        ecmaVersion: 10
      }
    },
    es2020: {
      globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 },
      parserOptions: {
        ecmaVersion: 11
      }
    },
    es2021: {
      globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
      parserOptions: {
        ecmaVersion: 12
      }
    },
    es2022: {
      globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
      parserOptions: {
        ecmaVersion: 13
      }
    },
    es2023: {
      globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
      parserOptions: {
        ecmaVersion: 14
      }
    },
    es2024: {
      globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
      parserOptions: {
        ecmaVersion: 15
      }
    },
    // Platforms
    browser: {
      globals: globals__default["default"].browser
    },
    node: {
      globals: globals__default["default"].node,
      parserOptions: {
        ecmaFeatures: {
          globalReturn: true
        }
      }
    },
    "shared-node-browser": {
      globals: globals__default["default"]["shared-node-browser"]
    },
    worker: {
      globals: globals__default["default"].worker
    },
    serviceworker: {
      globals: globals__default["default"].serviceworker
    },
    // Frameworks
    commonjs: {
      globals: globals__default["default"].commonjs,
      parserOptions: {
        ecmaFeatures: {
          globalReturn: true
        }
      }
    },
    amd: {
      globals: globals__default["default"].amd
    },
    mocha: {
      globals: globals__default["default"].mocha
    },
    jasmine: {
      globals: globals__default["default"].jasmine
    },
    jest: {
      globals: globals__default["default"].jest
    },
    phantomjs: {
      globals: globals__default["default"].phantomjs
    },
    jquery: {
      globals: globals__default["default"].jquery
    },
    qunit: {
      globals: globals__default["default"].qunit
    },
    prototypejs: {
      globals: globals__default["default"].prototypejs
    },
    shelljs: {
      globals: globals__default["default"].shelljs
    },
    meteor: {
      globals: globals__default["default"].meteor
    },
    mongo: {
      globals: globals__default["default"].mongo
    },
    protractor: {
      globals: globals__default["default"].protractor
    },
    applescript: {
      globals: globals__default["default"].applescript
    },
    nashorn: {
      globals: globals__default["default"].nashorn
    },
    atomtest: {
      globals: globals__default["default"].atomtest
    },
    embertest: {
      globals: globals__default["default"].embertest
    },
    webextensions: {
      globals: globals__default["default"].webextensions
    },
    greasemonkey: {
      globals: globals__default["default"].greasemonkey
    }
  }));
  const ajv2 = ajvOrig();
  const ruleValidators = /* @__PURE__ */ new WeakMap();
  const noop2 = Function.prototype;
  let validateSchema;
  const severityMap = {
    error: 2,
    warn: 1,
    off: 0
  };
  const validated = /* @__PURE__ */ new WeakSet();
  const noOptionsSchema = Object.freeze({
    type: "array",
    minItems: 0,
    maxItems: 0
  });
  class ConfigValidator {
    constructor({ builtInRules = /* @__PURE__ */ new Map() } = {}) {
      this.builtInRules = builtInRules;
    }
    /**
     * Gets a complete options schema for a rule.
     * @param {Rule} rule A rule object
     * @throws {TypeError} If `meta.schema` is specified but is not an array, object or `false`.
     * @returns {Object|null} JSON Schema for the rule's options.
     *      `null` if rule wasn't passed or its `meta.schema` is `false`.
     */
    getRuleOptionsSchema(rule) {
      if (!rule) {
        return null;
      }
      if (!rule.meta) {
        return { ...noOptionsSchema };
      }
      const schema = rule.meta.schema;
      if (typeof schema === "undefined") {
        return { ...noOptionsSchema };
      }
      if (schema === false) {
        return null;
      }
      if (typeof schema !== "object" || schema === null) {
        throw new TypeError("Rule's `meta.schema` must be an array or object");
      }
      if (Array.isArray(schema)) {
        if (schema.length) {
          return {
            type: "array",
            items: schema,
            minItems: 0,
            maxItems: schema.length
          };
        }
        return { ...noOptionsSchema };
      }
      return schema;
    }
    /**
     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
     * @param {options} options The given options for the rule.
     * @returns {number|string} The rule's severity value
     * @throws {Error} If the severity is invalid.
     */
    validateRuleSeverity(options) {
      const severity2 = Array.isArray(options) ? options[0] : options;
      const normSeverity = typeof severity2 === "string" ? severityMap[severity2.toLowerCase()] : severity2;
      if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
        return normSeverity;
      }
      throw new Error(`	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util__default["default"].inspect(severity2).replace(/'/gu, '"').replace(/\n/gu, "")}').
`);
    }
    /**
     * Validates the non-severity options passed to a rule, based on its schema.
     * @param {{create: Function}} rule The rule to validate
     * @param {Array} localOptions The options for the rule, excluding severity
     * @returns {void}
     * @throws {Error} If the options are invalid.
     */
    validateRuleSchema(rule, localOptions) {
      var _a2;
      if (!ruleValidators.has(rule)) {
        try {
          const schema = this.getRuleOptionsSchema(rule);
          if (schema) {
            ruleValidators.set(rule, ajv2.compile(schema));
          }
        } catch (err) {
          const errorWithCode = new Error(err.message, { cause: err });
          errorWithCode.code = "ESLINT_INVALID_RULE_OPTIONS_SCHEMA";
          throw errorWithCode;
        }
      }
      const validateRule = ruleValidators.get(rule);
      if (validateRule) {
        const mergedOptions = deepMergeArrays((_a2 = rule.meta) == null ? void 0 : _a2.defaultOptions, localOptions);
        validateRule(mergedOptions);
        if (validateRule.errors) {
          throw new Error(validateRule.errors.map(
            (error) => `	Value ${JSON.stringify(error.data)} ${error.message}.
`
          ).join(""));
        }
      }
    }
    /**
     * Validates a rule's options against its schema.
     * @param {{create: Function}|null} rule The rule that the config is being validated for
     * @param {string} ruleId The rule's unique name.
     * @param {Array|number} options The given options for the rule.
     * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
     * no source is prepended to the message.
     * @returns {void}
     * @throws {Error} If the options are invalid.
     */
    validateRuleOptions(rule, ruleId, options, source = null) {
      try {
        const severity2 = this.validateRuleSeverity(options);
        if (severity2 !== 0) {
          this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
        }
      } catch (err) {
        let enhancedMessage = err.code === "ESLINT_INVALID_RULE_OPTIONS_SCHEMA" ? `Error while processing options validation schema of rule '${ruleId}': ${err.message}` : `Configuration for rule "${ruleId}" is invalid:
${err.message}`;
        if (typeof source === "string") {
          enhancedMessage = `${source}:
	${enhancedMessage}`;
        }
        const enhancedError = new Error(enhancedMessage, { cause: err });
        if (err.code) {
          enhancedError.code = err.code;
        }
        throw enhancedError;
      }
    }
    /**
     * Validates an environment object
     * @param {Object} environment The environment config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {(envId:string) => Object} [getAdditionalEnv] A map from strings to loaded environments.
     * @returns {void}
     * @throws {Error} If the environment is invalid.
     */
    validateEnvironment(environment, source, getAdditionalEnv = noop2) {
      if (!environment) {
        return;
      }
      Object.keys(environment).forEach((id2) => {
        const env2 = getAdditionalEnv(id2) || environments.get(id2) || null;
        if (!env2) {
          const message = `${source}:
	Environment key "${id2}" is unknown
`;
          throw new Error(message);
        }
      });
    }
    /**
     * Validates a rules config object
     * @param {Object} rulesConfig The rules config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {(ruleId:string) => Object} getAdditionalRule A map from strings to loaded rules
     * @returns {void}
     */
    validateRules(rulesConfig, source, getAdditionalRule = noop2) {
      if (!rulesConfig) {
        return;
      }
      Object.keys(rulesConfig).forEach((id2) => {
        const rule = getAdditionalRule(id2) || this.builtInRules.get(id2) || null;
        this.validateRuleOptions(rule, id2, rulesConfig[id2], source);
      });
    }
    /**
     * Validates a `globals` section of a config file
     * @param {Object} globalsConfig The `globals` section
     * @param {string|null} source The name of the configuration source to report in the event of an error.
     * @returns {void}
     */
    validateGlobals(globalsConfig, source = null) {
      if (!globalsConfig) {
        return;
      }
      Object.entries(globalsConfig).forEach(([configuredGlobal, configuredValue]) => {
        try {
          normalizeConfigGlobal(configuredValue);
        } catch (err) {
          throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:
${err.message}`);
        }
      });
    }
    /**
     * Validate `processor` configuration.
     * @param {string|undefined} processorName The processor name.
     * @param {string} source The name of config file.
     * @param {(id:string) => Processor} getProcessor The getter of defined processors.
     * @returns {void}
     * @throws {Error} If the processor is invalid.
     */
    validateProcessor(processorName, source, getProcessor) {
      if (processorName && !getProcessor(processorName)) {
        throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);
      }
    }
    /**
     * Formats an array of schema validation errors.
     * @param {Array} errors An array of error messages to format.
     * @returns {string} Formatted error message
     */
    formatErrors(errors) {
      return errors.map((error) => {
        if (error.keyword === "additionalProperties") {
          const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;
          return `Unexpected top-level property "${formattedPropertyPath}"`;
        }
        if (error.keyword === "type") {
          const formattedField = error.dataPath.slice(1);
          const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
          const formattedValue = JSON.stringify(error.data);
          return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
        }
        const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
        return `"${field}" ${error.message}. Value: ${JSON.stringify(error.data)}`;
      }).map((message) => `	- ${message}.
`).join("");
    }
    /**
     * Validates the top level properties of the config object.
     * @param {Object} config The config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @returns {void}
     * @throws {Error} If the config is invalid.
     */
    validateConfigSchema(config2, source = null) {
      validateSchema = validateSchema || ajv2.compile(configSchema);
      if (!validateSchema(config2)) {
        throw new Error(`ESLint configuration in ${source} is invalid:
${this.formatErrors(validateSchema.errors)}`);
      }
      if (Object.hasOwn(config2, "ecmaFeatures")) {
        emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
      }
    }
    /**
     * Validates an entire config object.
     * @param {Object} config The config object to validate.
     * @param {string} source The name of the configuration source to report in any errors.
     * @param {(ruleId:string) => Object} [getAdditionalRule] A map from strings to loaded rules.
     * @param {(envId:string) => Object} [getAdditionalEnv] A map from strings to loaded envs.
     * @returns {void}
     */
    validate(config2, source, getAdditionalRule, getAdditionalEnv) {
      this.validateConfigSchema(config2, source);
      this.validateRules(config2.rules, source, getAdditionalRule);
      this.validateEnvironment(config2.env, source, getAdditionalEnv);
      this.validateGlobals(config2.globals, source);
      for (const override of config2.overrides || []) {
        this.validateRules(override.rules, source, getAdditionalRule);
        this.validateEnvironment(override.env, source, getAdditionalEnv);
        this.validateGlobals(config2.globals, source);
      }
    }
    /**
     * Validate config array object.
     * @param {ConfigArray} configArray The config array to validate.
     * @returns {void}
     */
    validateConfigArray(configArray) {
      const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
      const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
      const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);
      for (const element of configArray) {
        if (validated.has(element)) {
          continue;
        }
        validated.add(element);
        this.validateEnvironment(element.env, element.name, getPluginEnv);
        this.validateGlobals(element.globals, element.name);
        this.validateProcessor(element.processor, element.name, getPluginProcessor);
        this.validateRules(element.rules, element.name, getPluginRule);
      }
    }
  }
  const NAMESPACE_REGEX = /^@.*\//iu;
  function normalizePackageName(name2, prefix) {
    let normalizedName = name2;
    if (normalizedName.includes("\\")) {
      normalizedName = normalizedName.replace(/\\/gu, "/");
    }
    if (normalizedName.charAt(0) === "@") {
      const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`, "u"), scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`, "u");
      if (scopedPackageShortcutRegex.test(normalizedName)) {
        normalizedName = normalizedName.replace(scopedPackageShortcutRegex, `$1/${prefix}`);
      } else if (!scopedPackageNameRegex.test(normalizedName.split("/")[1])) {
        normalizedName = normalizedName.replace(/^@([^/]+)\/(.*)$/u, `@$1/${prefix}-$2`);
      }
    } else if (!normalizedName.startsWith(`${prefix}-`)) {
      normalizedName = `${prefix}-${normalizedName}`;
    }
    return normalizedName;
  }
  function getShorthandName(fullname, prefix) {
    if (fullname[0] === "@") {
      let matchResult = new RegExp(`^(@[^/]+)/${prefix}$`, "u").exec(fullname);
      if (matchResult) {
        return matchResult[1];
      }
      matchResult = new RegExp(`^(@[^/]+)/${prefix}-(.+)$`, "u").exec(fullname);
      if (matchResult) {
        return `${matchResult[1]}/${matchResult[2]}`;
      }
    } else if (fullname.startsWith(`${prefix}-`)) {
      return fullname.slice(prefix.length + 1);
    }
    return fullname;
  }
  function getNamespaceFromTerm(term) {
    const match = term.match(NAMESPACE_REGEX);
    return match ? match[0] : "";
  }
  var naming = {
    __proto__: null,
    normalizePackageName,
    getShorthandName,
    getNamespaceFromTerm
  };
  const Legacy = {
    environments,
    // shared
    ConfigOps,
    ConfigValidator,
    naming
  };
  eslintrcUniversal.Legacy = Legacy;
  return eslintrcUniversal;
}
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n2, name2) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms2 / n2) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter2) {
      const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search2, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search2.length) {
        if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name2, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name2, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports$1) {
    exports$1.formatArgs = formatArgs;
    exports$1.save = save;
    exports$1.load = load;
    exports$1.useColors = useColors;
    exports$1.storage = localstorage();
    exports$1.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports$1.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports$1.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports$1.storage.setItem("debug", namespaces);
        } else {
          exports$1.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports$1.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof browser$1$1 !== "undefined" && "env" in browser$1$1) {
        r2 = browser$1$1.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports$1);
    const { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  {
    src.exports = requireBrowser();
  }
  return src.exports;
}
var traverser;
var hasRequiredTraverser;
function requireTraverser() {
  if (hasRequiredTraverser) return traverser;
  hasRequiredTraverser = 1;
  const vk = requireEslintVisitorKeys$2();
  const debug = requireSrc()("eslint:traverser");
  function noop2() {
  }
  function isNode(x2) {
    return x2 !== null && typeof x2 === "object" && typeof x2.type === "string";
  }
  function getVisitorKeys(visitorKeys, node2) {
    let keys2 = visitorKeys[node2.type];
    if (!keys2) {
      keys2 = vk.getKeys(node2);
      debug(
        'Unknown node type "%s": Estimated visitor keys %j',
        node2.type,
        keys2
      );
    }
    return keys2;
  }
  class Traverser {
    constructor() {
      this._current = null;
      this._parents = [];
      this._skipped = false;
      this._broken = false;
      this._visitorKeys = null;
      this._enter = null;
      this._leave = null;
    }
    /**
     * Gives current node.
     * @returns {ASTNode} The current node.
     */
    current() {
      return this._current;
    }
    /**
     * Gives a copy of the ancestor nodes.
     * @returns {ASTNode[]} The ancestor nodes.
     */
    parents() {
      return this._parents.slice(0);
    }
    /**
     * Break the current traversal.
     * @returns {void}
     */
    break() {
      this._broken = true;
    }
    /**
     * Skip child nodes for the current traversal.
     * @returns {void}
     */
    skip() {
      this._skipped = true;
    }
    /**
     * Traverse the given AST tree.
     * @param {ASTNode} node The root node to traverse.
     * @param {Object} options The option object.
     * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
     * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
     * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
     * @returns {void}
     */
    traverse(node2, options) {
      this._current = null;
      this._parents = [];
      this._skipped = false;
      this._broken = false;
      this._visitorKeys = options.visitorKeys || vk.KEYS;
      this._enter = options.enter || noop2;
      this._leave = options.leave || noop2;
      this._traverse(node2, null);
    }
    /**
     * Traverse the given AST tree recursively.
     * @param {ASTNode} node The current node.
     * @param {ASTNode|null} parent The parent node.
     * @returns {void}
     * @private
     */
    _traverse(node2, parent) {
      if (!isNode(node2)) {
        return;
      }
      this._current = node2;
      this._skipped = false;
      this._enter(node2, parent);
      if (!this._skipped && !this._broken) {
        const keys2 = getVisitorKeys(this._visitorKeys, node2);
        if (keys2.length >= 1) {
          this._parents.push(node2);
          for (let i2 = 0; i2 < keys2.length && !this._broken; ++i2) {
            const child = node2[keys2[i2]];
            if (Array.isArray(child)) {
              for (let j = 0; j < child.length && !this._broken; ++j) {
                this._traverse(child[j], node2);
              }
            } else {
              this._traverse(child, node2);
            }
          }
          this._parents.pop();
        }
      }
      if (!this._broken) {
        this._leave(node2, parent);
      }
      this._current = parent;
    }
    /**
     * Calculates the keys to use for traversal.
     * @param {ASTNode} node The node to read keys from.
     * @returns {string[]} An array of keys to visit on the node.
     * @private
     */
    static getKeys(node2) {
      return vk.getKeys(node2);
    }
    /**
     * Traverse the given AST tree.
     * @param {ASTNode} node The root node to traverse.
     * @param {Object} options The option object.
     * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
     * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
     * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
     * @returns {void}
     */
    static traverse(node2, options) {
      new Traverser().traverse(node2, options);
    }
    /**
     * The default visitor keys.
     * @type {Object}
     */
    static get DEFAULT_VISITOR_KEYS() {
      return vk.KEYS;
    }
  }
  traverser = Traverser;
  return traverser;
}
var eslintUtils = {};
var eslintVisitorKeys = {};
var hasRequiredEslintVisitorKeys;
function requireEslintVisitorKeys() {
  if (hasRequiredEslintVisitorKeys) return eslintVisitorKeys;
  hasRequiredEslintVisitorKeys = 1;
  Object.defineProperty(eslintVisitorKeys, "__esModule", { value: true });
  const KEYS = {
    ArrayExpression: [
      "elements"
    ],
    ArrayPattern: [
      "elements"
    ],
    ArrowFunctionExpression: [
      "params",
      "body"
    ],
    AssignmentExpression: [
      "left",
      "right"
    ],
    AssignmentPattern: [
      "left",
      "right"
    ],
    AwaitExpression: [
      "argument"
    ],
    BinaryExpression: [
      "left",
      "right"
    ],
    BlockStatement: [
      "body"
    ],
    BreakStatement: [
      "label"
    ],
    CallExpression: [
      "callee",
      "arguments"
    ],
    CatchClause: [
      "param",
      "body"
    ],
    ChainExpression: [
      "expression"
    ],
    ClassBody: [
      "body"
    ],
    ClassDeclaration: [
      "id",
      "superClass",
      "body"
    ],
    ClassExpression: [
      "id",
      "superClass",
      "body"
    ],
    ConditionalExpression: [
      "test",
      "consequent",
      "alternate"
    ],
    ContinueStatement: [
      "label"
    ],
    DebuggerStatement: [],
    DoWhileStatement: [
      "body",
      "test"
    ],
    EmptyStatement: [],
    ExperimentalRestProperty: [
      "argument"
    ],
    ExperimentalSpreadProperty: [
      "argument"
    ],
    ExportAllDeclaration: [
      "exported",
      "source"
    ],
    ExportDefaultDeclaration: [
      "declaration"
    ],
    ExportNamedDeclaration: [
      "declaration",
      "specifiers",
      "source"
    ],
    ExportSpecifier: [
      "exported",
      "local"
    ],
    ExpressionStatement: [
      "expression"
    ],
    ForInStatement: [
      "left",
      "right",
      "body"
    ],
    ForOfStatement: [
      "left",
      "right",
      "body"
    ],
    ForStatement: [
      "init",
      "test",
      "update",
      "body"
    ],
    FunctionDeclaration: [
      "id",
      "params",
      "body"
    ],
    FunctionExpression: [
      "id",
      "params",
      "body"
    ],
    Identifier: [],
    IfStatement: [
      "test",
      "consequent",
      "alternate"
    ],
    ImportDeclaration: [
      "specifiers",
      "source"
    ],
    ImportDefaultSpecifier: [
      "local"
    ],
    ImportExpression: [
      "source"
    ],
    ImportNamespaceSpecifier: [
      "local"
    ],
    ImportSpecifier: [
      "imported",
      "local"
    ],
    JSXAttribute: [
      "name",
      "value"
    ],
    JSXClosingElement: [
      "name"
    ],
    JSXClosingFragment: [],
    JSXElement: [
      "openingElement",
      "children",
      "closingElement"
    ],
    JSXEmptyExpression: [],
    JSXExpressionContainer: [
      "expression"
    ],
    JSXFragment: [
      "openingFragment",
      "children",
      "closingFragment"
    ],
    JSXIdentifier: [],
    JSXMemberExpression: [
      "object",
      "property"
    ],
    JSXNamespacedName: [
      "namespace",
      "name"
    ],
    JSXOpeningElement: [
      "name",
      "attributes"
    ],
    JSXOpeningFragment: [],
    JSXSpreadAttribute: [
      "argument"
    ],
    JSXSpreadChild: [
      "expression"
    ],
    JSXText: [],
    LabeledStatement: [
      "label",
      "body"
    ],
    Literal: [],
    LogicalExpression: [
      "left",
      "right"
    ],
    MemberExpression: [
      "object",
      "property"
    ],
    MetaProperty: [
      "meta",
      "property"
    ],
    MethodDefinition: [
      "key",
      "value"
    ],
    NewExpression: [
      "callee",
      "arguments"
    ],
    ObjectExpression: [
      "properties"
    ],
    ObjectPattern: [
      "properties"
    ],
    PrivateIdentifier: [],
    Program: [
      "body"
    ],
    Property: [
      "key",
      "value"
    ],
    PropertyDefinition: [
      "key",
      "value"
    ],
    RestElement: [
      "argument"
    ],
    ReturnStatement: [
      "argument"
    ],
    SequenceExpression: [
      "expressions"
    ],
    SpreadElement: [
      "argument"
    ],
    StaticBlock: [
      "body"
    ],
    Super: [],
    SwitchCase: [
      "test",
      "consequent"
    ],
    SwitchStatement: [
      "discriminant",
      "cases"
    ],
    TaggedTemplateExpression: [
      "tag",
      "quasi"
    ],
    TemplateElement: [],
    TemplateLiteral: [
      "quasis",
      "expressions"
    ],
    ThisExpression: [],
    ThrowStatement: [
      "argument"
    ],
    TryStatement: [
      "block",
      "handler",
      "finalizer"
    ],
    UnaryExpression: [
      "argument"
    ],
    UpdateExpression: [
      "argument"
    ],
    VariableDeclaration: [
      "declarations"
    ],
    VariableDeclarator: [
      "id",
      "init"
    ],
    WhileStatement: [
      "test",
      "body"
    ],
    WithStatement: [
      "object",
      "body"
    ],
    YieldExpression: [
      "argument"
    ]
  };
  const NODE_TYPES = Object.keys(KEYS);
  for (const type2 of NODE_TYPES) {
    Object.freeze(KEYS[type2]);
  }
  Object.freeze(KEYS);
  const KEY_BLACKLIST = /* @__PURE__ */ new Set([
    "parent",
    "leadingComments",
    "trailingComments"
  ]);
  function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
  }
  function getKeys(node2) {
    return Object.keys(node2).filter(filterKey);
  }
  function unionWith(additionalKeys) {
    const retv = (
      /** @type {{
          [type: string]: ReadonlyArray<string>
      }} */
      Object.assign({}, KEYS)
    );
    for (const type2 of Object.keys(additionalKeys)) {
      if (Object.prototype.hasOwnProperty.call(retv, type2)) {
        const keys2 = new Set(additionalKeys[type2]);
        for (const key of retv[type2]) {
          keys2.add(key);
        }
        retv[type2] = Object.freeze(Array.from(keys2));
      } else {
        retv[type2] = Object.freeze(Array.from(additionalKeys[type2]));
      }
    }
    return Object.freeze(retv);
  }
  eslintVisitorKeys.KEYS = KEYS;
  eslintVisitorKeys.getKeys = getKeys;
  eslintVisitorKeys.unionWith = unionWith;
  return eslintVisitorKeys;
}
var hasRequiredEslintUtils;
function requireEslintUtils() {
  if (hasRequiredEslintUtils) return eslintUtils;
  hasRequiredEslintUtils = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    var eslintVisitorKeys2 = requireEslintVisitorKeys();
    function getInnermostScope(initialScope, node2) {
      const location = (
        /** @type {[number, number]} */
        node2.range[0]
      );
      let scope = initialScope;
      let found = false;
      do {
        found = false;
        for (const childScope of scope.childScopes) {
          const range = (
            /** @type {[number, number]} */
            childScope.block.range
          );
          if (range[0] <= location && location < range[1]) {
            scope = childScope;
            found = true;
            break;
          }
        }
      } while (found);
      return scope;
    }
    function findVariable(initialScope, nameOrNode) {
      let name2 = "";
      let scope = initialScope;
      if (typeof nameOrNode === "string") {
        name2 = nameOrNode;
      } else {
        name2 = nameOrNode.name;
        scope = getInnermostScope(scope, nameOrNode);
      }
      while (scope != null) {
        const variable = scope.set.get(name2);
        if (variable != null) {
          return variable;
        }
        scope = scope.upper;
      }
      return null;
    }
    function negate(f2) {
      return (token) => !f2(token);
    }
    function isPunctuatorTokenWithValue(token, value) {
      return token.type === "Punctuator" && token.value === value;
    }
    function isArrowToken(token) {
      return isPunctuatorTokenWithValue(token, "=>");
    }
    function isCommaToken(token) {
      return isPunctuatorTokenWithValue(token, ",");
    }
    function isSemicolonToken(token) {
      return isPunctuatorTokenWithValue(token, ";");
    }
    function isColonToken(token) {
      return isPunctuatorTokenWithValue(token, ":");
    }
    function isOpeningParenToken(token) {
      return isPunctuatorTokenWithValue(token, "(");
    }
    function isClosingParenToken(token) {
      return isPunctuatorTokenWithValue(token, ")");
    }
    function isOpeningBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "[");
    }
    function isClosingBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "]");
    }
    function isOpeningBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "{");
    }
    function isClosingBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "}");
    }
    function isCommentToken(token) {
      return ["Block", "Line", "Shebang"].includes(token.type);
    }
    const isNotArrowToken = negate(isArrowToken);
    const isNotCommaToken = negate(isCommaToken);
    const isNotSemicolonToken = negate(isSemicolonToken);
    const isNotColonToken = negate(isColonToken);
    const isNotOpeningParenToken = negate(isOpeningParenToken);
    const isNotClosingParenToken = negate(isClosingParenToken);
    const isNotOpeningBracketToken = negate(isOpeningBracketToken);
    const isNotClosingBracketToken = negate(isClosingBracketToken);
    const isNotOpeningBraceToken = negate(isOpeningBraceToken);
    const isNotClosingBraceToken = negate(isClosingBraceToken);
    const isNotCommentToken = negate(isCommentToken);
    function getOpeningParenOfParams(node2, sourceCode2) {
      return node2.id ? (
        /** @type {Token} */
        sourceCode2.getTokenAfter(node2.id, isOpeningParenToken)
      ) : (
        /** @type {Token} */
        sourceCode2.getFirstToken(node2, isOpeningParenToken)
      );
    }
    function getFunctionHeadLocation(node2, sourceCode2) {
      const parent = (
        /** @type {RuleNode} */
        node2.parent
      );
      let start = null;
      let end = null;
      if (node2.type === "ArrowFunctionExpression") {
        const arrowToken = (
          /** @type {Token} */
          sourceCode2.getTokenBefore(node2.body, isArrowToken)
        );
        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
      } else if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
        start = /** @type {SourceLocation} */
        parent.loc.start;
        end = getOpeningParenOfParams(node2, sourceCode2).loc.start;
      } else {
        start = /** @type {SourceLocation} */
        node2.loc.start;
        end = getOpeningParenOfParams(node2, sourceCode2).loc.start;
      }
      return {
        start: { ...start },
        end: { ...end }
      };
    }
    const globalObject = typeof globalThis !== "undefined" ? globalThis : (
      // @ts-ignore
      typeof self !== "undefined" ? (
        // @ts-ignore
        self
      ) : (
        // @ts-ignore
        typeof window !== "undefined" ? (
          // @ts-ignore
          window
        ) : typeof global$1 !== "undefined" ? global$1 : {}
      )
    );
    const builtinNames = Object.freeze(
      /* @__PURE__ */ new Set([
        "Array",
        "ArrayBuffer",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "Boolean",
        "DataView",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "Float32Array",
        "Float64Array",
        "Function",
        "Infinity",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "isFinite",
        "isNaN",
        "isPrototypeOf",
        "JSON",
        "Map",
        "Math",
        "NaN",
        "Number",
        "Object",
        "parseFloat",
        "parseInt",
        "Promise",
        "Proxy",
        "Reflect",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "undefined",
        "unescape",
        "WeakMap",
        "WeakSet"
      ])
    );
    const callAllowed = new Set(
      [
        Array.isArray,
        Array.of,
        Array.prototype.at,
        Array.prototype.concat,
        Array.prototype.entries,
        Array.prototype.every,
        Array.prototype.filter,
        Array.prototype.find,
        Array.prototype.findIndex,
        Array.prototype.flat,
        Array.prototype.includes,
        Array.prototype.indexOf,
        Array.prototype.join,
        Array.prototype.keys,
        Array.prototype.lastIndexOf,
        Array.prototype.slice,
        Array.prototype.some,
        Array.prototype.toString,
        Array.prototype.values,
        typeof BigInt === "function" ? BigInt : void 0,
        Boolean,
        Date,
        Date.parse,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        escape,
        isFinite,
        isNaN,
        // @ts-ignore
        isPrototypeOf,
        Map,
        Map.prototype.entries,
        Map.prototype.get,
        Map.prototype.has,
        Map.prototype.keys,
        Map.prototype.values,
        .../** @type {(keyof typeof Math)[]} */
        Object.getOwnPropertyNames(Math).filter((k) => k !== "random").map((k) => Math[k]).filter((f2) => typeof f2 === "function"),
        Number,
        Number.isFinite,
        Number.isNaN,
        Number.parseFloat,
        Number.parseInt,
        Number.prototype.toExponential,
        Number.prototype.toFixed,
        Number.prototype.toPrecision,
        Number.prototype.toString,
        Object,
        Object.entries,
        Object.is,
        Object.isExtensible,
        Object.isFrozen,
        Object.isSealed,
        Object.keys,
        Object.values,
        parseFloat,
        parseInt,
        RegExp,
        Set,
        Set.prototype.entries,
        Set.prototype.has,
        Set.prototype.keys,
        Set.prototype.values,
        String,
        String.fromCharCode,
        String.fromCodePoint,
        String.raw,
        String.prototype.at,
        String.prototype.charAt,
        String.prototype.charCodeAt,
        String.prototype.codePointAt,
        String.prototype.concat,
        String.prototype.endsWith,
        String.prototype.includes,
        String.prototype.indexOf,
        String.prototype.lastIndexOf,
        String.prototype.normalize,
        String.prototype.padEnd,
        String.prototype.padStart,
        String.prototype.slice,
        String.prototype.startsWith,
        String.prototype.substr,
        String.prototype.substring,
        String.prototype.toLowerCase,
        String.prototype.toString,
        String.prototype.toUpperCase,
        String.prototype.trim,
        String.prototype.trimEnd,
        String.prototype.trimLeft,
        String.prototype.trimRight,
        String.prototype.trimStart,
        Symbol.for,
        Symbol.keyFor,
        unescape
      ].filter((f2) => typeof f2 === "function")
    );
    const callPassThrough = /* @__PURE__ */ new Set([
      Object.freeze,
      Object.preventExtensions,
      Object.seal
    ]);
    const getterAllowed = [
      [Map, /* @__PURE__ */ new Set(["size"])],
      [
        RegExp,
        /* @__PURE__ */ new Set([
          "dotAll",
          "flags",
          "global",
          "hasIndices",
          "ignoreCase",
          "multiline",
          "source",
          "sticky",
          "unicode"
        ])
      ],
      [Set, /* @__PURE__ */ new Set(["size"])]
    ];
    function getPropertyDescriptor(object, name2) {
      let x2 = object;
      while ((typeof x2 === "object" || typeof x2 === "function") && x2 !== null) {
        const d2 = Object.getOwnPropertyDescriptor(x2, name2);
        if (d2) {
          return d2;
        }
        x2 = Object.getPrototypeOf(x2);
      }
      return null;
    }
    function isGetter(object, name2) {
      const d2 = getPropertyDescriptor(object, name2);
      return d2 != null && d2.get != null;
    }
    function getElementValues(nodeList, initialScope) {
      const valueList = [];
      for (let i2 = 0; i2 < nodeList.length; ++i2) {
        const elementNode = nodeList[i2];
        if (elementNode == null) {
          valueList.length = i2 + 1;
        } else if (elementNode.type === "SpreadElement") {
          const argument = getStaticValueR(elementNode.argument, initialScope);
          if (argument == null) {
            return null;
          }
          valueList.push(.../** @type {Iterable<any>} */
          argument.value);
        } else {
          const element = getStaticValueR(elementNode, initialScope);
          if (element == null) {
            return null;
          }
          valueList.push(element.value);
        }
      }
      return valueList;
    }
    function isBuiltinGlobal(variable) {
      return variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject;
    }
    function canBeConsideredConst(variable) {
      if (variable.defs.length !== 1) {
        return false;
      }
      const def = variable.defs[0];
      return Boolean(
        def.parent && def.type === "Variable" && (def.parent.kind === "const" || isEffectivelyConst(variable))
      );
    }
    function isEffectivelyConst(variable) {
      const refs = variable.references;
      const inits = refs.filter((r2) => r2.init).length;
      const reads = refs.filter((r2) => r2.isReadOnly()).length;
      if (inits === 1 && reads + inits === refs.length) {
        return true;
      }
      return false;
    }
    function hasMutationInProperty(variable, initialScope) {
      for (const ref2 of variable.references) {
        let node2 = (
          /** @type {TSESTreeNode} */
          ref2.identifier
        );
        while (node2 && node2.parent && node2.parent.type === "MemberExpression") {
          node2 = node2.parent;
        }
        if (!node2 || !node2.parent) {
          continue;
        }
        if (node2.parent.type === "AssignmentExpression" && node2.parent.left === node2 || node2.parent.type === "UpdateExpression" && node2.parent.argument === node2) {
          return true;
        }
        if (node2.parent.type === "CallExpression" && node2.parent.callee === node2 && node2.type === "MemberExpression") {
          const methodName = getStaticPropertyNameValue(node2, initialScope);
          if (isNameOfMutationArrayMethod(methodName)) {
            return true;
          }
        }
      }
      return false;
      function isNameOfMutationArrayMethod(methodName) {
        if (methodName == null || methodName.value == null) {
          return false;
        }
        const name2 = methodName.value;
        return name2 === "copyWithin" || name2 === "fill" || name2 === "pop" || name2 === "push" || name2 === "reverse" || name2 === "shift" || name2 === "sort" || name2 === "splice" || name2 === "unshift";
      }
    }
    const operations = Object.freeze({
      ArrayExpression(node2, initialScope) {
        const elements = getElementValues(node2.elements, initialScope);
        return elements != null ? { value: elements } : null;
      },
      AssignmentExpression(node2, initialScope) {
        if (node2.operator === "=") {
          return getStaticValueR(node2.right, initialScope);
        }
        return null;
      },
      //eslint-disable-next-line complexity
      BinaryExpression(node2, initialScope) {
        if (node2.operator === "in" || node2.operator === "instanceof") {
          return null;
        }
        const left = getStaticValueR(node2.left, initialScope);
        const right = getStaticValueR(node2.right, initialScope);
        if (left != null && right != null) {
          switch (node2.operator) {
            case "==":
              return { value: left.value == right.value };
            case "!=":
              return { value: left.value != right.value };
            case "===":
              return { value: left.value === right.value };
            case "!==":
              return { value: left.value !== right.value };
            case "<":
              return {
                value: (
                  /** @type {any} */
                  left.value < /** @type {any} */
                  right.value
                )
              };
            case "<=":
              return {
                value: (
                  /** @type {any} */
                  left.value <= /** @type {any} */
                  right.value
                )
              };
            case ">":
              return {
                value: (
                  /** @type {any} */
                  left.value > /** @type {any} */
                  right.value
                )
              };
            case ">=":
              return {
                value: (
                  /** @type {any} */
                  left.value >= /** @type {any} */
                  right.value
                )
              };
            case "<<":
              return {
                value: (
                  /** @type {any} */
                  left.value << /** @type {any} */
                  right.value
                )
              };
            case ">>":
              return {
                value: (
                  /** @type {any} */
                  left.value >> /** @type {any} */
                  right.value
                )
              };
            case ">>>":
              return {
                value: (
                  /** @type {any} */
                  left.value >>> /** @type {any} */
                  right.value
                )
              };
            case "+":
              return {
                value: (
                  /** @type {any} */
                  left.value + /** @type {any} */
                  right.value
                )
              };
            case "-":
              return {
                value: (
                  /** @type {any} */
                  left.value - /** @type {any} */
                  right.value
                )
              };
            case "*":
              return {
                value: (
                  /** @type {any} */
                  left.value * /** @type {any} */
                  right.value
                )
              };
            case "/":
              return {
                value: (
                  /** @type {any} */
                  left.value / /** @type {any} */
                  right.value
                )
              };
            case "%":
              return {
                value: (
                  /** @type {any} */
                  left.value % /** @type {any} */
                  right.value
                )
              };
            case "**":
              return {
                value: (
                  /** @type {any} */
                  left.value ** /** @type {any} */
                  right.value
                )
              };
            case "|":
              return {
                value: (
                  /** @type {any} */
                  left.value | /** @type {any} */
                  right.value
                )
              };
            case "^":
              return {
                value: (
                  /** @type {any} */
                  left.value ^ /** @type {any} */
                  right.value
                )
              };
            case "&":
              return {
                value: (
                  /** @type {any} */
                  left.value & /** @type {any} */
                  right.value
                )
              };
          }
        }
        return null;
      },
      CallExpression(node2, initialScope) {
        const calleeNode = node2.callee;
        const args = getElementValues(node2.arguments, initialScope);
        if (args != null) {
          if (calleeNode.type === "MemberExpression") {
            if (calleeNode.property.type === "PrivateIdentifier") {
              return null;
            }
            const object = getStaticValueR(calleeNode.object, initialScope);
            if (object != null) {
              if (object.value == null && (object.optional || node2.optional)) {
                return { value: void 0, optional: true };
              }
              const property = getStaticPropertyNameValue(
                calleeNode,
                initialScope
              );
              if (property != null) {
                const receiver = (
                  /** @type {Record<PropertyKey, (...args: any[]) => any>} */
                  object.value
                );
                const methodName = (
                  /** @type {PropertyKey} */
                  property.value
                );
                if (callAllowed.has(receiver[methodName])) {
                  return {
                    value: receiver[methodName](...args)
                  };
                }
                if (callPassThrough.has(receiver[methodName])) {
                  return { value: args[0] };
                }
              }
            }
          } else {
            const callee = getStaticValueR(calleeNode, initialScope);
            if (callee != null) {
              if (callee.value == null && node2.optional) {
                return { value: void 0, optional: true };
              }
              const func = (
                /** @type {(...args: any[]) => any} */
                callee.value
              );
              if (callAllowed.has(func)) {
                return { value: func(...args) };
              }
              if (callPassThrough.has(func)) {
                return { value: args[0] };
              }
            }
          }
        }
        return null;
      },
      ConditionalExpression(node2, initialScope) {
        const test = getStaticValueR(node2.test, initialScope);
        if (test != null) {
          return test.value ? getStaticValueR(node2.consequent, initialScope) : getStaticValueR(node2.alternate, initialScope);
        }
        return null;
      },
      ExpressionStatement(node2, initialScope) {
        return getStaticValueR(node2.expression, initialScope);
      },
      Identifier(node2, initialScope) {
        if (initialScope != null) {
          const variable = findVariable(initialScope, node2);
          if (variable != null) {
            if (isBuiltinGlobal(variable)) {
              return { value: globalObject[variable.name] };
            }
            if (canBeConsideredConst(variable)) {
              const def = variable.defs[0];
              if (
                // TODO(mysticatea): don't support destructuring here.
                def.node.id.type === "Identifier"
              ) {
                const init = getStaticValueR(
                  def.node.init,
                  initialScope
                );
                if (init && typeof init.value === "object" && init.value !== null) {
                  if (hasMutationInProperty(variable, initialScope)) {
                    return null;
                  }
                }
                return init;
              }
            }
          }
        }
        return null;
      },
      Literal(node2) {
        const literal2 = (
          /** @type {Partial<Literal> & Partial<RegExpLiteral> & Partial<BigIntLiteral>} */
          node2
        );
        if ((literal2.regex != null || literal2.bigint != null) && literal2.value == null) {
          return null;
        }
        return { value: literal2.value };
      },
      LogicalExpression(node2, initialScope) {
        const left = getStaticValueR(node2.left, initialScope);
        if (left != null) {
          if (node2.operator === "||" && Boolean(left.value) === true || node2.operator === "&&" && Boolean(left.value) === false || node2.operator === "??" && left.value != null) {
            return left;
          }
          const right = getStaticValueR(node2.right, initialScope);
          if (right != null) {
            return right;
          }
        }
        return null;
      },
      MemberExpression(node2, initialScope) {
        if (node2.property.type === "PrivateIdentifier") {
          return null;
        }
        const object = getStaticValueR(node2.object, initialScope);
        if (object != null) {
          if (object.value == null && (object.optional || node2.optional)) {
            return { value: void 0, optional: true };
          }
          const property = getStaticPropertyNameValue(node2, initialScope);
          if (property != null) {
            if (!isGetter(
              /** @type {object} */
              object.value,
              /** @type {PropertyKey} */
              property.value
            )) {
              return {
                value: (
                  /** @type {Record<PropertyKey, unknown>} */
                  object.value[
                    /** @type {PropertyKey} */
                    property.value
                  ]
                )
              };
            }
            for (const [classFn, allowed] of getterAllowed) {
              if (object.value instanceof classFn && allowed.has(
                /** @type {string} */
                property.value
              )) {
                return {
                  value: (
                    /** @type {Record<PropertyKey, unknown>} */
                    object.value[
                      /** @type {PropertyKey} */
                      property.value
                    ]
                  )
                };
              }
            }
          }
        }
        return null;
      },
      ChainExpression(node2, initialScope) {
        const expression = getStaticValueR(node2.expression, initialScope);
        if (expression != null) {
          return { value: expression.value };
        }
        return null;
      },
      NewExpression(node2, initialScope) {
        const callee = getStaticValueR(node2.callee, initialScope);
        const args = getElementValues(node2.arguments, initialScope);
        if (callee != null && args != null) {
          const Func2 = (
            /** @type {new (...args: any[]) => any} */
            callee.value
          );
          if (callAllowed.has(Func2)) {
            return { value: new Func2(...args) };
          }
        }
        return null;
      },
      ObjectExpression(node2, initialScope) {
        const object = {};
        for (const propertyNode of node2.properties) {
          if (propertyNode.type === "Property") {
            if (propertyNode.kind !== "init") {
              return null;
            }
            const key = getStaticPropertyNameValue(
              propertyNode,
              initialScope
            );
            const value = getStaticValueR(propertyNode.value, initialScope);
            if (key == null || value == null) {
              return null;
            }
            object[
              /** @type {PropertyKey} */
              key.value
            ] = value.value;
          } else if (propertyNode.type === "SpreadElement" || // @ts-expect-error -- Backward compatibility
          propertyNode.type === "ExperimentalSpreadProperty") {
            const argument = getStaticValueR(
              propertyNode.argument,
              initialScope
            );
            if (argument == null) {
              return null;
            }
            Object.assign(object, argument.value);
          } else {
            return null;
          }
        }
        return { value: object };
      },
      SequenceExpression(node2, initialScope) {
        const last = node2.expressions[node2.expressions.length - 1];
        return getStaticValueR(last, initialScope);
      },
      TaggedTemplateExpression(node2, initialScope) {
        const tag = getStaticValueR(node2.tag, initialScope);
        const expressions = getElementValues(
          node2.quasi.expressions,
          initialScope
        );
        if (tag != null && expressions != null) {
          const func = (
            /** @type {(...args: any[]) => any} */
            tag.value
          );
          const strings = node2.quasi.quasis.map((q) => q.value.cooked);
          strings.raw = node2.quasi.quasis.map((q) => q.value.raw);
          if (func === String.raw) {
            return { value: func(strings, ...expressions) };
          }
        }
        return null;
      },
      TemplateLiteral(node2, initialScope) {
        const expressions = getElementValues(node2.expressions, initialScope);
        if (expressions != null) {
          let value = node2.quasis[0].value.cooked;
          for (let i2 = 0; i2 < expressions.length; ++i2) {
            value += expressions[i2];
            value += /** @type {string} */
            node2.quasis[i2 + 1].value.cooked;
          }
          return { value };
        }
        return null;
      },
      UnaryExpression(node2, initialScope) {
        if (node2.operator === "delete") {
          return null;
        }
        if (node2.operator === "void") {
          return { value: void 0 };
        }
        const arg = getStaticValueR(node2.argument, initialScope);
        if (arg != null) {
          switch (node2.operator) {
            case "-":
              return { value: -/** @type {any} */
              arg.value };
            case "+":
              return { value: +/** @type {any} */
              arg.value };
            case "!":
              return { value: !arg.value };
            case "~":
              return { value: ~/** @type {any} */
              arg.value };
            case "typeof":
              return { value: typeof arg.value };
          }
        }
        return null;
      },
      TSAsExpression(node2, initialScope) {
        return getStaticValueR(node2.expression, initialScope);
      },
      TSSatisfiesExpression(node2, initialScope) {
        return getStaticValueR(node2.expression, initialScope);
      },
      TSTypeAssertion(node2, initialScope) {
        return getStaticValueR(node2.expression, initialScope);
      },
      TSNonNullExpression(node2, initialScope) {
        return getStaticValueR(node2.expression, initialScope);
      },
      TSInstantiationExpression(node2, initialScope) {
        return getStaticValueR(node2.expression, initialScope);
      }
    });
    function getStaticValueR(node2, initialScope) {
      if (node2 != null && Object.hasOwnProperty.call(operations, node2.type)) {
        return (
          /** @type {VisitorCallback<any>} */
          operations[node2.type](
            /** @type {TSESTreeNode} */
            node2,
            initialScope
          )
        );
      }
      return null;
    }
    function getStaticPropertyNameValue(node2, initialScope) {
      const nameNode = node2.type === "Property" ? node2.key : node2.property;
      if (node2.computed) {
        return getStaticValueR(nameNode, initialScope);
      }
      if (nameNode.type === "Identifier") {
        return { value: nameNode.name };
      }
      if (nameNode.type === "Literal") {
        if (
          /** @type {Partial<BigIntLiteral>} */
          nameNode.bigint
        ) {
          return { value: (
            /** @type {BigIntLiteral} */
            nameNode.bigint
          ) };
        }
        return { value: String(nameNode.value) };
      }
      return null;
    }
    function getStaticValue(node2, initialScope = null) {
      try {
        return getStaticValueR(node2, initialScope);
      } catch (_error) {
        return null;
      }
    }
    function getStringIfConstant(node2, initialScope = null) {
      if (node2 && node2.type === "Literal" && node2.value === null) {
        const literal2 = (
          /** @type {Partial<SimpleLiteral> & Partial<RegExpLiteral> & Partial<BigIntLiteral>} */
          node2
        );
        if (literal2.regex) {
          return `/${literal2.regex.pattern}/${literal2.regex.flags}`;
        }
        if (literal2.bigint) {
          return literal2.bigint;
        }
      }
      const evaluated = getStaticValue(node2, initialScope);
      if (evaluated) {
        try {
          return String(evaluated.value);
        } catch {
        }
      }
      return null;
    }
    function getPropertyName(node2, initialScope) {
      switch (node2.type) {
        case "MemberExpression":
          if (node2.computed) {
            return getStringIfConstant(node2.property, initialScope);
          }
          if (node2.property.type === "PrivateIdentifier") {
            return null;
          }
          return (
            /** @type {Partial<Identifier>} */
            node2.property.name
          );
        case "Property":
        case "MethodDefinition":
        case "PropertyDefinition":
          if (node2.computed) {
            return getStringIfConstant(node2.key, initialScope);
          }
          if (node2.key.type === "Literal") {
            return String(node2.key.value);
          }
          if (node2.key.type === "PrivateIdentifier") {
            return null;
          }
          return (
            /** @type {Partial<Identifier>} */
            node2.key.name
          );
      }
      return null;
    }
    function getFunctionNameWithKind(node2, sourceCode2) {
      const parent = (
        /** @type {RuleNode} */
        node2.parent
      );
      const tokens = [];
      const isObjectMethod = parent.type === "Property" && parent.value === node2;
      const isClassMethod = parent.type === "MethodDefinition" && parent.value === node2;
      const isClassFieldMethod = parent.type === "PropertyDefinition" && parent.value === node2;
      if (isClassMethod || isClassFieldMethod) {
        if (parent.static) {
          tokens.push("static");
        }
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push("private");
        }
      }
      if (node2.async) {
        tokens.push("async");
      }
      if (node2.generator) {
        tokens.push("generator");
      }
      if (isObjectMethod || isClassMethod) {
        if (parent.kind === "constructor") {
          return "constructor";
        }
        if (parent.kind === "get") {
          tokens.push("getter");
        } else if (parent.kind === "set") {
          tokens.push("setter");
        } else {
          tokens.push("method");
        }
      } else if (isClassFieldMethod) {
        tokens.push("method");
      } else {
        if (node2.type === "ArrowFunctionExpression") {
          tokens.push("arrow");
        }
        tokens.push("function");
      }
      if (isObjectMethod || isClassMethod || isClassFieldMethod) {
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push(`#${parent.key.name}`);
        } else {
          const name2 = getPropertyName(parent);
          if (name2) {
            tokens.push(`'${name2}'`);
          } else if (sourceCode2) {
            const keyText = sourceCode2.getText(parent.key);
            if (!keyText.includes("\n")) {
              tokens.push(`[${keyText}]`);
            }
          }
        }
      } else if (hasId(node2)) {
        tokens.push(`'${node2.id.name}'`);
      } else if (parent.type === "VariableDeclarator" && parent.id && parent.id.type === "Identifier") {
        tokens.push(`'${parent.id.name}'`);
      } else if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left && parent.left.type === "Identifier") {
        tokens.push(`'${parent.left.name}'`);
      } else if (parent.type === "ExportDefaultDeclaration" && parent.declaration === node2) {
        tokens.push("'default'");
      }
      return tokens.join(" ");
    }
    function hasId(node2) {
      return Boolean(
        /** @type {Partial<FunctionDeclaration | FunctionExpression>} */
        node2.id
      );
    }
    const typeConversionBinaryOps = Object.freeze(
      /* @__PURE__ */ new Set([
        "==",
        "!=",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "|",
        "^",
        "&",
        "in"
      ])
    );
    const typeConversionUnaryOps = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
    function isNode(x2) {
      return x2 !== null && typeof x2 === "object" && typeof x2.type === "string";
    }
    const visitor = Object.freeze(
      Object.assign(/* @__PURE__ */ Object.create(null), {
        /**
         * @param {Node} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        $visit(node2, options, visitorKeys) {
          const { type: type2 } = node2;
          if (typeof /** @type {any} */
          this[type2] === "function") {
            return (
              /** @type {any} */
              this[type2](
                node2,
                options,
                visitorKeys
              )
            );
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        /**
         * @param {Node} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        $visitChildren(node2, options, visitorKeys) {
          const { type: type2 } = node2;
          for (
            const key of
            /** @type {(keyof Node)[]} */
            visitorKeys[type2] || eslintVisitorKeys2.getKeys(node2)
          ) {
            const value = node2[key];
            if (Array.isArray(value)) {
              for (const element of value) {
                if (isNode(element) && this.$visit(element, options, visitorKeys)) {
                  return true;
                }
              }
            } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
              return true;
            }
          }
          return false;
        },
        ArrowFunctionExpression() {
          return false;
        },
        AssignmentExpression() {
          return true;
        },
        AwaitExpression() {
          return true;
        },
        /**
         * @param {BinaryExpression} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        BinaryExpression(node2, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node2.operator) && (node2.left.type !== "Literal" || node2.right.type !== "Literal")) {
            return true;
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        CallExpression() {
          return true;
        },
        FunctionExpression() {
          return false;
        },
        ImportExpression() {
          return true;
        },
        /**
         * @param {MemberExpression} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        MemberExpression(node2, options, visitorKeys) {
          if (options.considerGetters) {
            return true;
          }
          if (options.considerImplicitTypeConversion && node2.computed && node2.property.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        /**
         * @param {MethodDefinition} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        MethodDefinition(node2, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node2.computed && node2.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        NewExpression() {
          return true;
        },
        /**
         * @param {Property} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        Property(node2, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node2.computed && node2.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        /**
         * @param {PropertyDefinition} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        PropertyDefinition(node2, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node2.computed && node2.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        /**
         * @param {UnaryExpression} node
         * @param {HasSideEffectOptions} options
         * @param {Record<string, string[]>} visitorKeys
         */
        UnaryExpression(node2, options, visitorKeys) {
          if (node2.operator === "delete") {
            return true;
          }
          if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node2.operator) && node2.argument.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node2, options, visitorKeys);
        },
        UpdateExpression() {
          return true;
        },
        YieldExpression() {
          return true;
        }
      })
    );
    function hasSideEffect(node2, sourceCode2, options = {}) {
      const { considerGetters = false, considerImplicitTypeConversion = false } = options;
      return visitor.$visit(
        node2,
        { considerGetters, considerImplicitTypeConversion },
        sourceCode2.visitorKeys || eslintVisitorKeys2.KEYS
      );
    }
    function getParentSyntaxParen(node2, sourceCode2) {
      const parent = (
        /** @type {RuleNode} */
        node2.parent
      );
      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          if (parent.arguments.length === 1 && parent.arguments[0] === node2) {
            return sourceCode2.getTokenAfter(
              /** @type {RuleNode} */
              /** @type {unknown} */
              /** @type {TSNewExpression | TSCallExpression} */
              parent.typeParameters || parent.callee,
              isOpeningParenToken
            );
          }
          return null;
        case "DoWhileStatement":
          if (parent.test === node2) {
            return sourceCode2.getTokenAfter(
              parent.body,
              isOpeningParenToken
            );
          }
          return null;
        case "IfStatement":
        case "WhileStatement":
          if (parent.test === node2) {
            return sourceCode2.getFirstToken(parent, 1);
          }
          return null;
        case "ImportExpression":
          if (parent.source === node2) {
            return sourceCode2.getFirstToken(parent, 1);
          }
          return null;
        case "SwitchStatement":
          if (parent.discriminant === node2) {
            return sourceCode2.getFirstToken(parent, 1);
          }
          return null;
        case "WithStatement":
          if (parent.object === node2) {
            return sourceCode2.getFirstToken(parent, 1);
          }
          return null;
        default:
          return null;
      }
    }
    function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
      let times, node2, sourceCode2, maybeLeftParen, maybeRightParen;
      if (typeof timesOrNode === "number") {
        times = timesOrNode | 0;
        node2 = /** @type {RuleNode} */
        nodeOrSourceCode;
        sourceCode2 = /** @type {SourceCode} */
        optionalSourceCode;
        if (!(times >= 1)) {
          throw new TypeError("'times' should be a positive integer.");
        }
      } else {
        times = 1;
        node2 = /** @type {RuleNode} */
        timesOrNode;
        sourceCode2 = /** @type {SourceCode} */
        nodeOrSourceCode;
      }
      if (node2 == null || // `Program` can't be parenthesized
      node2.parent == null || // `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`
      node2.parent.type === "CatchClause" && node2.parent.param === node2) {
        return false;
      }
      maybeLeftParen = maybeRightParen = node2;
      do {
        maybeLeftParen = sourceCode2.getTokenBefore(maybeLeftParen);
        maybeRightParen = sourceCode2.getTokenAfter(maybeRightParen);
      } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken(maybeLeftParen) && isClosingParenToken(maybeRightParen) && // Avoid false positive such as `if (a) {}`
      maybeLeftParen !== getParentSyntaxParen(node2, sourceCode2) && --times > 0);
      return times === 0;
    }
    const placeholder2 = /\$(?:[$&`']|[1-9][0-9]?)/gu;
    const internal = /* @__PURE__ */ new WeakMap();
    function isEscaped(str, index2) {
      let escaped = false;
      for (let i2 = index2 - 1; i2 >= 0 && str.charCodeAt(i2) === 92; --i2) {
        escaped = !escaped;
      }
      return escaped;
    }
    function replaceS(matcher2, str, replacement) {
      const chunks = [];
      let index2 = 0;
      function replacer(key, match) {
        switch (key) {
          case "$$":
            return "$";
          case "$&":
            return match[0];
          case "$`":
            return str.slice(0, match.index);
          case "$'":
            return str.slice(match.index + match[0].length);
          default: {
            const i2 = key.slice(1);
            if (i2 in match) {
              return match[
                /** @type {any} */
                i2
              ];
            }
            return key;
          }
        }
      }
      for (const match of matcher2.execAll(str)) {
        chunks.push(str.slice(index2, match.index));
        chunks.push(
          replacement.replace(placeholder2, (key) => replacer(key, match))
        );
        index2 = match.index + match[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    function replaceF(matcher2, str, replace2) {
      const chunks = [];
      let index2 = 0;
      for (const match of matcher2.execAll(str)) {
        chunks.push(str.slice(index2, match.index));
        chunks.push(
          String(
            replace2(
              .../** @type {[string, ...string[]]} */
              /** @type {string[]} */
              match,
              match.index,
              match.input
            )
          )
        );
        index2 = match.index + match[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    class PatternMatcher {
      /**
       * Initialize this matcher.
       * @param {RegExp} pattern The pattern to match.
       * @param {{escaped?:boolean}} [options] The options.
       */
      constructor(pattern2, options = {}) {
        const { escaped = false } = options;
        if (!(pattern2 instanceof RegExp)) {
          throw new TypeError("'pattern' should be a RegExp instance.");
        }
        if (!pattern2.flags.includes("g")) {
          throw new Error("'pattern' should contains 'g' flag.");
        }
        internal.set(this, {
          pattern: new RegExp(pattern2.source, pattern2.flags),
          escaped: Boolean(escaped)
        });
      }
      /**
       * Find the pattern in a given string.
       * @param {string} str The string to find.
       * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
       */
      *execAll(str) {
        const { pattern: pattern2, escaped } = (
          /** @type {{pattern:RegExp,escaped:boolean}} */
          internal.get(this)
        );
        let match = null;
        let lastIndex = 0;
        pattern2.lastIndex = 0;
        while ((match = pattern2.exec(str)) != null) {
          if (escaped || !isEscaped(str, match.index)) {
            lastIndex = pattern2.lastIndex;
            yield match;
            pattern2.lastIndex = lastIndex;
          }
        }
      }
      /**
       * Check whether the pattern is found in a given string.
       * @param {string} str The string to check.
       * @returns {boolean} `true` if the pattern was found in the string.
       */
      test(str) {
        const it = this.execAll(str);
        const ret = it.next();
        return !ret.done;
      }
      /**
       * Replace a given string.
       * @param {string} str The string to be replaced.
       * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
       * @returns {string} The replaced string.
       */
      [Symbol.replace](str, replacer) {
        return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
      }
    }
    const IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
    function isHasSource(node2) {
      return IMPORT_TYPE.test(node2.type) && /** @type {ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration} */
      node2.source != null;
    }
    const has = (
      /** @type {<T>(traceMap: TraceMap<unknown>, v: T) => v is (string extends T ? string : T)} */
      Function.call.bind(Object.hasOwnProperty)
    );
    const READ = Symbol("read");
    const CALL = Symbol("call");
    const CONSTRUCT = Symbol("construct");
    const ESM = Symbol("esm");
    const requireCall = { require: { [CALL]: true } };
    function isModifiedGlobal(variable) {
      return variable == null || variable.defs.length !== 0 || variable.references.some((r2) => r2.isWrite());
    }
    function isPassThrough(node2) {
      const parent = (
        /** @type {TSESTreeNode} */
        node2.parent
      );
      if (parent) {
        switch (parent.type) {
          case "ConditionalExpression":
            return parent.consequent === node2 || parent.alternate === node2;
          case "LogicalExpression":
            return true;
          case "SequenceExpression":
            return parent.expressions[parent.expressions.length - 1] === node2;
          case "ChainExpression":
            return true;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
          case "TSInstantiationExpression":
            return true;
          default:
            return false;
        }
      }
      return false;
    }
    class ReferenceTracker {
      /**
       * Initialize this tracker.
       * @param {Scope} globalScope The global scope.
       * @param {object} [options] The options.
       * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
       * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
       */
      constructor(globalScope, options = {}) {
        const {
          mode = "strict",
          globalObjectNames = ["global", "globalThis", "self", "window"]
        } = options;
        this.variableStack = [];
        this.globalScope = globalScope;
        this.mode = mode;
        this.globalObjectNames = globalObjectNames.slice(0);
      }
      /**
       * Iterate the references of global variables.
       * @template T
       * @param {TraceMap<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      *iterateGlobalReferences(traceMap) {
        for (const key of Object.keys(traceMap)) {
          const nextTraceMap = traceMap[key];
          const path = [key];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            /** @type {Variable} */
            variable,
            path,
            nextTraceMap,
            true
          );
        }
        for (const key of this.globalObjectNames) {
          const path = [];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            /** @type {Variable} */
            variable,
            path,
            traceMap,
            false
          );
        }
      }
      /**
       * Iterate the references of CommonJS modules.
       * @template T
       * @param {TraceMap<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      *iterateCjsReferences(traceMap) {
        for (const { node: node2 } of this.iterateGlobalReferences(requireCall)) {
          const key = getStringIfConstant(
            /** @type {CallExpression} */
            node2.arguments[0]
          );
          if (key == null || !has(traceMap, key)) {
            continue;
          }
          const nextTraceMap = traceMap[key];
          const path = [key];
          if (nextTraceMap[READ]) {
            yield {
              node: node2,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iteratePropertyReferences(
            /** @type {CallExpression} */
            node2,
            path,
            nextTraceMap
          );
        }
      }
      /**
       * Iterate the references of ES modules.
       * @template T
       * @param {TraceMap<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      *iterateEsmReferences(traceMap) {
        const programNode = (
          /** @type {Program} */
          this.globalScope.block
        );
        for (const node2 of programNode.body) {
          if (!isHasSource(node2)) {
            continue;
          }
          const moduleId = (
            /** @type {string} */
            node2.source.value
          );
          if (!has(traceMap, moduleId)) {
            continue;
          }
          const nextTraceMap = traceMap[moduleId];
          const path = [moduleId];
          if (nextTraceMap[READ]) {
            yield {
              // eslint-disable-next-line object-shorthand -- apply type
              node: (
                /** @type {RuleNode} */
                node2
              ),
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          if (node2.type === "ExportAllDeclaration") {
            for (const key of Object.keys(nextTraceMap)) {
              const exportTraceMap = nextTraceMap[key];
              if (exportTraceMap[READ]) {
                yield {
                  // eslint-disable-next-line object-shorthand -- apply type
                  node: (
                    /** @type {RuleNode} */
                    node2
                  ),
                  path: path.concat(key),
                  type: READ,
                  info: exportTraceMap[READ]
                };
              }
            }
          } else {
            for (const specifier of node2.specifiers) {
              const esm = has(nextTraceMap, ESM);
              const it = this._iterateImportReferences(
                specifier,
                path,
                esm ? nextTraceMap : this.mode === "legacy" ? { default: nextTraceMap, ...nextTraceMap } : { default: nextTraceMap }
              );
              if (esm) {
                yield* it;
              } else {
                for (const report of it) {
                  report.path = report.path.filter(exceptDefault);
                  if (report.path.length >= 2 || report.type !== READ) {
                    yield report;
                  }
                }
              }
            }
          }
        }
      }
      /**
       * Iterate the property references for a given expression AST node.
       * @template T
       * @param {Expression} node The expression AST node to iterate property references.
       * @param {TraceMap<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate property references.
       */
      *iteratePropertyReferences(node2, traceMap) {
        yield* this._iteratePropertyReferences(node2, [], traceMap);
      }
      /**
       * Iterate the references for a given variable.
       * @private
       * @template T
       * @param {Variable} variable The variable to iterate that references.
       * @param {string[]} path The current path.
       * @param {TraceMapObject<T>} traceMap The trace map.
       * @param {boolean} shouldReport = The flag to report those references.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      *_iterateVariableReferences(variable, path, traceMap, shouldReport) {
        if (this.variableStack.includes(variable)) {
          return;
        }
        this.variableStack.push(variable);
        try {
          for (const reference of variable.references) {
            if (!reference.isRead()) {
              continue;
            }
            const node2 = (
              /** @type {RuleNode & Identifier} */
              reference.identifier
            );
            if (shouldReport && traceMap[READ]) {
              yield { node: node2, path, type: READ, info: traceMap[READ] };
            }
            yield* this._iteratePropertyReferences(node2, path, traceMap);
          }
        } finally {
          this.variableStack.pop();
        }
      }
      /**
       * Iterate the references for a given AST node.
       * @private
       * @template T
       * @param {Expression} rootNode The AST node to iterate references.
       * @param {string[]} path The current path.
       * @param {TraceMapObject<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      //eslint-disable-next-line complexity
      *_iteratePropertyReferences(rootNode, path, traceMap) {
        let node2 = rootNode;
        while (isPassThrough(node2)) {
          node2 = node2.parent;
        }
        const parent = (
          /** @type {RuleNode} */
          node2.parent
        );
        if (parent.type === "MemberExpression") {
          if (parent.object === node2) {
            const key = getPropertyName(parent);
            if (key == null || !has(traceMap, key)) {
              return;
            }
            path = path.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: parent,
                path,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iteratePropertyReferences(
              parent,
              path,
              nextTraceMap
            );
          }
          return;
        }
        if (parent.type === "CallExpression") {
          if (parent.callee === node2 && traceMap[CALL]) {
            yield { node: parent, path, type: CALL, info: traceMap[CALL] };
          }
          return;
        }
        if (parent.type === "NewExpression") {
          if (parent.callee === node2 && traceMap[CONSTRUCT]) {
            yield {
              node: parent,
              path,
              type: CONSTRUCT,
              info: traceMap[CONSTRUCT]
            };
          }
          return;
        }
        if (parent.type === "AssignmentExpression") {
          if (parent.right === node2) {
            yield* this._iterateLhsReferences(parent.left, path, traceMap);
            yield* this._iteratePropertyReferences(parent, path, traceMap);
          }
          return;
        }
        if (parent.type === "AssignmentPattern") {
          if (parent.right === node2) {
            yield* this._iterateLhsReferences(parent.left, path, traceMap);
          }
          return;
        }
        if (parent.type === "VariableDeclarator") {
          if (parent.init === node2) {
            yield* this._iterateLhsReferences(parent.id, path, traceMap);
          }
        }
      }
      /**
       * Iterate the references for a given Pattern node.
       * @private
       * @template T
       * @param {Pattern} patternNode The Pattern node to iterate references.
       * @param {string[]} path The current path.
       * @param {TraceMapObject<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      *_iterateLhsReferences(patternNode, path, traceMap) {
        if (patternNode.type === "Identifier") {
          const variable = findVariable(this.globalScope, patternNode);
          if (variable != null) {
            yield* this._iterateVariableReferences(
              variable,
              path,
              traceMap,
              false
            );
          }
          return;
        }
        if (patternNode.type === "ObjectPattern") {
          for (const property of patternNode.properties) {
            const key = getPropertyName(
              /** @type {AssignmentProperty} */
              property
            );
            if (key == null || !has(traceMap, key)) {
              continue;
            }
            const nextPath = path.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: (
                  /** @type {RuleNode} */
                  property
                ),
                path: nextPath,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iterateLhsReferences(
              /** @type {AssignmentProperty} */
              property.value,
              nextPath,
              nextTraceMap
            );
          }
          return;
        }
        if (patternNode.type === "AssignmentPattern") {
          yield* this._iterateLhsReferences(patternNode.left, path, traceMap);
        }
      }
      /**
       * Iterate the references for a given ModuleSpecifier node.
       * @private
       * @template T
       * @param {ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier} specifierNode The ModuleSpecifier node to iterate references.
       * @param {string[]} path The current path.
       * @param {TraceMapObject<T>} traceMap The trace map.
       * @returns {IterableIterator<TrackedReferences<T>>} The iterator to iterate references.
       */
      *_iterateImportReferences(specifierNode, path, traceMap) {
        const type2 = specifierNode.type;
        if (type2 === "ImportSpecifier" || type2 === "ImportDefaultSpecifier") {
          const key = type2 === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.type === "Identifier" ? specifierNode.imported.name : specifierNode.imported.value;
          if (!has(traceMap, key)) {
            return;
          }
          path = path.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: (
                /** @type {RuleNode} */
                specifierNode
              ),
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iterateVariableReferences(
            /** @type {Variable} */
            findVariable(this.globalScope, specifierNode.local),
            path,
            nextTraceMap,
            false
          );
          return;
        }
        if (type2 === "ImportNamespaceSpecifier") {
          yield* this._iterateVariableReferences(
            /** @type {Variable} */
            findVariable(this.globalScope, specifierNode.local),
            path,
            traceMap,
            false
          );
          return;
        }
        if (type2 === "ExportSpecifier") {
          const key = specifierNode.local.type === "Identifier" ? specifierNode.local.name : specifierNode.local.value;
          if (!has(traceMap, key)) {
            return;
          }
          path = path.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: (
                /** @type {RuleNode} */
                specifierNode
              ),
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
        }
      }
    }
    ReferenceTracker.READ = READ;
    ReferenceTracker.CALL = CALL;
    ReferenceTracker.CONSTRUCT = CONSTRUCT;
    ReferenceTracker.ESM = ESM;
    function exceptDefault(name2, index2) {
      return !(index2 === 1 && name2 === "default");
    }
    var index = {
      CALL,
      CONSTRUCT,
      ESM,
      findVariable,
      getFunctionHeadLocation,
      getFunctionNameWithKind,
      getInnermostScope,
      getPropertyName,
      getStaticValue,
      getStringIfConstant,
      hasSideEffect,
      isArrowToken,
      isClosingBraceToken,
      isClosingBracketToken,
      isClosingParenToken,
      isColonToken,
      isCommaToken,
      isCommentToken,
      isNotArrowToken,
      isNotClosingBraceToken,
      isNotClosingBracketToken,
      isNotClosingParenToken,
      isNotColonToken,
      isNotCommaToken,
      isNotCommentToken,
      isNotOpeningBraceToken,
      isNotOpeningBracketToken,
      isNotOpeningParenToken,
      isNotSemicolonToken,
      isOpeningBraceToken,
      isOpeningBracketToken,
      isOpeningParenToken,
      isParenthesized,
      isSemicolonToken,
      PatternMatcher,
      READ,
      ReferenceTracker
    };
    exports$1.CALL = CALL;
    exports$1.CONSTRUCT = CONSTRUCT;
    exports$1.ESM = ESM;
    exports$1.PatternMatcher = PatternMatcher;
    exports$1.READ = READ;
    exports$1.ReferenceTracker = ReferenceTracker;
    exports$1["default"] = index;
    exports$1.findVariable = findVariable;
    exports$1.getFunctionHeadLocation = getFunctionHeadLocation;
    exports$1.getFunctionNameWithKind = getFunctionNameWithKind;
    exports$1.getInnermostScope = getInnermostScope;
    exports$1.getPropertyName = getPropertyName;
    exports$1.getStaticValue = getStaticValue;
    exports$1.getStringIfConstant = getStringIfConstant;
    exports$1.hasSideEffect = hasSideEffect;
    exports$1.isArrowToken = isArrowToken;
    exports$1.isClosingBraceToken = isClosingBraceToken;
    exports$1.isClosingBracketToken = isClosingBracketToken;
    exports$1.isClosingParenToken = isClosingParenToken;
    exports$1.isColonToken = isColonToken;
    exports$1.isCommaToken = isCommaToken;
    exports$1.isCommentToken = isCommentToken;
    exports$1.isNotArrowToken = isNotArrowToken;
    exports$1.isNotClosingBraceToken = isNotClosingBraceToken;
    exports$1.isNotClosingBracketToken = isNotClosingBracketToken;
    exports$1.isNotClosingParenToken = isNotClosingParenToken;
    exports$1.isNotColonToken = isNotColonToken;
    exports$1.isNotCommaToken = isNotCommaToken;
    exports$1.isNotCommentToken = isNotCommentToken;
    exports$1.isNotOpeningBraceToken = isNotOpeningBraceToken;
    exports$1.isNotOpeningBracketToken = isNotOpeningBracketToken;
    exports$1.isNotOpeningParenToken = isNotOpeningParenToken;
    exports$1.isNotSemicolonToken = isNotSemicolonToken;
    exports$1.isOpeningBraceToken = isOpeningBraceToken;
    exports$1.isOpeningBracketToken = isOpeningBracketToken;
    exports$1.isOpeningParenToken = isOpeningParenToken;
    exports$1.isParenthesized = isParenthesized;
    exports$1.isSemicolonToken = isSemicolonToken;
  })(eslintUtils);
  return eslintUtils;
}
var assert;
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert;
  hasRequiredAssert = 1;
  function ok(value, message = "Assertion failed.") {
    if (!value) {
      throw new Error(message);
    }
  }
  assert = ok;
  return assert;
}
var cursor;
var hasRequiredCursor;
function requireCursor() {
  if (hasRequiredCursor) return cursor;
  hasRequiredCursor = 1;
  cursor = class Cursor {
    /**
     * Initializes this cursor.
     */
    constructor() {
      this.current = null;
    }
    /**
     * Gets the first token.
     * This consumes this cursor.
     * @returns {Token|Comment} The first token or null.
     */
    getOneToken() {
      return this.moveNext() ? this.current : null;
    }
    /**
     * Gets the first tokens.
     * This consumes this cursor.
     * @returns {(Token|Comment)[]} All tokens.
     */
    getAllTokens() {
      const tokens = [];
      while (this.moveNext()) {
        tokens.push(this.current);
      }
      return tokens;
    }
    /**
     * Moves this cursor to the next token.
     * @returns {boolean} `true` if the next token exists.
     * @abstract
     */
    /* c8 ignore next */
    // eslint-disable-next-line class-methods-use-this -- Unused
    moveNext() {
      throw new Error("Not implemented.");
    }
  };
  return cursor;
}
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  utils$1.search = function search2(tokens, location) {
    for (let minIndex = 0, maxIndex = tokens.length - 1; minIndex <= maxIndex; ) {
      const index = (minIndex + maxIndex) / 2 | 0;
      const token = tokens[index];
      const tokenStartLocation = token.range[0];
      if (location <= tokenStartLocation) {
        if (index === minIndex) {
          return index;
        }
        maxIndex = index;
      } else {
        minIndex = index + 1;
      }
    }
    return tokens.length;
  };
  utils$1.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
    if (startLoc in indexMap) {
      return indexMap[startLoc];
    }
    if (startLoc - 1 in indexMap) {
      const index = indexMap[startLoc - 1];
      const token = tokens[index];
      if (!token) {
        return tokens.length;
      }
      if (token.range[0] >= startLoc) {
        return index;
      }
      return index + 1;
    }
    return 0;
  };
  utils$1.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
    if (endLoc in indexMap) {
      return indexMap[endLoc] - 1;
    }
    if (endLoc - 1 in indexMap) {
      const index = indexMap[endLoc - 1];
      const token = tokens[index];
      if (!token) {
        return tokens.length - 1;
      }
      if (token.range[1] > endLoc) {
        return index - 1;
      }
      return index;
    }
    return tokens.length - 1;
  };
  return utils$1;
}
var backwardTokenCommentCursor;
var hasRequiredBackwardTokenCommentCursor;
function requireBackwardTokenCommentCursor() {
  if (hasRequiredBackwardTokenCommentCursor) return backwardTokenCommentCursor;
  hasRequiredBackwardTokenCommentCursor = 1;
  const Cursor = requireCursor();
  const utils2 = requireUtils$1();
  backwardTokenCommentCursor = class BackwardTokenCommentCursor extends Cursor {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.comments = comments;
      this.tokenIndex = utils2.getLastIndex(tokens, indexMap, endLoc);
      this.commentIndex = utils2.search(comments, endLoc) - 1;
      this.border = startLoc;
    }
    /** @inheritdoc */
    moveNext() {
      const token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
      const comment2 = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
      if (token && (!comment2 || token.range[1] > comment2.range[1])) {
        this.current = token;
        this.tokenIndex -= 1;
      } else if (comment2) {
        this.current = comment2;
        this.commentIndex -= 1;
      } else {
        this.current = null;
      }
      return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
    }
  };
  return backwardTokenCommentCursor;
}
var backwardTokenCursor;
var hasRequiredBackwardTokenCursor;
function requireBackwardTokenCursor() {
  if (hasRequiredBackwardTokenCursor) return backwardTokenCursor;
  hasRequiredBackwardTokenCursor = 1;
  const Cursor = requireCursor();
  const { getLastIndex, getFirstIndex } = requireUtils$1();
  backwardTokenCursor = class BackwardTokenCursor extends Cursor {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.index = getLastIndex(tokens, indexMap, endLoc);
      this.indexEnd = getFirstIndex(tokens, indexMap, startLoc);
    }
    /** @inheritdoc */
    moveNext() {
      if (this.index >= this.indexEnd) {
        this.current = this.tokens[this.index];
        this.index -= 1;
        return true;
      }
      return false;
    }
    /*
     *
     * Shorthand for performance.
     *
     */
    /** @inheritdoc */
    getOneToken() {
      return this.index >= this.indexEnd ? this.tokens[this.index] : null;
    }
  };
  return backwardTokenCursor;
}
var decorativeCursor;
var hasRequiredDecorativeCursor;
function requireDecorativeCursor() {
  if (hasRequiredDecorativeCursor) return decorativeCursor;
  hasRequiredDecorativeCursor = 1;
  const Cursor = requireCursor();
  decorativeCursor = class DecorativeCursor extends Cursor {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     */
    constructor(cursor2) {
      super();
      this.cursor = cursor2;
    }
    /** @inheritdoc */
    moveNext() {
      const retv = this.cursor.moveNext();
      this.current = this.cursor.current;
      return retv;
    }
  };
  return decorativeCursor;
}
var filterCursor;
var hasRequiredFilterCursor;
function requireFilterCursor() {
  if (hasRequiredFilterCursor) return filterCursor;
  hasRequiredFilterCursor = 1;
  const DecorativeCursor = requireDecorativeCursor();
  filterCursor = class FilterCursor extends DecorativeCursor {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     * @param {Function} predicate The predicate function to decide tokens this cursor iterates.
     */
    constructor(cursor2, predicate) {
      super(cursor2);
      this.predicate = predicate;
    }
    /** @inheritdoc */
    moveNext() {
      const predicate = this.predicate;
      while (super.moveNext()) {
        if (predicate(this.current)) {
          return true;
        }
      }
      return false;
    }
  };
  return filterCursor;
}
var forwardTokenCommentCursor;
var hasRequiredForwardTokenCommentCursor;
function requireForwardTokenCommentCursor() {
  if (hasRequiredForwardTokenCommentCursor) return forwardTokenCommentCursor;
  hasRequiredForwardTokenCommentCursor = 1;
  const Cursor = requireCursor();
  const { getFirstIndex, search: search2 } = requireUtils$1();
  forwardTokenCommentCursor = class ForwardTokenCommentCursor extends Cursor {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.comments = comments;
      this.tokenIndex = getFirstIndex(tokens, indexMap, startLoc);
      this.commentIndex = search2(comments, startLoc);
      this.border = endLoc;
    }
    /** @inheritdoc */
    moveNext() {
      const token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
      const comment2 = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
      if (token && (!comment2 || token.range[0] < comment2.range[0])) {
        this.current = token;
        this.tokenIndex += 1;
      } else if (comment2) {
        this.current = comment2;
        this.commentIndex += 1;
      } else {
        this.current = null;
      }
      return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
    }
  };
  return forwardTokenCommentCursor;
}
var forwardTokenCursor;
var hasRequiredForwardTokenCursor;
function requireForwardTokenCursor() {
  if (hasRequiredForwardTokenCursor) return forwardTokenCursor;
  hasRequiredForwardTokenCursor = 1;
  const Cursor = requireCursor();
  const { getFirstIndex, getLastIndex } = requireUtils$1();
  forwardTokenCursor = class ForwardTokenCursor extends Cursor {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     */
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.index = getFirstIndex(tokens, indexMap, startLoc);
      this.indexEnd = getLastIndex(tokens, indexMap, endLoc);
    }
    /** @inheritdoc */
    moveNext() {
      if (this.index <= this.indexEnd) {
        this.current = this.tokens[this.index];
        this.index += 1;
        return true;
      }
      return false;
    }
    /*
     *
     * Shorthand for performance.
     *
     */
    /** @inheritdoc */
    getOneToken() {
      return this.index <= this.indexEnd ? this.tokens[this.index] : null;
    }
    /** @inheritdoc */
    getAllTokens() {
      return this.tokens.slice(this.index, this.indexEnd + 1);
    }
  };
  return forwardTokenCursor;
}
var limitCursor;
var hasRequiredLimitCursor;
function requireLimitCursor() {
  if (hasRequiredLimitCursor) return limitCursor;
  hasRequiredLimitCursor = 1;
  const DecorativeCursor = requireDecorativeCursor();
  limitCursor = class LimitCursor extends DecorativeCursor {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     * @param {number} count The count of tokens this cursor iterates.
     */
    constructor(cursor2, count) {
      super(cursor2);
      this.count = count;
    }
    /** @inheritdoc */
    moveNext() {
      if (this.count > 0) {
        this.count -= 1;
        return super.moveNext();
      }
      return false;
    }
  };
  return limitCursor;
}
var skipCursor;
var hasRequiredSkipCursor;
function requireSkipCursor() {
  if (hasRequiredSkipCursor) return skipCursor;
  hasRequiredSkipCursor = 1;
  const DecorativeCursor = requireDecorativeCursor();
  skipCursor = class SkipCursor extends DecorativeCursor {
    /**
     * Initializes this cursor.
     * @param {Cursor} cursor The cursor to be decorated.
     * @param {number} count The count of tokens this cursor skips.
     */
    constructor(cursor2, count) {
      super(cursor2);
      this.count = count;
    }
    /** @inheritdoc */
    moveNext() {
      while (this.count > 0) {
        this.count -= 1;
        if (!super.moveNext()) {
          return false;
        }
      }
      return super.moveNext();
    }
  };
  return skipCursor;
}
var cursors;
var hasRequiredCursors;
function requireCursors() {
  if (hasRequiredCursors) return cursors;
  hasRequiredCursors = 1;
  const BackwardTokenCommentCursor = requireBackwardTokenCommentCursor();
  const BackwardTokenCursor = requireBackwardTokenCursor();
  const FilterCursor = requireFilterCursor();
  const ForwardTokenCommentCursor = requireForwardTokenCommentCursor();
  const ForwardTokenCursor = requireForwardTokenCursor();
  const LimitCursor = requireLimitCursor();
  const SkipCursor = requireSkipCursor();
  class CursorFactory {
    /**
     * Initializes this cursor.
     * @param {Function} TokenCursor The class of the cursor which iterates tokens only.
     * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.
     */
    constructor(TokenCursor, TokenCommentCursor) {
      this.TokenCursor = TokenCursor;
      this.TokenCommentCursor = TokenCommentCursor;
    }
    /**
     * Creates a base cursor instance that can be decorated by createCursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     * @param {boolean} includeComments The flag to iterate comments as well.
     * @returns {Cursor} The created base cursor.
     */
    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
      const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;
      return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
    }
    /**
     * Creates a cursor that iterates tokens with normalized options.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     * @param {boolean} includeComments The flag to iterate comments as well.
     * @param {Function|null} filter The predicate function to choose tokens.
     * @param {number} skip The count of tokens the cursor skips.
     * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
     * @returns {Cursor} The created cursor.
     */
    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter2, skip, count) {
      let cursor2 = this.createBaseCursor(
        tokens,
        comments,
        indexMap,
        startLoc,
        endLoc,
        includeComments
      );
      if (filter2) {
        cursor2 = new FilterCursor(cursor2, filter2);
      }
      if (skip >= 1) {
        cursor2 = new SkipCursor(cursor2, skip);
      }
      if (count >= 0) {
        cursor2 = new LimitCursor(cursor2, count);
      }
      return cursor2;
    }
  }
  cursors = {
    forward: new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor),
    backward: new CursorFactory(
      BackwardTokenCursor,
      BackwardTokenCommentCursor
    )
  };
  return cursors;
}
var paddedTokenCursor;
var hasRequiredPaddedTokenCursor;
function requirePaddedTokenCursor() {
  if (hasRequiredPaddedTokenCursor) return paddedTokenCursor;
  hasRequiredPaddedTokenCursor = 1;
  const ForwardTokenCursor = requireForwardTokenCursor();
  paddedTokenCursor = class PaddedTokenCursor extends ForwardTokenCursor {
    /**
     * Initializes this cursor.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     * @param {Object} indexMap The map from locations to indices in `tokens`.
     * @param {number} startLoc The start location of the iteration range.
     * @param {number} endLoc The end location of the iteration range.
     * @param {number} beforeCount The number of tokens this cursor iterates before start.
     * @param {number} afterCount The number of tokens this cursor iterates after end.
     */
    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
      super(tokens, comments, indexMap, startLoc, endLoc);
      this.index = Math.max(0, this.index - beforeCount);
      this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);
    }
  };
  return paddedTokenCursor;
}
var tokenStore;
var hasRequiredTokenStore;
function requireTokenStore() {
  if (hasRequiredTokenStore) return tokenStore;
  hasRequiredTokenStore = 1;
  const { isCommentToken } = /* @__PURE__ */ requireEslintUtils();
  const assert2 = requireAssert();
  const cursors2 = requireCursors();
  const ForwardTokenCursor = requireForwardTokenCursor();
  const PaddedTokenCursor = requirePaddedTokenCursor();
  const utils2 = requireUtils$1();
  const TOKENS = Symbol("tokens");
  const COMMENTS = Symbol("comments");
  const INDEX_MAP = Symbol("indexMap");
  function createIndexMap(tokens, comments) {
    const map = /* @__PURE__ */ Object.create(null);
    let tokenIndex = 0;
    let commentIndex = 0;
    let nextStart;
    let range;
    while (tokenIndex < tokens.length || commentIndex < comments.length) {
      nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
      while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
        map[range[0]] = tokenIndex;
        map[range[1] - 1] = tokenIndex;
        tokenIndex += 1;
      }
      nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
      while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
        map[range[0]] = tokenIndex;
        map[range[1] - 1] = tokenIndex;
        commentIndex += 1;
      }
    }
    return map;
  }
  function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
    let includeComments = false;
    let skip = 0;
    let filter2 = null;
    if (typeof opts === "number") {
      skip = opts | 0;
    } else if (typeof opts === "function") {
      filter2 = opts;
    } else if (opts) {
      includeComments = !!opts.includeComments;
      skip = opts.skip | 0;
      filter2 = opts.filter || null;
    }
    assert2(skip >= 0, "options.skip should be zero or a positive integer.");
    assert2(
      !filter2 || typeof filter2 === "function",
      "options.filter should be a function."
    );
    return factory.createCursor(
      tokens,
      comments,
      indexMap,
      startLoc,
      endLoc,
      includeComments,
      filter2,
      skip,
      -1
    );
  }
  function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
    let includeComments = false;
    let count = 0;
    let countExists = false;
    let filter2 = null;
    if (typeof opts === "number") {
      count = opts | 0;
      countExists = true;
    } else if (typeof opts === "function") {
      filter2 = opts;
    } else if (opts) {
      includeComments = !!opts.includeComments;
      count = opts.count | 0;
      countExists = typeof opts.count === "number";
      filter2 = opts.filter || null;
    }
    assert2(count >= 0, "options.count should be zero or a positive integer.");
    assert2(
      !filter2 || typeof filter2 === "function",
      "options.filter should be a function."
    );
    return factory.createCursor(
      tokens,
      comments,
      indexMap,
      startLoc,
      endLoc,
      includeComments,
      filter2,
      0,
      countExists ? count : -1
    );
  }
  function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
    if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
      return new ForwardTokenCursor(
        tokens,
        comments,
        indexMap,
        startLoc,
        endLoc
      );
    }
    if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
      return new PaddedTokenCursor(
        tokens,
        comments,
        indexMap,
        startLoc,
        endLoc,
        beforeCount | 0,
        afterCount | 0
      );
    }
    return createCursorWithCount(
      cursors2.forward,
      tokens,
      comments,
      indexMap,
      startLoc,
      endLoc,
      beforeCount
    );
  }
  function getAdjacentCommentTokensFromCursor(cursor2) {
    const tokens = [];
    let currentToken = cursor2.getOneToken();
    while (currentToken && isCommentToken(currentToken)) {
      tokens.push(currentToken);
      currentToken = cursor2.getOneToken();
    }
    return tokens;
  }
  tokenStore = class TokenStore {
    /**
     * Initializes this token store.
     * @param {Token[]} tokens The array of tokens.
     * @param {Comment[]} comments The array of comments.
     */
    constructor(tokens, comments) {
      this[TOKENS] = tokens;
      this[COMMENTS] = comments;
      this[INDEX_MAP] = createIndexMap(tokens, comments);
    }
    //--------------------------------------------------------------------------
    // Gets single token.
    //--------------------------------------------------------------------------
    /**
     * Gets the token starting at the specified index.
     * @param {number} offset Index of the start of the token's range.
     * @param {Object} [options=0] The option object.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @returns {Token|null} The token starting at index, or null if no such token.
     */
    getTokenByRangeStart(offset, options) {
      const includeComments = options && options.includeComments;
      const token = cursors2.forward.createBaseCursor(
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        offset,
        -1,
        includeComments
      ).getOneToken();
      if (token && token.range[0] === offset) {
        return token;
      }
      return null;
    }
    /**
     * Gets the first token of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.skip=0] The count of tokens the cursor skips.
     * @returns {Token|null} An object representing the token.
     */
    getFirstToken(node2, options) {
      return createCursorWithSkip(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[0],
        node2.range[1],
        options
      ).getOneToken();
    }
    /**
     * Gets the last token of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getLastToken(node2, options) {
      return createCursorWithSkip(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[0],
        node2.range[1],
        options
      ).getOneToken();
    }
    /**
     * Gets the token that precedes a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getTokenBefore(node2, options) {
      return createCursorWithSkip(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        -1,
        node2.range[0],
        options
      ).getOneToken();
    }
    /**
     * Gets the token that follows a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getTokenAfter(node2, options) {
      return createCursorWithSkip(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[1],
        -1,
        options
      ).getOneToken();
    }
    /**
     * Gets the first token between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getFirstTokenBetween(left, right, options) {
      return createCursorWithSkip(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        left.range[1],
        right.range[0],
        options
      ).getOneToken();
    }
    /**
     * Gets the last token between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
     * @returns {Token|null} An object representing the token.
     */
    getLastTokenBetween(left, right, options) {
      return createCursorWithSkip(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        left.range[1],
        right.range[0],
        options
      ).getOneToken();
    }
    /**
     * Gets the token that precedes a given node or token in the token stream.
     * This is defined for backward compatibility. Use `includeComments` option instead.
     * TODO: We have a plan to remove this in a future major version.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number} [skip=0] A number of tokens to skip.
     * @returns {Token|null} An object representing the token.
     * @deprecated
     */
    getTokenOrCommentBefore(node2, skip) {
      return this.getTokenBefore(node2, { includeComments: true, skip });
    }
    /**
     * Gets the token that follows a given node or token in the token stream.
     * This is defined for backward compatibility. Use `includeComments` option instead.
     * TODO: We have a plan to remove this in a future major version.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number} [skip=0] A number of tokens to skip.
     * @returns {Token|null} An object representing the token.
     * @deprecated
     */
    getTokenOrCommentAfter(node2, skip) {
      return this.getTokenAfter(node2, { includeComments: true, skip });
    }
    //--------------------------------------------------------------------------
    // Gets multiple tokens.
    //--------------------------------------------------------------------------
    /**
     * Gets the first `count` tokens of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
     * @returns {Token[]} Tokens.
     */
    getFirstTokens(node2, options) {
      return createCursorWithCount(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[0],
        node2.range[1],
        options
      ).getAllTokens();
    }
    /**
     * Gets the last `count` tokens of the given node.
     * @param {ASTNode} node The AST node.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens.
     */
    getLastTokens(node2, options) {
      return createCursorWithCount(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[0],
        node2.range[1],
        options
      ).getAllTokens().reverse();
    }
    /**
     * Gets the `count` tokens that precedes a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens.
     */
    getTokensBefore(node2, options) {
      return createCursorWithCount(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        -1,
        node2.range[0],
        options
      ).getAllTokens().reverse();
    }
    /**
     * Gets the `count` tokens that follows a given node or token.
     * @param {ASTNode|Token|Comment} node The AST node or token.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens.
     */
    getTokensAfter(node2, options) {
      return createCursorWithCount(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[1],
        -1,
        options
      ).getAllTokens();
    }
    /**
     * Gets the first `count` tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens between left and right.
     */
    getFirstTokensBetween(left, right, options) {
      return createCursorWithCount(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        left.range[1],
        right.range[0],
        options
      ).getAllTokens();
    }
    /**
     * Gets the last `count` tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
     * @returns {Token[]} Tokens between left and right.
     */
    getLastTokensBetween(left, right, options) {
      return createCursorWithCount(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        left.range[1],
        right.range[0],
        options
      ).getAllTokens().reverse();
    }
    /**
     * Gets all tokens that are related to the given node.
     * @param {ASTNode} node The AST node.
     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
     * @returns {Token[]} Array of objects representing tokens.
     */
    /**
     * Gets all tokens that are related to the given node.
     * @param {ASTNode} node The AST node.
     * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.
     * @param {number} [afterCount=0] The number of tokens after the node to retrieve.
     * @returns {Token[]} Array of objects representing tokens.
     */
    getTokens(node2, beforeCount, afterCount) {
      return createCursorWithPadding(
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        node2.range[0],
        node2.range[1],
        beforeCount,
        afterCount
      ).getAllTokens();
    }
    /**
     * Gets all of the tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
     * @returns {Token[]} Tokens between left and right.
     */
    /**
     * Gets all of the tokens between two non-overlapping nodes.
     * @param {ASTNode|Token|Comment} left Node before the desired token range.
     * @param {ASTNode|Token|Comment} right Node after the desired token range.
     * @param {number} [padding=0] Number of extra tokens on either side of center.
     * @returns {Token[]} Tokens between left and right.
     */
    getTokensBetween(left, right, padding) {
      return createCursorWithPadding(
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        left.range[1],
        right.range[0],
        padding,
        padding
      ).getAllTokens();
    }
    //--------------------------------------------------------------------------
    // Others.
    //--------------------------------------------------------------------------
    /**
     * Checks whether any comments exist or not between the given 2 nodes.
     * @param {ASTNode} left The node to check.
     * @param {ASTNode} right The node to check.
     * @returns {boolean} `true` if one or more comments exist.
     */
    commentsExistBetween(left, right) {
      const index = utils2.search(this[COMMENTS], left.range[1]);
      return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
    }
    /**
     * Gets all comment tokens directly before the given node or token.
     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
     * @returns {Array} An array of comments in occurrence order.
     */
    getCommentsBefore(nodeOrToken) {
      const cursor2 = createCursorWithCount(
        cursors2.backward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        -1,
        nodeOrToken.range[0],
        { includeComments: true }
      );
      return getAdjacentCommentTokensFromCursor(cursor2).reverse();
    }
    /**
     * Gets all comment tokens directly after the given node or token.
     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
     * @returns {Array} An array of comments in occurrence order.
     */
    getCommentsAfter(nodeOrToken) {
      const cursor2 = createCursorWithCount(
        cursors2.forward,
        this[TOKENS],
        this[COMMENTS],
        this[INDEX_MAP],
        nodeOrToken.range[1],
        -1,
        { includeComments: true }
      );
      return getAdjacentCommentTokensFromCursor(cursor2);
    }
    /**
     * Gets all comment tokens inside the given node.
     * @param {ASTNode} node The AST node to get the comments for.
     * @returns {Array} An array of comments in occurrence order.
     */
    getCommentsInside(node2) {
      return this.getTokens(node2, {
        includeComments: true,
        filter: isCommentToken
      });
    }
  };
  return tokenStore;
}
var astUtils$1;
var hasRequiredAstUtils$1;
function requireAstUtils$1() {
  if (hasRequiredAstUtils$1) return astUtils$1;
  hasRequiredAstUtils$1 = 1;
  const breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;
  const lineBreakPattern = /\r\n|[\r\n\u2028\u2029]/u;
  const shebangPattern = /^#!([^\r\n]+)/u;
  function createGlobalLinebreakMatcher() {
    return new RegExp(lineBreakPattern.source, "gu");
  }
  astUtils$1 = {
    breakableTypePattern,
    lineBreakPattern,
    createGlobalLinebreakMatcher,
    shebangPattern
  };
  return astUtils$1;
}
var globals;
var hasRequiredGlobals;
function requireGlobals() {
  if (hasRequiredGlobals) return globals;
  hasRequiredGlobals = 1;
  const commonjs2 = {
    exports: true,
    global: false,
    module: false,
    require: false
  };
  const es3 = {
    Array: false,
    Boolean: false,
    constructor: false,
    Date: false,
    decodeURI: false,
    decodeURIComponent: false,
    encodeURI: false,
    encodeURIComponent: false,
    Error: false,
    escape: false,
    eval: false,
    EvalError: false,
    Function: false,
    hasOwnProperty: false,
    Infinity: false,
    isFinite: false,
    isNaN: false,
    isPrototypeOf: false,
    Math: false,
    NaN: false,
    Number: false,
    Object: false,
    parseFloat: false,
    parseInt: false,
    propertyIsEnumerable: false,
    RangeError: false,
    ReferenceError: false,
    RegExp: false,
    String: false,
    SyntaxError: false,
    toLocaleString: false,
    toString: false,
    TypeError: false,
    undefined: false,
    unescape: false,
    URIError: false,
    valueOf: false
  };
  const es52 = {
    ...es3,
    JSON: false
  };
  const es20152 = {
    ...es52,
    ArrayBuffer: false,
    DataView: false,
    Float32Array: false,
    Float64Array: false,
    Int16Array: false,
    Int32Array: false,
    Int8Array: false,
    Intl: false,
    Map: false,
    Promise: false,
    Proxy: false,
    Reflect: false,
    Set: false,
    Symbol: false,
    Uint16Array: false,
    Uint32Array: false,
    Uint8Array: false,
    Uint8ClampedArray: false,
    WeakMap: false,
    WeakSet: false
  };
  const es2016 = {
    ...es20152
  };
  const es20172 = {
    ...es2016,
    Atomics: false,
    SharedArrayBuffer: false
  };
  const es2018 = {
    ...es20172
  };
  const es2019 = {
    ...es2018
  };
  const es20202 = {
    ...es2019,
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    globalThis: false
  };
  const es20212 = {
    ...es20202,
    AggregateError: false,
    FinalizationRegistry: false,
    WeakRef: false
  };
  const es2022 = {
    ...es20212
  };
  const es2023 = {
    ...es2022
  };
  const es2024 = {
    ...es2023
  };
  const es2025 = {
    ...es2024,
    Float16Array: false,
    Iterator: false
  };
  const es2026 = {
    ...es2025,
    AsyncDisposableStack: false,
    DisposableStack: false,
    SuppressedError: false
  };
  globals = {
    commonjs: commonjs2,
    es3,
    es5: es52,
    es2015: es20152,
    es2016,
    es2017: es20172,
    es2018,
    es2019,
    es2020: es20202,
    es2021: es20212,
    es2022,
    es2023,
    es2024,
    es2025,
    es2026
  };
  return globals;
}
var directives;
var hasRequiredDirectives;
function requireDirectives() {
  if (hasRequiredDirectives) return directives;
  hasRequiredDirectives = 1;
  const directivesPattern = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u;
  directives = {
    directivesPattern
  };
  return directives;
}
var debugHelpers;
var hasRequiredDebugHelpers;
function requireDebugHelpers() {
  if (hasRequiredDebugHelpers) return debugHelpers;
  hasRequiredDebugHelpers = 1;
  const debug = requireSrc()("eslint:code-path");
  function getId(segment) {
    return segment.id + (segment.reachable ? "" : "!");
  }
  function nodeToString(node2, label) {
    const suffix = label ? `:${label}` : "";
    switch (node2.type) {
      case "Identifier":
        return `${node2.type}${suffix} (${node2.name})`;
      case "Literal":
        return `${node2.type}${suffix} (${node2.value})`;
      default:
        return `${node2.type}${suffix}`;
    }
  }
  debugHelpers = {
    /**
     * A flag that debug dumping is enabled or not.
     * @type {boolean}
     */
    enabled: debug.enabled,
    /**
     * Dumps given objects.
     * @param {...any} args objects to dump.
     * @returns {void}
     */
    dump: debug,
    /**
     * Dumps the current analyzing state.
     * @param {ASTNode} node A node to dump.
     * @param {CodePathState} state A state to dump.
     * @param {boolean} leaving A flag whether or not it's leaving
     * @returns {void}
     */
    dumpState: !debug.enabled ? debug : (
      /* c8 ignore next */
      function(node2, state, leaving) {
        for (let i2 = 0; i2 < state.currentSegments.length; ++i2) {
          const segInternal = state.currentSegments[i2].internal;
          if (leaving) {
            const last = segInternal.nodes.length - 1;
            if (last >= 0 && segInternal.nodes[last] === nodeToString(node2, "enter")) {
              segInternal.nodes[last] = nodeToString(
                node2,
                void 0
              );
            } else {
              segInternal.nodes.push(nodeToString(node2, "exit"));
            }
          } else {
            segInternal.nodes.push(nodeToString(node2, "enter"));
          }
        }
        debug(
          [
            `${state.currentSegments.map(getId).join(",")})`,
            `${node2.type}${leaving ? ":exit" : ""}`
          ].join(" ")
        );
      }
    ),
    /**
     * Dumps a DOT code of a given code path.
     * The DOT code can be visualized with Graphvis.
     * @param {CodePath} codePath A code path to dump.
     * @returns {void}
     * @see http://www.graphviz.org
     * @see http://www.webgraphviz.com
     */
    dumpDot: !debug.enabled ? debug : (
      /* c8 ignore next */
      function(codePath2) {
        let text = '\ndigraph {\nnode[shape=box,style="rounded,filled",fillcolor=white];\ninitial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
        if (codePath2.returnedSegments.length > 0) {
          text += 'final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
        }
        if (codePath2.thrownSegments.length > 0) {
          text += 'thrown[label="✘",shape=circle,width=0.3,height=0.3,fixedsize=true];\n';
        }
        const traceMap = /* @__PURE__ */ Object.create(null);
        const arrows = this.makeDotArrows(codePath2, traceMap);
        for (const id2 in traceMap) {
          const segment = traceMap[id2];
          text += `${id2}[`;
          if (segment.reachable) {
            text += 'label="';
          } else {
            text += 'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n';
          }
          if (segment.internal.nodes.length > 0) {
            text += segment.internal.nodes.join("\\n");
          } else {
            text += "????";
          }
          text += '"];\n';
        }
        text += `${arrows}
`;
        text += "}";
        debug("DOT", text);
      }
    ),
    /**
     * Makes a DOT code of a given code path.
     * The DOT code can be visualized with Graphvis.
     * @param {CodePath} codePath A code path to make DOT.
     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.
     * @returns {string} A DOT code of the code path.
     */
    makeDotArrows(codePath2, traceMap) {
      const stack = [[codePath2.initialSegment, 0]];
      const done = traceMap || /* @__PURE__ */ Object.create(null);
      let lastId = codePath2.initialSegment.id;
      let text = `initial->${codePath2.initialSegment.id}`;
      while (stack.length > 0) {
        const item = stack.pop();
        const segment = item[0];
        const index = item[1];
        if (done[segment.id] && index === 0) {
          continue;
        }
        done[segment.id] = segment;
        const nextSegment = segment.allNextSegments[index];
        if (!nextSegment) {
          continue;
        }
        if (lastId === segment.id) {
          text += `->${nextSegment.id}`;
        } else {
          text += `;
${segment.id}->${nextSegment.id}`;
        }
        lastId = nextSegment.id;
        stack.unshift([segment, 1 + index]);
        stack.push([nextSegment, 0]);
      }
      codePath2.returnedSegments.forEach((finalSegment) => {
        if (lastId === finalSegment.id) {
          text += "->final";
        } else {
          text += `;
${finalSegment.id}->final`;
        }
        lastId = null;
      });
      codePath2.thrownSegments.forEach((finalSegment) => {
        if (lastId === finalSegment.id) {
          text += "->thrown";
        } else {
          text += `;
${finalSegment.id}->thrown`;
        }
        lastId = null;
      });
      return `${text};`;
    }
  };
  return debugHelpers;
}
var codePathSegment;
var hasRequiredCodePathSegment;
function requireCodePathSegment() {
  if (hasRequiredCodePathSegment) return codePathSegment;
  hasRequiredCodePathSegment = 1;
  const debug = requireDebugHelpers();
  function isReachable(segment) {
    return segment.reachable;
  }
  class CodePathSegment {
    /**
     * Creates a new instance.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     *   This array includes unreachable segments.
     * @param {boolean} reachable A flag which shows this is reachable.
     */
    constructor(id2, allPrevSegments, reachable) {
      this.id = id2;
      this.nextSegments = [];
      this.prevSegments = allPrevSegments.filter(isReachable);
      this.allNextSegments = [];
      this.allPrevSegments = allPrevSegments;
      this.reachable = reachable;
      Object.defineProperty(this, "internal", {
        value: {
          // determines if the segment has been attached to the code path
          used: false,
          // array of previous segments coming from the end of a loop
          loopedPrevSegments: []
        }
      });
      if (debug.enabled) {
        this.internal.nodes = [];
      }
    }
    /**
     * Checks a given previous segment is coming from the end of a loop.
     * @param {CodePathSegment} segment A previous segment to check.
     * @returns {boolean} `true` if the segment is coming from the end of a loop.
     */
    isLoopedPrevSegment(segment) {
      return this.internal.loopedPrevSegments.includes(segment);
    }
    /**
     * Creates the root segment.
     * @param {string} id An identifier.
     * @returns {CodePathSegment} The created segment.
     */
    static newRoot(id2) {
      return new CodePathSegment(id2, [], true);
    }
    /**
     * Creates a new segment and appends it after the given segments.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments
     *      to append to.
     * @returns {CodePathSegment} The created segment.
     */
    static newNext(id2, allPrevSegments) {
      return new CodePathSegment(
        id2,
        CodePathSegment.flattenUnusedSegments(allPrevSegments),
        allPrevSegments.some(isReachable)
      );
    }
    /**
     * Creates an unreachable segment and appends it after the given segments.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newUnreachable(id2, allPrevSegments) {
      const segment = new CodePathSegment(
        id2,
        CodePathSegment.flattenUnusedSegments(allPrevSegments),
        false
      );
      CodePathSegment.markUsed(segment);
      return segment;
    }
    /**
     * Creates a segment that follows given segments.
     * This factory method does not connect with `allPrevSegments`.
     * But this inherits `reachable` flag.
     * @param {string} id An identifier.
     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newDisconnected(id2, allPrevSegments) {
      return new CodePathSegment(id2, [], allPrevSegments.some(isReachable));
    }
    /**
     * Marks a given segment as used.
     *
     * And this function registers the segment into the previous segments as a next.
     * @param {CodePathSegment} segment A segment to mark.
     * @returns {void}
     */
    static markUsed(segment) {
      if (segment.internal.used) {
        return;
      }
      segment.internal.used = true;
      let i2;
      if (segment.reachable) {
        for (i2 = 0; i2 < segment.allPrevSegments.length; ++i2) {
          const prevSegment = segment.allPrevSegments[i2];
          prevSegment.allNextSegments.push(segment);
          prevSegment.nextSegments.push(segment);
        }
      } else {
        for (i2 = 0; i2 < segment.allPrevSegments.length; ++i2) {
          segment.allPrevSegments[i2].allNextSegments.push(segment);
        }
      }
    }
    /**
     * Marks a previous segment as looped.
     * @param {CodePathSegment} segment A segment.
     * @param {CodePathSegment} prevSegment A previous segment to mark.
     * @returns {void}
     */
    static markPrevSegmentAsLooped(segment, prevSegment) {
      segment.internal.loopedPrevSegments.push(prevSegment);
    }
    /**
     * Creates a new array based on an array of segments. If any segment in the
     * array is unused, then it is replaced by all of its previous segments.
     * All used segments are returned as-is without replacement.
     * @param {CodePathSegment[]} segments The array of segments to flatten.
     * @returns {CodePathSegment[]} The flattened array.
     */
    static flattenUnusedSegments(segments) {
      const done = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < segments.length; ++i2) {
        const segment = segments[i2];
        if (done.has(segment)) {
          continue;
        }
        if (!segment.internal.used) {
          for (let j = 0; j < segment.allPrevSegments.length; ++j) {
            const prevSegment = segment.allPrevSegments[j];
            if (!done.has(prevSegment)) {
              done.add(prevSegment);
            }
          }
        } else {
          done.add(segment);
        }
      }
      return [...done];
    }
  }
  codePathSegment = CodePathSegment;
  return codePathSegment;
}
var forkContext;
var hasRequiredForkContext;
function requireForkContext() {
  if (hasRequiredForkContext) return forkContext;
  hasRequiredForkContext = 1;
  const assert2 = requireAssert(), CodePathSegment = requireCodePathSegment();
  function isReachable(segment) {
    return segment.reachable;
  }
  function createSegments(context, startIndex, endIndex, create) {
    const list = context.segmentsList;
    const normalizedBegin = startIndex >= 0 ? startIndex : list.length + startIndex;
    const normalizedEnd = endIndex >= 0 ? endIndex : list.length + endIndex;
    const segments = [];
    for (let i2 = 0; i2 < context.count; ++i2) {
      const allPrevSegments = [];
      for (let j = normalizedBegin; j <= normalizedEnd; ++j) {
        allPrevSegments.push(list[j][i2]);
      }
      segments.push(create(context.idGenerator.next(), allPrevSegments));
    }
    return segments;
  }
  function mergeExtraSegments(context, segments) {
    let currentSegments = segments;
    while (currentSegments.length > context.count) {
      const merged = [];
      for (let i2 = 0, length = Math.floor(currentSegments.length / 2); i2 < length; ++i2) {
        merged.push(
          CodePathSegment.newNext(context.idGenerator.next(), [
            currentSegments[i2],
            currentSegments[i2 + length]
          ])
        );
      }
      currentSegments = merged;
    }
    return currentSegments;
  }
  class ForkContext {
    /**
     * Creates a new instance.
     * @param {IdGenerator} idGenerator An identifier generator for segments.
     * @param {ForkContext|null} upper The preceding fork context.
     * @param {number} count The number of parallel segments in each element
     *      of `segmentsList`.
     */
    constructor(idGenerator2, upper, count) {
      this.idGenerator = idGenerator2;
      this.upper = upper;
      this.count = count;
      this.segmentsList = [];
    }
    /**
     * The segments that begin this fork context.
     * @type {Array<CodePathSegment>}
     */
    get head() {
      const list = this.segmentsList;
      return list.length === 0 ? [] : list.at(-1);
    }
    /**
     * Indicates if the context contains no segments.
     * @type {boolean}
     */
    get empty() {
      return this.segmentsList.length === 0;
    }
    /**
     * Indicates if there are any segments that are reachable.
     * @type {boolean}
     */
    get reachable() {
      const segments = this.head;
      return segments.length > 0 && segments.some(isReachable);
    }
    /**
     * Creates new segments in this context and appends them to the end of the
     * already existing `CodePathSegment`s specified by `startIndex` and
     * `endIndex`.
     * @param {number} startIndex The index of the first segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @param {number} endIndex The index of the last segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @returns {Array<CodePathSegment>} An array of the newly created segments.
     */
    makeNext(startIndex, endIndex) {
      return createSegments(
        this,
        startIndex,
        endIndex,
        CodePathSegment.newNext
      );
    }
    /**
     * Creates new unreachable segments in this context and appends them to the end of the
     * already existing `CodePathSegment`s specified by `startIndex` and
     * `endIndex`.
     * @param {number} startIndex The index of the first segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @param {number} endIndex The index of the last segment in the context
     *      that should be specified as previous segments for the newly created segments.
     * @returns {Array<CodePathSegment>} An array of the newly created segments.
     */
    makeUnreachable(startIndex, endIndex) {
      return createSegments(
        this,
        startIndex,
        endIndex,
        CodePathSegment.newUnreachable
      );
    }
    /**
     * Creates new segments in this context and does not append them to the end
     *  of the already existing `CodePathSegment`s specified by `startIndex` and
     * `endIndex`. The `startIndex` and `endIndex` are only used to determine if
     * the new segments should be reachable. If any of the segments in this range
     * are reachable then the new segments are also reachable; otherwise, the new
     * segments are unreachable.
     * @param {number} startIndex The index of the first segment in the context
     *      that should be considered for reachability.
     * @param {number} endIndex The index of the last segment in the context
     *      that should be considered for reachability.
     * @returns {Array<CodePathSegment>} An array of the newly created segments.
     */
    makeDisconnected(startIndex, endIndex) {
      return createSegments(
        this,
        startIndex,
        endIndex,
        CodePathSegment.newDisconnected
      );
    }
    /**
     * Adds segments to the head of this context.
     * @param {Array<CodePathSegment>} segments The segments to add.
     * @returns {void}
     */
    add(segments) {
      assert2(
        segments.length >= this.count,
        `${segments.length} >= ${this.count}`
      );
      this.segmentsList.push(mergeExtraSegments(this, segments));
    }
    /**
     * Replaces the head segments with the given segments.
     * The current head segments are removed.
     * @param {Array<CodePathSegment>} replacementHeadSegments The new head segments.
     * @returns {void}
     */
    replaceHead(replacementHeadSegments) {
      assert2(
        replacementHeadSegments.length >= this.count,
        `${replacementHeadSegments.length} >= ${this.count}`
      );
      this.segmentsList.splice(
        -1,
        1,
        mergeExtraSegments(this, replacementHeadSegments)
      );
    }
    /**
     * Adds all segments of a given fork context into this context.
     * @param {ForkContext} otherForkContext The fork context to add from.
     * @returns {void}
     */
    addAll(otherForkContext) {
      assert2(otherForkContext.count === this.count);
      this.segmentsList.push(...otherForkContext.segmentsList);
    }
    /**
     * Clears all segments in this context.
     * @returns {void}
     */
    clear() {
      this.segmentsList = [];
    }
    /**
     * Creates a new root context, meaning that there are no parent
     * fork contexts.
     * @param {IdGenerator} idGenerator An identifier generator for segments.
     * @returns {ForkContext} New fork context.
     */
    static newRoot(idGenerator2) {
      const context = new ForkContext(idGenerator2, null, 1);
      context.add([CodePathSegment.newRoot(idGenerator2.next())]);
      return context;
    }
    /**
     * Creates an empty fork context preceded by a given context.
     * @param {ForkContext} parentContext The parent fork context.
     * @param {boolean} shouldForkLeavingPath Indicates that we are inside of
     *      a `finally` block and should therefore fork the path that leaves
     *      `finally`.
     * @returns {ForkContext} New fork context.
     */
    static newEmpty(parentContext, shouldForkLeavingPath) {
      return new ForkContext(
        parentContext.idGenerator,
        parentContext,
        (shouldForkLeavingPath ? 2 : 1) * parentContext.count
      );
    }
  }
  forkContext = ForkContext;
  return forkContext;
}
var codePathState;
var hasRequiredCodePathState;
function requireCodePathState() {
  if (hasRequiredCodePathState) return codePathState;
  hasRequiredCodePathState = 1;
  const CodePathSegment = requireCodePathSegment(), ForkContext = requireForkContext();
  class BreakContext {
    /**
     * Creates a new instance.
     * @param {BreakContext} upperContext The previous `BreakContext`.
     * @param {boolean} breakable Indicates if we are inside a statement where
     *      `break` without a label will exit the statement.
     * @param {string|null} label The label for the statement.
     * @param {ForkContext} forkContext The current fork context.
     */
    constructor(upperContext, breakable, label, forkContext2) {
      this.upper = upperContext;
      this.breakable = breakable;
      this.label = label;
      this.brokenForkContext = ForkContext.newEmpty(forkContext2);
    }
  }
  class ChainContext {
    /**
     * Creates a new instance.
     * @param {ChainContext} upperContext The previous `ChainContext`.
     */
    constructor(upperContext) {
      this.upper = upperContext;
      this.choiceContextCount = 0;
    }
  }
  class ChoiceContext {
    /**
     * Creates a new instance.
     * @param {ChoiceContext} upperContext The previous `ChoiceContext`.
     * @param {string} kind The kind of choice. If it's a logical or assignment expression, this
     *      is `"&&"` or `"||"` or `"??"`; if it's an `if` statement or
     *      conditional expression, this is `"test"`; otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult Indicates if the result of the choice
     *      creates a fork.
     * @param {ForkContext} forkContext The containing `ForkContext`.
     */
    constructor(upperContext, kind, isForkingAsResult, forkContext2) {
      this.upper = upperContext;
      this.kind = kind;
      this.isForkingAsResult = isForkingAsResult;
      this.trueForkContext = ForkContext.newEmpty(forkContext2);
      this.falseForkContext = ForkContext.newEmpty(forkContext2);
      this.nullishForkContext = ForkContext.newEmpty(forkContext2);
      this.processed = false;
    }
  }
  class LoopContextBase {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string} type The AST node's `type` for the loop.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, type2, label, breakContext) {
      this.upper = upperContext;
      this.type = type2;
      this.label = label;
      this.brokenForkContext = breakContext.brokenForkContext;
    }
  }
  class WhileLoopContext extends LoopContextBase {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
      super(upperContext, "WhileStatement", label, breakContext);
      this.test = void 0;
      this.continueDestSegments = null;
    }
  }
  class DoWhileLoopContext extends LoopContextBase {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     * @param {ForkContext} forkContext The enclosing fork context.
     */
    constructor(upperContext, label, breakContext, forkContext2) {
      super(upperContext, "DoWhileStatement", label, breakContext);
      this.test = void 0;
      this.entrySegments = null;
      this.continueForkContext = ForkContext.newEmpty(forkContext2);
    }
  }
  class ForLoopContext extends LoopContextBase {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
      super(upperContext, "ForStatement", label, breakContext);
      this.test = void 0;
      this.endOfInitSegments = null;
      this.testSegments = null;
      this.endOfTestSegments = null;
      this.updateSegments = null;
      this.endOfUpdateSegments = null;
      this.continueDestSegments = null;
    }
  }
  class ForInLoopContext extends LoopContextBase {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
      super(upperContext, "ForInStatement", label, breakContext);
      this.prevSegments = null;
      this.leftSegments = null;
      this.endOfLeftSegments = null;
      this.continueDestSegments = null;
    }
  }
  class ForOfLoopContext extends LoopContextBase {
    /**
     * Creates a new instance.
     * @param {LoopContext|null} upperContext The previous `LoopContext`.
     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.
     * @param {BreakContext} breakContext The context for breaking the loop.
     */
    constructor(upperContext, label, breakContext) {
      super(upperContext, "ForOfStatement", label, breakContext);
      this.prevSegments = null;
      this.leftSegments = null;
      this.endOfLeftSegments = null;
      this.continueDestSegments = null;
    }
  }
  class SwitchContext {
    /**
     * Creates a new instance.
     * @param {SwitchContext} upperContext The previous context.
     * @param {boolean} hasCase Indicates if there is at least one `case` statement.
     *      `default` doesn't count.
     */
    constructor(upperContext, hasCase) {
      this.upper = upperContext;
      this.hasCase = hasCase;
      this.defaultSegments = null;
      this.defaultBodySegments = null;
      this.foundEmptyDefault = false;
      this.lastIsDefault = false;
      this.forkCount = 0;
    }
  }
  class TryContext {
    /**
     * Creates a new instance.
     * @param {TryContext} upperContext The previous context.
     * @param {boolean} hasFinalizer Indicates if the `try` statement has a
     *      `finally` block.
     * @param {ForkContext} forkContext The enclosing fork context.
     */
    constructor(upperContext, hasFinalizer, forkContext2) {
      this.upper = upperContext;
      this.hasFinalizer = hasFinalizer;
      this.position = "try";
      this.returnedForkContext = hasFinalizer ? ForkContext.newEmpty(forkContext2) : null;
      this.thrownForkContext = ForkContext.newEmpty(forkContext2);
      this.lastOfTryIsReachable = false;
      this.lastOfCatchIsReachable = false;
    }
  }
  function addToReturnedOrThrown(dest, others, all, segments) {
    for (let i2 = 0; i2 < segments.length; ++i2) {
      const segment = segments[i2];
      dest.push(segment);
      if (!others.includes(segment)) {
        all.push(segment);
      }
    }
  }
  function getContinueContext(state, label) {
    if (!label) {
      return state.loopContext;
    }
    let context = state.loopContext;
    while (context) {
      if (context.label === label) {
        return context;
      }
      context = context.upper;
    }
    return null;
  }
  function getBreakContext(state, label) {
    let context = state.breakContext;
    while (context) {
      if (label ? context.label === label : context.breakable) {
        return context;
      }
      context = context.upper;
    }
    return null;
  }
  function getReturnContext(state) {
    let context = state.tryContext;
    while (context) {
      if (context.hasFinalizer && context.position !== "finally") {
        return context;
      }
      context = context.upper;
    }
    return state;
  }
  function getThrowContext(state) {
    let context = state.tryContext;
    while (context) {
      if (context.position === "try" || context.hasFinalizer && context.position === "catch") {
        return context;
      }
      context = context.upper;
    }
    return state;
  }
  function removeFromArray(elements, value) {
    elements.splice(elements.indexOf(value), 1);
  }
  function disconnectSegments(prevSegments, nextSegments) {
    for (let i2 = 0; i2 < prevSegments.length; ++i2) {
      const prevSegment = prevSegments[i2];
      const nextSegment = nextSegments[i2];
      removeFromArray(prevSegment.nextSegments, nextSegment);
      removeFromArray(prevSegment.allNextSegments, nextSegment);
      removeFromArray(nextSegment.prevSegments, prevSegment);
      removeFromArray(nextSegment.allPrevSegments, prevSegment);
    }
  }
  function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
    const fromSegments = CodePathSegment.flattenUnusedSegments(
      unflattenedFromSegments
    );
    const toSegments = CodePathSegment.flattenUnusedSegments(
      unflattenedToSegments
    );
    const end = Math.min(fromSegments.length, toSegments.length);
    for (let i2 = 0; i2 < end; ++i2) {
      const fromSegment = fromSegments[i2];
      const toSegment = toSegments[i2];
      if (toSegment.reachable) {
        fromSegment.nextSegments.push(toSegment);
      }
      if (fromSegment.reachable) {
        toSegment.prevSegments.push(fromSegment);
      }
      fromSegment.allNextSegments.push(toSegment);
      toSegment.allPrevSegments.push(fromSegment);
      if (toSegment.allPrevSegments.length >= 2) {
        CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
      }
      state.notifyLooped(fromSegment, toSegment);
    }
  }
  function finalizeTestSegmentsOfFor(context, choiceContext, head) {
    if (!choiceContext.processed) {
      choiceContext.trueForkContext.add(head);
      choiceContext.falseForkContext.add(head);
      choiceContext.nullishForkContext.add(head);
    }
    if (context.test !== true) {
      context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }
    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
  }
  class CodePathState {
    /**
     * Creates a new instance.
     * @param {IdGenerator} idGenerator An id generator to generate id for code
     *   path segments.
     * @param {Function} onLooped A callback function to notify looping.
     */
    constructor(idGenerator2, onLooped) {
      this.idGenerator = idGenerator2;
      this.notifyLooped = onLooped;
      this.forkContext = ForkContext.newRoot(idGenerator2);
      this.choiceContext = null;
      this.switchContext = null;
      this.tryContext = null;
      this.loopContext = null;
      this.breakContext = null;
      this.chainContext = null;
      this.currentSegments = [];
      this.initialSegment = this.forkContext.head[0];
      this.finalSegments = [];
      this.returnedForkContext = [];
      this.thrownForkContext = [];
      const final = this.finalSegments;
      const returned = this.returnedForkContext;
      const thrown = this.thrownForkContext;
      returned.add = addToReturnedOrThrown.bind(
        null,
        returned,
        thrown,
        final
      );
      thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
    }
    /**
     * A passthrough property exposing the current pointer as part of the API.
     * @type {CodePathSegment[]}
     */
    get headSegments() {
      return this.forkContext.head;
    }
    /**
     * The parent forking context.
     * This is used for the root of new forks.
     * @type {ForkContext}
     */
    get parentForkContext() {
      const current = this.forkContext;
      return current && current.upper;
    }
    /**
     * Creates and stacks new forking context.
     * @param {boolean} forkLeavingPath A flag which shows being in a
     *   "finally" block.
     * @returns {ForkContext} The created context.
     */
    pushForkContext(forkLeavingPath) {
      this.forkContext = ForkContext.newEmpty(
        this.forkContext,
        forkLeavingPath
      );
      return this.forkContext;
    }
    /**
     * Pops and merges the last forking context.
     * @returns {ForkContext} The last context.
     */
    popForkContext() {
      const lastContext = this.forkContext;
      this.forkContext = lastContext.upper;
      this.forkContext.replaceHead(lastContext.makeNext(0, -1));
      return lastContext;
    }
    /**
     * Creates a new path.
     * @returns {void}
     */
    forkPath() {
      this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    }
    /**
     * Creates a bypass path.
     * This is used for such as IfStatement which does not have "else" chunk.
     * @returns {void}
     */
    forkBypassPath() {
      this.forkContext.add(this.parentForkContext.head);
    }
    //--------------------------------------------------------------------------
    // ConditionalExpression, LogicalExpression, IfStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),
     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
     *
     * LogicalExpressions have cases that it goes different paths between the
     * `true` case and the `false` case.
     *
     * For Example:
     *
     *     if (a || b) {
     *         foo();
     *     } else {
     *         bar();
     *     }
     *
     * In this case, `b` is evaluated always in the code path of the `else`
     * block, but it's not so in the code path of the `if` block.
     * So there are 3 paths.
     *
     *     a -> foo();
     *     a -> b -> foo();
     *     a -> b -> bar();
     * @param {string} kind A kind string.
     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `"&&"` or `"||"` or `"??"`.
     *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
     *   Otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult Indicates if the result of the choice
     *      creates a fork.
     * @returns {void}
     */
    pushChoiceContext(kind, isForkingAsResult) {
      this.choiceContext = new ChoiceContext(
        this.choiceContext,
        kind,
        isForkingAsResult,
        this.forkContext
      );
    }
    /**
     * Pops the last choice context and finalizes it.
     * This is called upon leaving a node that represents a choice.
     * @throws {Error} (Unreachable.)
     * @returns {ChoiceContext} The popped context.
     */
    popChoiceContext() {
      const poppedChoiceContext = this.choiceContext;
      const forkContext2 = this.forkContext;
      const head = forkContext2.head;
      this.choiceContext = poppedChoiceContext.upper;
      switch (poppedChoiceContext.kind) {
        case "&&":
        case "||":
        case "??":
          if (!poppedChoiceContext.processed) {
            poppedChoiceContext.trueForkContext.add(head);
            poppedChoiceContext.falseForkContext.add(head);
            poppedChoiceContext.nullishForkContext.add(head);
          }
          if (poppedChoiceContext.isForkingAsResult) {
            const parentContext = this.choiceContext;
            parentContext.trueForkContext.addAll(
              poppedChoiceContext.trueForkContext
            );
            parentContext.falseForkContext.addAll(
              poppedChoiceContext.falseForkContext
            );
            parentContext.nullishForkContext.addAll(
              poppedChoiceContext.nullishForkContext
            );
            parentContext.processed = true;
            return poppedChoiceContext;
          }
          break;
        case "test":
          if (!poppedChoiceContext.processed) {
            poppedChoiceContext.trueForkContext.clear();
            poppedChoiceContext.trueForkContext.add(head);
          } else {
            poppedChoiceContext.falseForkContext.clear();
            poppedChoiceContext.falseForkContext.add(head);
          }
          break;
        case "loop":
          return poppedChoiceContext;
        default:
          throw new Error("unreachable");
      }
      const combinedForkContext = poppedChoiceContext.trueForkContext;
      combinedForkContext.addAll(poppedChoiceContext.falseForkContext);
      forkContext2.replaceHead(combinedForkContext.makeNext(0, -1));
      return poppedChoiceContext;
    }
    /**
     * Creates a code path segment to represent right-hand operand of a logical
     * expression.
     * This is called in the preprocessing phase when entering a node.
     * @throws {Error} (Unreachable.)
     * @returns {void}
     */
    makeLogicalRight() {
      const currentChoiceContext = this.choiceContext;
      const forkContext2 = this.forkContext;
      if (currentChoiceContext.processed) {
        let prevForkContext;
        switch (currentChoiceContext.kind) {
          case "&&":
            prevForkContext = currentChoiceContext.trueForkContext;
            break;
          case "||":
            prevForkContext = currentChoiceContext.falseForkContext;
            break;
          case "??":
            prevForkContext = currentChoiceContext.nullishForkContext;
            break;
          default:
            throw new Error("unreachable");
        }
        forkContext2.replaceHead(prevForkContext.makeNext(0, -1));
        prevForkContext.clear();
        currentChoiceContext.processed = false;
      } else {
        switch (currentChoiceContext.kind) {
          case "&&":
            currentChoiceContext.falseForkContext.add(forkContext2.head);
            currentChoiceContext.nullishForkContext.add(
              forkContext2.head
            );
            break;
          case "||":
            currentChoiceContext.trueForkContext.add(forkContext2.head);
            break;
          case "??":
            currentChoiceContext.trueForkContext.add(forkContext2.head);
            currentChoiceContext.falseForkContext.add(forkContext2.head);
            break;
          default:
            throw new Error("unreachable");
        }
        forkContext2.replaceHead(forkContext2.makeNext(-1, -1));
      }
    }
    /**
     * Makes a code path segment of the `if` block.
     * @returns {void}
     */
    makeIfConsequent() {
      const context = this.choiceContext;
      const forkContext2 = this.forkContext;
      if (!context.processed) {
        context.trueForkContext.add(forkContext2.head);
        context.falseForkContext.add(forkContext2.head);
        context.nullishForkContext.add(forkContext2.head);
      }
      context.processed = false;
      forkContext2.replaceHead(context.trueForkContext.makeNext(0, -1));
    }
    /**
     * Makes a code path segment of the `else` block.
     * @returns {void}
     */
    makeIfAlternate() {
      const context = this.choiceContext;
      const forkContext2 = this.forkContext;
      context.trueForkContext.clear();
      context.trueForkContext.add(forkContext2.head);
      context.processed = true;
      forkContext2.replaceHead(context.falseForkContext.makeNext(0, -1));
    }
    //--------------------------------------------------------------------------
    // ChainExpression
    //--------------------------------------------------------------------------
    /**
     * Pushes a new `ChainExpression` context to the stack. This method is
     * called when entering a `ChainExpression` node. A chain context is used to
     * count forking in the optional chain then merge them on the exiting from the
     * `ChainExpression` node.
     * @returns {void}
     */
    pushChainContext() {
      this.chainContext = new ChainContext(this.chainContext);
    }
    /**
     * Pop a `ChainExpression` context from the stack. This method is called on
     * exiting from each `ChainExpression` node. This merges all forks of the
     * last optional chaining.
     * @returns {void}
     */
    popChainContext() {
      const context = this.chainContext;
      this.chainContext = context.upper;
      for (let i2 = context.choiceContextCount; i2 > 0; --i2) {
        this.popChoiceContext();
      }
    }
    /**
     * Create a choice context for optional access.
     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.
     * This creates a choice context as similar to `LogicalExpression[operator="??"]` node.
     * @returns {void}
     */
    makeOptionalNode() {
      if (this.chainContext) {
        this.chainContext.choiceContextCount += 1;
        this.pushChoiceContext("??", false);
      }
    }
    /**
     * Create a fork.
     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.
     * @returns {void}
     */
    makeOptionalRight() {
      if (this.chainContext) {
        this.makeLogicalRight();
      }
    }
    //--------------------------------------------------------------------------
    // SwitchStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of SwitchStatement and stacks it.
     * @param {boolean} hasCase `true` if the switch statement has one or more
     *   case parts.
     * @param {string|null} label The label text.
     * @returns {void}
     */
    pushSwitchContext(hasCase, label) {
      this.switchContext = new SwitchContext(this.switchContext, hasCase);
      this.pushBreakContext(true, label);
    }
    /**
     * Pops the last context of SwitchStatement and finalizes it.
     *
     * - Disposes all forking stack for `case` and `default`.
     * - Creates the next code path segment from `context.brokenForkContext`.
     * - If the last `SwitchCase` node is not a `default` part, creates a path
     *   to the `default` body.
     * @returns {void}
     */
    popSwitchContext() {
      const context = this.switchContext;
      this.switchContext = context.upper;
      const forkContext2 = this.forkContext;
      const brokenForkContext = this.popBreakContext().brokenForkContext;
      if (context.forkCount === 0) {
        if (!brokenForkContext.empty) {
          brokenForkContext.add(forkContext2.makeNext(-1, -1));
          forkContext2.replaceHead(brokenForkContext.makeNext(0, -1));
        }
        return;
      }
      const lastSegments = forkContext2.head;
      this.forkBypassPath();
      const lastCaseSegments = forkContext2.head;
      brokenForkContext.add(lastSegments);
      if (!context.lastIsDefault) {
        if (context.defaultBodySegments) {
          disconnectSegments(
            context.defaultSegments,
            context.defaultBodySegments
          );
          makeLooped(this, lastCaseSegments, context.defaultBodySegments);
        } else {
          brokenForkContext.add(lastCaseSegments);
        }
      }
      for (let i2 = 0; i2 < context.forkCount; ++i2) {
        this.forkContext = this.forkContext.upper;
      }
      this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    }
    /**
     * Makes a code path segment for a `SwitchCase` node.
     * @param {boolean} isCaseBodyEmpty `true` if the body is empty.
     * @param {boolean} isDefaultCase `true` if the body is the default case.
     * @returns {void}
     */
    makeSwitchCaseBody(isCaseBodyEmpty, isDefaultCase) {
      const context = this.switchContext;
      if (!context.hasCase) {
        return;
      }
      const parentForkContext = this.forkContext;
      const forkContext2 = this.pushForkContext();
      forkContext2.add(parentForkContext.makeNext(0, -1));
      if (isDefaultCase) {
        context.defaultSegments = parentForkContext.head;
        if (isCaseBodyEmpty) {
          context.foundEmptyDefault = true;
        } else {
          context.defaultBodySegments = forkContext2.head;
        }
      } else {
        if (!isCaseBodyEmpty && context.foundEmptyDefault) {
          context.foundEmptyDefault = false;
          context.defaultBodySegments = forkContext2.head;
        }
      }
      context.lastIsDefault = isDefaultCase;
      context.forkCount += 1;
    }
    //--------------------------------------------------------------------------
    // TryStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of TryStatement and stacks it.
     * @param {boolean} hasFinalizer `true` if the try statement has a
     *   `finally` block.
     * @returns {void}
     */
    pushTryContext(hasFinalizer) {
      this.tryContext = new TryContext(
        this.tryContext,
        hasFinalizer,
        this.forkContext
      );
    }
    /**
     * Pops the last context of TryStatement and finalizes it.
     * @returns {void}
     */
    popTryContext() {
      const context = this.tryContext;
      this.tryContext = context.upper;
      if (context.position === "catch") {
        this.popForkContext();
        return;
      }
      const originalReturnedForkContext = context.returnedForkContext;
      const originalThrownForkContext = context.thrownForkContext;
      if (originalReturnedForkContext.empty && originalThrownForkContext.empty) {
        return;
      }
      const headSegments = this.forkContext.head;
      this.forkContext = this.forkContext.upper;
      const normalSegments = headSegments.slice(
        0,
        headSegments.length / 2 | 0
      );
      const leavingSegments = headSegments.slice(
        headSegments.length / 2 | 0
      );
      if (!originalReturnedForkContext.empty) {
        getReturnContext(this).returnedForkContext.add(leavingSegments);
      }
      if (!originalThrownForkContext.empty) {
        getThrowContext(this).thrownForkContext.add(leavingSegments);
      }
      this.forkContext.replaceHead(normalSegments);
      if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
        this.forkContext.makeUnreachable();
      }
    }
    /**
     * Makes a code path segment for a `catch` block.
     * @returns {void}
     */
    makeCatchBlock() {
      const context = this.tryContext;
      const forkContext2 = this.forkContext;
      const originalThrownForkContext = context.thrownForkContext;
      context.position = "catch";
      context.thrownForkContext = ForkContext.newEmpty(forkContext2);
      context.lastOfTryIsReachable = forkContext2.reachable;
      originalThrownForkContext.add(forkContext2.head);
      const thrownSegments = originalThrownForkContext.makeNext(0, -1);
      this.pushForkContext();
      this.forkBypassPath();
      this.forkContext.add(thrownSegments);
    }
    /**
     * Makes a code path segment for a `finally` block.
     *
     * In the `finally` block, parallel paths are created. The parallel paths
     * are used as leaving-paths. The leaving-paths are paths from `return`
     * statements and `throw` statements in a `try` block or a `catch` block.
     * @returns {void}
     */
    makeFinallyBlock() {
      const context = this.tryContext;
      let forkContext2 = this.forkContext;
      const originalReturnedForkContext = context.returnedForkContext;
      const originalThrownForContext = context.thrownForkContext;
      const headOfLeavingSegments = forkContext2.head;
      if (context.position === "catch") {
        this.popForkContext();
        forkContext2 = this.forkContext;
        context.lastOfCatchIsReachable = forkContext2.reachable;
      } else {
        context.lastOfTryIsReachable = forkContext2.reachable;
      }
      context.position = "finally";
      if (originalReturnedForkContext.empty && originalThrownForContext.empty) {
        return;
      }
      const segments = forkContext2.makeNext(-1, -1);
      for (let i2 = 0; i2 < forkContext2.count; ++i2) {
        const prevSegsOfLeavingSegment = [headOfLeavingSegments[i2]];
        for (let j = 0; j < originalReturnedForkContext.segmentsList.length; ++j) {
          prevSegsOfLeavingSegment.push(
            originalReturnedForkContext.segmentsList[j][i2]
          );
        }
        for (let j = 0; j < originalThrownForContext.segmentsList.length; ++j) {
          prevSegsOfLeavingSegment.push(
            originalThrownForContext.segmentsList[j][i2]
          );
        }
        segments.push(
          CodePathSegment.newNext(
            this.idGenerator.next(),
            prevSegsOfLeavingSegment
          )
        );
      }
      this.pushForkContext(true);
      this.forkContext.add(segments);
    }
    /**
     * Makes a code path segment from the first throwable node to the `catch`
     * block or the `finally` block.
     * @returns {void}
     */
    makeFirstThrowablePathInTryBlock() {
      const forkContext2 = this.forkContext;
      if (!forkContext2.reachable) {
        return;
      }
      const context = getThrowContext(this);
      if (context === this || context.position !== "try" || !context.thrownForkContext.empty) {
        return;
      }
      context.thrownForkContext.add(forkContext2.head);
      forkContext2.replaceHead(forkContext2.makeNext(-1, -1));
    }
    //--------------------------------------------------------------------------
    // Loop Statements
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of a loop statement and stacks it.
     * @param {string} type The type of the node which was triggered. One of
     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
     *   and `ForStatement`.
     * @param {string|null} label A label of the node which was triggered.
     * @throws {Error} (Unreachable - unknown type.)
     * @returns {void}
     */
    pushLoopContext(type2, label) {
      const forkContext2 = this.forkContext;
      const breakContext = this.pushBreakContext(true, label);
      switch (type2) {
        case "WhileStatement":
          this.pushChoiceContext("loop", false);
          this.loopContext = new WhileLoopContext(
            this.loopContext,
            label,
            breakContext
          );
          break;
        case "DoWhileStatement":
          this.pushChoiceContext("loop", false);
          this.loopContext = new DoWhileLoopContext(
            this.loopContext,
            label,
            breakContext,
            forkContext2
          );
          break;
        case "ForStatement":
          this.pushChoiceContext("loop", false);
          this.loopContext = new ForLoopContext(
            this.loopContext,
            label,
            breakContext
          );
          break;
        case "ForInStatement":
          this.loopContext = new ForInLoopContext(
            this.loopContext,
            label,
            breakContext
          );
          break;
        case "ForOfStatement":
          this.loopContext = new ForOfLoopContext(
            this.loopContext,
            label,
            breakContext
          );
          break;
        default:
          throw new Error(`unknown type: "${type2}"`);
      }
    }
    /**
     * Pops the last context of a loop statement and finalizes it.
     * @throws {Error} (Unreachable - unknown type.)
     * @returns {void}
     */
    popLoopContext() {
      const context = this.loopContext;
      this.loopContext = context.upper;
      const forkContext2 = this.forkContext;
      const brokenForkContext = this.popBreakContext().brokenForkContext;
      switch (context.type) {
        case "WhileStatement":
        case "ForStatement":
          this.popChoiceContext();
          makeLooped(
            this,
            forkContext2.head,
            context.continueDestSegments
          );
          break;
        case "DoWhileStatement": {
          const choiceContext = this.popChoiceContext();
          if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext2.head);
            choiceContext.falseForkContext.add(forkContext2.head);
          }
          if (context.test !== true) {
            brokenForkContext.addAll(choiceContext.falseForkContext);
          }
          const segmentsList = choiceContext.trueForkContext.segmentsList;
          for (let i2 = 0; i2 < segmentsList.length; ++i2) {
            makeLooped(this, segmentsList[i2], context.entrySegments);
          }
          break;
        }
        case "ForInStatement":
        case "ForOfStatement":
          brokenForkContext.add(forkContext2.head);
          makeLooped(this, forkContext2.head, context.leftSegments);
          break;
        default:
          throw new Error("unreachable");
      }
      if (brokenForkContext.empty) {
        forkContext2.replaceHead(forkContext2.makeUnreachable(-1, -1));
      } else {
        forkContext2.replaceHead(brokenForkContext.makeNext(0, -1));
      }
    }
    /**
     * Makes a code path segment for the test part of a WhileStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeWhileTest(test) {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      const testSegments = forkContext2.makeNext(0, -1);
      context.test = test;
      context.continueDestSegments = testSegments;
      forkContext2.replaceHead(testSegments);
    }
    /**
     * Makes a code path segment for the body part of a WhileStatement.
     * @returns {void}
     */
    makeWhileBody() {
      const context = this.loopContext;
      const choiceContext = this.choiceContext;
      const forkContext2 = this.forkContext;
      if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(forkContext2.head);
        choiceContext.falseForkContext.add(forkContext2.head);
      }
      if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
      }
      forkContext2.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
    }
    /**
     * Makes a code path segment for the body part of a DoWhileStatement.
     * @returns {void}
     */
    makeDoWhileBody() {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      const bodySegments = forkContext2.makeNext(-1, -1);
      context.entrySegments = bodySegments;
      forkContext2.replaceHead(bodySegments);
    }
    /**
     * Makes a code path segment for the test part of a DoWhileStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeDoWhileTest(test) {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      context.test = test;
      if (!context.continueForkContext.empty) {
        context.continueForkContext.add(forkContext2.head);
        const testSegments = context.continueForkContext.makeNext(0, -1);
        forkContext2.replaceHead(testSegments);
      }
    }
    /**
     * Makes a code path segment for the test part of a ForStatement.
     * @param {boolean|undefined} test The test value (only when constant).
     * @returns {void}
     */
    makeForTest(test) {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      const endOfInitSegments = forkContext2.head;
      const testSegments = forkContext2.makeNext(-1, -1);
      context.test = test;
      context.endOfInitSegments = endOfInitSegments;
      context.continueDestSegments = context.testSegments = testSegments;
      forkContext2.replaceHead(testSegments);
    }
    /**
     * Makes a code path segment for the update part of a ForStatement.
     * @returns {void}
     */
    makeForUpdate() {
      const context = this.loopContext;
      const choiceContext = this.choiceContext;
      const forkContext2 = this.forkContext;
      if (context.testSegments) {
        finalizeTestSegmentsOfFor(context, choiceContext, forkContext2.head);
      } else {
        context.endOfInitSegments = forkContext2.head;
      }
      const updateSegments = forkContext2.makeDisconnected(-1, -1);
      context.continueDestSegments = context.updateSegments = updateSegments;
      forkContext2.replaceHead(updateSegments);
    }
    /**
     * Makes a code path segment for the body part of a ForStatement.
     * @returns {void}
     */
    makeForBody() {
      const context = this.loopContext;
      const choiceContext = this.choiceContext;
      const forkContext2 = this.forkContext;
      if (context.updateSegments) {
        context.endOfUpdateSegments = forkContext2.head;
        if (context.testSegments) {
          makeLooped(
            this,
            context.endOfUpdateSegments,
            context.testSegments
          );
        }
      } else if (context.testSegments) {
        finalizeTestSegmentsOfFor(context, choiceContext, forkContext2.head);
      } else {
        context.endOfInitSegments = forkContext2.head;
      }
      let bodySegments = context.endOfTestSegments;
      if (!bodySegments) {
        const prevForkContext = ForkContext.newEmpty(forkContext2);
        prevForkContext.add(context.endOfInitSegments);
        if (context.endOfUpdateSegments) {
          prevForkContext.add(context.endOfUpdateSegments);
        }
        bodySegments = prevForkContext.makeNext(0, -1);
      }
      context.continueDestSegments = context.continueDestSegments || bodySegments;
      forkContext2.replaceHead(bodySegments);
    }
    /**
     * Makes a code path segment for the left part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfLeft() {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      const leftSegments = forkContext2.makeDisconnected(-1, -1);
      context.prevSegments = forkContext2.head;
      context.leftSegments = context.continueDestSegments = leftSegments;
      forkContext2.replaceHead(leftSegments);
    }
    /**
     * Makes a code path segment for the right part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfRight() {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      const temp = ForkContext.newEmpty(forkContext2);
      temp.add(context.prevSegments);
      const rightSegments = temp.makeNext(-1, -1);
      context.endOfLeftSegments = forkContext2.head;
      forkContext2.replaceHead(rightSegments);
    }
    /**
     * Makes a code path segment for the body part of a ForInStatement and a
     * ForOfStatement.
     * @returns {void}
     */
    makeForInOfBody() {
      const context = this.loopContext;
      const forkContext2 = this.forkContext;
      const temp = ForkContext.newEmpty(forkContext2);
      temp.add(context.endOfLeftSegments);
      const bodySegments = temp.makeNext(-1, -1);
      makeLooped(this, forkContext2.head, context.leftSegments);
      context.brokenForkContext.add(forkContext2.head);
      forkContext2.replaceHead(bodySegments);
    }
    //--------------------------------------------------------------------------
    // Control Statements
    //--------------------------------------------------------------------------
    /**
     * Creates new context in which a `break` statement can be used. This occurs inside of a loop,
     * labeled statement, or switch statement.
     * @param {boolean} breakable Indicates if we are inside a statement where
     *      `break` without a label will exit the statement.
     * @param {string|null} label The label associated with the statement.
     * @returns {BreakContext} The new context.
     */
    pushBreakContext(breakable, label) {
      this.breakContext = new BreakContext(
        this.breakContext,
        breakable,
        label,
        this.forkContext
      );
      return this.breakContext;
    }
    /**
     * Removes the top item of the break context stack.
     * @returns {Object} The removed context.
     */
    popBreakContext() {
      const context = this.breakContext;
      const forkContext2 = this.forkContext;
      this.breakContext = context.upper;
      if (!context.breakable) {
        const brokenForkContext = context.brokenForkContext;
        if (!brokenForkContext.empty) {
          brokenForkContext.add(forkContext2.head);
          forkContext2.replaceHead(brokenForkContext.makeNext(0, -1));
        }
      }
      return context;
    }
    /**
     * Makes a path for a `break` statement.
     *
     * It registers the head segment to a context of `break`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @param {string|null} label A label of the break statement.
     * @returns {void}
     */
    makeBreak(label) {
      const forkContext2 = this.forkContext;
      if (!forkContext2.reachable) {
        return;
      }
      const context = getBreakContext(this, label);
      if (context) {
        context.brokenForkContext.add(forkContext2.head);
      }
      forkContext2.replaceHead(forkContext2.makeUnreachable(-1, -1));
    }
    /**
     * Makes a path for a `continue` statement.
     *
     * It makes a looping path.
     * It makes new unreachable segment, then it set the head with the segment.
     * @param {string|null} label A label of the continue statement.
     * @returns {void}
     */
    makeContinue(label) {
      const forkContext2 = this.forkContext;
      if (!forkContext2.reachable) {
        return;
      }
      const context = getContinueContext(this, label);
      if (context) {
        if (context.continueDestSegments) {
          makeLooped(
            this,
            forkContext2.head,
            context.continueDestSegments
          );
          if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
            context.brokenForkContext.add(forkContext2.head);
          }
        } else {
          context.continueForkContext.add(forkContext2.head);
        }
      }
      forkContext2.replaceHead(forkContext2.makeUnreachable(-1, -1));
    }
    /**
     * Makes a path for a `return` statement.
     *
     * It registers the head segment to a context of `return`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @returns {void}
     */
    makeReturn() {
      const forkContext2 = this.forkContext;
      if (forkContext2.reachable) {
        getReturnContext(this).returnedForkContext.add(forkContext2.head);
        forkContext2.replaceHead(forkContext2.makeUnreachable(-1, -1));
      }
    }
    /**
     * Makes a path for a `throw` statement.
     *
     * It registers the head segment to a context of `throw`.
     * It makes new unreachable segment, then it set the head with the segment.
     * @returns {void}
     */
    makeThrow() {
      const forkContext2 = this.forkContext;
      if (forkContext2.reachable) {
        getThrowContext(this).thrownForkContext.add(forkContext2.head);
        forkContext2.replaceHead(forkContext2.makeUnreachable(-1, -1));
      }
    }
    /**
     * Makes the final path.
     * @returns {void}
     */
    makeFinal() {
      const segments = this.currentSegments;
      if (segments.length > 0 && segments[0].reachable) {
        this.returnedForkContext.add(segments);
      }
    }
  }
  codePathState = CodePathState;
  return codePathState;
}
var idGenerator;
var hasRequiredIdGenerator;
function requireIdGenerator() {
  if (hasRequiredIdGenerator) return idGenerator;
  hasRequiredIdGenerator = 1;
  class IdGenerator {
    /**
     * @param {string} prefix Optional. A prefix of generated ids.
     */
    constructor(prefix) {
      this.prefix = String(prefix);
      this.n = 0;
    }
    /**
     * Generates id.
     * @returns {string} A generated id.
     */
    next() {
      this.n = 1 + this.n | 0;
      if (this.n < 0) {
        this.n = 1;
      }
      return this.prefix + this.n;
    }
  }
  idGenerator = IdGenerator;
  return idGenerator;
}
var codePath;
var hasRequiredCodePath;
function requireCodePath() {
  if (hasRequiredCodePath) return codePath;
  hasRequiredCodePath = 1;
  const CodePathState = requireCodePathState();
  const IdGenerator = requireIdGenerator();
  class CodePath {
    /**
     * Creates a new instance.
     * @param {Object} options Options for the function (see below).
     * @param {string} options.id An identifier.
     * @param {string} options.origin The type of code path origin.
     * @param {CodePath|null} options.upper The code path of the upper function scope.
     * @param {Function} options.onLooped A callback function to notify looping.
     */
    constructor({ id: id2, origin, upper, onLooped }) {
      this.id = id2;
      this.origin = origin;
      this.upper = upper;
      this.childCodePaths = [];
      Object.defineProperty(this, "internal", {
        value: new CodePathState(new IdGenerator(`${id2}_`), onLooped)
      });
      if (upper) {
        upper.childCodePaths.push(this);
      }
    }
    /**
     * Gets the state of a given code path.
     * @param {CodePath} codePath A code path to get.
     * @returns {CodePathState} The state of the code path.
     */
    static getState(codePath2) {
      return codePath2.internal;
    }
    /**
     * The initial code path segment. This is the segment that is at the head
     * of the code path.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment}
     */
    get initialSegment() {
      return this.internal.initialSegment;
    }
    /**
     * Final code path segments. These are the terminal (tail) segments in the
     * code path, which is the combination of `returnedSegments` and `thrownSegments`.
     * All segments in this array are reachable.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment[]}
     */
    get finalSegments() {
      return this.internal.finalSegments;
    }
    /**
     * Final code path segments that represent normal completion of the code path.
     * For functions, this means both explicit `return` statements and implicit returns,
     * such as the last reachable segment in a function that does not have an
     * explicit `return` as this implicitly returns `undefined`. For scripts,
     * modules, class field initializers, and class static blocks, this means
     * all lines of code have been executed.
     * These segments are also present in `finalSegments`.
     * This is a passthrough to the underlying `CodePathState`.
     * @type {CodePathSegment[]}
     */
    get returnedSegments() {
      return this.internal.returnedForkContext;
    }
    /**
     * Final code path segments that represent `throw` statements.
     * This is a passthrough to the underlying `CodePathState`.
     * These segments are also present in `finalSegments`.
     * @type {CodePathSegment[]}
     */
    get thrownSegments() {
      return this.internal.thrownForkContext;
    }
    /**
     * Traverses all segments in this code path.
     *
     *     codePath.traverseSegments((segment, controller) => {
     *         // do something.
     *     });
     *
     * This method enumerates segments in order from the head.
     *
     * The `controller` argument has two methods:
     *
     * - `skip()` - skips the following segments in this branch
     * - `break()` - skips all following segments in the traversal
     *
     * A note on the parameters: the `options` argument is optional. This means
     * the first argument might be an options object or the callback function.
     * @param {Object} [optionsOrCallback] Optional first and last segments to traverse.
     * @param {CodePathSegment} [optionsOrCallback.first] The first segment to traverse.
     * @param {CodePathSegment} [optionsOrCallback.last] The last segment to traverse.
     * @param {Function} callback A callback function.
     * @returns {void}
     */
    traverseSegments(optionsOrCallback, callback) {
      let resolvedOptions;
      let resolvedCallback;
      if (typeof optionsOrCallback === "function") {
        resolvedCallback = optionsOrCallback;
        resolvedOptions = {};
      } else {
        resolvedOptions = optionsOrCallback || {};
        resolvedCallback = callback;
      }
      const startSegment = resolvedOptions.first || this.internal.initialSegment;
      const lastSegment = resolvedOptions.last;
      let record;
      let index;
      let end;
      let segment = null;
      const visited = /* @__PURE__ */ new Set();
      const stack = [[startSegment, 0]];
      const skipped = /* @__PURE__ */ new Set();
      let broken = false;
      const controller = {
        /**
         * Skip the following segments in this branch.
         * @returns {void}
         */
        skip() {
          skipped.add(segment);
        },
        /**
         * Stop traversal completely - do not traverse to any
         * other segments.
         * @returns {void}
         */
        break() {
          broken = true;
        }
      };
      function isVisited(prevSegment) {
        return visited.has(prevSegment) || segment.isLoopedPrevSegment(prevSegment);
      }
      function isSkipped(prevSegment) {
        return skipped.has(prevSegment) || segment.isLoopedPrevSegment(prevSegment);
      }
      while (stack.length > 0) {
        record = stack.at(-1);
        segment = record[0];
        index = record[1];
        if (index === 0) {
          if (visited.has(segment)) {
            stack.pop();
            continue;
          }
          if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
            stack.pop();
            continue;
          }
          visited.add(segment);
          const shouldSkip = skipped.size > 0 && segment.prevSegments.length > 0 && segment.prevSegments.every(isSkipped);
          if (!shouldSkip) {
            resolvedCallback.call(this, segment, controller);
            if (segment === lastSegment) {
              controller.skip();
            }
            if (broken) {
              break;
            }
          } else {
            skipped.add(segment);
          }
        }
        end = segment.nextSegments.length - 1;
        if (index < end) {
          record[1] += 1;
          stack.push([segment.nextSegments[index], 0]);
        } else if (index === end) {
          record[0] = segment.nextSegments[index];
          record[1] = 0;
        } else {
          stack.pop();
        }
      }
    }
  }
  codePath = CodePath;
  return codePath;
}
var codePathAnalyzer;
var hasRequiredCodePathAnalyzer;
function requireCodePathAnalyzer() {
  if (hasRequiredCodePathAnalyzer) return codePathAnalyzer;
  hasRequiredCodePathAnalyzer = 1;
  const assert2 = requireAssert(), { breakableTypePattern } = requireAstUtils$1(), CodePath = requireCodePath(), CodePathSegment = requireCodePathSegment(), IdGenerator = requireIdGenerator(), debug = requireDebugHelpers();
  function isCaseNode(node2) {
    return Boolean(node2.test);
  }
  function isPropertyDefinitionValue(node2) {
    const parent = node2.parent;
    return parent && parent.type === "PropertyDefinition" && parent.value === node2;
  }
  function isHandledLogicalOperator(operator2) {
    return operator2 === "&&" || operator2 === "||" || operator2 === "??";
  }
  function isLogicalAssignmentOperator(operator2) {
    return operator2 === "&&=" || operator2 === "||=" || operator2 === "??=";
  }
  function getLabel(node2) {
    if (node2.parent.type === "LabeledStatement") {
      return node2.parent.label.name;
    }
    return null;
  }
  function isForkingByTrueOrFalse(node2) {
    const parent = node2.parent;
    switch (parent.type) {
      case "ConditionalExpression":
      case "IfStatement":
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
        return parent.test === node2;
      case "LogicalExpression":
        return isHandledLogicalOperator(parent.operator);
      case "AssignmentExpression":
        return isLogicalAssignmentOperator(parent.operator);
      default:
        return false;
    }
  }
  function getBooleanValueIfSimpleConstant(node2) {
    if (node2.type === "Literal") {
      return Boolean(node2.value);
    }
    return void 0;
  }
  function isIdentifierReference(node2) {
    const parent = node2.parent;
    switch (parent.type) {
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "ArrayPattern":
      case "RestElement":
      case "ImportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "CatchClause":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "ClassDeclaration":
      case "ClassExpression":
      case "VariableDeclarator":
        return parent.id !== node2;
      case "Property":
      case "PropertyDefinition":
      case "MethodDefinition":
        return parent.key !== node2 || parent.computed || parent.shorthand;
      case "AssignmentPattern":
        return parent.key !== node2;
      default:
        return true;
    }
  }
  function forwardCurrentToHead(analyzer, node2) {
    const codePath2 = analyzer.codePath;
    const state = CodePath.getState(codePath2);
    const currentSegments = state.currentSegments;
    const headSegments = state.headSegments;
    const end = Math.max(currentSegments.length, headSegments.length);
    let i2, currentSegment, headSegment;
    for (i2 = 0; i2 < end; ++i2) {
      currentSegment = currentSegments[i2];
      headSegment = headSegments[i2];
      if (currentSegment !== headSegment && currentSegment) {
        const eventName = currentSegment.reachable ? "onCodePathSegmentEnd" : "onUnreachableCodePathSegmentEnd";
        debug.dump(`${eventName} ${currentSegment.id}`);
        analyzer.emit(eventName, [currentSegment, node2]);
      }
    }
    state.currentSegments = headSegments;
    for (i2 = 0; i2 < end; ++i2) {
      currentSegment = currentSegments[i2];
      headSegment = headSegments[i2];
      if (currentSegment !== headSegment && headSegment) {
        const eventName = headSegment.reachable ? "onCodePathSegmentStart" : "onUnreachableCodePathSegmentStart";
        debug.dump(`${eventName} ${headSegment.id}`);
        CodePathSegment.markUsed(headSegment);
        analyzer.emit(eventName, [headSegment, node2]);
      }
    }
  }
  function leaveFromCurrentSegment(analyzer, node2) {
    const state = CodePath.getState(analyzer.codePath);
    const currentSegments = state.currentSegments;
    for (let i2 = 0; i2 < currentSegments.length; ++i2) {
      const currentSegment = currentSegments[i2];
      const eventName = currentSegment.reachable ? "onCodePathSegmentEnd" : "onUnreachableCodePathSegmentEnd";
      debug.dump(`${eventName} ${currentSegment.id}`);
      analyzer.emit(eventName, [currentSegment, node2]);
    }
    state.currentSegments = [];
  }
  function preprocess(analyzer, node2) {
    const codePath2 = analyzer.codePath;
    const state = CodePath.getState(codePath2);
    const parent = node2.parent;
    switch (parent.type) {
      case "CallExpression":
        if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node2) {
          state.makeOptionalRight();
        }
        break;
      case "MemberExpression":
        if (parent.optional === true && parent.property === node2) {
          state.makeOptionalRight();
        }
        break;
      case "LogicalExpression":
        if (parent.right === node2 && isHandledLogicalOperator(parent.operator)) {
          state.makeLogicalRight();
        }
        break;
      case "AssignmentExpression":
        if (parent.right === node2 && isLogicalAssignmentOperator(parent.operator)) {
          state.makeLogicalRight();
        }
        break;
      case "ConditionalExpression":
      case "IfStatement":
        if (parent.consequent === node2) {
          state.makeIfConsequent();
        } else if (parent.alternate === node2) {
          state.makeIfAlternate();
        }
        break;
      case "SwitchCase":
        if (parent.consequent[0] === node2) {
          state.makeSwitchCaseBody(false, !parent.test);
        }
        break;
      case "TryStatement":
        if (parent.handler === node2) {
          state.makeCatchBlock();
        } else if (parent.finalizer === node2) {
          state.makeFinallyBlock();
        }
        break;
      case "WhileStatement":
        if (parent.test === node2) {
          state.makeWhileTest(getBooleanValueIfSimpleConstant(node2));
        } else {
          assert2(parent.body === node2);
          state.makeWhileBody();
        }
        break;
      case "DoWhileStatement":
        if (parent.body === node2) {
          state.makeDoWhileBody();
        } else {
          assert2(parent.test === node2);
          state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node2));
        }
        break;
      case "ForStatement":
        if (parent.test === node2) {
          state.makeForTest(getBooleanValueIfSimpleConstant(node2));
        } else if (parent.update === node2) {
          state.makeForUpdate();
        } else if (parent.body === node2) {
          state.makeForBody();
        }
        break;
      case "ForInStatement":
      case "ForOfStatement":
        if (parent.left === node2) {
          state.makeForInOfLeft();
        } else if (parent.right === node2) {
          state.makeForInOfRight();
        } else {
          assert2(parent.body === node2);
          state.makeForInOfBody();
        }
        break;
      case "AssignmentPattern":
        if (parent.right === node2) {
          state.pushForkContext();
          state.forkBypassPath();
          state.forkPath();
        }
        break;
    }
  }
  function processCodePathToEnter(analyzer, node2) {
    let codePath2 = analyzer.codePath;
    let state = codePath2 && CodePath.getState(codePath2);
    const parent = node2.parent;
    function startCodePath(origin) {
      if (codePath2) {
        forwardCurrentToHead(analyzer, node2);
        debug.dumpState(node2, state, false);
      }
      codePath2 = analyzer.codePath = new CodePath({
        id: analyzer.idGenerator.next(),
        origin,
        upper: codePath2,
        onLooped: analyzer.onLooped
      });
      state = CodePath.getState(codePath2);
      debug.dump(`onCodePathStart ${codePath2.id}`);
      analyzer.emit("onCodePathStart", [codePath2, node2]);
    }
    if (isPropertyDefinitionValue(node2)) {
      startCodePath("class-field-initializer");
    }
    switch (node2.type) {
      case "Program":
        startCodePath("program");
        break;
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
        startCodePath("function");
        break;
      case "StaticBlock":
        startCodePath("class-static-block");
        break;
      case "ChainExpression":
        state.pushChainContext();
        break;
      case "CallExpression":
        if (node2.optional === true) {
          state.makeOptionalNode();
        }
        break;
      case "MemberExpression":
        if (node2.optional === true) {
          state.makeOptionalNode();
        }
        break;
      case "LogicalExpression":
        if (isHandledLogicalOperator(node2.operator)) {
          state.pushChoiceContext(
            node2.operator,
            isForkingByTrueOrFalse(node2)
          );
        }
        break;
      case "AssignmentExpression":
        if (isLogicalAssignmentOperator(node2.operator)) {
          state.pushChoiceContext(
            node2.operator.slice(0, -1),
            // removes `=` from the end
            isForkingByTrueOrFalse(node2)
          );
        }
        break;
      case "ConditionalExpression":
      case "IfStatement":
        state.pushChoiceContext("test", false);
        break;
      case "SwitchStatement":
        state.pushSwitchContext(
          node2.cases.some(isCaseNode),
          getLabel(node2)
        );
        break;
      case "TryStatement":
        state.pushTryContext(Boolean(node2.finalizer));
        break;
      case "SwitchCase":
        if (parent.discriminant !== node2 && parent.cases[0] !== node2) {
          state.forkPath();
        }
        break;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
        state.pushLoopContext(node2.type, getLabel(node2));
        break;
      case "LabeledStatement":
        if (!breakableTypePattern.test(node2.body.type)) {
          state.pushBreakContext(false, node2.label.name);
        }
        break;
    }
    forwardCurrentToHead(analyzer, node2);
    debug.dumpState(node2, state, false);
  }
  function processCodePathToExit(analyzer, node2) {
    const codePath2 = analyzer.codePath;
    const state = CodePath.getState(codePath2);
    let dontForward = false;
    switch (node2.type) {
      case "ChainExpression":
        state.popChainContext();
        break;
      case "IfStatement":
      case "ConditionalExpression":
        state.popChoiceContext();
        break;
      case "LogicalExpression":
        if (isHandledLogicalOperator(node2.operator)) {
          state.popChoiceContext();
        }
        break;
      case "AssignmentExpression":
        if (isLogicalAssignmentOperator(node2.operator)) {
          state.popChoiceContext();
        }
        break;
      case "SwitchStatement":
        state.popSwitchContext();
        break;
      case "SwitchCase":
        if (node2.consequent.length === 0) {
          state.makeSwitchCaseBody(true, !node2.test);
        }
        if (state.forkContext.reachable) {
          dontForward = true;
        }
        break;
      case "TryStatement":
        state.popTryContext();
        break;
      case "BreakStatement":
        forwardCurrentToHead(analyzer, node2);
        state.makeBreak(node2.label && node2.label.name);
        dontForward = true;
        break;
      case "ContinueStatement":
        forwardCurrentToHead(analyzer, node2);
        state.makeContinue(node2.label && node2.label.name);
        dontForward = true;
        break;
      case "ReturnStatement":
        forwardCurrentToHead(analyzer, node2);
        state.makeReturn();
        dontForward = true;
        break;
      case "ThrowStatement":
        forwardCurrentToHead(analyzer, node2);
        state.makeThrow();
        dontForward = true;
        break;
      case "Identifier":
        if (isIdentifierReference(node2)) {
          state.makeFirstThrowablePathInTryBlock();
          dontForward = true;
        }
        break;
      case "CallExpression":
      case "ImportExpression":
      case "MemberExpression":
      case "NewExpression":
      case "YieldExpression":
        state.makeFirstThrowablePathInTryBlock();
        break;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
        state.popLoopContext();
        break;
      case "AssignmentPattern":
        state.popForkContext();
        break;
      case "LabeledStatement":
        if (!breakableTypePattern.test(node2.body.type)) {
          state.popBreakContext();
        }
        break;
    }
    if (!dontForward) {
      forwardCurrentToHead(analyzer, node2);
    }
    debug.dumpState(node2, state, true);
  }
  function postprocess(analyzer, node2) {
    function endCodePath() {
      let codePath2 = analyzer.codePath;
      CodePath.getState(codePath2).makeFinal();
      leaveFromCurrentSegment(analyzer, node2);
      debug.dump(`onCodePathEnd ${codePath2.id}`);
      analyzer.emit("onCodePathEnd", [codePath2, node2]);
      debug.dumpDot(codePath2);
      codePath2 = analyzer.codePath = analyzer.codePath.upper;
      if (codePath2) {
        debug.dumpState(node2, CodePath.getState(codePath2), true);
      }
    }
    switch (node2.type) {
      case "Program":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "StaticBlock": {
        endCodePath();
        break;
      }
      case "CallExpression":
        if (node2.optional === true && node2.arguments.length === 0) {
          CodePath.getState(analyzer.codePath).makeOptionalRight();
        }
        break;
    }
    if (isPropertyDefinitionValue(node2)) {
      endCodePath();
    }
  }
  class CodePathAnalyzer {
    /**
     * @param {EventGenerator} eventGenerator An event generator to wrap.
     */
    constructor(eventGenerator) {
      this.original = eventGenerator;
      this.emit = eventGenerator.emit;
      this.codePath = null;
      this.idGenerator = new IdGenerator("s");
      this.currentNode = null;
      this.onLooped = this.onLooped.bind(this);
    }
    /**
     * Does the process to enter a given AST node.
     * This updates state of analysis and calls `enterNode` of the wrapped.
     * @param {ASTNode} node A node which is entering.
     * @returns {void}
     */
    enterNode(node2) {
      this.currentNode = node2;
      if (node2.parent) {
        preprocess(this, node2);
      }
      processCodePathToEnter(this, node2);
      this.original.enterNode(node2);
      this.currentNode = null;
    }
    /**
     * Does the process to leave a given AST node.
     * This updates state of analysis and calls `leaveNode` of the wrapped.
     * @param {ASTNode} node A node which is leaving.
     * @returns {void}
     */
    leaveNode(node2) {
      this.currentNode = node2;
      processCodePathToExit(this, node2);
      this.original.leaveNode(node2);
      postprocess(this, node2);
      this.currentNode = null;
    }
    /**
     * This is called on a code path looped.
     * Then this raises a looped event.
     * @param {CodePathSegment} fromSegment A segment of prev.
     * @param {CodePathSegment} toSegment A segment of next.
     * @returns {void}
     */
    onLooped(fromSegment, toSegment) {
      if (fromSegment.reachable && toSegment.reachable) {
        debug.dump(
          `onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`
        );
        this.emit("onCodePathSegmentLoop", [
          fromSegment,
          toSegment,
          this.currentNode
        ]);
      }
    }
  }
  codePathAnalyzer = CodePathAnalyzer;
  return codePathAnalyzer;
}
var cjs$2 = {};
var lib$2 = { exports: {} };
var parseString = { exports: {} };
var Func;
var hasRequiredFunc;
function requireFunc() {
  if (hasRequiredFunc) return Func;
  hasRequiredFunc = 1;
  var apply, curry, flip, fix, over, memoize, toString$ = {}.toString;
  apply = curry$(function(f2, list) {
    return f2.apply(null, list);
  });
  curry = function(f2) {
    return curry$(f2);
  };
  flip = curry$(function(f2, x2, y2) {
    return f2(y2, x2);
  });
  fix = function(f2) {
    return /* @__PURE__ */ function(g2) {
      return function() {
        return f2(g2(g2)).apply(null, arguments);
      };
    }(function(g2) {
      return function() {
        return f2(g2(g2)).apply(null, arguments);
      };
    });
  };
  over = curry$(function(f2, g2, x2, y2) {
    return f2(g2(x2), g2(y2));
  });
  memoize = function(f2) {
    var memo;
    memo = {};
    return function() {
      var args, res$, i$, to$, key, arg;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      args = res$;
      key = function() {
        var i$2, ref$, len$, results$ = [];
        for (i$2 = 0, len$ = (ref$ = args).length; i$2 < len$; ++i$2) {
          arg = ref$[i$2];
          results$.push(arg + toString$.call(arg).slice(8, -1));
        }
        return results$;
      }().join("");
      return memo[key] = key in memo ? memo[key] : f2.apply(null, args);
    };
  };
  Func = {
    curry,
    flip,
    fix,
    apply,
    over,
    memoize
  };
  function curry$(f2, bound) {
    var context, _curry = function(args) {
      return f2.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context = this;
        return params.push.apply(params, arguments) < f2.length && arguments.length ? _curry.call(context, params) : f2.apply(context, params);
      } : f2;
    };
    return _curry();
  }
  return Func;
}
var List;
var hasRequiredList;
function requireList() {
  if (hasRequiredList) return List;
  hasRequiredList = 1;
  var each, map, compact, filter2, reject, remove2, partition, find2, head, first, tail, last, initial, empty2, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap2, flatten2, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString;
  each = curry$(function(f2, xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      f2(x2);
    }
    return xs;
  });
  map = curry$(function(f2, xs) {
    var i$, len$, x2, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      results$.push(f2(x2));
    }
    return results$;
  });
  compact = function(xs) {
    var i$, len$, x2, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (x2) {
        results$.push(x2);
      }
    }
    return results$;
  };
  filter2 = curry$(function(f2, xs) {
    var i$, len$, x2, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (f2(x2)) {
        results$.push(x2);
      }
    }
    return results$;
  });
  reject = curry$(function(f2, xs) {
    var i$, len$, x2, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (!f2(x2)) {
        results$.push(x2);
      }
    }
    return results$;
  });
  remove2 = curry$(function(el, xs) {
    var i2, x$;
    i2 = elemIndex(el, xs);
    x$ = xs.slice();
    if (i2 != null) {
      x$.splice(i2, 1);
    }
    return x$;
  });
  partition = curry$(function(f2, xs) {
    var passed, failed, i$, len$, x2;
    passed = [];
    failed = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      (f2(x2) ? passed : failed).push(x2);
    }
    return [passed, failed];
  });
  find2 = curry$(function(f2, xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (f2(x2)) {
        return x2;
      }
    }
  });
  head = first = function(xs) {
    return xs[0];
  };
  tail = function(xs) {
    if (!xs.length) {
      return;
    }
    return xs.slice(1);
  };
  last = function(xs) {
    return xs[xs.length - 1];
  };
  initial = function(xs) {
    if (!xs.length) {
      return;
    }
    return xs.slice(0, -1);
  };
  empty2 = function(xs) {
    return !xs.length;
  };
  reverse = function(xs) {
    return xs.concat().reverse();
  };
  unique = function(xs) {
    var result, i$, len$, x2;
    result = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (!in$(x2, result)) {
        result.push(x2);
      }
    }
    return result;
  };
  uniqueBy = curry$(function(f2, xs) {
    var seen, i$, len$, x2, val, results$ = [];
    seen = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      val = f2(x2);
      if (in$(val, seen)) {
        continue;
      }
      seen.push(val);
      results$.push(x2);
    }
    return results$;
  });
  fold = foldl = curry$(function(f2, memo, xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      memo = f2(memo, x2);
    }
    return memo;
  });
  fold1 = foldl1 = curry$(function(f2, xs) {
    return fold(f2, xs[0], xs.slice(1));
  });
  foldr = curry$(function(f2, memo, xs) {
    var i$, x2;
    for (i$ = xs.length - 1; i$ >= 0; --i$) {
      x2 = xs[i$];
      memo = f2(x2, memo);
    }
    return memo;
  });
  foldr1 = curry$(function(f2, xs) {
    return foldr(f2, xs[xs.length - 1], xs.slice(0, -1));
  });
  unfoldr = curry$(function(f2, b) {
    var result, x2, that;
    result = [];
    x2 = b;
    while ((that = f2(x2)) != null) {
      result.push(that[0]);
      x2 = that[1];
    }
    return result;
  });
  concat = function(xss) {
    return [].concat.apply([], xss);
  };
  concatMap2 = curry$(function(f2, xs) {
    var x2;
    return [].concat.apply([], function() {
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x2 = ref$[i$];
        results$.push(f2(x2));
      }
      return results$;
    }());
  });
  flatten2 = function(xs) {
    var x2;
    return [].concat.apply([], function() {
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x2 = ref$[i$];
        if (toString$.call(x2).slice(8, -1) === "Array") {
          results$.push(flatten2(x2));
        } else {
          results$.push(x2);
        }
      }
      return results$;
    }());
  };
  difference = function(xs) {
    var yss, res$, i$, to$, results, len$, x2, j$, len1$, ys;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    yss = res$;
    results = [];
    outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
        ys = yss[j$];
        if (in$(x2, ys)) {
          continue outer;
        }
      }
      results.push(x2);
    }
    return results;
  };
  intersection = function(xs) {
    var yss, res$, i$, to$, results, len$, x2, j$, len1$, ys;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    yss = res$;
    results = [];
    outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
        ys = yss[j$];
        if (!in$(x2, ys)) {
          continue outer;
        }
      }
      results.push(x2);
    }
    return results;
  };
  union = function() {
    var xss, res$, i$, to$, results, len$, xs, j$, len1$, x2;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    results = [];
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
        x2 = xs[j$];
        if (!in$(x2, results)) {
          results.push(x2);
        }
      }
    }
    return results;
  };
  countBy = curry$(function(f2, xs) {
    var results, i$, len$, x2, key;
    results = {};
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      key = f2(x2);
      if (key in results) {
        results[key] += 1;
      } else {
        results[key] = 1;
      }
    }
    return results;
  });
  groupBy = curry$(function(f2, xs) {
    var results, i$, len$, x2, key;
    results = {};
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      key = f2(x2);
      if (key in results) {
        results[key].push(x2);
      } else {
        results[key] = [x2];
      }
    }
    return results;
  });
  andList = function(xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (!x2) {
        return false;
      }
    }
    return true;
  };
  orList = function(xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (x2) {
        return true;
      }
    }
    return false;
  };
  any = curry$(function(f2, xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (f2(x2)) {
        return true;
      }
    }
    return false;
  });
  all = curry$(function(f2, xs) {
    var i$, len$, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      if (!f2(x2)) {
        return false;
      }
    }
    return true;
  });
  sort = function(xs) {
    return xs.concat().sort(function(x2, y2) {
      if (x2 > y2) {
        return 1;
      } else if (x2 < y2) {
        return -1;
      } else {
        return 0;
      }
    });
  };
  sortWith = curry$(function(f2, xs) {
    return xs.concat().sort(f2);
  });
  sortBy = curry$(function(f2, xs) {
    return xs.concat().sort(function(x2, y2) {
      if (f2(x2) > f2(y2)) {
        return 1;
      } else if (f2(x2) < f2(y2)) {
        return -1;
      } else {
        return 0;
      }
    });
  });
  sum = function(xs) {
    var result, i$, len$, x2;
    result = 0;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      result += x2;
    }
    return result;
  };
  product = function(xs) {
    var result, i$, len$, x2;
    result = 1;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      result *= x2;
    }
    return result;
  };
  mean = average = function(xs) {
    var sum2, i$, len$, x2;
    sum2 = 0;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x2 = xs[i$];
      sum2 += x2;
    }
    return sum2 / xs.length;
  };
  maximum = function(xs) {
    var max, i$, ref$, len$, x2;
    max = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x2 = ref$[i$];
      if (x2 > max) {
        max = x2;
      }
    }
    return max;
  };
  minimum = function(xs) {
    var min, i$, ref$, len$, x2;
    min = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x2 = ref$[i$];
      if (x2 < min) {
        min = x2;
      }
    }
    return min;
  };
  maximumBy = curry$(function(f2, xs) {
    var max, i$, ref$, len$, x2;
    max = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x2 = ref$[i$];
      if (f2(x2) > f2(max)) {
        max = x2;
      }
    }
    return max;
  });
  minimumBy = curry$(function(f2, xs) {
    var min, i$, ref$, len$, x2;
    min = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x2 = ref$[i$];
      if (f2(x2) < f2(min)) {
        min = x2;
      }
    }
    return min;
  });
  scan = scanl = curry$(function(f2, memo, xs) {
    var last2, x2;
    last2 = memo;
    return [memo].concat(function() {
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x2 = ref$[i$];
        results$.push(last2 = f2(last2, x2));
      }
      return results$;
    }());
  });
  scan1 = scanl1 = curry$(function(f2, xs) {
    if (!xs.length) {
      return;
    }
    return scan(f2, xs[0], xs.slice(1));
  });
  scanr = curry$(function(f2, memo, xs) {
    xs = xs.concat().reverse();
    return scan(f2, memo, xs).reverse();
  });
  scanr1 = curry$(function(f2, xs) {
    if (!xs.length) {
      return;
    }
    xs = xs.concat().reverse();
    return scan(f2, xs[0], xs.slice(1)).reverse();
  });
  slice = curry$(function(x2, y2, xs) {
    return xs.slice(x2, y2);
  });
  take = curry$(function(n2, xs) {
    if (n2 <= 0) {
      return xs.slice(0, 0);
    } else {
      return xs.slice(0, n2);
    }
  });
  drop = curry$(function(n2, xs) {
    if (n2 <= 0) {
      return xs;
    } else {
      return xs.slice(n2);
    }
  });
  splitAt = curry$(function(n2, xs) {
    return [take(n2, xs), drop(n2, xs)];
  });
  takeWhile = curry$(function(p2, xs) {
    var len, i2;
    len = xs.length;
    if (!len) {
      return xs;
    }
    i2 = 0;
    while (i2 < len && p2(xs[i2])) {
      i2 += 1;
    }
    return xs.slice(0, i2);
  });
  dropWhile = curry$(function(p2, xs) {
    var len, i2;
    len = xs.length;
    if (!len) {
      return xs;
    }
    i2 = 0;
    while (i2 < len && p2(xs[i2])) {
      i2 += 1;
    }
    return xs.slice(i2);
  });
  span = curry$(function(p2, xs) {
    return [takeWhile(p2, xs), dropWhile(p2, xs)];
  });
  breakList = curry$(function(p2, xs) {
    return span(compose$(p2, not$), xs);
  });
  zip = curry$(function(xs, ys) {
    var result, len, i$, len$, i2, x2;
    result = [];
    len = ys.length;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i2 = i$;
      x2 = xs[i$];
      if (i2 === len) {
        break;
      }
      result.push([x2, ys[i2]]);
    }
    return result;
  });
  zipWith = curry$(function(f2, xs, ys) {
    var result, len, i$, len$, i2, x2;
    result = [];
    len = ys.length;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i2 = i$;
      x2 = xs[i$];
      if (i2 === len) {
        break;
      }
      result.push(f2(x2, ys[i2]));
    }
    return result;
  });
  zipAll = function() {
    var xss, res$, i$, to$, minLength, len$, xs, ref$, i2, lresult$, j$, results$ = [];
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    minLength = void 0;
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      minLength <= (ref$ = xs.length) || (minLength = ref$);
    }
    for (i$ = 0; i$ < minLength; ++i$) {
      i2 = i$;
      lresult$ = [];
      for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
        xs = xss[j$];
        lresult$.push(xs[i2]);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  zipAllWith = function(f2) {
    var xss, res$, i$, to$, minLength, len$, xs, ref$, i2, results$ = [];
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    minLength = void 0;
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      minLength <= (ref$ = xs.length) || (minLength = ref$);
    }
    for (i$ = 0; i$ < minLength; ++i$) {
      i2 = i$;
      results$.push(f2.apply(null, fn$()));
    }
    return results$;
    function fn$() {
      var i$2, ref$2, len$2, results$2 = [];
      for (i$2 = 0, len$2 = (ref$2 = xss).length; i$2 < len$2; ++i$2) {
        xs = ref$2[i$2];
        results$2.push(xs[i2]);
      }
      return results$2;
    }
  };
  at = curry$(function(n2, xs) {
    if (n2 < 0) {
      return xs[xs.length + n2];
    } else {
      return xs[n2];
    }
  });
  elemIndex = curry$(function(el, xs) {
    var i$, len$, i2, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i2 = i$;
      x2 = xs[i$];
      if (x2 === el) {
        return i2;
      }
    }
  });
  elemIndices = curry$(function(el, xs) {
    var i$, len$, i2, x2, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i2 = i$;
      x2 = xs[i$];
      if (x2 === el) {
        results$.push(i2);
      }
    }
    return results$;
  });
  findIndex = curry$(function(f2, xs) {
    var i$, len$, i2, x2;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i2 = i$;
      x2 = xs[i$];
      if (f2(x2)) {
        return i2;
      }
    }
  });
  findIndices = curry$(function(f2, xs) {
    var i$, len$, i2, x2, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i2 = i$;
      x2 = xs[i$];
      if (f2(x2)) {
        results$.push(i2);
      }
    }
    return results$;
  });
  List = {
    each,
    map,
    filter: filter2,
    compact,
    reject,
    remove: remove2,
    partition,
    find: find2,
    head,
    first,
    tail,
    last,
    initial,
    empty: empty2,
    reverse,
    difference,
    intersection,
    union,
    countBy,
    groupBy,
    fold,
    fold1,
    foldl,
    foldl1,
    foldr,
    foldr1,
    unfoldr,
    andList,
    orList,
    any,
    all,
    unique,
    uniqueBy,
    sort,
    sortWith,
    sortBy,
    sum,
    product,
    mean,
    average,
    concat,
    concatMap: concatMap2,
    flatten: flatten2,
    maximum,
    minimum,
    maximumBy,
    minimumBy,
    scan,
    scan1,
    scanl,
    scanl1,
    scanr,
    scanr1,
    slice,
    take,
    drop,
    splitAt,
    takeWhile,
    dropWhile,
    span,
    breakList,
    zip,
    zipWith,
    zipAll,
    zipAllWith,
    at,
    elemIndex,
    elemIndices,
    findIndex,
    findIndices
  };
  function curry$(f2, bound) {
    var context, _curry = function(args) {
      return f2.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context = this;
        return params.push.apply(params, arguments) < f2.length && arguments.length ? _curry.call(context, params) : f2.apply(context, params);
      } : f2;
    };
    return _curry();
  }
  function in$(x2, xs) {
    var i2 = -1, l2 = xs.length >>> 0;
    while (++i2 < l2) if (x2 === xs[i2]) return true;
    return false;
  }
  function compose$() {
    var functions = arguments;
    return function() {
      var i2, result;
      result = functions[0].apply(this, arguments);
      for (i2 = 1; i2 < functions.length; ++i2) {
        result = functions[i2](result);
      }
      return result;
    };
  }
  function not$(x2) {
    return !x2;
  }
  return List;
}
var Obj;
var hasRequiredObj;
function requireObj() {
  if (hasRequiredObj) return Obj;
  hasRequiredObj = 1;
  var values, keys2, pairsToObj, objToPairs, listsToObj, objToLists, empty2, each, map, compact, filter2, reject, partition, find2;
  values = function(object) {
    var i$, x2, results$ = [];
    for (i$ in object) {
      x2 = object[i$];
      results$.push(x2);
    }
    return results$;
  };
  keys2 = function(object) {
    var x2, results$ = [];
    for (x2 in object) {
      results$.push(x2);
    }
    return results$;
  };
  pairsToObj = function(object) {
    var i$, len$, x2, resultObj$ = {};
    for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
      x2 = object[i$];
      resultObj$[x2[0]] = x2[1];
    }
    return resultObj$;
  };
  objToPairs = function(object) {
    var key, value, results$ = [];
    for (key in object) {
      value = object[key];
      results$.push([key, value]);
    }
    return results$;
  };
  listsToObj = curry$(function(keys3, values2) {
    var i$, len$, i2, key, resultObj$ = {};
    for (i$ = 0, len$ = keys3.length; i$ < len$; ++i$) {
      i2 = i$;
      key = keys3[i$];
      resultObj$[key] = values2[i2];
    }
    return resultObj$;
  });
  objToLists = function(object) {
    var keys3, values2, key, value;
    keys3 = [];
    values2 = [];
    for (key in object) {
      value = object[key];
      keys3.push(key);
      values2.push(value);
    }
    return [keys3, values2];
  };
  empty2 = function(object) {
    var x2;
    for (x2 in object) {
      return false;
    }
    return true;
  };
  each = curry$(function(f2, object) {
    var i$, x2;
    for (i$ in object) {
      x2 = object[i$];
      f2(x2);
    }
    return object;
  });
  map = curry$(function(f2, object) {
    var k, x2, resultObj$ = {};
    for (k in object) {
      x2 = object[k];
      resultObj$[k] = f2(x2);
    }
    return resultObj$;
  });
  compact = function(object) {
    var k, x2, resultObj$ = {};
    for (k in object) {
      x2 = object[k];
      if (x2) {
        resultObj$[k] = x2;
      }
    }
    return resultObj$;
  };
  filter2 = curry$(function(f2, object) {
    var k, x2, resultObj$ = {};
    for (k in object) {
      x2 = object[k];
      if (f2(x2)) {
        resultObj$[k] = x2;
      }
    }
    return resultObj$;
  });
  reject = curry$(function(f2, object) {
    var k, x2, resultObj$ = {};
    for (k in object) {
      x2 = object[k];
      if (!f2(x2)) {
        resultObj$[k] = x2;
      }
    }
    return resultObj$;
  });
  partition = curry$(function(f2, object) {
    var passed, failed, k, x2;
    passed = {};
    failed = {};
    for (k in object) {
      x2 = object[k];
      (f2(x2) ? passed : failed)[k] = x2;
    }
    return [passed, failed];
  });
  find2 = curry$(function(f2, object) {
    var i$, x2;
    for (i$ in object) {
      x2 = object[i$];
      if (f2(x2)) {
        return x2;
      }
    }
  });
  Obj = {
    values,
    keys: keys2,
    pairsToObj,
    objToPairs,
    listsToObj,
    objToLists,
    empty: empty2,
    each,
    map,
    filter: filter2,
    compact,
    reject,
    partition,
    find: find2
  };
  function curry$(f2, bound) {
    var context, _curry = function(args) {
      return f2.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context = this;
        return params.push.apply(params, arguments) < f2.length && arguments.length ? _curry.call(context, params) : f2.apply(context, params);
      } : f2;
    };
    return _curry();
  }
  return Obj;
}
var Str;
var hasRequiredStr;
function requireStr() {
  if (hasRequiredStr) return Str;
  hasRequiredStr = 1;
  var split, join2, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
  split = curry$(function(sep2, str) {
    return str.split(sep2);
  });
  join2 = curry$(function(sep2, xs) {
    return xs.join(sep2);
  });
  lines = function(str) {
    if (!str.length) {
      return [];
    }
    return str.split("\n");
  };
  unlines = function(it) {
    return it.join("\n");
  };
  words = function(str) {
    if (!str.length) {
      return [];
    }
    return str.split(/[ ]+/);
  };
  unwords = function(it) {
    return it.join(" ");
  };
  chars = function(it) {
    return it.split("");
  };
  unchars = function(it) {
    return it.join("");
  };
  reverse = function(str) {
    return str.split("").reverse().join("");
  };
  repeat = curry$(function(n2, str) {
    var result, i$;
    result = "";
    for (i$ = 0; i$ < n2; ++i$) {
      result += str;
    }
    return result;
  });
  capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  camelize = function(it) {
    return it.replace(/[-_]+(.)?/g, function(arg$, c2) {
      return (c2 != null ? c2 : "").toUpperCase();
    });
  };
  dasherize = function(str) {
    return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper) {
      return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
    }).replace(/^([A-Z]+)/, function(arg$, upper) {
      if (upper.length > 1) {
        return upper + "-";
      } else {
        return upper.toLowerCase();
      }
    });
  };
  Str = {
    split,
    join: join2,
    lines,
    unlines,
    words,
    unwords,
    chars,
    unchars,
    reverse,
    repeat,
    capitalize,
    camelize,
    dasherize
  };
  function curry$(f2, bound) {
    var context, _curry = function(args) {
      return f2.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context = this;
        return params.push.apply(params, arguments) < f2.length && arguments.length ? _curry.call(context, params) : f2.apply(context, params);
      } : f2;
    };
    return _curry();
  }
  return Str;
}
var Num;
var hasRequiredNum;
function requireNum() {
  if (hasRequiredNum) return Num;
  hasRequiredNum = 1;
  var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
  max = curry$(function(x$, y$) {
    return x$ > y$ ? x$ : y$;
  });
  min = curry$(function(x$, y$) {
    return x$ < y$ ? x$ : y$;
  });
  negate = function(x2) {
    return -x2;
  };
  abs = Math.abs;
  signum = function(x2) {
    if (x2 < 0) {
      return -1;
    } else if (x2 > 0) {
      return 1;
    } else {
      return 0;
    }
  };
  quot = curry$(function(x2, y2) {
    return ~~(x2 / y2);
  });
  rem = curry$(function(x$, y$) {
    return x$ % y$;
  });
  div = curry$(function(x2, y2) {
    return Math.floor(x2 / y2);
  });
  mod = curry$(function(x$, y$) {
    var ref$;
    return (x$ % (ref$ = y$) + ref$) % ref$;
  });
  recip = function(it) {
    return 1 / it;
  };
  pi = Math.PI;
  tau = pi * 2;
  exp = Math.exp;
  sqrt = Math.sqrt;
  ln = Math.log;
  pow = curry$(function(x$, y$) {
    return Math.pow(x$, y$);
  });
  sin = Math.sin;
  tan = Math.tan;
  cos = Math.cos;
  asin = Math.asin;
  acos = Math.acos;
  atan = Math.atan;
  atan2 = curry$(function(x2, y2) {
    return Math.atan2(x2, y2);
  });
  truncate = function(x2) {
    return ~~x2;
  };
  round = Math.round;
  ceiling = Math.ceil;
  floor = Math.floor;
  isItNaN = function(x2) {
    return x2 !== x2;
  };
  even = function(x2) {
    return x2 % 2 === 0;
  };
  odd = function(x2) {
    return x2 % 2 !== 0;
  };
  gcd = curry$(function(x2, y2) {
    var z;
    x2 = Math.abs(x2);
    y2 = Math.abs(y2);
    while (y2 !== 0) {
      z = x2 % y2;
      x2 = y2;
      y2 = z;
    }
    return x2;
  });
  lcm = curry$(function(x2, y2) {
    return Math.abs(Math.floor(x2 / gcd(x2, y2) * y2));
  });
  Num = {
    max,
    min,
    negate,
    abs,
    signum,
    quot,
    rem,
    div,
    mod,
    recip,
    pi,
    tau,
    exp,
    sqrt,
    ln,
    pow,
    sin,
    tan,
    cos,
    acos,
    asin,
    atan,
    atan2,
    truncate,
    round,
    ceiling,
    floor,
    isItNaN,
    even,
    odd,
    gcd,
    lcm
  };
  function curry$(f2, bound) {
    var context, _curry = function(args) {
      return f2.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context = this;
        return params.push.apply(params, arguments) < f2.length && arguments.length ? _curry.call(context, params) : f2.apply(context, params);
      } : f2;
    };
    return _curry();
  }
  return Num;
}
var lib$1;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  var Func2, List2, Obj2, Str2, Num2, id2, isType, replicate, prelude, toString$ = {}.toString;
  Func2 = requireFunc();
  List2 = requireList();
  Obj2 = requireObj();
  Str2 = requireStr();
  Num2 = requireNum();
  id2 = function(x2) {
    return x2;
  };
  isType = curry$(function(type2, x2) {
    return toString$.call(x2).slice(8, -1) === type2;
  });
  replicate = curry$(function(n2, x2) {
    var i$, results$ = [];
    for (i$ = 0; i$ < n2; ++i$) {
      results$.push(x2);
    }
    return results$;
  });
  Str2.empty = List2.empty;
  Str2.slice = List2.slice;
  Str2.take = List2.take;
  Str2.drop = List2.drop;
  Str2.splitAt = List2.splitAt;
  Str2.takeWhile = List2.takeWhile;
  Str2.dropWhile = List2.dropWhile;
  Str2.span = List2.span;
  Str2.breakStr = List2.breakList;
  prelude = {
    Func: Func2,
    List: List2,
    Obj: Obj2,
    Str: Str2,
    Num: Num2,
    id: id2,
    isType,
    replicate
  };
  prelude.each = List2.each;
  prelude.map = List2.map;
  prelude.filter = List2.filter;
  prelude.compact = List2.compact;
  prelude.reject = List2.reject;
  prelude.partition = List2.partition;
  prelude.find = List2.find;
  prelude.head = List2.head;
  prelude.first = List2.first;
  prelude.tail = List2.tail;
  prelude.last = List2.last;
  prelude.initial = List2.initial;
  prelude.empty = List2.empty;
  prelude.reverse = List2.reverse;
  prelude.difference = List2.difference;
  prelude.intersection = List2.intersection;
  prelude.union = List2.union;
  prelude.countBy = List2.countBy;
  prelude.groupBy = List2.groupBy;
  prelude.fold = List2.fold;
  prelude.foldl = List2.foldl;
  prelude.fold1 = List2.fold1;
  prelude.foldl1 = List2.foldl1;
  prelude.foldr = List2.foldr;
  prelude.foldr1 = List2.foldr1;
  prelude.unfoldr = List2.unfoldr;
  prelude.andList = List2.andList;
  prelude.orList = List2.orList;
  prelude.any = List2.any;
  prelude.all = List2.all;
  prelude.unique = List2.unique;
  prelude.uniqueBy = List2.uniqueBy;
  prelude.sort = List2.sort;
  prelude.sortWith = List2.sortWith;
  prelude.sortBy = List2.sortBy;
  prelude.sum = List2.sum;
  prelude.product = List2.product;
  prelude.mean = List2.mean;
  prelude.average = List2.average;
  prelude.concat = List2.concat;
  prelude.concatMap = List2.concatMap;
  prelude.flatten = List2.flatten;
  prelude.maximum = List2.maximum;
  prelude.minimum = List2.minimum;
  prelude.maximumBy = List2.maximumBy;
  prelude.minimumBy = List2.minimumBy;
  prelude.scan = List2.scan;
  prelude.scanl = List2.scanl;
  prelude.scan1 = List2.scan1;
  prelude.scanl1 = List2.scanl1;
  prelude.scanr = List2.scanr;
  prelude.scanr1 = List2.scanr1;
  prelude.slice = List2.slice;
  prelude.take = List2.take;
  prelude.drop = List2.drop;
  prelude.splitAt = List2.splitAt;
  prelude.takeWhile = List2.takeWhile;
  prelude.dropWhile = List2.dropWhile;
  prelude.span = List2.span;
  prelude.breakList = List2.breakList;
  prelude.zip = List2.zip;
  prelude.zipWith = List2.zipWith;
  prelude.zipAll = List2.zipAll;
  prelude.zipAllWith = List2.zipAllWith;
  prelude.at = List2.at;
  prelude.elemIndex = List2.elemIndex;
  prelude.elemIndices = List2.elemIndices;
  prelude.findIndex = List2.findIndex;
  prelude.findIndices = List2.findIndices;
  prelude.apply = Func2.apply;
  prelude.curry = Func2.curry;
  prelude.flip = Func2.flip;
  prelude.fix = Func2.fix;
  prelude.over = Func2.over;
  prelude.split = Str2.split;
  prelude.join = Str2.join;
  prelude.lines = Str2.lines;
  prelude.unlines = Str2.unlines;
  prelude.words = Str2.words;
  prelude.unwords = Str2.unwords;
  prelude.chars = Str2.chars;
  prelude.unchars = Str2.unchars;
  prelude.repeat = Str2.repeat;
  prelude.capitalize = Str2.capitalize;
  prelude.camelize = Str2.camelize;
  prelude.dasherize = Str2.dasherize;
  prelude.values = Obj2.values;
  prelude.keys = Obj2.keys;
  prelude.pairsToObj = Obj2.pairsToObj;
  prelude.objToPairs = Obj2.objToPairs;
  prelude.listsToObj = Obj2.listsToObj;
  prelude.objToLists = Obj2.objToLists;
  prelude.max = Num2.max;
  prelude.min = Num2.min;
  prelude.negate = Num2.negate;
  prelude.abs = Num2.abs;
  prelude.signum = Num2.signum;
  prelude.quot = Num2.quot;
  prelude.rem = Num2.rem;
  prelude.div = Num2.div;
  prelude.mod = Num2.mod;
  prelude.recip = Num2.recip;
  prelude.pi = Num2.pi;
  prelude.tau = Num2.tau;
  prelude.exp = Num2.exp;
  prelude.sqrt = Num2.sqrt;
  prelude.ln = Num2.ln;
  prelude.pow = Num2.pow;
  prelude.sin = Num2.sin;
  prelude.tan = Num2.tan;
  prelude.cos = Num2.cos;
  prelude.acos = Num2.acos;
  prelude.asin = Num2.asin;
  prelude.atan = Num2.atan;
  prelude.atan2 = Num2.atan2;
  prelude.truncate = Num2.truncate;
  prelude.round = Num2.round;
  prelude.ceiling = Num2.ceiling;
  prelude.floor = Num2.floor;
  prelude.isItNaN = Num2.isItNaN;
  prelude.even = Num2.even;
  prelude.odd = Num2.odd;
  prelude.gcd = Num2.gcd;
  prelude.lcm = Num2.lcm;
  prelude.VERSION = "1.2.1";
  lib$1 = prelude;
  function curry$(f2, bound) {
    var context, _curry = function(args) {
      return f2.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context = this;
        return params.push.apply(params, arguments) < f2.length && arguments.length ? _curry.call(context, params) : f2.apply(context, params);
      } : f2;
    };
    return _curry();
  }
  return lib$1;
}
var hasRequiredParseString;
function requireParseString() {
  if (hasRequiredParseString) return parseString.exports;
  hasRequiredParseString = 1;
  (function() {
    var reject, special, tokenRegex;
    reject = requireLib$2().reject;
    function consumeOp(tokens, op) {
      if (tokens[0] === op) {
        return tokens.shift();
      } else {
        throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
      }
    }
    function maybeConsumeOp(tokens, op) {
      if (tokens[0] === op) {
        return tokens.shift();
      }
    }
    function consumeList(tokens, arg$, hasDelimiters) {
      var open, close, result, untilTest;
      open = arg$[0], close = arg$[1];
      if (hasDelimiters) {
        consumeOp(tokens, open);
      }
      result = [];
      untilTest = "," + (hasDelimiters ? close : "");
      while (tokens.length && (hasDelimiters && tokens[0] !== close)) {
        result.push(consumeElement(tokens, untilTest));
        maybeConsumeOp(tokens, ",");
      }
      if (hasDelimiters) {
        consumeOp(tokens, close);
      }
      return result;
    }
    function consumeArray(tokens, hasDelimiters) {
      return consumeList(tokens, ["[", "]"], hasDelimiters);
    }
    function consumeTuple(tokens, hasDelimiters) {
      return consumeList(tokens, ["(", ")"], hasDelimiters);
    }
    function consumeFields(tokens, hasDelimiters) {
      var result, untilTest, key;
      if (hasDelimiters) {
        consumeOp(tokens, "{");
      }
      result = {};
      untilTest = "," + (hasDelimiters ? "}" : "");
      while (tokens.length && (!hasDelimiters || tokens[0] !== "}")) {
        key = consumeValue(tokens, ":");
        consumeOp(tokens, ":");
        result[key] = consumeElement(tokens, untilTest);
        maybeConsumeOp(tokens, ",");
      }
      if (hasDelimiters) {
        consumeOp(tokens, "}");
      }
      return result;
    }
    function consumeValue(tokens, untilTest) {
      var out;
      untilTest == null && (untilTest = "");
      out = "";
      while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
        out += tokens.shift();
      }
      return out;
    }
    function consumeElement(tokens, untilTest) {
      switch (tokens[0]) {
        case "[":
          return consumeArray(tokens, true);
        case "(":
          return consumeTuple(tokens, true);
        case "{":
          return consumeFields(tokens, true);
        default:
          return consumeValue(tokens, untilTest);
      }
    }
    function consumeTopLevel(tokens, types2, options) {
      var ref$, type2, structure, origTokens, result, finalResult, x$, y$;
      ref$ = types2[0], type2 = ref$.type, structure = ref$.structure;
      origTokens = tokens.concat();
      if (!options.explicit && types2.length === 1 && (!type2 && structure || (type2 === "Array" || type2 === "Object"))) {
        result = structure === "array" || type2 === "Array" ? consumeArray(tokens, tokens[0] === "[") : structure === "tuple" ? consumeTuple(tokens, tokens[0] === "(") : consumeFields(tokens, tokens[0] === "{");
        finalResult = tokens.length ? consumeElement(structure === "array" || type2 === "Array" ? (x$ = origTokens, x$.unshift("["), x$.push("]"), x$) : (y$ = origTokens, y$.unshift("("), y$.push(")"), y$)) : result;
      } else {
        finalResult = consumeElement(tokens);
      }
      return finalResult;
    }
    special = /\[\]\(\)}{:,/.source;
    tokenRegex = RegExp(`("(?:\\\\"|[^"])*")|('(?:\\\\'|[^'])*')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([` + special + "])|([^\\s" + special + "](?:\\s*[^\\s" + special + "]+)*)|\\s*");
    parseString.exports = function(types2, string2, options) {
      var tokens, node2;
      options == null && (options = {});
      if (!options.explicit && types2.length === 1 && types2[0].type === "String") {
        return string2;
      }
      tokens = reject(not$, string2.split(tokenRegex));
      node2 = consumeTopLevel(tokens, types2, options);
      if (!node2) {
        throw new Error("Error parsing '" + string2 + "'.");
      }
      return node2;
    };
    function not$(x2) {
      return !x2;
    }
  }).call(this);
  return parseString.exports;
}
var cast = { exports: {} };
var lib = { exports: {} };
var parseType = { exports: {} };
var hasRequiredParseType;
function requireParseType() {
  if (hasRequiredParseType) return parseType.exports;
  hasRequiredParseType = 1;
  (function() {
    var identifierRegex, tokenRegex;
    identifierRegex = /[\$\w]+/;
    function peek(tokens) {
      var token;
      token = tokens[0];
      if (token == null) {
        throw new Error("Unexpected end of input.");
      }
      return token;
    }
    function consumeIdent(tokens) {
      var token;
      token = peek(tokens);
      if (!identifierRegex.test(token)) {
        throw new Error("Expected text, got '" + token + "' instead.");
      }
      return tokens.shift();
    }
    function consumeOp(tokens, op) {
      var token;
      token = peek(tokens);
      if (token !== op) {
        throw new Error("Expected '" + op + "', got '" + token + "' instead.");
      }
      return tokens.shift();
    }
    function maybeConsumeOp(tokens, op) {
      var token;
      token = tokens[0];
      if (token === op) {
        return tokens.shift();
      } else {
        return null;
      }
    }
    function consumeArray(tokens) {
      var types2;
      consumeOp(tokens, "[");
      if (peek(tokens) === "]") {
        throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
      }
      types2 = consumeTypes(tokens);
      consumeOp(tokens, "]");
      return {
        structure: "array",
        of: types2
      };
    }
    function consumeTuple(tokens) {
      var components;
      components = [];
      consumeOp(tokens, "(");
      if (peek(tokens) === ")") {
        throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
      }
      for (; ; ) {
        components.push(consumeTypes(tokens));
        maybeConsumeOp(tokens, ",");
        if (")" === peek(tokens)) {
          break;
        }
      }
      consumeOp(tokens, ")");
      return {
        structure: "tuple",
        of: components
      };
    }
    function consumeFields(tokens) {
      var fields, subset, ref$, key, types2;
      fields = {};
      consumeOp(tokens, "{");
      subset = false;
      for (; ; ) {
        if (maybeConsumeOp(tokens, "...")) {
          subset = true;
          break;
        }
        ref$ = consumeField(tokens), key = ref$[0], types2 = ref$[1];
        fields[key] = types2;
        maybeConsumeOp(tokens, ",");
        if ("}" === peek(tokens)) {
          break;
        }
      }
      consumeOp(tokens, "}");
      return {
        structure: "fields",
        of: fields,
        subset
      };
    }
    function consumeField(tokens) {
      var key, types2;
      key = consumeIdent(tokens);
      consumeOp(tokens, ":");
      types2 = consumeTypes(tokens);
      return [key, types2];
    }
    function maybeConsumeStructure(tokens) {
      switch (tokens[0]) {
        case "[":
          return consumeArray(tokens);
        case "(":
          return consumeTuple(tokens);
        case "{":
          return consumeFields(tokens);
      }
    }
    function consumeType(tokens) {
      var token, wildcard, type2, structure;
      token = peek(tokens);
      wildcard = token === "*";
      if (wildcard || identifierRegex.test(token)) {
        type2 = wildcard ? consumeOp(tokens, "*") : consumeIdent(tokens);
        structure = maybeConsumeStructure(tokens);
        if (structure) {
          return structure.type = type2, structure;
        } else {
          return {
            type: type2
          };
        }
      } else {
        structure = maybeConsumeStructure(tokens);
        if (!structure) {
          throw new Error("Unexpected character: " + token);
        }
        return structure;
      }
    }
    function consumeTypes(tokens) {
      var lookahead, types2, typesSoFar, typeObj, type2, structure;
      if ("::" === peek(tokens)) {
        throw new Error("No comment before comment separator '::' found.");
      }
      lookahead = tokens[1];
      if (lookahead != null && lookahead === "::") {
        tokens.shift();
        tokens.shift();
      }
      types2 = [];
      typesSoFar = {};
      if ("Maybe" === peek(tokens)) {
        tokens.shift();
        types2 = [
          {
            type: "Undefined"
          },
          {
            type: "Null"
          }
        ];
        typesSoFar = {
          Undefined: true,
          Null: true
        };
      }
      for (; ; ) {
        typeObj = consumeType(tokens), type2 = typeObj.type, structure = typeObj.structure;
        if (!typesSoFar[type2]) {
          types2.push(typeObj);
        }
        if (structure == null) {
          typesSoFar[type2] = true;
        }
        if (!maybeConsumeOp(tokens, "|")) {
          break;
        }
      }
      return types2;
    }
    tokenRegex = RegExp("\\.\\.\\.|::|->|" + identifierRegex.source + "|\\S", "g");
    parseType.exports = function(input) {
      var tokens, e2;
      if (!input.length) {
        throw new Error("No type specified.");
      }
      tokens = input.match(tokenRegex) || [];
      if (in$("->", tokens)) {
        throw new Error("Function types are not supported. To validate that something is a function, you may use 'Function'.");
      }
      try {
        return consumeTypes(tokens);
      } catch (e$) {
        e2 = e$;
        throw new Error(e2.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
      }
    };
    function in$(x2, xs) {
      var i2 = -1, l2 = xs.length >>> 0;
      while (++i2 < l2) if (x2 === xs[i2]) return true;
      return false;
    }
  }).call(this);
  return parseType.exports;
}
var check = { exports: {} };
var hasRequiredCheck;
function requireCheck() {
  if (hasRequiredCheck) return check.exports;
  hasRequiredCheck = 1;
  (function() {
    var ref$, any, all, isItNaN, types2, defaultType, toString$ = {}.toString;
    ref$ = requireLib$2(), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
    types2 = {
      Number: {
        typeOf: "Number",
        validate: function(it) {
          return !isItNaN(it);
        }
      },
      NaN: {
        typeOf: "Number",
        validate: isItNaN
      },
      Int: {
        typeOf: "Number",
        validate: function(it) {
          return !isItNaN(it) && it % 1 === 0;
        }
      },
      Float: {
        typeOf: "Number",
        validate: function(it) {
          return !isItNaN(it);
        }
      },
      Date: {
        typeOf: "Date",
        validate: function(it) {
          return !isItNaN(it.getTime());
        }
      }
    };
    defaultType = {
      array: "Array",
      tuple: "Array"
    };
    function checkArray(input, type2, options) {
      return all(function(it) {
        return checkMultiple(it, type2.of, options);
      }, input);
    }
    function checkTuple(input, type2, options) {
      var i2, i$, ref$2, len$, types3;
      i2 = 0;
      for (i$ = 0, len$ = (ref$2 = type2.of).length; i$ < len$; ++i$) {
        types3 = ref$2[i$];
        if (!checkMultiple(input[i2], types3, options)) {
          return false;
        }
        i2++;
      }
      return input.length <= i2;
    }
    function checkFields(input, type2, options) {
      var inputKeys, numInputKeys, k, numOfKeys, key, ref$2, types3;
      inputKeys = {};
      numInputKeys = 0;
      for (k in input) {
        inputKeys[k] = true;
        numInputKeys++;
      }
      numOfKeys = 0;
      for (key in ref$2 = type2.of) {
        types3 = ref$2[key];
        if (!checkMultiple(input[key], types3, options)) {
          return false;
        }
        if (inputKeys[key]) {
          numOfKeys++;
        }
      }
      return type2.subset || numInputKeys === numOfKeys;
    }
    function checkStructure(input, type2, options) {
      if (!(input instanceof Object)) {
        return false;
      }
      switch (type2.structure) {
        case "fields":
          return checkFields(input, type2, options);
        case "array":
          return checkArray(input, type2, options);
        case "tuple":
          return checkTuple(input, type2, options);
      }
    }
    function check$1(input, typeObj, options) {
      var type2, structure, setting, that;
      type2 = typeObj.type, structure = typeObj.structure;
      if (type2) {
        if (type2 === "*") {
          return true;
        }
        setting = options.customTypes[type2] || types2[type2];
        if (setting) {
          return (setting.typeOf === void 0 || setting.typeOf === toString$.call(input).slice(8, -1)) && setting.validate(input);
        } else {
          return type2 === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj, options));
        }
      } else if (structure) {
        if (that = defaultType[structure]) {
          if (that !== toString$.call(input).slice(8, -1)) {
            return false;
          }
        }
        return checkStructure(input, typeObj, options);
      } else {
        throw new Error("No type defined. Input: " + input + ".");
      }
    }
    function checkMultiple(input, types3, options) {
      if (toString$.call(types3).slice(8, -1) !== "Array") {
        throw new Error("Types must be in an array. Input: " + input + ".");
      }
      return any(function(it) {
        return check$1(input, it, options);
      }, types3);
    }
    check.exports = function(parsedType, input, options) {
      options == null && (options = {});
      if (options.customTypes == null) {
        options.customTypes = {};
      }
      return checkMultiple(input, parsedType, options);
    };
  }).call(this);
  return check.exports;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib.exports;
  hasRequiredLib$1 = 1;
  (function() {
    var VERSION, parseType2, parsedTypeCheck, typeCheck;
    VERSION = "0.4.0";
    parseType2 = requireParseType();
    parsedTypeCheck = requireCheck();
    typeCheck = function(type2, input, options) {
      return parsedTypeCheck(parseType2(type2), input, options);
    };
    lib.exports = {
      VERSION,
      typeCheck,
      parsedTypeCheck,
      parseType: parseType2
    };
  }).call(this);
  return lib.exports;
}
var hasRequiredCast;
function requireCast() {
  if (hasRequiredCast) return cast.exports;
  hasRequiredCast = 1;
  (function() {
    var parsedTypeCheck, types2, toString$ = {}.toString;
    parsedTypeCheck = requireLib$1().parsedTypeCheck;
    types2 = {
      "*": function(value, options) {
        switch (toString$.call(value).slice(8, -1)) {
          case "Array":
            return typeCast(value, {
              type: "Array"
            }, options);
          case "Object":
            return typeCast(value, {
              type: "Object"
            }, options);
          default:
            return {
              type: "Just",
              value: typesCast(value, [
                {
                  type: "Undefined"
                },
                {
                  type: "Null"
                },
                {
                  type: "NaN"
                },
                {
                  type: "Boolean"
                },
                {
                  type: "Number"
                },
                {
                  type: "Date"
                },
                {
                  type: "RegExp"
                },
                {
                  type: "Array"
                },
                {
                  type: "Object"
                },
                {
                  type: "String"
                }
              ], (options.explicit = true, options))
            };
        }
      },
      Undefined: function(it) {
        if (it === "undefined" || it === void 0) {
          return {
            type: "Just",
            value: void 0
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      Null: function(it) {
        if (it === "null") {
          return {
            type: "Just",
            value: null
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      NaN: function(it) {
        if (it === "NaN") {
          return {
            type: "Just",
            value: NaN
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      Boolean: function(it) {
        if (it === "true") {
          return {
            type: "Just",
            value: true
          };
        } else if (it === "false") {
          return {
            type: "Just",
            value: false
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      Number: function(it) {
        return {
          type: "Just",
          value: +it
        };
      },
      Int: function(it) {
        return {
          type: "Just",
          value: +it
        };
      },
      Float: function(it) {
        return {
          type: "Just",
          value: +it
        };
      },
      Date: function(value, options) {
        var that;
        if (that = /^\#([\s\S]*)\#$/.exec(value)) {
          return {
            type: "Just",
            value: new Date(+that[1] || that[1])
          };
        } else if (options.explicit) {
          return {
            type: "Nothing"
          };
        } else {
          return {
            type: "Just",
            value: new Date(+value || value)
          };
        }
      },
      RegExp: function(value, options) {
        var that;
        if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
          return {
            type: "Just",
            value: new RegExp(that[1], that[2])
          };
        } else if (options.explicit) {
          return {
            type: "Nothing"
          };
        } else {
          return {
            type: "Just",
            value: new RegExp(value)
          };
        }
      },
      Array: function(value, options) {
        return castArray(value, {
          of: [{
            type: "*"
          }]
        }, options);
      },
      Object: function(value, options) {
        return castFields(value, {
          of: {}
        }, options);
      },
      String: function(it) {
        var replace2, that;
        if (toString$.call(it).slice(8, -1) !== "String") {
          return {
            type: "Nothing"
          };
        }
        replace2 = function(value, quote) {
          return value.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function(all, escaped) {
            switch (escaped[0]) {
              case quote:
                return quote;
              case "\\":
                return "\\";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "t":
                return "	";
              case "u":
                return JSON.parse('"' + all + '"');
              default:
                return escaped;
            }
          });
        };
        if (that = it.match(/^'([\s\S]*)'$/)) {
          return {
            type: "Just",
            value: replace2(that[1], "'")
          };
        } else if (that = it.match(/^"([\s\S]*)"$/)) {
          return {
            type: "Just",
            value: replace2(that[1], '"')
          };
        } else {
          return {
            type: "Just",
            value: it
          };
        }
      }
    };
    function castArray(node2, type2, options) {
      var typeOf, element;
      if (toString$.call(node2).slice(8, -1) !== "Array") {
        return {
          type: "Nothing"
        };
      }
      typeOf = type2.of;
      return {
        type: "Just",
        value: function() {
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = node2).length; i$ < len$; ++i$) {
            element = ref$[i$];
            results$.push(typesCast(element, typeOf, options));
          }
          return results$;
        }()
      };
    }
    function castTuple(node2, type2, options) {
      var result, i2, i$, ref$, len$, types3, cast2;
      if (toString$.call(node2).slice(8, -1) !== "Array") {
        return {
          type: "Nothing"
        };
      }
      result = [];
      i2 = 0;
      for (i$ = 0, len$ = (ref$ = type2.of).length; i$ < len$; ++i$) {
        types3 = ref$[i$];
        cast2 = typesCast(node2[i2], types3, options);
        if (toString$.call(cast2).slice(8, -1) !== "Undefined") {
          result.push(cast2);
        }
        i2++;
      }
      if (node2.length <= i2) {
        return {
          type: "Just",
          value: result
        };
      } else {
        return {
          type: "Nothing"
        };
      }
    }
    function castFields(node2, type2, options) {
      var typeOf, key, value;
      if (toString$.call(node2).slice(8, -1) !== "Object") {
        return {
          type: "Nothing"
        };
      }
      typeOf = type2.of;
      return {
        type: "Just",
        value: function() {
          var ref$, resultObj$ = {};
          for (key in ref$ = node2) {
            value = ref$[key];
            resultObj$[typesCast(key, [{
              type: "String"
            }], options)] = typesCast(value, typeOf[key] || [{
              type: "*"
            }], options);
          }
          return resultObj$;
        }()
      };
    }
    function typeCast(node2, typeObj, options) {
      var type2, structure, castFunc, ref$;
      type2 = typeObj.type, structure = typeObj.structure;
      if (type2) {
        castFunc = ((ref$ = options.customTypes[type2]) != null ? ref$.cast : void 0) || types2[type2];
        if (!castFunc) {
          throw new Error("Type not defined: " + type2 + ".");
        }
        return castFunc(node2, options, typesCast);
      } else {
        switch (structure) {
          case "array":
            return castArray(node2, typeObj, options);
          case "tuple":
            return castTuple(node2, typeObj, options);
          case "fields":
            return castFields(node2, typeObj, options);
        }
      }
    }
    function typesCast(node2, types3, options) {
      var i$, len$, type2, ref$, valueType, value;
      for (i$ = 0, len$ = types3.length; i$ < len$; ++i$) {
        type2 = types3[i$];
        ref$ = typeCast(node2, type2, options), valueType = ref$.type, value = ref$.value;
        if (valueType === "Nothing") {
          continue;
        }
        if (parsedTypeCheck([type2], value, {
          customTypes: options.customTypes
        })) {
          return value;
        }
      }
      throw new Error("Value " + JSON.stringify(node2) + " does not type check against " + JSON.stringify(types3) + ".");
    }
    cast.exports = function(node2, types3, options) {
      if (!options.explicit && types3.length === 1 && types3[0].type === "String") {
        return node2;
      }
      return typesCast(node2, types3, options);
    };
  }).call(this);
  return cast.exports;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$2.exports;
  hasRequiredLib = 1;
  (function() {
    var parseString2, cast2, parseType2, VERSION, parsedTypeParse, parse;
    parseString2 = requireParseString();
    cast2 = requireCast();
    parseType2 = requireLib$1().parseType;
    VERSION = "0.4.1";
    parsedTypeParse = function(parsedType, string2, options) {
      options == null && (options = {});
      options.explicit == null && (options.explicit = false);
      options.customTypes == null && (options.customTypes = {});
      return cast2(parseString2(parsedType, string2, options), parsedType, options);
    };
    parse = function(type2, string2, options) {
      return parsedTypeParse(parseType2(type2), string2, options);
    };
    lib$2.exports = {
      VERSION,
      parse,
      parsedTypeParse
    };
  }).call(this);
  return lib$2.exports;
}
var hasRequiredCjs$2;
function requireCjs$2() {
  var _ConfigCommentParser_instances, extractDirectiveComment_fn, _lines, _lineStartIndices, _lineEndingPattern, _TextSourceCodeBase_instances, findNextLine_fn, ensureLines_fn, ensureLineStartIndicesFromIndex_fn, ensureLineStartIndicesFromLoc_fn;
  if (hasRequiredCjs$2) return cjs$2;
  hasRequiredCjs$2 = 1;
  var levn = requireLib();
  const directivesPattern = /^([a-z]+(?:-[a-z]+)*)(?:\s|$)/u;
  const validSeverities = /* @__PURE__ */ new Set([0, 1, 2, "off", "warn", "error"]);
  function isSeverityValid(ruleConfig) {
    const severity2 = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
    return validSeverities.has(severity2);
  }
  function isEverySeverityValid(rulesConfig) {
    return Object.values(rulesConfig).every(isSeverityValid);
  }
  class DirectiveComment {
    /**
     * Creates a new directive comment.
     * @param {string} label The label of the directive.
     * @param {string} value The value of the directive.
     * @param {string} justification The justification of the directive.
     */
    constructor(label, value, justification) {
      /**
       * The label of the directive, such as "eslint", "eslint-disable", etc.
       * @type {string}
       */
      __publicField(this, "label", "");
      /**
       * The value of the directive (the string after the label).
       * @type {string}
       */
      __publicField(this, "value", "");
      /**
       * The justification of the directive (the string after the --).
       * @type {string}
       */
      __publicField(this, "justification", "");
      this.label = label;
      this.value = value;
      this.justification = justification;
    }
  }
  class ConfigCommentParser {
    constructor() {
      __privateAdd(this, _ConfigCommentParser_instances);
    }
    /**
     * Parses a list of "name:string_value" or/and "name" options divided by comma or
     * whitespace. Used for "global" comments.
     * @param {string} string The string to parse.
     * @returns {StringConfig} Result map object of names and string values, or null values if no value was provided.
     */
    parseStringConfig(string2) {
      const items2 = (
        /** @type {StringConfig} */
        {}
      );
      const trimmedString = string2.trim().replace(new RegExp("(?<!\\s)\\s*([:,])\\s*", "gu"), "$1");
      trimmedString.split(/\s|,+/u).forEach((name2) => {
        if (!name2) {
          return;
        }
        const [key, value = null] = name2.split(":");
        items2[key] = value;
      });
      return items2;
    }
    /**
     * Parses a JSON-like config.
     * @param {string} string The string to parse.
     * @returns {({ok: true, config: RulesConfig}|{ok: false, error: {message: string}})} Result map object
     */
    parseJSONLikeConfig(string2) {
      try {
        const items2 = (
          /** @type {RulesConfig} */
          levn.parse("Object", string2) || {}
        );
        if (isEverySeverityValid(items2)) {
          return {
            ok: true,
            config: items2
          };
        }
      } catch {
      }
      const normalizedString = string2.replace(new RegExp("(?<![-a-zA-Z0-9/])([-a-zA-Z0-9/]+):", "gu"), '"$1":').replace(/([\]0-9])\s+(?=")/u, "$1,");
      try {
        const items2 = JSON.parse(`{${normalizedString}}`);
        return {
          ok: true,
          config: items2
        };
      } catch (ex) {
        const errorMessage = ex instanceof Error ? ex.message : String(ex);
        return {
          ok: false,
          error: {
            message: `Failed to parse JSON from '${normalizedString}': ${errorMessage}`
          }
        };
      }
    }
    /**
     * Parses a config of values separated by comma.
     * @param {string} string The string to parse.
     * @returns {BooleanConfig} Result map of values and true values
     */
    parseListConfig(string2) {
      const items2 = (
        /** @type {BooleanConfig} */
        {}
      );
      string2.split(",").forEach((name2) => {
        const trimmedName = name2.trim().replace(
          /^(?<quote>['"]?)(?<ruleId>.*)\k<quote>$/su,
          "$<ruleId>"
        );
        if (trimmedName) {
          items2[trimmedName] = true;
        }
      });
      return items2;
    }
    /**
     * Parses a directive comment into directive text and value.
     * @param {string} string The string with the directive to be parsed.
     * @returns {DirectiveComment|undefined} The parsed directive or `undefined` if the directive is invalid.
     */
    parseDirective(string2) {
      const { directivePart, justificationPart } = __privateMethod(this, _ConfigCommentParser_instances, extractDirectiveComment_fn).call(this, string2);
      const match = directivesPattern.exec(directivePart);
      if (!match) {
        return void 0;
      }
      const directiveText = match[1];
      const directiveValue = directivePart.slice(
        match.index + directiveText.length
      );
      return new DirectiveComment(
        directiveText,
        directiveValue.trim(),
        justificationPart
      );
    }
  }
  _ConfigCommentParser_instances = new WeakSet();
  /**
   * Extract the directive and the justification from a given directive comment and trim them.
   * @param {string} value The comment text to extract.
   * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.
   */
  extractDirectiveComment_fn = function(value) {
    const match = /\s-{2,}\s/u.exec(value);
    if (!match) {
      return { directivePart: value.trim(), justificationPart: "" };
    }
    const directive = value.slice(0, match.index).trim();
    const justification = value.slice(match.index + match[0].length).trim();
    return { directivePart: directive, justificationPart: justification };
  };
  function hasESTreeStyleLoc(node2) {
    return "loc" in node2;
  }
  function hasPosStyleLoc(node2) {
    return "position" in node2;
  }
  function hasESTreeStyleRange(node2) {
    return "range" in node2;
  }
  function hasPosStyleRange(node2) {
    return "position" in node2;
  }
  function findLineNumberBinarySearch(lineStartIndices, targetIndex) {
    let low = 0;
    let high = lineStartIndices.length - 1;
    while (low < high) {
      const mid = (low + high) / 2 | 0;
      if (targetIndex < lineStartIndices[mid]) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low;
  }
  class VisitNodeStep {
    /**
     * Creates a new instance.
     * @param {Object} options The options for the step.
     * @param {object} options.target The target of the step.
     * @param {1|2} options.phase The phase of the step.
     * @param {Array<any>} options.args The arguments of the step.
     */
    constructor({ target, phase, args }) {
      /**
       * The type of the step.
       * @type {"visit"}
       * @readonly
       */
      __publicField(this, "type", "visit");
      /**
       * The kind of the step. Represents the same data as the `type` property
       * but it's a number for performance.
       * @type {1}
       * @readonly
       */
      __publicField(this, "kind", 1);
      /**
       * The target of the step.
       * @type {object}
       */
      __publicField(this, "target");
      /**
       * The phase of the step.
       * @type {1|2}
       */
      __publicField(this, "phase");
      /**
       * The arguments of the step.
       * @type {Array<any>}
       */
      __publicField(this, "args");
      this.target = target;
      this.phase = phase;
      this.args = args;
    }
  }
  class CallMethodStep {
    /**
     * Creates a new instance.
     * @param {Object} options The options for the step.
     * @param {string} options.target The target of the step.
     * @param {Array<any>} options.args The arguments of the step.
     */
    constructor({ target, args }) {
      /**
       * The type of the step.
       * @type {"call"}
       * @readonly
       */
      __publicField(this, "type", "call");
      /**
       * The kind of the step. Represents the same data as the `type` property
       * but it's a number for performance.
       * @type {2}
       * @readonly
       */
      __publicField(this, "kind", 2);
      /**
       * The name of the method to call.
       * @type {string}
       */
      __publicField(this, "target");
      /**
       * The arguments to pass to the method.
       * @type {Array<any>}
       */
      __publicField(this, "args");
      this.target = target;
      this.args = args;
    }
  }
  class Directive {
    /**
     * Creates a new instance.
     * @param {Object} options The options for the directive.
     * @param {"disable"|"enable"|"disable-next-line"|"disable-line"} options.type The type of directive.
     * @param {unknown} options.node The node representing the directive.
     * @param {string} options.value The value of the directive.
     * @param {string} options.justification The justification for the directive.
     */
    constructor({ type: type2, node: node2, value, justification }) {
      /**
       * The type of directive.
       * @type {DirectiveType}
       * @readonly
       */
      __publicField(this, "type");
      /**
       * The node representing the directive.
       * @type {unknown}
       * @readonly
       */
      __publicField(this, "node");
      /**
       * Everything after the "eslint-disable" portion of the directive,
       * but before the "--" that indicates the justification.
       * @type {string}
       * @readonly
       */
      __publicField(this, "value");
      /**
       * The justification for the directive.
       * @type {string}
       * @readonly
       */
      __publicField(this, "justification");
      this.type = type2;
      this.node = node2;
      this.value = value;
      this.justification = justification;
    }
  }
  class TextSourceCodeBase {
    /**
     * Creates a new instance.
     * @param {Object} options The options for the instance.
     * @param {string} options.text The source code text.
     * @param {Options['RootNode']} options.ast The root AST node.
     * @param {RegExp} [options.lineEndingPattern] The pattern to match lineEndings in the source code. Defaults to `/\r?\n/u`.
     */
    constructor({ text, ast: ast2, lineEndingPattern = /\r?\n/u }) {
      __privateAdd(this, _TextSourceCodeBase_instances);
      /**
       * The lines of text in the source code.
       * @type {Array<string>}
       */
      __privateAdd(this, _lines, []);
      /**
       * The indices of the start of each line in the source code.
       * @type {Array<number>}
       */
      __privateAdd(this, _lineStartIndices, [0]);
      /**
       * The pattern to match lineEndings in the source code.
       * @type {RegExp}
       */
      __privateAdd(this, _lineEndingPattern);
      /**
       * The AST of the source code.
       * @type {Options['RootNode']}
       */
      __publicField(this, "ast");
      /**
       * The text of the source code.
       * @type {string}
       */
      __publicField(this, "text");
      this.ast = ast2;
      this.text = text;
      __privateSet(this, _lineEndingPattern, new RegExp(
        lineEndingPattern.source,
        lineEndingPattern.flags.replace(/[gy]/gu, "")
      ));
    }
    /**
     * Returns the loc information for the given node or token.
     * @param {Options['SyntaxElementWithLoc']} nodeOrToken The node or token to get the loc information for.
     * @returns {SourceLocation} The loc information for the node or token.
     * @throws {Error} If the node or token does not have loc information.
     */
    getLoc(nodeOrToken) {
      if (hasESTreeStyleLoc(nodeOrToken)) {
        return nodeOrToken.loc;
      }
      if (hasPosStyleLoc(nodeOrToken)) {
        return nodeOrToken.position;
      }
      throw new Error(
        "Custom getLoc() method must be implemented in the subclass."
      );
    }
    /**
     * Converts a source text index into a `{ line: number, column: number }` pair.
     * @param {number} index The index of a character in a file.
     * @throws {TypeError|RangeError} If non-numeric index or index out of range.
     * @returns {{line: number, column: number}} A `{ line: number, column: number }` location object with 0 or 1-indexed line and 0 or 1-indexed column based on language.
     * @public
     */
    getLocFromIndex(index) {
      if (typeof index !== "number") {
        throw new TypeError("Expected `index` to be a number.");
      }
      if (index < 0 || index > this.text.length) {
        throw new RangeError(
          `Index out of range (requested index ${index}, but source text has length ${this.text.length}).`
        );
      }
      const {
        start: { line: lineStart, column: columnStart },
        end: { line: lineEnd, column: columnEnd }
      } = this.getLoc(this.ast);
      if (index === 0) {
        return {
          line: lineStart,
          column: columnStart
        };
      }
      if (index === this.text.length) {
        return {
          line: lineEnd,
          column: columnEnd
        };
      }
      __privateMethod(this, _TextSourceCodeBase_instances, ensureLineStartIndicesFromIndex_fn).call(this, index);
      const lineNumber = (index >= (__privateGet(this, _lineStartIndices).at(-1) ?? 0) ? __privateGet(this, _lineStartIndices).length : findLineNumberBinarySearch(__privateGet(this, _lineStartIndices), index)) - 1 + lineStart;
      return {
        line: lineNumber,
        column: index - __privateGet(this, _lineStartIndices)[lineNumber - lineStart] + columnStart
      };
    }
    /**
     * Converts a `{ line: number, column: number }` pair into a source text index.
     * @param {Object} loc A line/column location.
     * @param {number} loc.line The line number of the location. (0 or 1-indexed based on language.)
     * @param {number} loc.column The column number of the location. (0 or 1-indexed based on language.)
     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric
     * `line` and `column`, if the `line` is less than or equal to zero or
     * the `line` or `column` is out of the expected range.
     * @returns {number} The index of the line/column location in a file.
     * @public
     */
    getIndexFromLoc(loc) {
      if (loc === null || typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
        throw new TypeError(
          "Expected `loc` to be an object with numeric `line` and `column` properties."
        );
      }
      const {
        start: { line: lineStart, column: columnStart },
        end: { line: lineEnd, column: columnEnd }
      } = this.getLoc(this.ast);
      if (loc.line < lineStart || lineEnd < loc.line) {
        throw new RangeError(
          `Line number out of range (line ${loc.line} requested). Valid range: ${lineStart}-${lineEnd}`
        );
      }
      if (loc.line === lineStart && loc.column === columnStart) {
        return 0;
      }
      if (loc.line === lineEnd && loc.column === columnEnd) {
        return this.text.length;
      }
      __privateMethod(this, _TextSourceCodeBase_instances, ensureLineStartIndicesFromLoc_fn).call(this, loc, lineStart);
      const isLastLine = loc.line === lineEnd;
      const lineStartIndex = __privateGet(this, _lineStartIndices)[loc.line - lineStart];
      const lineEndIndex = isLastLine ? this.text.length : __privateGet(this, _lineStartIndices)[loc.line - lineStart + 1];
      const positionIndex = lineStartIndex + loc.column - columnStart;
      if (loc.column < columnStart || isLastLine && positionIndex > lineEndIndex || !isLastLine && positionIndex >= lineEndIndex) {
        throw new RangeError(
          `Column number out of range (column ${loc.column} requested). Valid range for line ${loc.line}: ${columnStart}-${lineEndIndex - lineStartIndex + columnStart + (isLastLine ? 0 : -1)}`
        );
      }
      return positionIndex;
    }
    /**
     * Returns the range information for the given node or token.
     * @param {Options['SyntaxElementWithLoc']} nodeOrToken The node or token to get the range information for.
     * @returns {SourceRange} The range information for the node or token.
     * @throws {Error} If the node or token does not have range information.
     */
    getRange(nodeOrToken) {
      if (hasESTreeStyleRange(nodeOrToken)) {
        return nodeOrToken.range;
      }
      if (hasPosStyleRange(nodeOrToken)) {
        return [
          nodeOrToken.position.start.offset,
          nodeOrToken.position.end.offset
        ];
      }
      throw new Error(
        "Custom getRange() method must be implemented in the subclass."
      );
    }
    /* eslint-disable no-unused-vars -- Required to complete interface. */
    /**
     * Returns the parent of the given node.
     * @param {Options['SyntaxElementWithLoc']} node The node to get the parent of.
     * @returns {Options['SyntaxElementWithLoc']|undefined} The parent of the node.
     * @throws {Error} If the method is not implemented in the subclass.
     */
    getParent(node2) {
      throw new Error("Not implemented.");
    }
    /* eslint-enable no-unused-vars -- Required to complete interface. */
    /**
     * Gets all the ancestors of a given node
     * @param {Options['SyntaxElementWithLoc']} node The node
     * @returns {Array<Options['SyntaxElementWithLoc']>} All the ancestor nodes in the AST, not including the provided node, starting
     * from the root node at index 0 and going inwards to the parent node.
     * @throws {TypeError} When `node` is missing.
     */
    getAncestors(node2) {
      if (!node2) {
        throw new TypeError("Missing required argument: node.");
      }
      const ancestorsStartingAtParent = [];
      for (let ancestor = this.getParent(node2); ancestor; ancestor = this.getParent(ancestor)) {
        ancestorsStartingAtParent.push(ancestor);
      }
      return ancestorsStartingAtParent.reverse();
    }
    /**
     * Gets the source code for the given node.
     * @param {Options['SyntaxElementWithLoc']} [node] The AST node to get the text for.
     * @param {number} [beforeCount] The number of characters before the node to retrieve.
     * @param {number} [afterCount] The number of characters after the node to retrieve.
     * @returns {string} The text representing the AST node.
     * @public
     */
    getText(node2, beforeCount, afterCount) {
      if (node2) {
        const range = this.getRange(node2);
        return this.text.slice(
          Math.max(range[0] - (beforeCount || 0), 0),
          range[1] + (afterCount || 0)
        );
      }
      return this.text;
    }
    /**
     * Gets the entire source text split into an array of lines.
     * @returns {Array<string>} The source text as an array of lines.
     * @public
     */
    get lines() {
      __privateMethod(this, _TextSourceCodeBase_instances, ensureLines_fn).call(this);
      return __privateGet(this, _lines);
    }
    /**
     * Traverse the source code and return the steps that were taken.
     * @returns {Iterable<TraversalStep>} The steps that were taken while traversing the source code.
     */
    traverse() {
      throw new Error("Not implemented.");
    }
  }
  _lines = new WeakMap();
  _lineStartIndices = new WeakMap();
  _lineEndingPattern = new WeakMap();
  _TextSourceCodeBase_instances = new WeakSet();
  /**
   * Finds the next line in the source text and updates `#lines` and `#lineStartIndices`.
   * @param {string} text The text to search for the next line.
   * @returns {boolean} `true` if a next line was found, `false` otherwise.
   */
  findNextLine_fn = function(text) {
    const match = __privateGet(this, _lineEndingPattern).exec(text);
    if (!match) {
      return false;
    }
    __privateGet(this, _lines).push(text.slice(0, match.index));
    __privateGet(this, _lineStartIndices).push(
      (__privateGet(this, _lineStartIndices).at(-1) ?? 0) + match.index + match[0].length
    );
    return true;
  };
  /**
   * Ensures `#lines` is lazily calculated from the source text.
   * @returns {void}
   */
  ensureLines_fn = function() {
    if (__privateGet(this, _lines).length === __privateGet(this, _lineStartIndices).length) {
      return;
    }
    while (__privateMethod(this, _TextSourceCodeBase_instances, findNextLine_fn).call(this, this.text.slice(__privateGet(this, _lineStartIndices).at(-1)))) {
    }
    __privateGet(this, _lines).push(this.text.slice(__privateGet(this, _lineStartIndices).at(-1)));
    Object.freeze(__privateGet(this, _lines));
  };
  /**
   * Ensures `#lineStartIndices` is lazily calculated up to the specified index.
   * @param {number} index The index of a character in a file.
   * @returns {void}
   */
  ensureLineStartIndicesFromIndex_fn = function(index) {
    if (index <= (__privateGet(this, _lineStartIndices).at(-1) ?? 0)) {
      return;
    }
    while (index > (__privateGet(this, _lineStartIndices).at(-1) ?? 0) && __privateMethod(this, _TextSourceCodeBase_instances, findNextLine_fn).call(this, this.text.slice(__privateGet(this, _lineStartIndices).at(-1)))) {
    }
  };
  /**
   * Ensures `#lineStartIndices` is lazily calculated up to the specified loc.
   * @param {Object} loc A line/column location.
   * @param {number} loc.line The line number of the location. (0 or 1-indexed based on language.)
   * @param {number} lineStart The line number at which the parser starts counting.
   * @returns {void}
   */
  ensureLineStartIndicesFromLoc_fn = function(loc, lineStart) {
    const nextLocLineIndex = loc.line - lineStart + 1;
    const lastCalculatedLineIndex = __privateGet(this, _lineStartIndices).length - 1;
    let additionalLinesNeeded = nextLocLineIndex - lastCalculatedLineIndex;
    if (additionalLinesNeeded <= 0) {
      return;
    }
    while (additionalLinesNeeded > 0 && __privateMethod(this, _TextSourceCodeBase_instances, findNextLine_fn).call(this, this.text.slice(__privateGet(this, _lineStartIndices).at(-1)))) {
      additionalLinesNeeded -= 1;
    }
  };
  cjs$2.CallMethodStep = CallMethodStep;
  cjs$2.ConfigCommentParser = ConfigCommentParser;
  cjs$2.Directive = Directive;
  cjs$2.TextSourceCodeBase = TextSourceCodeBase;
  cjs$2.VisitNodeStep = VisitNodeStep;
  return cjs$2;
}
var sourceCode$1;
var hasRequiredSourceCode$1;
function requireSourceCode$1() {
  var _steps;
  if (hasRequiredSourceCode$1) return sourceCode$1;
  hasRequiredSourceCode$1 = 1;
  const { isCommentToken } = /* @__PURE__ */ requireEslintUtils(), TokenStore = requireTokenStore(), astUtils2 = requireAstUtils$1(), Traverser = requireTraverser(), globals2 = requireGlobals(), { directivesPattern } = requireDirectives(), CodePathAnalyzer = requireCodePathAnalyzer(), {
    ConfigCommentParser,
    VisitNodeStep,
    CallMethodStep,
    Directive
  } = requireCjs$2(), eslintScope2 = requireEslintScope();
  const commentParser = new ConfigCommentParser();
  function validate2(ast2) {
    if (!ast2) {
      throw new TypeError(`Unexpected empty AST. (${ast2})`);
    }
    if (!ast2.tokens) {
      throw new TypeError("AST is missing the tokens array.");
    }
    if (!ast2.comments) {
      throw new TypeError("AST is missing the comments array.");
    }
    if (!ast2.loc) {
      throw new TypeError("AST is missing location information.");
    }
    if (!ast2.range) {
      throw new TypeError("AST is missing range information");
    }
  }
  function getGlobalsForEcmaVersion(ecmaVersion2) {
    switch (ecmaVersion2) {
      case 3:
        return globals2.es3;
      case 5:
        return globals2.es5;
      default:
        if (ecmaVersion2 < 2015) {
          return globals2[`es${ecmaVersion2 + 2009}`];
        }
        return globals2[`es${ecmaVersion2}`];
    }
  }
  function looksLikeExport(astNode) {
    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
  }
  function sortedMerge(tokens, comments) {
    const result = [];
    let tokenIndex = 0;
    let commentIndex = 0;
    while (tokenIndex < tokens.length || commentIndex < comments.length) {
      if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
        result.push(tokens[tokenIndex++]);
      } else {
        result.push(comments[commentIndex++]);
      }
    }
    return result;
  }
  function normalizeConfigGlobal(configuredValue) {
    switch (configuredValue) {
      case "off":
        return "off";
      case true:
      case "true":
      case "writeable":
      case "writable":
        return "writable";
      case null:
      case false:
      case "false":
      case "readable":
      case "readonly":
        return "readonly";
      default:
        throw new Error(
          `'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`
        );
    }
  }
  function nodesOrTokensOverlap(first, second) {
    return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];
  }
  function isSpaceBetween(sourceCode2, first, second, checkInsideOfJSXText) {
    if (nodesOrTokensOverlap(first, second)) {
      return false;
    }
    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];
    const firstToken = sourceCode2.getLastToken(startingNodeOrToken) || startingNodeOrToken;
    const finalToken = sourceCode2.getFirstToken(endingNodeOrToken) || endingNodeOrToken;
    let currentToken = firstToken;
    while (currentToken !== finalToken) {
      const nextToken = sourceCode2.getTokenAfter(currentToken, {
        includeComments: true
      });
      if (currentToken.range[1] !== nextToken.range[0] || /*
       * For backward compatibility, check spaces in JSXText.
       * https://github.com/eslint/eslint/issues/12614
       */
      checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === "JSXText" && /\s/u.test(nextToken.value)) {
        return true;
      }
      currentToken = nextToken;
    }
    return false;
  }
  function findLineNumberBinarySearch(lineStartIndices, target) {
    let low = 0;
    let high = lineStartIndices.length;
    while (low < high) {
      const mid = (low + high) / 2 | 0;
      if (target < lineStartIndices[mid]) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low;
  }
  function addDeclaredGlobals(globalScope, configGlobals = {}, inlineGlobals = {}) {
    for (const id2 of /* @__PURE__ */ new Set([
      ...Object.keys(configGlobals),
      ...Object.keys(inlineGlobals)
    ])) {
      const configValue = configGlobals[id2] === void 0 ? void 0 : normalizeConfigGlobal(configGlobals[id2]);
      const commentValue = inlineGlobals[id2] && inlineGlobals[id2].value;
      const value = commentValue || configValue;
      const sourceComments = inlineGlobals[id2] && inlineGlobals[id2].comments;
      if (value === "off") {
        continue;
      }
      let variable = globalScope.set.get(id2);
      if (!variable) {
        variable = new eslintScope2.Variable(id2, globalScope);
        globalScope.variables.push(variable);
        globalScope.set.set(id2, variable);
      }
      variable.eslintImplicitGlobalSetting = configValue;
      variable.eslintExplicitGlobal = sourceComments !== void 0;
      variable.eslintExplicitGlobalComments = sourceComments;
      variable.writeable = value === "writable";
    }
    globalScope.through = globalScope.through.filter((reference) => {
      const name2 = reference.identifier.name;
      const variable = globalScope.set.get(name2);
      if (variable) {
        reference.resolved = variable;
        variable.references.push(reference);
        return false;
      }
      return true;
    });
    const { implicit } = globalScope;
    if (typeof implicit === "object" && implicit !== null) {
      implicit.variables = implicit.variables.filter((variable) => {
        const name2 = variable.name;
        if (globalScope.set.has(name2)) {
          implicit.set.delete(name2);
          return false;
        }
        return true;
      });
      if (implicit.left) {
        implicit.left = implicit.left.filter(
          (reference) => !globalScope.set.has(reference.identifier.name)
        );
      }
    }
  }
  function markExportedVariables(globalScope, variables) {
    Object.keys(variables).forEach((name2) => {
      const variable = globalScope.set.get(name2);
      if (variable) {
        variable.eslintUsed = true;
        variable.eslintExported = true;
      }
    });
  }
  const caches = Symbol("caches");
  class SourceCode extends TokenStore {
    /**
     * Creates a new instance.
     * @param {string|Object} textOrConfig The source code text or config object.
     * @param {string} textOrConfig.text The source code text.
     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
     * @param {boolean} textOrConfig.hasBOM Indicates if the text has a Unicode BOM.
     * @param {Object|null} textOrConfig.parserServices The parser services.
     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.
     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.
     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
     */
    constructor(textOrConfig, astIfNoConfig) {
      let text, hasBOM, ast2, parserServices, scopeManager, visitorKeys;
      if (typeof textOrConfig === "string") {
        text = textOrConfig;
        ast2 = astIfNoConfig;
        hasBOM = false;
      } else if (typeof textOrConfig === "object" && textOrConfig !== null) {
        text = textOrConfig.text;
        ast2 = textOrConfig.ast;
        hasBOM = textOrConfig.hasBOM;
        parserServices = textOrConfig.parserServices;
        scopeManager = textOrConfig.scopeManager;
        visitorKeys = textOrConfig.visitorKeys;
      }
      validate2(ast2);
      super(ast2.tokens, ast2.comments);
      /**
       * The cache of steps that were taken while traversing the source code.
       * @type {Array<ITraversalStep>}
       */
      __privateAdd(this, _steps);
      this[caches] = /* @__PURE__ */ new Map([
        ["scopes", /* @__PURE__ */ new WeakMap()],
        ["vars", /* @__PURE__ */ new Map()],
        ["configNodes", void 0],
        ["isGlobalReference", /* @__PURE__ */ new WeakMap()]
      ]);
      this.isESTree = ast2.type === "Program";
      const textHasBOM = text.charCodeAt(0) === 65279;
      this.hasBOM = textHasBOM || !!hasBOM;
      this.text = textHasBOM ? text.slice(1) : text;
      this.ast = ast2;
      this.parserServices = parserServices || {};
      this.scopeManager = scopeManager || null;
      this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;
      const shebangMatched = this.text.match(astUtils2.shebangPattern);
      const hasShebang = shebangMatched && ast2.comments.length && ast2.comments[0].value === shebangMatched[1];
      if (hasShebang) {
        ast2.comments[0].type = "Shebang";
      }
      this.tokensAndComments = sortedMerge(ast2.tokens, ast2.comments);
      this.lines = [];
      this.lineStartIndices = [0];
      const lineEndingPattern = astUtils2.createGlobalLinebreakMatcher();
      let match;
      while (match = lineEndingPattern.exec(this.text)) {
        this.lines.push(
          this.text.slice(this.lineStartIndices.at(-1), match.index)
        );
        this.lineStartIndices.push(match.index + match[0].length);
      }
      this.lines.push(this.text.slice(this.lineStartIndices.at(-1)));
      Object.freeze(this);
      Object.freeze(this.lines);
    }
    /**
     * Split the source code into multiple lines based on the line delimiters.
     * @param {string} text Source code as a string.
     * @returns {string[]} Array of source code lines.
     * @public
     */
    static splitLines(text) {
      return text.split(astUtils2.createGlobalLinebreakMatcher());
    }
    /**
     * Gets the source code for the given node.
     * @param {ASTNode} [node] The AST node to get the text for.
     * @param {number} [beforeCount] The number of characters before the node to retrieve.
     * @param {number} [afterCount] The number of characters after the node to retrieve.
     * @returns {string} The text representing the AST node.
     * @public
     */
    getText(node2, beforeCount, afterCount) {
      if (node2) {
        return this.text.slice(
          Math.max(node2.range[0] - (beforeCount || 0), 0),
          node2.range[1] + (afterCount || 0)
        );
      }
      return this.text;
    }
    /**
     * Gets the entire source text split into an array of lines.
     * @returns {string[]} The source text as an array of lines.
     * @public
     */
    getLines() {
      return this.lines;
    }
    /**
     * Retrieves an array containing all comments in the source code.
     * @returns {ASTNode[]} An array of comment nodes.
     * @public
     */
    getAllComments() {
      return this.ast.comments;
    }
    /**
     * Retrieves the JSDoc comment for a given node.
     * @param {ASTNode} node The AST node to get the comment for.
     * @returns {Token|null} The Block comment token containing the JSDoc comment
     *      for the given node or null if not found.
     * @public
     * @deprecated
     */
    getJSDocComment(node2) {
      const findJSDocComment = (astNode) => {
        const tokenBefore = this.getTokenBefore(astNode, {
          includeComments: true
        });
        if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
          return tokenBefore;
        }
        return null;
      };
      let parent = node2.parent;
      switch (node2.type) {
        case "ClassDeclaration":
        case "FunctionDeclaration":
          return findJSDocComment(
            looksLikeExport(parent) ? parent : node2
          );
        case "ClassExpression":
          return findJSDocComment(parent.parent);
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
            while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
              parent = parent.parent;
              if (!parent) {
                break;
              }
            }
            if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
              return findJSDocComment(parent);
            }
          }
          return findJSDocComment(node2);
        default:
          return null;
      }
    }
    /**
     * Gets the deepest node containing a range index.
     * @param {number} index Range index of the desired node.
     * @returns {ASTNode} The node if found or null if not found.
     * @public
     */
    getNodeByRangeIndex(index) {
      let result = null;
      Traverser.traverse(this.ast, {
        visitorKeys: this.visitorKeys,
        enter(node2) {
          if (node2.range[0] <= index && index < node2.range[1]) {
            result = node2;
          } else {
            this.skip();
          }
        },
        leave(node2) {
          if (node2 === result) {
            this.break();
          }
        }
      });
      return result;
    }
    /**
     * Determines if two nodes or tokens have at least one whitespace character
     * between them. Order does not matter. Returns false if the given nodes or
     * tokens overlap.
     * @param {ASTNode|Token} first The first node or token to check between.
     * @param {ASTNode|Token} second The second node or token to check between.
     * @returns {boolean} True if there is a whitespace character between
     * any of the tokens found between the two given nodes or tokens.
     * @public
     */
    isSpaceBetween(first, second) {
      return isSpaceBetween(this, first, second, false);
    }
    /**
     * Determines if two nodes or tokens have at least one whitespace character
     * between them. Order does not matter. Returns false if the given nodes or
     * tokens overlap.
     * For backward compatibility, this method returns true if there are
     * `JSXText` tokens that contain whitespaces between the two.
     * @param {ASTNode|Token} first The first node or token to check between.
     * @param {ASTNode|Token} second The second node or token to check between.
     * @returns {boolean} True if there is a whitespace character between
     * any of the tokens found between the two given nodes or tokens.
     * @deprecated in favor of isSpaceBetween().
     * @public
     */
    isSpaceBetweenTokens(first, second) {
      return isSpaceBetween(this, first, second, true);
    }
    /**
     * Converts a source text index into a (line, column) pair.
     * @param {number} index The index of a character in a file.
     * @throws {TypeError|RangeError} If non-numeric index or index out of range.
     * @returns {{line: number, column: number}} A {line, column} location object with 1-indexed line and 0-indexed column.
     * @public
     */
    getLocFromIndex(index) {
      if (typeof index !== "number") {
        throw new TypeError("Expected `index` to be a number.");
      }
      if (index < 0 || index > this.text.length) {
        throw new RangeError(
          `Index out of range (requested index ${index}, but source text has length ${this.text.length}).`
        );
      }
      if (index === this.text.length) {
        return {
          line: this.lines.length,
          column: this.lines.at(-1).length
        };
      }
      const lineNumber = index >= this.lineStartIndices.at(-1) ? this.lineStartIndices.length : findLineNumberBinarySearch(this.lineStartIndices, index);
      return {
        line: lineNumber,
        column: index - this.lineStartIndices[lineNumber - 1]
      };
    }
    /**
     * Converts a (line, column) pair into a range index.
     * @param {Object} loc A line/column location
     * @param {number} loc.line The line number of the location (1-indexed)
     * @param {number} loc.column The column number of the location (0-indexed)
     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric
     *   `line` and `column`, if the `line` is less than or equal to zero or
     *   the line or column is out of the expected range.
     * @returns {number} The range index of the location in the file.
     * @public
     */
    getIndexFromLoc(loc) {
      if (loc === null || typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
        throw new TypeError(
          "Expected `loc` to be an object with numeric `line` and `column` properties."
        );
      }
      if (loc.line <= 0) {
        throw new RangeError(
          `Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`
        );
      }
      if (loc.line > this.lineStartIndices.length) {
        throw new RangeError(
          `Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`
        );
      }
      if (loc.column < 0) {
        throw new RangeError(
          `Invalid column number (column ${loc.column} requested).`
        );
      }
      const lineStartIndex = this.lineStartIndices[loc.line - 1];
      const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
      const positionIndex = lineStartIndex + loc.column;
      if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
        throw new RangeError(
          `Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`
        );
      }
      return positionIndex;
    }
    /**
     * Gets the scope for the given node
     * @param {ASTNode} currentNode The node to get the scope of
     * @returns {Scope} The scope information for this node
     * @throws {TypeError} If the `currentNode` argument is missing.
     */
    getScope(currentNode) {
      if (!currentNode) {
        throw new TypeError("Missing required argument: node.");
      }
      const cache2 = this[caches].get("scopes");
      const cachedScope = cache2.get(currentNode);
      if (cachedScope) {
        return cachedScope;
      }
      const inner = currentNode.type !== "Program";
      for (let node2 = currentNode; node2; node2 = node2.parent) {
        const scope = this.scopeManager.acquire(node2, inner);
        if (scope) {
          if (scope.type === "function-expression-name") {
            cache2.set(currentNode, scope.childScopes[0]);
            return scope.childScopes[0];
          }
          cache2.set(currentNode, scope);
          return scope;
        }
      }
      cache2.set(currentNode, this.scopeManager.scopes[0]);
      return this.scopeManager.scopes[0];
    }
    /**
     * Get the variables that `node` defines.
     * This is a convenience method that passes through
     * to the same method on the `scopeManager`.
     * @param {ASTNode} node The node for which the variables are obtained.
     * @returns {Array<Variable>} An array of variable nodes representing
     *      the variables that `node` defines.
     */
    getDeclaredVariables(node2) {
      return this.scopeManager.getDeclaredVariables(node2);
    }
    /* eslint-disable class-methods-use-this -- node is owned by SourceCode */
    /**
     * Gets all the ancestors of a given node
     * @param {ASTNode} node The node
     * @returns {Array<ASTNode>} All the ancestor nodes in the AST, not including the provided node, starting
     * from the root node at index 0 and going inwards to the parent node.
     * @throws {TypeError} When `node` is missing.
     */
    getAncestors(node2) {
      if (!node2) {
        throw new TypeError("Missing required argument: node.");
      }
      const ancestorsStartingAtParent = [];
      for (let ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
        ancestorsStartingAtParent.push(ancestor);
      }
      return ancestorsStartingAtParent.reverse();
    }
    /**
     * Determines whether the given identifier node is a reference to a global variable.
     * @param {ASTNode} node `Identifier` node to check.
     * @returns {boolean} True if the identifier is a reference to a global variable.
     */
    isGlobalReference(node2) {
      if (!node2) {
        throw new TypeError("Missing required argument: node.");
      }
      const cache2 = this[caches].get("isGlobalReference");
      if (cache2.has(node2)) {
        return cache2.get(node2);
      }
      if (node2.type !== "Identifier") {
        cache2.set(node2, false);
        return false;
      }
      const variable = this.scopeManager.scopes[0].set.get(node2.name);
      if (!variable || variable.defs.length > 0) {
        cache2.set(node2, false);
        return false;
      }
      const result = variable.references.some(
        ({ identifier }) => identifier === node2
      );
      cache2.set(node2, result);
      return result;
    }
    /**
     * Returns the location of the given node or token.
     * @param {ASTNode|Token} nodeOrToken The node or token to get the location of.
     * @returns {SourceLocation} The location of the node or token.
     */
    getLoc(nodeOrToken) {
      return nodeOrToken.loc;
    }
    /**
     * Returns the range of the given node or token.
     * @param {ASTNode|Token} nodeOrToken The node or token to get the range of.
     * @returns {[number, number]} The range of the node or token.
     */
    getRange(nodeOrToken) {
      return nodeOrToken.range;
    }
    /* eslint-enable class-methods-use-this -- node is owned by SourceCode */
    /**
     * Marks a variable as used in the current scope
     * @param {string} name The name of the variable to mark as used.
     * @param {ASTNode} [refNode] The closest node to the variable reference.
     * @returns {boolean} True if the variable was found and marked as used, false if not.
     */
    markVariableAsUsed(name2, refNode = this.ast) {
      const currentScope = this.getScope(refNode);
      let initialScope = currentScope;
      if (currentScope.type === "global" && currentScope.childScopes.length > 0 && // top-level scopes refer to a `Program` node
      currentScope.childScopes[0].block === this.ast) {
        initialScope = currentScope.childScopes[0];
      }
      for (let scope = initialScope; scope; scope = scope.upper) {
        const variable = scope.variables.find(
          (scopeVar) => scopeVar.name === name2
        );
        if (variable) {
          variable.eslintUsed = true;
          return true;
        }
      }
      return false;
    }
    /**
     * Returns an array of all inline configuration nodes found in the
     * source code.
     * @returns {Array<Token>} An array of all inline configuration nodes.
     */
    getInlineConfigNodes() {
      let configNodes = this[caches].get("configNodes");
      if (configNodes) {
        return configNodes;
      }
      configNodes = this.ast.comments.filter((comment2) => {
        if (comment2.type === "Shebang") {
          return false;
        }
        const directive = commentParser.parseDirective(comment2.value);
        if (!directive) {
          return false;
        }
        if (!directivesPattern.test(directive.label)) {
          return false;
        }
        return comment2.type !== "Line" || !!/^eslint-disable-(?:next-)?line$/u.test(directive.label);
      });
      this[caches].set("configNodes", configNodes);
      return configNodes;
    }
    /**
     * Returns an all directive nodes that enable or disable rules along with any problems
     * encountered while parsing the directives.
     * @returns {{problems:Array<Problem>,directives:Array<Directive>}} Information
     *      that ESLint needs to further process the directives.
     */
    getDisableDirectives() {
      const cachedDirectives = this[caches].get("disableDirectives");
      if (cachedDirectives) {
        return cachedDirectives;
      }
      const problems = [];
      const directives2 = [];
      this.getInlineConfigNodes().forEach((comment2) => {
        const {
          label,
          value,
          justification: justificationPart
        } = commentParser.parseDirective(comment2.value);
        const lineCommentSupported = /^eslint-disable-(?:next-)?line$/u.test(label);
        if (comment2.type === "Line" && !lineCommentSupported) {
          return;
        }
        if (label === "eslint-disable-line" && comment2.loc.start.line !== comment2.loc.end.line) {
          const message = `${label} comment should not span multiple lines.`;
          problems.push({
            ruleId: null,
            message,
            loc: comment2.loc
          });
          return;
        }
        switch (label) {
          case "eslint-disable":
          case "eslint-enable":
          case "eslint-disable-next-line":
          case "eslint-disable-line": {
            const directiveType = label.slice("eslint-".length);
            directives2.push(
              new Directive({
                type: directiveType,
                node: comment2,
                value,
                justification: justificationPart
              })
            );
          }
        }
      });
      const result = { problems, directives: directives2 };
      this[caches].set("disableDirectives", result);
      return result;
    }
    /**
     * Applies language options sent in from the core.
     * @param {Object} languageOptions The language options for this run.
     * @returns {void}
     */
    applyLanguageOptions(languageOptions) {
      const configGlobals = Object.assign(
        /* @__PURE__ */ Object.create(null),
        // https://github.com/eslint/eslint/issues/18363
        getGlobalsForEcmaVersion(languageOptions.ecmaVersion),
        languageOptions.sourceType === "commonjs" ? globals2.commonjs : void 0,
        languageOptions.globals
      );
      const varsCache = this[caches].get("vars");
      varsCache.set("configGlobals", configGlobals);
    }
    /**
     * Applies configuration found inside of the source code. This method is only
     * called when ESLint is running with inline configuration allowed.
     * @returns {{problems:Array<Problem>,configs:{config:FlatConfigArray,loc:Location}}} Information
     *      that ESLint needs to further process the inline configuration.
     */
    applyInlineConfig() {
      const problems = [];
      const configs = [];
      const exportedVariables = {};
      const inlineGlobals = /* @__PURE__ */ Object.create(null);
      this.getInlineConfigNodes().forEach((comment2) => {
        const { label, value } = commentParser.parseDirective(
          comment2.value
        );
        switch (label) {
          case "exported":
            Object.assign(
              exportedVariables,
              commentParser.parseListConfig(value)
            );
            break;
          case "globals":
          case "global":
            for (const [id2, idSetting] of Object.entries(
              commentParser.parseStringConfig(value)
            )) {
              let normalizedValue;
              try {
                normalizedValue = normalizeConfigGlobal(idSetting);
              } catch (err) {
                problems.push({
                  ruleId: null,
                  loc: comment2.loc,
                  message: err.message
                });
                continue;
              }
              if (inlineGlobals[id2]) {
                inlineGlobals[id2].comments.push(comment2);
                inlineGlobals[id2].value = normalizedValue;
              } else {
                inlineGlobals[id2] = {
                  comments: [comment2],
                  value: normalizedValue
                };
              }
            }
            break;
          case "eslint": {
            const parseResult = commentParser.parseJSONLikeConfig(value);
            if (parseResult.ok) {
              configs.push({
                config: {
                  rules: parseResult.config
                },
                loc: comment2.loc
              });
            } else {
              problems.push({
                ruleId: null,
                loc: comment2.loc,
                message: parseResult.error.message
              });
            }
            break;
          }
        }
      });
      const varsCache = this[caches].get("vars");
      varsCache.set("inlineGlobals", inlineGlobals);
      varsCache.set("exportedVariables", exportedVariables);
      return {
        configs,
        problems
      };
    }
    /**
     * Called by ESLint core to indicate that it has finished providing
     * information. We now add in all the missing variables and ensure that
     * state-changing methods cannot be called by rules.
     * @returns {void}
     */
    finalize() {
      const varsCache = this[caches].get("vars");
      const configGlobals = varsCache.get("configGlobals");
      const inlineGlobals = varsCache.get("inlineGlobals");
      const exportedVariables = varsCache.get("exportedVariables");
      const globalScope = this.scopeManager.scopes[0];
      addDeclaredGlobals(globalScope, configGlobals, inlineGlobals);
      if (exportedVariables) {
        markExportedVariables(globalScope, exportedVariables);
      }
    }
    /**
     * Traverse the source code and return the steps that were taken.
     * @returns {Array<TraversalStep>} The steps that were taken while traversing the source code.
     */
    traverse() {
      if (__privateGet(this, _steps)) {
        return __privateGet(this, _steps);
      }
      const steps = __privateSet(this, _steps, []);
      let analyzer = {
        enterNode(node2) {
          steps.push(
            new VisitNodeStep({
              target: node2,
              phase: 1,
              args: [node2]
            })
          );
        },
        leaveNode(node2) {
          steps.push(
            new VisitNodeStep({
              target: node2,
              phase: 2,
              args: [node2]
            })
          );
        },
        emit(eventName, args) {
          steps.push(
            new CallMethodStep({
              target: eventName,
              args
            })
          );
        }
      };
      if (this.isESTree) {
        analyzer = new CodePathAnalyzer(analyzer);
      }
      Traverser.traverse(this.ast, {
        enter(node2, parent) {
          node2.parent = parent;
          analyzer.enterNode(node2);
        },
        leave(node2) {
          analyzer.leaveNode(node2);
        },
        visitorKeys: this.visitorKeys
      });
      return steps;
    }
  }
  _steps = new WeakMap();
  sourceCode$1 = SourceCode;
  return sourceCode$1;
}
var sourceCode;
var hasRequiredSourceCode;
function requireSourceCode() {
  if (hasRequiredSourceCode) return sourceCode;
  hasRequiredSourceCode = 1;
  const SourceCode = requireSourceCode$1();
  sourceCode = {
    SourceCode
  };
  return sourceCode;
}
var escapeStringRegexp;
var hasRequiredEscapeStringRegexp;
function requireEscapeStringRegexp() {
  if (hasRequiredEscapeStringRegexp) return escapeStringRegexp;
  hasRequiredEscapeStringRegexp = 1;
  escapeStringRegexp = (string2) => {
    if (typeof string2 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  };
  return escapeStringRegexp;
}
var deepMergeArrays_1;
var hasRequiredDeepMergeArrays;
function requireDeepMergeArrays() {
  if (hasRequiredDeepMergeArrays) return deepMergeArrays_1;
  hasRequiredDeepMergeArrays = 1;
  function isObjectNotArray(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
  function deepMergeObjects(first, second) {
    if (second === void 0) {
      return first;
    }
    if (!isObjectNotArray(first) || !isObjectNotArray(second)) {
      return second;
    }
    const result = { ...first, ...second };
    for (const key of Object.keys(second)) {
      if (Object.prototype.propertyIsEnumerable.call(first, key)) {
        result[key] = deepMergeObjects(first[key], second[key]);
      }
    }
    return result;
  }
  function deepMergeArrays(first, second) {
    if (!first || !second) {
      return second || first || [];
    }
    return [
      ...first.map(
        (value, i2) => deepMergeObjects(value, i2 < second.length ? second[i2] : void 0)
      ),
      ...second.slice(first.length)
    ];
  }
  deepMergeArrays_1 = { deepMergeArrays };
  return deepMergeArrays_1;
}
var severity;
var hasRequiredSeverity;
function requireSeverity() {
  if (hasRequiredSeverity) return severity;
  hasRequiredSeverity = 1;
  function normalizeSeverityToString(severity2) {
    if ([2, "2", "error"].includes(severity2)) {
      return "error";
    }
    if ([1, "1", "warn"].includes(severity2)) {
      return "warn";
    }
    if ([0, "0", "off"].includes(severity2)) {
      return "off";
    }
    throw new Error(`Invalid severity value: ${severity2}`);
  }
  function normalizeSeverityToNumber(severity2) {
    if ([2, "2", "error"].includes(severity2)) {
      return 2;
    }
    if ([1, "1", "warn"].includes(severity2)) {
      return 1;
    }
    if ([0, "0", "off"].includes(severity2)) {
      return 0;
    }
    throw new Error(`Invalid severity value: ${severity2}`);
  }
  severity = {
    normalizeSeverityToString,
    normalizeSeverityToNumber
  };
  return severity;
}
var flatConfigSchema_1;
var hasRequiredFlatConfigSchema;
function requireFlatConfigSchema() {
  if (hasRequiredFlatConfigSchema) return flatConfigSchema_1;
  hasRequiredFlatConfigSchema = 1;
  const { normalizeSeverityToNumber } = requireSeverity();
  const ruleSeverities = /* @__PURE__ */ new Map([
    [0, 0],
    ["off", 0],
    [1, 1],
    ["warn", 1],
    [2, 2],
    ["error", 2]
  ]);
  function isNonNullObject(value) {
    return typeof value === "object" && value !== null;
  }
  function isNonArrayObject(value) {
    return isNonNullObject(value) && !Array.isArray(value);
  }
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  function deepMerge(first, second, mergeMap = /* @__PURE__ */ new Map()) {
    let secondMergeMap = mergeMap.get(first);
    if (secondMergeMap) {
      const result2 = secondMergeMap.get(second);
      if (result2) {
        return result2;
      }
    } else {
      secondMergeMap = /* @__PURE__ */ new Map();
      mergeMap.set(first, secondMergeMap);
    }
    const result = {
      ...first,
      ...second
    };
    delete result.__proto__;
    secondMergeMap.set(second, result);
    for (const key of Object.keys(second)) {
      if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(first, key)) {
        continue;
      }
      const firstValue = first[key];
      const secondValue = second[key];
      if (isNonArrayObject(firstValue) && isNonArrayObject(secondValue)) {
        result[key] = deepMerge(firstValue, secondValue, mergeMap);
      } else if (isUndefined(secondValue)) {
        result[key] = firstValue;
      }
    }
    return result;
  }
  function normalizeRuleOptions(ruleOptions) {
    const finalOptions = Array.isArray(ruleOptions) ? ruleOptions.slice(0) : [ruleOptions];
    finalOptions[0] = ruleSeverities.get(finalOptions[0]);
    return structuredClone(finalOptions);
  }
  function hasMethod(object) {
    for (const key of Object.keys(object)) {
      if (typeof object[key] === "function") {
        return true;
      }
    }
    return false;
  }
  class InvalidRuleOptionsError extends Error {
    /**
     * @param {string} ruleId Rule name being configured.
     * @param {any} value The invalid value.
     */
    constructor(ruleId, value) {
      super(
        `Key "${ruleId}": Expected severity of "off", 0, "warn", 1, "error", or 2.`
      );
      this.messageTemplate = "invalid-rule-options";
      this.messageData = { ruleId, value };
    }
  }
  function assertIsRuleOptions(ruleId, value) {
    if (typeof value !== "string" && typeof value !== "number" && !Array.isArray(value)) {
      throw new InvalidRuleOptionsError(ruleId, value);
    }
  }
  class InvalidRuleSeverityError extends Error {
    /**
     * @param {string} ruleId Rule name being configured.
     * @param {any} value The invalid value.
     */
    constructor(ruleId, value) {
      super(
        `Key "${ruleId}": Expected severity of "off", 0, "warn", 1, "error", or 2.`
      );
      this.messageTemplate = "invalid-rule-severity";
      this.messageData = { ruleId, value };
    }
  }
  function assertIsRuleSeverity(ruleId, value) {
    const severity2 = ruleSeverities.get(value);
    if (typeof severity2 === "undefined") {
      throw new InvalidRuleSeverityError(ruleId, value);
    }
  }
  function assertIsPluginMemberName(value) {
    if (!/[\w\-@$]+(?:\/[\w\-$]+)+$/iu.test(value)) {
      throw new TypeError(
        `Expected string in the form "pluginName/objectName" but found "${value}".`
      );
    }
  }
  function assertIsObject(value) {
    if (!isNonNullObject(value)) {
      throw new TypeError("Expected an object.");
    }
  }
  class IncompatibleKeyError extends Error {
    /**
     * @param {string} key The invalid key.
     */
    constructor(key) {
      super(
        "This appears to be in eslintrc format rather than flat config format."
      );
      this.messageTemplate = "eslintrc-incompat";
      this.messageData = { key };
    }
  }
  class IncompatiblePluginsError extends Error {
    /**
     * Creates a new instance.
     * @param {Array<string>} plugins The plugins array.
     */
    constructor(plugins) {
      super(
        "This appears to be in eslintrc format (array of strings) rather than flat config format (object)."
      );
      this.messageTemplate = "eslintrc-plugins";
      this.messageData = { plugins };
    }
  }
  const booleanSchema = {
    merge: "replace",
    validate: "boolean"
  };
  const ALLOWED_SEVERITIES = /* @__PURE__ */ new Set(["error", "warn", "off", 2, 1, 0]);
  const disableDirectiveSeveritySchema = {
    merge(first, second) {
      const value = second === void 0 ? first : second;
      if (typeof value === "boolean") {
        return value ? "warn" : "off";
      }
      return normalizeSeverityToNumber(value);
    },
    validate(value) {
      if (!(ALLOWED_SEVERITIES.has(value) || typeof value === "boolean")) {
        throw new TypeError(
          'Expected one of: "error", "warn", "off", 0, 1, 2, or a boolean.'
        );
      }
    }
  };
  const unusedInlineConfigsSeveritySchema = {
    merge(first, second) {
      const value = second === void 0 ? first : second;
      return normalizeSeverityToNumber(value);
    },
    validate(value) {
      if (!ALLOWED_SEVERITIES.has(value)) {
        throw new TypeError(
          'Expected one of: "error", "warn", "off", 0, 1, or 2.'
        );
      }
    }
  };
  const deepObjectAssignSchema = {
    merge(first = {}, second = {}) {
      return deepMerge(first, second);
    },
    validate: "object"
  };
  const languageOptionsSchema = {
    merge(first = {}, second = {}) {
      const result = deepMerge(first, second);
      for (const [key, value] of Object.entries(result)) {
        if (isNonArrayObject(value)) {
          if (hasMethod(value)) {
            result[key] = second[key] ?? first[key];
            continue;
          }
          result[key] = { ...result[key] };
          continue;
        }
      }
      return result;
    },
    validate: "object"
  };
  const languageSchema = {
    merge: "replace",
    validate: assertIsPluginMemberName
  };
  const pluginsSchema = {
    merge(first = {}, second = {}) {
      const keys2 = /* @__PURE__ */ new Set([...Object.keys(first), ...Object.keys(second)]);
      const result = {};
      for (const key of keys2) {
        if (key === "__proto__") {
          continue;
        }
        if (key in first && key in second && first[key] !== second[key]) {
          throw new TypeError(`Cannot redefine plugin "${key}".`);
        }
        result[key] = second[key] || first[key];
      }
      return result;
    },
    validate(value) {
      if (value === null || typeof value !== "object") {
        throw new TypeError("Expected an object.");
      }
      if (Array.isArray(value)) {
        throw new IncompatiblePluginsError(value);
      }
      for (const key of Object.keys(value)) {
        if (key === "__proto__") {
          continue;
        }
        if (value[key] === null || typeof value[key] !== "object") {
          throw new TypeError(`Key "${key}": Expected an object.`);
        }
      }
    }
  };
  const processorSchema = {
    merge: "replace",
    validate(value) {
      if (typeof value === "string") {
        assertIsPluginMemberName(value);
      } else if (value && typeof value === "object") {
        if (typeof value.preprocess !== "function" || typeof value.postprocess !== "function") {
          throw new TypeError(
            "Object must have a preprocess() and a postprocess() method."
          );
        }
      } else {
        throw new TypeError("Expected an object or a string.");
      }
    }
  };
  const rulesSchema = {
    merge(first = {}, second = {}) {
      const result = {
        ...first,
        ...second
      };
      for (const ruleId of Object.keys(result)) {
        try {
          if (ruleId === "__proto__") {
            delete result.__proto__;
            continue;
          }
          result[ruleId] = normalizeRuleOptions(result[ruleId]);
          if (!(ruleId in first) || !(ruleId in second)) {
            continue;
          }
          const firstRuleOptions = normalizeRuleOptions(first[ruleId]);
          const secondRuleOptions = normalizeRuleOptions(second[ruleId]);
          if (secondRuleOptions.length === 1) {
            result[ruleId] = [
              secondRuleOptions[0],
              ...firstRuleOptions.slice(1)
            ];
            continue;
          }
        } catch (ex) {
          throw new Error(`Key "${ruleId}": ${ex.message}`, {
            cause: ex
          });
        }
      }
      return result;
    },
    validate(value) {
      assertIsObject(value);
      for (const ruleId of Object.keys(value)) {
        if (ruleId === "__proto__") {
          continue;
        }
        const ruleOptions = value[ruleId];
        assertIsRuleOptions(ruleId, ruleOptions);
        if (Array.isArray(ruleOptions)) {
          assertIsRuleSeverity(ruleId, ruleOptions[0]);
        } else {
          assertIsRuleSeverity(ruleId, ruleOptions);
        }
      }
    }
  };
  function createEslintrcErrorSchema(key) {
    return {
      merge: "replace",
      validate() {
        throw new IncompatibleKeyError(key);
      }
    };
  }
  const eslintrcKeys = [
    "env",
    "extends",
    "globals",
    "ignorePatterns",
    "noInlineConfig",
    "overrides",
    "parser",
    "parserOptions",
    "reportUnusedDisableDirectives",
    "root"
  ];
  const flatConfigSchema = {
    // eslintrc-style keys that should always error
    ...Object.fromEntries(
      eslintrcKeys.map((key) => [key, createEslintrcErrorSchema(key)])
    ),
    // flat config keys
    settings: deepObjectAssignSchema,
    linterOptions: {
      schema: {
        noInlineConfig: booleanSchema,
        reportUnusedDisableDirectives: disableDirectiveSeveritySchema,
        reportUnusedInlineConfigs: unusedInlineConfigsSeveritySchema
      }
    },
    language: languageSchema,
    languageOptions: languageOptionsSchema,
    processor: processorSchema,
    plugins: pluginsSchema,
    rules: rulesSchema
  };
  flatConfigSchema_1 = {
    flatConfigSchema,
    hasMethod,
    assertIsRuleSeverity
  };
  return flatConfigSchema_1;
}
var cjs$1 = {};
var posix = {};
var hasRequiredPosix;
function requirePosix() {
  if (hasRequiredPosix) return posix;
  hasRequiredPosix = 1;
  function assertPath(path) {
    if (typeof path !== "string") {
      throw new TypeError(`Path must be a string, received "${JSON.stringify(path)}"`);
    }
  }
  function stripSuffix(name2, suffix) {
    if (suffix.length >= name2.length) {
      return name2;
    }
    const lenDiff = name2.length - suffix.length;
    for (let i2 = suffix.length - 1; i2 >= 0; --i2) {
      if (name2.charCodeAt(lenDiff + i2) !== suffix.charCodeAt(i2)) {
        return name2;
      }
    }
    return name2.slice(0, -suffix.length);
  }
  function lastPathSegment(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for (let i2 = path.length - 1; i2 >= start; --i2) {
      if (isSep(path.charCodeAt(i2))) {
        if (matchedNonSeparator) {
          start = i2 + 1;
          break;
        }
      } else if (!matchedNonSeparator) {
        matchedNonSeparator = true;
        end = i2 + 1;
      }
    }
    return path.slice(start, end);
  }
  function assertArgs$1(path, suffix) {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
      throw new TypeError(`Suffix must be a string, received "${JSON.stringify(suffix)}"`);
    }
  }
  function assertArg$3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol !== "file:") {
      throw new TypeError(`URL must be a file URL: received "${url.protocol}"`);
    }
    return url;
  }
  function fromFileUrl(url) {
    url = assertArg$3(url);
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
  }
  function stripTrailingSeparators(segment, isSep) {
    if (segment.length <= 1) {
      return segment;
    }
    let end = segment.length;
    for (let i2 = segment.length - 1; i2 > 0; i2--) {
      if (isSep(segment.charCodeAt(i2))) {
        end = i2;
      } else {
        break;
      }
    }
    return segment.slice(0, end);
  }
  const CHAR_DOT = 46;
  const CHAR_FORWARD_SLASH = 47;
  function isPosixPathSeparator(code2) {
    return code2 === CHAR_FORWARD_SLASH;
  }
  function basename2(path, suffix = "") {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertArgs$1(path, suffix);
    const lastSegment = lastPathSegment(path, isPosixPathSeparator);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
  }
  const DELIMITER = ":";
  const SEPARATOR = "/";
  const SEPARATOR_PATTERN = /\/+/;
  function assertArg$2(path) {
    assertPath(path);
    if (path.length === 0) return ".";
  }
  function dirname2(path) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertArg$2(path);
    let end = -1;
    let matchedNonSeparator = false;
    for (let i2 = path.length - 1; i2 >= 1; --i2) {
      if (isPosixPathSeparator(path.charCodeAt(i2))) {
        if (matchedNonSeparator) {
          end = i2;
          break;
        }
      } else {
        matchedNonSeparator = true;
      }
    }
    if (end === -1) {
      return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
  }
  function extname2(path) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i2 = path.length - 1; i2 >= 0; --i2) {
      const code2 = path.charCodeAt(i2);
      if (isPosixPathSeparator(code2)) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) startDot = i2;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  }
  function _format(sep2, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base2 = pathObject.base || (pathObject.name ?? "") + (pathObject.ext ?? "");
    if (!dir) return base2;
    if (base2 === sep2) return dir;
    if (dir === pathObject.root) return dir + base2;
    return dir + sep2 + base2;
  }
  function assertArg$1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError(`The "pathObject" argument must be of type Object, received type "${typeof pathObject}"`);
    }
  }
  function format2(pathObject) {
    assertArg$1(pathObject);
    return _format("/", pathObject);
  }
  function isAbsolute2(path) {
    assertPath(path);
    return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
  }
  function assertArg(path) {
    assertPath(path);
    if (path.length === 0) return ".";
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code2;
    for (let i2 = 0; i2 <= path.length; ++i2) {
      if (i2 < path.length) code2 = path.charCodeAt(i2);
      else if (isPathSeparator(code2)) break;
      else code2 = CHAR_FORWARD_SLASH;
      if (isPathSeparator(code2)) {
        if (lastSlash === i2 - 1 || dots === 1) ;
        else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i2;
              dots = 0;
              continue;
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) res += `${separator}..`;
            else res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += separator + path.slice(lastSlash + 1, i2);
          else res = path.slice(lastSlash + 1, i2);
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code2 === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function normalize2(path) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertArg(path);
    const isAbsolute3 = isPosixPathSeparator(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
    path = normalizeString(path, !isAbsolute3, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute3) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute3) return `/${path}`;
    return path;
  }
  function join2(path, ...paths) {
    if (path === void 0) return ".";
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    paths = path ? [
      path,
      ...paths
    ] : paths;
    paths.forEach((path2) => assertPath(path2));
    const joined = paths.filter((path2) => path2.length > 0).join("/");
    return joined === "" ? "." : normalize2(joined);
  }
  function parse(path) {
    assertPath(path);
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute3 = isPosixPathSeparator(path.charCodeAt(0));
    let start;
    if (isAbsolute3) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path.length - 1;
    let preDotState = 0;
    for (; i2 >= start; --i2) {
      const code2 = path.charCodeAt(i2);
      if (isPosixPathSeparator(code2)) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) startDot = i2;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute3) {
          ret.base = ret.name = path.slice(1, end);
        } else {
          ret.base = ret.name = path.slice(startPart, end);
        }
      }
      ret.base = ret.base || "/";
    } else {
      if (startPart === 0 && isAbsolute3) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
      ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);
    } else if (isAbsolute3) ret.dir = "/";
    return ret;
  }
  function resolve2(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      let path;
      if (i2 >= 0) path = pathSegments[i2];
      else {
        const { Deno } = globalThis;
        if (typeof (Deno == null ? void 0 : Deno.cwd) !== "function") {
          throw new TypeError("Resolved a relative path without a current working directory (CWD)");
        }
        path = Deno.cwd();
      }
      assertPath(path);
      if (path.length === 0) {
        continue;
      }
      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) return `/${resolvedPath}`;
      else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
  }
  function assertArgs(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
  }
  function relative2(from, to) {
    assertArgs(from, to);
    from = resolve2(from);
    to = resolve2(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for (; fromStart < fromEnd; ++fromStart) {
      if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for (; toStart < toEnd; ++toStart) {
      if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for (; i2 <= length; ++i2) {
      if (i2 === length) {
        if (toLen > length) {
          if (isPosixPathSeparator(to.charCodeAt(toStart + i2))) {
            return to.slice(toStart + i2 + 1);
          } else if (i2 === 0) {
            return to.slice(toStart + i2);
          }
        } else if (fromLen > length) {
          if (isPosixPathSeparator(from.charCodeAt(fromStart + i2))) {
            lastCommonSep = i2;
          } else if (i2 === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i2);
      const toCode = to.charCodeAt(toStart + i2);
      if (fromCode !== toCode) break;
      else if (isPosixPathSeparator(fromCode)) lastCommonSep = i2;
    }
    let out = "";
    for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
      if (i2 === fromEnd || isPosixPathSeparator(from.charCodeAt(i2))) {
        if (out.length === 0) out += "..";
        else out += "/..";
      }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
      return to.slice(toStart);
    }
  }
  const WHITESPACE_ENCODINGS = {
    "	": "%09",
    "\n": "%0A",
    "\v": "%0B",
    "\f": "%0C",
    "\r": "%0D",
    " ": "%20"
  };
  function encodeWhitespace(string2) {
    return string2.replaceAll(/[\s]/g, (c2) => {
      return WHITESPACE_ENCODINGS[c2] ?? c2;
    });
  }
  function toFileUrl(path) {
    if (!isAbsolute2(path)) {
      throw new TypeError(`Path must be absolute: received "${path}"`);
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
  }
  function toNamespacedPath(path) {
    return path;
  }
  function common$1(paths, sep2) {
    const [first = "", ...remaining] = paths;
    const parts = first.split(sep2);
    let endOfPrefix = parts.length;
    let append = "";
    for (const path of remaining) {
      const compare2 = path.split(sep2);
      if (compare2.length <= endOfPrefix) {
        endOfPrefix = compare2.length;
        append = "";
      }
      for (let i2 = 0; i2 < endOfPrefix; i2++) {
        if (compare2[i2] !== parts[i2]) {
          endOfPrefix = i2;
          append = i2 === 0 ? "" : sep2;
          break;
        }
      }
    }
    return parts.slice(0, endOfPrefix).join(sep2) + append;
  }
  function common2(paths) {
    return common$1(paths, SEPARATOR);
  }
  const REG_EXP_ESCAPE_CHARS = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
  ];
  const RANGE_ESCAPE_CHARS = [
    "-",
    "\\",
    "]"
  ];
  function _globToRegExp(c2, glob, {
    extended = true,
    globstar: globstarOption = true,
    // os = osType,
    caseInsensitive = false
  } = {}) {
    if (glob === "") {
      return /(?!)/;
    }
    let newLength = glob.length;
    for (; newLength > 1 && c2.seps.includes(glob[newLength - 1]); newLength--) ;
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for (let j = 0; j < glob.length; ) {
      let segment = "";
      const groupStack = [];
      let inRange = false;
      let inEscape = false;
      let endsWithSep = false;
      let i2 = j;
      for (; i2 < glob.length && !c2.seps.includes(glob[i2]); i2++) {
        if (inEscape) {
          inEscape = false;
          const escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;
          segment += escapeChars.includes(glob[i2]) ? `\\${glob[i2]}` : glob[i2];
          continue;
        }
        if (glob[i2] === c2.escapePrefix) {
          inEscape = true;
          continue;
        }
        if (glob[i2] === "[") {
          if (!inRange) {
            inRange = true;
            segment += "[";
            if (glob[i2 + 1] === "!") {
              i2++;
              segment += "^";
            } else if (glob[i2 + 1] === "^") {
              i2++;
              segment += "\\^";
            }
            continue;
          } else if (glob[i2 + 1] === ":") {
            let k = i2 + 1;
            let value = "";
            while (glob[k + 1] !== void 0 && glob[k + 1] !== ":") {
              value += glob[k + 1];
              k++;
            }
            if (glob[k + 1] === ":" && glob[k + 2] === "]") {
              i2 = k + 2;
              if (value === "alnum") segment += "\\dA-Za-z";
              else if (value === "alpha") segment += "A-Za-z";
              else if (value === "ascii") segment += "\0-";
              else if (value === "blank") segment += "	 ";
              else if (value === "cntrl") segment += "\0-";
              else if (value === "digit") segment += "\\d";
              else if (value === "graph") segment += "!-~";
              else if (value === "lower") segment += "a-z";
              else if (value === "print") segment += " -~";
              else if (value === "punct") {
                segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~`;
              } else if (value === "space") segment += "\\s\v";
              else if (value === "upper") segment += "A-Z";
              else if (value === "word") segment += "\\w";
              else if (value === "xdigit") segment += "\\dA-Fa-f";
              continue;
            }
          }
        }
        if (glob[i2] === "]" && inRange) {
          inRange = false;
          segment += "]";
          continue;
        }
        if (inRange) {
          segment += glob[i2];
          continue;
        }
        if (glob[i2] === ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
          segment += ")";
          const type2 = groupStack.pop();
          if (type2 === "!") {
            segment += c2.wildcard;
          } else if (type2 !== "@") {
            segment += type2;
          }
          continue;
        }
        if (glob[i2] === "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
          segment += "|";
          continue;
        }
        if (glob[i2] === "+" && extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("+");
          segment += "(?:";
          continue;
        }
        if (glob[i2] === "@" && extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("@");
          segment += "(?:";
          continue;
        }
        if (glob[i2] === "?") {
          if (extended && glob[i2 + 1] === "(") {
            i2++;
            groupStack.push("?");
            segment += "(?:";
          } else {
            segment += ".";
          }
          continue;
        }
        if (glob[i2] === "!" && extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("!");
          segment += "(?!";
          continue;
        }
        if (glob[i2] === "{") {
          groupStack.push("BRACE");
          segment += "(?:";
          continue;
        }
        if (glob[i2] === "}" && groupStack[groupStack.length - 1] === "BRACE") {
          groupStack.pop();
          segment += ")";
          continue;
        }
        if (glob[i2] === "," && groupStack[groupStack.length - 1] === "BRACE") {
          segment += "|";
          continue;
        }
        if (glob[i2] === "*") {
          if (extended && glob[i2 + 1] === "(") {
            i2++;
            groupStack.push("*");
            segment += "(?:";
          } else {
            const prevChar2 = glob[i2 - 1];
            let numStars = 1;
            while (glob[i2 + 1] === "*") {
              i2++;
              numStars++;
            }
            const nextChar2 = glob[i2 + 1];
            if (globstarOption && numStars === 2 && [
              ...c2.seps,
              void 0
            ].includes(prevChar2) && [
              ...c2.seps,
              void 0
            ].includes(nextChar2)) {
              segment += c2.globstar;
              endsWithSep = true;
            } else {
              segment += c2.wildcard;
            }
          }
          continue;
        }
        segment += REG_EXP_ESCAPE_CHARS.includes(glob[i2]) ? `\\${glob[i2]}` : glob[i2];
      }
      if (groupStack.length > 0 || inRange || inEscape) {
        segment = "";
        for (const c3 of glob.slice(j, i2)) {
          segment += REG_EXP_ESCAPE_CHARS.includes(c3) ? `\\${c3}` : c3;
          endsWithSep = false;
        }
      }
      regExpString += segment;
      if (!endsWithSep) {
        regExpString += i2 < glob.length ? c2.sep : c2.sepMaybe;
        endsWithSep = true;
      }
      while (c2.seps.includes(glob[i2])) i2++;
      j = i2;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
  }
  const constants = {
    sep: "/+",
    sepMaybe: "/*",
    seps: [
      "/"
    ],
    globstar: "(?:[^/]*(?:/|$)+)*",
    wildcard: "[^/]*",
    escapePrefix: "\\"
  };
  function globToRegExp(glob, options = {}) {
    return _globToRegExp(constants, glob, options);
  }
  function isGlob(str) {
    const chars = {
      "{": "}",
      "(": ")",
      "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^[\\\]]+\]|\{[^{\\}]+\}|\(\?[:!=][^\\)]+\)|\([^(|]+\|[^\\)]+\))/;
    if (str === "") {
      return false;
    }
    let match;
    while (match = regex.exec(str)) {
      if (match[2]) return true;
      let idx = match.index + match[0].length;
      const open = match[1];
      const close = open ? chars[open] : null;
      if (open && close) {
        const n2 = str.indexOf(close, idx);
        if (n2 !== -1) {
          idx = n2 + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  }
  function normalizeGlob(glob, options = {}) {
    const { globstar = false } = options;
    if (glob.match(/\0/g)) {
      throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
      return normalize2(glob);
    }
    const s2 = SEPARATOR_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s2}|^)\\*\\*${s2})\\.\\.(?=${s2}|$)`, "g");
    return normalize2(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
  }
  function joinGlobs(globs, options = {}) {
    const { globstar = false } = options;
    if (!globstar || globs.length === 0) {
      return join2(...globs);
    }
    let joined;
    for (const glob of globs) {
      const path = glob;
      if (path.length > 0) {
        if (!joined) joined = path;
        else joined += `${SEPARATOR}${path}`;
      }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
      globstar
    });
  }
  posix.DELIMITER = DELIMITER;
  posix.SEPARATOR = SEPARATOR;
  posix.SEPARATOR_PATTERN = SEPARATOR_PATTERN;
  posix.basename = basename2;
  posix.common = common2;
  posix.dirname = dirname2;
  posix.extname = extname2;
  posix.format = format2;
  posix.fromFileUrl = fromFileUrl;
  posix.globToRegExp = globToRegExp;
  posix.isAbsolute = isAbsolute2;
  posix.isGlob = isGlob;
  posix.join = join2;
  posix.joinGlobs = joinGlobs;
  posix.normalize = normalize2;
  posix.normalizeGlob = normalizeGlob;
  posix.parse = parse;
  posix.relative = relative2;
  posix.resolve = resolve2;
  posix.toFileUrl = toFileUrl;
  posix.toNamespacedPath = toNamespacedPath;
  return posix;
}
var windows = {};
var hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1;
  function assertPath(path) {
    if (typeof path !== "string") {
      throw new TypeError(`Path must be a string, received "${JSON.stringify(path)}"`);
    }
  }
  function stripSuffix(name2, suffix) {
    if (suffix.length >= name2.length) {
      return name2;
    }
    const lenDiff = name2.length - suffix.length;
    for (let i2 = suffix.length - 1; i2 >= 0; --i2) {
      if (name2.charCodeAt(lenDiff + i2) !== suffix.charCodeAt(i2)) {
        return name2;
      }
    }
    return name2.slice(0, -suffix.length);
  }
  function lastPathSegment(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for (let i2 = path.length - 1; i2 >= start; --i2) {
      if (isSep(path.charCodeAt(i2))) {
        if (matchedNonSeparator) {
          start = i2 + 1;
          break;
        }
      } else if (!matchedNonSeparator) {
        matchedNonSeparator = true;
        end = i2 + 1;
      }
    }
    return path.slice(start, end);
  }
  function assertArgs$1(path, suffix) {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
      throw new TypeError(`Suffix must be a string, received "${JSON.stringify(suffix)}"`);
    }
  }
  const CHAR_UPPERCASE_A = 65;
  const CHAR_LOWERCASE_A = 97;
  const CHAR_UPPERCASE_Z = 90;
  const CHAR_LOWERCASE_Z = 122;
  const CHAR_DOT = 46;
  const CHAR_FORWARD_SLASH = 47;
  const CHAR_BACKWARD_SLASH = 92;
  const CHAR_COLON = 58;
  const CHAR_QUESTION_MARK = 63;
  function stripTrailingSeparators(segment, isSep) {
    if (segment.length <= 1) {
      return segment;
    }
    let end = segment.length;
    for (let i2 = segment.length - 1; i2 > 0; i2--) {
      if (isSep(segment.charCodeAt(i2))) {
        end = i2;
      } else {
        break;
      }
    }
    return segment.slice(0, end);
  }
  function isPosixPathSeparator(code2) {
    return code2 === CHAR_FORWARD_SLASH;
  }
  function isPathSeparator(code2) {
    return code2 === CHAR_FORWARD_SLASH || code2 === CHAR_BACKWARD_SLASH;
  }
  function isWindowsDeviceRoot(code2) {
    return code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z || code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z;
  }
  function assertArg$3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol !== "file:") {
      throw new TypeError(`URL must be a file URL: received "${url.protocol}"`);
    }
    return url;
  }
  function fromFileUrl(url) {
    url = assertArg$3(url);
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname !== "") {
      path = `\\\\${url.hostname}${path}`;
    }
    return path;
  }
  function basename2(path, suffix = "") {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertArgs$1(path, suffix);
    let start = 0;
    if (path.length >= 2) {
      const drive = path.charCodeAt(0);
      if (isWindowsDeviceRoot(drive)) {
        if (path.charCodeAt(1) === CHAR_COLON) start = 2;
      }
    }
    const lastSegment = lastPathSegment(path, isPathSeparator, start);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
  }
  const DELIMITER = ";";
  const SEPARATOR = "\\";
  const SEPARATOR_PATTERN = /[\\/]+/;
  function assertArg$2(path) {
    assertPath(path);
    if (path.length === 0) return ".";
  }
  function dirname2(path) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertArg$2(path);
    const len = path.length;
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code2 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        rootEnd = offset = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j === len) {
                return path;
              }
              if (j !== last) {
                rootEnd = offset = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path.charCodeAt(1) === CHAR_COLON) {
          rootEnd = offset = 2;
          if (len > 2) {
            if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      return path;
    }
    for (let i2 = len - 1; i2 >= offset; --i2) {
      if (isPathSeparator(path.charCodeAt(i2))) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) {
      if (rootEnd === -1) return ".";
      else end = rootEnd;
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
  }
  function extname2(path) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }
    for (let i2 = path.length - 1; i2 >= start; --i2) {
      const code2 = path.charCodeAt(i2);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) startDot = i2;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  }
  function _format(sep2, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base2 = pathObject.base || (pathObject.name ?? "") + (pathObject.ext ?? "");
    if (!dir) return base2;
    if (base2 === sep2) return dir;
    if (dir === pathObject.root) return dir + base2;
    return dir + sep2 + base2;
  }
  function assertArg$1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError(`The "pathObject" argument must be of type Object, received type "${typeof pathObject}"`);
    }
  }
  function format2(pathObject) {
    assertArg$1(pathObject);
    return _format("\\", pathObject);
  }
  function isAbsolute2(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code2 = path.charCodeAt(0);
    if (isPathSeparator(code2)) {
      return true;
    } else if (isWindowsDeviceRoot(code2)) {
      if (len > 2 && path.charCodeAt(1) === CHAR_COLON) {
        if (isPathSeparator(path.charCodeAt(2))) return true;
      }
    }
    return false;
  }
  function assertArg(path) {
    assertPath(path);
    if (path.length === 0) return ".";
  }
  function normalizeString(path, allowAboveRoot, separator, isPathSeparator2) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code2;
    for (let i2 = 0; i2 <= path.length; ++i2) {
      if (i2 < path.length) code2 = path.charCodeAt(i2);
      else if (isPathSeparator2(code2)) break;
      else code2 = CHAR_FORWARD_SLASH;
      if (isPathSeparator2(code2)) {
        if (lastSlash === i2 - 1 || dots === 1) ;
        else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf(separator);
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
              }
              lastSlash = i2;
              dots = 0;
              continue;
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i2;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) res += `${separator}..`;
            else res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += separator + path.slice(lastSlash + 1, i2);
          else res = path.slice(lastSlash + 1, i2);
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code2 === CHAR_DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function normalize2(path) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    assertArg(path);
    const len = path.length;
    let rootEnd = 0;
    let device;
    let isAbsolute3 = false;
    const code2 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        isAbsolute3 = true;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j === len) {
                return `\\\\${firstPart}\\${path.slice(last)}\\`;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path.charCodeAt(1) === CHAR_COLON) {
          device = path.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path.charCodeAt(2))) {
              isAbsolute3 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      return "\\";
    }
    let tail;
    if (rootEnd < len) {
      tail = normalizeString(path.slice(rootEnd), !isAbsolute3, "\\", isPathSeparator);
    } else {
      tail = "";
    }
    if (tail.length === 0 && !isAbsolute3) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
      tail += "\\";
    }
    if (device === void 0) {
      if (isAbsolute3) {
        if (tail.length > 0) return `\\${tail}`;
        else return "\\";
      }
      return tail;
    } else if (isAbsolute3) {
      if (tail.length > 0) return `${device}\\${tail}`;
      else return `${device}\\`;
    }
    return device + tail;
  }
  function join2(path, ...paths) {
    if (path instanceof URL) {
      path = fromFileUrl(path);
    }
    paths = path ? [
      path,
      ...paths
    ] : paths;
    paths.forEach((path2) => assertPath(path2));
    paths = paths.filter((path2) => path2.length > 0);
    if (paths.length === 0) return ".";
    let needsReplace = true;
    let slashCount = 0;
    const firstPart = paths[0];
    if (isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1) {
        if (isPathSeparator(firstPart.charCodeAt(1))) {
          ++slashCount;
          if (firstLen > 2) {
            if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
            else {
              needsReplace = false;
            }
          }
        }
      }
    }
    let joined = paths.join("\\");
    if (needsReplace) {
      for (; slashCount < joined.length; ++slashCount) {
        if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
      }
      if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize2(joined);
  }
  function parse(path) {
    assertPath(path);
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code2 = path.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        rootEnd = 1;
        if (isPathSeparator(path.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path.charCodeAt(j))) break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j === len) {
                rootEnd = j;
              } else if (j !== last) {
                rootEnd = j + 1;
              }
            }
          }
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path.charCodeAt(1) === CHAR_COLON) {
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path.charCodeAt(2))) {
              if (len === 3) {
                ret.root = ret.dir = path;
                ret.base = "\\";
                return ret;
              }
              rootEnd = 3;
            }
          } else {
            ret.root = ret.dir = path;
            return ret;
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      ret.root = ret.dir = path;
      ret.base = "\\";
      return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i2 = path.length - 1;
    let preDotState = 0;
    for (; i2 >= rootEnd; --i2) {
      code2 = path.charCodeAt(i2);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code2 === CHAR_DOT) {
        if (startDot === -1) startDot = i2;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      ret.name = path.slice(startPart, startDot);
      ret.base = path.slice(startPart, end);
      ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
      ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
  }
  function resolve2(...pathSegments) {
    var _a2;
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
      let path;
      const { Deno } = globalThis;
      if (i2 >= 0) {
        path = pathSegments[i2];
      } else if (!resolvedDevice) {
        if (typeof (Deno == null ? void 0 : Deno.cwd) !== "function") {
          throw new TypeError("Resolved a drive-letter-less path without a current working directory (CWD)");
        }
        path = Deno.cwd();
      } else {
        if (typeof ((_a2 = Deno == null ? void 0 : Deno.env) == null ? void 0 : _a2.get) !== "function" || typeof (Deno == null ? void 0 : Deno.cwd) !== "function") {
          throw new TypeError("Resolved a relative path without a current working directory (CWD)");
        }
        path = Deno.cwd();
        if (path === void 0 || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
          path = `${resolvedDevice}\\`;
        }
      }
      assertPath(path);
      const len = path.length;
      if (len === 0) continue;
      let rootEnd = 0;
      let device = "";
      let isAbsolute3 = false;
      const code2 = path.charCodeAt(0);
      if (len > 1) {
        if (isPathSeparator(code2)) {
          isAbsolute3 = true;
          if (isPathSeparator(path.charCodeAt(1))) {
            let j = 2;
            let last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path.charCodeAt(j))) break;
            }
            if (j < len && j !== last) {
              const firstPart = path.slice(last, j);
              last = j;
              for (; j < len; ++j) {
                if (!isPathSeparator(path.charCodeAt(j))) break;
              }
              if (j < len && j !== last) {
                last = j;
                for (; j < len; ++j) {
                  if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j === len) {
                  device = `\\\\${firstPart}\\${path.slice(last)}`;
                  rootEnd = j;
                } else if (j !== last) {
                  device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                  rootEnd = j;
                }
              }
            }
          } else {
            rootEnd = 1;
          }
        } else if (isWindowsDeviceRoot(code2)) {
          if (path.charCodeAt(1) === CHAR_COLON) {
            device = path.slice(0, 2);
            rootEnd = 2;
            if (len > 2) {
              if (isPathSeparator(path.charCodeAt(2))) {
                isAbsolute3 = true;
                rootEnd = 3;
              }
            }
          }
        }
      } else if (isPathSeparator(code2)) {
        rootEnd = 1;
        isAbsolute3 = true;
      }
      if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
        continue;
      }
      if (resolvedDevice.length === 0 && device.length > 0) {
        resolvedDevice = device;
      }
      if (!resolvedAbsolute) {
        resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute3;
      }
      if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
  }
  function assertArgs(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
  }
  function relative2(from, to) {
    assertArgs(from, to);
    const fromOrig = resolve2(from);
    const toOrig = resolve2(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for (; fromStart < fromEnd; ++fromStart) {
      if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH) break;
    }
    for (; fromEnd - 1 > fromStart; --fromEnd) {
      if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for (; toStart < toEnd; ++toStart) {
      if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH) break;
    }
    for (; toEnd - 1 > toStart; --toEnd) {
      if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i2 = 0;
    for (; i2 <= length; ++i2) {
      if (i2 === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH) {
            return toOrig.slice(toStart + i2 + 1);
          } else if (i2 === 2) {
            return toOrig.slice(toStart + i2);
          }
        }
        if (fromLen > length) {
          if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH) {
            lastCommonSep = i2;
          } else if (i2 === 2) {
            lastCommonSep = 3;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i2);
      const toCode = to.charCodeAt(toStart + i2);
      if (fromCode !== toCode) break;
      else if (fromCode === CHAR_BACKWARD_SLASH) lastCommonSep = i2;
    }
    if (i2 !== length && lastCommonSep === -1) {
      return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
      if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH) {
        if (out.length === 0) out += "..";
        else out += "\\..";
      }
    }
    if (out.length > 0) {
      return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
      toStart += lastCommonSep;
      if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) ++toStart;
      return toOrig.slice(toStart, toEnd);
    }
  }
  const WHITESPACE_ENCODINGS = {
    "	": "%09",
    "\n": "%0A",
    "\v": "%0B",
    "\f": "%0C",
    "\r": "%0D",
    " ": "%20"
  };
  function encodeWhitespace(string2) {
    return string2.replaceAll(/[\s]/g, (c2) => {
      return WHITESPACE_ENCODINGS[c2] ?? c2;
    });
  }
  function toFileUrl(path) {
    if (!isAbsolute2(path)) {
      throw new TypeError(`Path must be absolute: received "${path}"`);
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname !== void 0 && hostname !== "localhost") {
      url.hostname = hostname;
      if (!url.hostname) {
        throw new TypeError(`Invalid hostname: "${url.hostname}"`);
      }
    }
    return url;
  }
  function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve2(path);
    if (resolvedPath.length >= 3) {
      if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
        if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
          const code2 = resolvedPath.charCodeAt(2);
          if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
            return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
          }
        }
      } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
        if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
          return `\\\\?\\${resolvedPath}`;
        }
      }
    }
    return path;
  }
  function common$1(paths, sep2) {
    const [first = "", ...remaining] = paths;
    const parts = first.split(sep2);
    let endOfPrefix = parts.length;
    let append = "";
    for (const path of remaining) {
      const compare2 = path.split(sep2);
      if (compare2.length <= endOfPrefix) {
        endOfPrefix = compare2.length;
        append = "";
      }
      for (let i2 = 0; i2 < endOfPrefix; i2++) {
        if (compare2[i2] !== parts[i2]) {
          endOfPrefix = i2;
          append = i2 === 0 ? "" : sep2;
          break;
        }
      }
    }
    return parts.slice(0, endOfPrefix).join(sep2) + append;
  }
  function common2(paths) {
    return common$1(paths, SEPARATOR);
  }
  const REG_EXP_ESCAPE_CHARS = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
  ];
  const RANGE_ESCAPE_CHARS = [
    "-",
    "\\",
    "]"
  ];
  function _globToRegExp(c2, glob, {
    extended = true,
    globstar: globstarOption = true,
    // os = osType,
    caseInsensitive = false
  } = {}) {
    if (glob === "") {
      return /(?!)/;
    }
    let newLength = glob.length;
    for (; newLength > 1 && c2.seps.includes(glob[newLength - 1]); newLength--) ;
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for (let j = 0; j < glob.length; ) {
      let segment = "";
      const groupStack = [];
      let inRange = false;
      let inEscape = false;
      let endsWithSep = false;
      let i2 = j;
      for (; i2 < glob.length && !c2.seps.includes(glob[i2]); i2++) {
        if (inEscape) {
          inEscape = false;
          const escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;
          segment += escapeChars.includes(glob[i2]) ? `\\${glob[i2]}` : glob[i2];
          continue;
        }
        if (glob[i2] === c2.escapePrefix) {
          inEscape = true;
          continue;
        }
        if (glob[i2] === "[") {
          if (!inRange) {
            inRange = true;
            segment += "[";
            if (glob[i2 + 1] === "!") {
              i2++;
              segment += "^";
            } else if (glob[i2 + 1] === "^") {
              i2++;
              segment += "\\^";
            }
            continue;
          } else if (glob[i2 + 1] === ":") {
            let k = i2 + 1;
            let value = "";
            while (glob[k + 1] !== void 0 && glob[k + 1] !== ":") {
              value += glob[k + 1];
              k++;
            }
            if (glob[k + 1] === ":" && glob[k + 2] === "]") {
              i2 = k + 2;
              if (value === "alnum") segment += "\\dA-Za-z";
              else if (value === "alpha") segment += "A-Za-z";
              else if (value === "ascii") segment += "\0-";
              else if (value === "blank") segment += "	 ";
              else if (value === "cntrl") segment += "\0-";
              else if (value === "digit") segment += "\\d";
              else if (value === "graph") segment += "!-~";
              else if (value === "lower") segment += "a-z";
              else if (value === "print") segment += " -~";
              else if (value === "punct") {
                segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~`;
              } else if (value === "space") segment += "\\s\v";
              else if (value === "upper") segment += "A-Z";
              else if (value === "word") segment += "\\w";
              else if (value === "xdigit") segment += "\\dA-Fa-f";
              continue;
            }
          }
        }
        if (glob[i2] === "]" && inRange) {
          inRange = false;
          segment += "]";
          continue;
        }
        if (inRange) {
          segment += glob[i2];
          continue;
        }
        if (glob[i2] === ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
          segment += ")";
          const type2 = groupStack.pop();
          if (type2 === "!") {
            segment += c2.wildcard;
          } else if (type2 !== "@") {
            segment += type2;
          }
          continue;
        }
        if (glob[i2] === "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
          segment += "|";
          continue;
        }
        if (glob[i2] === "+" && extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("+");
          segment += "(?:";
          continue;
        }
        if (glob[i2] === "@" && extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("@");
          segment += "(?:";
          continue;
        }
        if (glob[i2] === "?") {
          if (extended && glob[i2 + 1] === "(") {
            i2++;
            groupStack.push("?");
            segment += "(?:";
          } else {
            segment += ".";
          }
          continue;
        }
        if (glob[i2] === "!" && extended && glob[i2 + 1] === "(") {
          i2++;
          groupStack.push("!");
          segment += "(?!";
          continue;
        }
        if (glob[i2] === "{") {
          groupStack.push("BRACE");
          segment += "(?:";
          continue;
        }
        if (glob[i2] === "}" && groupStack[groupStack.length - 1] === "BRACE") {
          groupStack.pop();
          segment += ")";
          continue;
        }
        if (glob[i2] === "," && groupStack[groupStack.length - 1] === "BRACE") {
          segment += "|";
          continue;
        }
        if (glob[i2] === "*") {
          if (extended && glob[i2 + 1] === "(") {
            i2++;
            groupStack.push("*");
            segment += "(?:";
          } else {
            const prevChar2 = glob[i2 - 1];
            let numStars = 1;
            while (glob[i2 + 1] === "*") {
              i2++;
              numStars++;
            }
            const nextChar2 = glob[i2 + 1];
            if (globstarOption && numStars === 2 && [
              ...c2.seps,
              void 0
            ].includes(prevChar2) && [
              ...c2.seps,
              void 0
            ].includes(nextChar2)) {
              segment += c2.globstar;
              endsWithSep = true;
            } else {
              segment += c2.wildcard;
            }
          }
          continue;
        }
        segment += REG_EXP_ESCAPE_CHARS.includes(glob[i2]) ? `\\${glob[i2]}` : glob[i2];
      }
      if (groupStack.length > 0 || inRange || inEscape) {
        segment = "";
        for (const c3 of glob.slice(j, i2)) {
          segment += REG_EXP_ESCAPE_CHARS.includes(c3) ? `\\${c3}` : c3;
          endsWithSep = false;
        }
      }
      regExpString += segment;
      if (!endsWithSep) {
        regExpString += i2 < glob.length ? c2.sep : c2.sepMaybe;
        endsWithSep = true;
      }
      while (c2.seps.includes(glob[i2])) i2++;
      j = i2;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
  }
  const constants = {
    sep: "(?:\\\\|/)+",
    sepMaybe: "(?:\\\\|/)*",
    seps: [
      "\\",
      "/"
    ],
    globstar: "(?:[^\\\\/]*(?:\\\\|/|$)+)*",
    wildcard: "[^\\\\/]*",
    escapePrefix: "`"
  };
  function globToRegExp(glob, options = {}) {
    return _globToRegExp(constants, glob, options);
  }
  function isGlob(str) {
    const chars = {
      "{": "}",
      "(": ")",
      "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^[\\\]]+\]|\{[^{\\}]+\}|\(\?[:!=][^\\)]+\)|\([^(|]+\|[^\\)]+\))/;
    if (str === "") {
      return false;
    }
    let match;
    while (match = regex.exec(str)) {
      if (match[2]) return true;
      let idx = match.index + match[0].length;
      const open = match[1];
      const close = open ? chars[open] : null;
      if (open && close) {
        const n2 = str.indexOf(close, idx);
        if (n2 !== -1) {
          idx = n2 + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  }
  function normalizeGlob(glob, options = {}) {
    const { globstar = false } = options;
    if (glob.match(/\0/g)) {
      throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
      return normalize2(glob);
    }
    const s2 = SEPARATOR_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s2}|^)\\*\\*${s2})\\.\\.(?=${s2}|$)`, "g");
    return normalize2(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
  }
  function joinGlobs(globs, options = {}) {
    const { globstar = false } = options;
    if (!globstar || globs.length === 0) {
      return join2(...globs);
    }
    let joined;
    for (const glob of globs) {
      const path = glob;
      if (path.length > 0) {
        if (!joined) joined = path;
        else joined += `${SEPARATOR}${path}`;
      }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
      globstar
    });
  }
  windows.DELIMITER = DELIMITER;
  windows.SEPARATOR = SEPARATOR;
  windows.SEPARATOR_PATTERN = SEPARATOR_PATTERN;
  windows.basename = basename2;
  windows.common = common2;
  windows.dirname = dirname2;
  windows.extname = extname2;
  windows.format = format2;
  windows.fromFileUrl = fromFileUrl;
  windows.globToRegExp = globToRegExp;
  windows.isAbsolute = isAbsolute2;
  windows.isGlob = isGlob;
  windows.join = join2;
  windows.joinGlobs = joinGlobs;
  windows.normalize = normalize2;
  windows.normalizeGlob = normalizeGlob;
  windows.parse = parse;
  windows.relative = relative2;
  windows.resolve = resolve2;
  windows.toFileUrl = toFileUrl;
  windows.toNamespacedPath = toNamespacedPath;
  return windows;
}
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i2 = parts.length - 1; i2 >= 0; i2--) {
    var last = parts[i2];
    if (last === ".") {
      parts.splice(i2, 1);
    } else if (last === "..") {
      parts.splice(i2, 1);
      up++;
    } else if (up) {
      parts.splice(i2, 1);
      up--;
    }
  }
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift("..");
    }
  }
  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};
function resolve() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    var path = i2 >= 0 ? arguments[i2] : "/";
    if (typeof path !== "string") {
      throw new TypeError("Arguments to path.resolve must be strings");
    } else if (!path) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p2) {
    return !!p2;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
}
function normalize(path) {
  var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
  path = normalizeArray(filter(path.split("/"), function(p2) {
    return !!p2;
  }), !isPathAbsolute).join("/");
  if (!path && !isPathAbsolute) {
    path = ".";
  }
  if (path && trailingSlash) {
    path += "/";
  }
  return (isPathAbsolute ? "/" : "") + path;
}
function isAbsolute(path) {
  return path.charAt(0) === "/";
}
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p2, index) {
    if (typeof p2 !== "string") {
      throw new TypeError("Arguments to path.join must be strings");
    }
    return p2;
  }).join("/"));
}
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);
  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== "") break;
    }
    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== "") break;
    }
    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i2 = 0; i2 < length; i2++) {
    if (fromParts[i2] !== toParts[i2]) {
      samePartsLength = i2;
      break;
    }
  }
  var outputParts = [];
  for (var i2 = samePartsLength; i2 < fromParts.length; i2++) {
    outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
}
var sep = "/";
var delimiter = ":";
function dirname(path) {
  var result = splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
    return ".";
  }
  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
}
function basename(path, ext) {
  var f2 = splitPath(path)[2];
  if (ext && f2.substr(-1 * ext.length) === ext) {
    f2 = f2.substr(0, f2.length - ext.length);
  }
  return f2;
}
function extname(path) {
  return splitPath(path)[3];
}
var _polyfillNode_path = {
  extname,
  basename,
  dirname,
  sep,
  delimiter,
  relative,
  join,
  isAbsolute,
  normalize,
  resolve
};
function filter(xs, f2) {
  if (xs.filter) return xs.filter(f2);
  var res = [];
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (f2(xs[i2], i2, xs)) res.push(xs[i2]);
  }
  return res;
}
var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
  return str.substr(start, len);
} : function(str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
var _polyfillNode_path$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basename,
  default: _polyfillNode_path,
  delimiter,
  dirname,
  extname,
  isAbsolute,
  join,
  normalize,
  relative,
  resolve,
  sep
});
var require$$0 = /* @__PURE__ */ getDefaultExportFromNamespaceIfPresent(_polyfillNode_path$1);
var concatMap;
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1;
  concatMap = function(xs, fn) {
    var res = [];
    for (var i2 = 0; i2 < xs.length; i2++) {
      var x2 = fn(xs[i2], i2);
      if (isArray(x2)) res.push.apply(res, x2);
      else res.push(x2);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap;
}
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a2, b, str) {
    if (a2 instanceof RegExp) a2 = maybeMatch(a2, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r2 = range(a2, b, str);
    return r2 && {
      start: r2[0],
      end: r2[1],
      pre: str.slice(0, r2[0]),
      body: str.slice(r2[0] + a2.length, r2[1]),
      post: str.slice(r2[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range;
  function range(a2, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a2);
    var bi = str.indexOf(b, ai + 1);
    var i2 = ai;
    if (ai >= 0 && bi > 0) {
      if (a2 === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i2 >= 0 && !result) {
        if (i2 == ai) {
          begs.push(i2);
          ai = str.indexOf(a2, i2 + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i2 + 1);
        }
        i2 = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var concatMap2 = requireConcatMap();
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p2 = pre.split(",");
    p2[p2.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p2[p2.length - 1] += postParts.shift();
      p2.push.apply(p2, postParts);
    }
    parts.push.apply(parts, p2);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i2, y2) {
    return i2 <= y2;
  }
  function gte(i2, y2) {
    return i2 >= y2;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre)) return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,.*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand(str);
      }
      return [str];
    }
    var n2;
    if (isSequence) {
      n2 = m2.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m2.body);
      if (n2.length === 1) {
        n2 = expand(n2[0], false).map(embrace);
        if (n2.length === 1) {
          var post = m2.post.length ? expand(m2.post, false) : [""];
          return post.map(function(p2) {
            return m2.pre + n2[0] + p2;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand(m2.post, false) : [""];
    var N;
    if (isSequence) {
      var x2 = numeric(n2[0]);
      var y2 = numeric(n2[1]);
      var width = Math.max(n2[0].length, n2[1].length);
      var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
      var test = lte;
      var reverse = y2 < x2;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n2.some(isPadded);
      N = [];
      for (var i2 = x2; test(i2, y2); i2 += incr) {
        var c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i2);
          if (c2 === "\\")
            c2 = "";
        } else {
          c2 = String(i2);
          if (pad) {
            var need = width - c2.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i2 < 0)
                c2 = "-" + z + c2.slice(1);
              else
                c2 = z + c2;
            }
          }
        }
        N.push(c2);
      }
    } else {
      N = concatMap2(n2, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path = function() {
    try {
      return require$$0;
    } catch (e2) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = requireBraceExpansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star2 = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s2) {
    return s2.split("").reduce(function(set, c2) {
      set[c2] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter2;
  function filter2(pattern2, options) {
    options = options || {};
    return function(p2, i2, list) {
      return minimatch(p2, pattern2, options);
    };
  }
  function ext(a2, b) {
    b = b || {};
    var t2 = {};
    Object.keys(a2).forEach(function(k) {
      t2[k] = a2[k];
    });
    Object.keys(b).forEach(function(k) {
      t2[k] = b[k];
    });
    return t2;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m2 = function minimatch2(p2, pattern2, options) {
      return orig(p2, pattern2, ext(def, options));
    };
    m2.Minimatch = function Minimatch2(pattern2, options) {
      return new orig.Minimatch(pattern2, ext(def, options));
    };
    m2.Minimatch.defaults = function defaults2(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };
    m2.filter = function filter3(pattern2, options) {
      return orig.filter(pattern2, ext(def, options));
    };
    m2.defaults = function defaults2(options) {
      return orig.defaults(ext(def, options));
    };
    m2.makeRe = function makeRe2(pattern2, options) {
      return orig.makeRe(pattern2, ext(def, options));
    };
    m2.braceExpand = function braceExpand2(pattern2, options) {
      return orig.braceExpand(pattern2, ext(def, options));
    };
    m2.match = function(list, pattern2, options) {
      return orig.match(list, pattern2, ext(def, options));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p2, pattern2, options) {
    assertValidPattern(pattern2);
    if (!options) options = {};
    if (!options.nocomment && pattern2.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern2, options).match(p2);
  }
  function Minimatch(pattern2, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern2, options);
    }
    assertValidPattern(pattern2);
    if (!options) options = {};
    pattern2 = pattern2.trim();
    if (!options.allowWindowsEscape && path.sep !== "/") {
      pattern2 = pattern2.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern2;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern2 = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern2.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern2) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug) this.debug = function debug() {
      console.error.apply(console, arguments);
    };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s2) {
      return s2.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s2, si, set2) {
      return s2.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s2) {
      return s2.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern2 = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate) return;
    for (var i2 = 0, l2 = pattern2.length; i2 < l2 && pattern2.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern2.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern2, options) {
    return braceExpand(pattern2, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern2, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern2 = typeof pattern2 === "undefined" ? this.pattern : pattern2;
    assertValidPattern(pattern2);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
      return [pattern2];
    }
    return expand(pattern2);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern2) {
    if (typeof pattern2 !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern2.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern2, isSub) {
    assertValidPattern(pattern2);
    var options = this.options;
    if (pattern2 === "**") {
      if (!options.noglobstar)
        return GLOBSTAR;
      else
        pattern2 = "*";
    }
    if (pattern2 === "") return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern2.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star2;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i2 = 0, len = pattern2.length, c2; i2 < len && (c2 = pattern2.charAt(i2)); i2++) {
      this.debug("%s	%s %s %j", pattern2, i2, re, c2);
      if (escaping && reSpecials[c2]) {
        re += "\\" + c2;
        escaping = false;
        continue;
      }
      switch (c2) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern2, i2, re, c2);
          if (inClass) {
            this.debug("  in class");
            if (c2 === "!" && i2 === classStart + 1) c2 = "^";
            re += c2;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c2;
          if (options.noext) clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i2 - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = true;
          classStart = i2;
          reClassStart = re.length;
          re += c2;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re += "\\" + c2;
            escaping = false;
            continue;
          }
          var cs = pattern2.substring(classStart + 1, i2);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c2;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
            re += "\\";
          }
          re += c2;
      }
    }
    if (inClass) {
      cs = pattern2.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t2 = pl.type === "*" ? star2 : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t2 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n2 = negativeLists.length - 1; n2 > -1; n2--) {
      var nl = negativeLists[n2];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i2 = 0; i2 < openParensBefore; i2++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern2);
    }
    var flags2 = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags2);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern2;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern2, options) {
    return new Minimatch(pattern2, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
    var flags2 = options.nocase ? "i" : "";
    var re = set.map(function(pattern2) {
      return pattern2.map(function(p2) {
        return p2 === GLOBSTAR ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate) re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags2);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern2, options) {
    options = options || {};
    var mm = new Minimatch(pattern2, options);
    list = list.filter(function(f2) {
      return mm.match(f2);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern2);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f2, partial) {
    if (typeof partial === "undefined") partial = this.partial;
    this.debug("match", f2, this.pattern);
    if (this.comment) return false;
    if (this.empty) return f2 === "";
    if (f2 === "/" && partial) return true;
    var options = this.options;
    if (path.sep !== "/") {
      f2 = f2.split(path.sep).join("/");
    }
    f2 = f2.split(slashSplit);
    this.debug(this.pattern, "split", f2);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i2;
    for (i2 = f2.length - 1; i2 >= 0; i2--) {
      filename = f2[i2];
      if (filename) break;
    }
    for (i2 = 0; i2 < set.length; i2++) {
      var pattern2 = set[i2];
      var file = f2;
      if (options.matchBase && pattern2.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern2, partial);
      if (hit) {
        if (options.flipNegate) return true;
        return !this.negate;
      }
    }
    if (options.flipNegate) return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern2, partial) {
    var options = this.options;
    this.debug(
      "matchOne",
      { "this": this, file, pattern: pattern2 }
    );
    this.debug("matchOne", file.length, pattern2.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern2.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern2[pi];
      var f2 = file[fi];
      this.debug(pattern2, p2, f2);
      if (p2 === false) return false;
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern2, p2, f2]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern2, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern2.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern2, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern2, pr);
          if (fr === fl) return true;
        }
        return false;
      }
      var hit;
      if (typeof p2 === "string") {
        hit = f2 === p2;
        this.debug("string match", p2, f2, hit);
      } else {
        hit = f2.match(p2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit) return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s2) {
    return s2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s2) {
    return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1;
}
var cjs = {};
var hasRequiredCjs$1;
function requireCjs$1() {
  var _definitions, _requiredKeys;
  if (hasRequiredCjs$1) return cjs;
  hasRequiredCjs$1 = 1;
  class MergeStrategy {
    /**
     * Merges two keys by overwriting the first with the second.
     * @param {*} value1 The value from the first object key.
     * @param {*} value2 The value from the second object key.
     * @returns {*} The second value.
     */
    static overwrite(value1, value2) {
      return value2;
    }
    /**
     * Merges two keys by replacing the first with the second only if the
     * second is defined.
     * @param {*} value1 The value from the first object key.
     * @param {*} value2 The value from the second object key.
     * @returns {*} The second value if it is defined.
     */
    static replace(value1, value2) {
      if (typeof value2 !== "undefined") {
        return value2;
      }
      return value1;
    }
    /**
     * Merges two properties by assigning properties from the second to the first.
     * @param {*} value1 The value from the first object key.
     * @param {*} value2 The value from the second object key.
     * @returns {*} A new object containing properties from both value1 and
     *      value2.
     */
    static assign(value1, value2) {
      return Object.assign({}, value1, value2);
    }
  }
  class ValidationStrategy {
    /**
     * Validates that a value is an array.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static array(value) {
      if (!Array.isArray(value)) {
        throw new TypeError("Expected an array.");
      }
    }
    /**
     * Validates that a value is a boolean.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static boolean(value) {
      if (typeof value !== "boolean") {
        throw new TypeError("Expected a Boolean.");
      }
    }
    /**
     * Validates that a value is a number.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static number(value) {
      if (typeof value !== "number") {
        throw new TypeError("Expected a number.");
      }
    }
    /**
     * Validates that a value is a object.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static object(value) {
      if (!value || typeof value !== "object") {
        throw new TypeError("Expected an object.");
      }
    }
    /**
     * Validates that a value is a object or null.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static "object?"(value) {
      if (typeof value !== "object") {
        throw new TypeError("Expected an object or null.");
      }
    }
    /**
     * Validates that a value is a string.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static string(value) {
      if (typeof value !== "string") {
        throw new TypeError("Expected a string.");
      }
    }
    /**
     * Validates that a value is a non-empty string.
     * @param {*} value The value to validate.
     * @returns {void}
     * @throws {TypeError} If the value is invalid.
     */
    static "string!"(value) {
      if (typeof value !== "string" || value.length === 0) {
        throw new TypeError("Expected a non-empty string.");
      }
    }
  }
  function validateDefinition(name2, definition) {
    let hasSchema = false;
    if (definition.schema) {
      if (typeof definition.schema === "object") {
        hasSchema = true;
      } else {
        throw new TypeError("Schema must be an object.");
      }
    }
    if (typeof definition.merge === "string") {
      if (!(definition.merge in MergeStrategy)) {
        throw new TypeError(
          `Definition for key "${name2}" missing valid merge strategy.`
        );
      }
    } else if (!hasSchema && typeof definition.merge !== "function") {
      throw new TypeError(
        `Definition for key "${name2}" must have a merge property.`
      );
    }
    if (typeof definition.validate === "string") {
      if (!(definition.validate in ValidationStrategy)) {
        throw new TypeError(
          `Definition for key "${name2}" missing valid validation strategy.`
        );
      }
    } else if (!hasSchema && typeof definition.validate !== "function") {
      throw new TypeError(
        `Definition for key "${name2}" must have a validate() method.`
      );
    }
  }
  class UnexpectedKeyError extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The key that was unexpected.
     */
    constructor(key) {
      super(`Unexpected key "${key}" found.`);
    }
  }
  class MissingKeyError extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The key that was missing.
     */
    constructor(key) {
      super(`Missing required key "${key}".`);
    }
  }
  class MissingDependentKeysError extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The key that was unexpected.
     * @param {Array<string>} requiredKeys The keys that are required.
     */
    constructor(key, requiredKeys) {
      super(`Key "${key}" requires keys "${requiredKeys.join('", "')}".`);
    }
  }
  class WrapperError extends Error {
    /**
     * Creates a new instance.
     * @param {string} key The object key causing the error.
     * @param {Error} source The source error.
     */
    constructor(key, source) {
      super(`Key "${key}": ${source.message}`, { cause: source });
      for (const sourceKey of Object.keys(source)) {
        if (!(sourceKey in this)) {
          this[sourceKey] = source[sourceKey];
        }
      }
    }
  }
  const _ObjectSchema = class _ObjectSchema {
    /**
     * Creates a new instance.
     * @param {ObjectDefinition} definitions The schema definitions.
     * @throws {Error} When the definitions are missing or invalid.
     */
    constructor(definitions2) {
      /**
       * Track all definitions in the schema by key.
       * @type {Map<string, PropertyDefinition>}
       */
      __privateAdd(this, _definitions, /* @__PURE__ */ new Map());
      /**
       * Separately track any keys that are required for faster validtion.
       * @type {Map<string, PropertyDefinition>}
       */
      __privateAdd(this, _requiredKeys, /* @__PURE__ */ new Map());
      if (!definitions2) {
        throw new Error("Schema definitions missing.");
      }
      for (const key of Object.keys(definitions2)) {
        validateDefinition(key, definitions2[key]);
        if (typeof definitions2[key].schema === "object") {
          const schema = new _ObjectSchema(definitions2[key].schema);
          definitions2[key] = {
            ...definitions2[key],
            merge(first = {}, second = {}) {
              return schema.merge(first, second);
            },
            validate(value) {
              ValidationStrategy.object(value);
              schema.validate(value);
            }
          };
        }
        if (typeof definitions2[key].merge === "string") {
          definitions2[key] = {
            ...definitions2[key],
            merge: MergeStrategy[
              /** @type {string} */
              definitions2[key].merge
            ]
          };
        }
        if (typeof definitions2[key].validate === "string") {
          definitions2[key] = {
            ...definitions2[key],
            validate: ValidationStrategy[
              /** @type {string} */
              definitions2[key].validate
            ]
          };
        }
        __privateGet(this, _definitions).set(key, definitions2[key]);
        if (definitions2[key].required) {
          __privateGet(this, _requiredKeys).set(key, definitions2[key]);
        }
      }
    }
    /**
     * Determines if a strategy has been registered for the given object key.
     * @param {string} key The object key to find a strategy for.
     * @returns {boolean} True if the key has a strategy registered, false if not.
     */
    hasKey(key) {
      return __privateGet(this, _definitions).has(key);
    }
    /**
     * Merges objects together to create a new object comprised of the keys
     * of the all objects. Keys are merged based on the each key's merge
     * strategy.
     * @param {...Object} objects The objects to merge.
     * @returns {Object} A new object with a mix of all objects' keys.
     * @throws {TypeError} If any object is invalid.
     */
    merge(...objects) {
      if (objects.length < 2) {
        throw new TypeError("merge() requires at least two arguments.");
      }
      if (objects.some(
        (object) => object === null || typeof object !== "object"
      )) {
        throw new TypeError("All arguments must be objects.");
      }
      return objects.reduce((result, object) => {
        this.validate(object);
        for (const [key, strategy] of __privateGet(this, _definitions)) {
          try {
            if (key in result || key in object) {
              const merge = (
                /** @type {Function} */
                strategy.merge
              );
              const value = merge.call(
                this,
                result[key],
                object[key]
              );
              if (value !== void 0) {
                result[key] = value;
              }
            }
          } catch (ex) {
            throw new WrapperError(key, ex);
          }
        }
        return result;
      }, {});
    }
    /**
     * Validates an object's keys based on the validate strategy for each key.
     * @param {Object} object The object to validate.
     * @returns {void}
     * @throws {Error} When the object is invalid.
     */
    validate(object) {
      for (const key of Object.keys(object)) {
        if (!this.hasKey(key)) {
          throw new UnexpectedKeyError(key);
        }
        const definition = __privateGet(this, _definitions).get(key);
        if (Array.isArray(definition.requires)) {
          if (!definition.requires.every((otherKey) => otherKey in object)) {
            throw new MissingDependentKeysError(
              key,
              definition.requires
            );
          }
        }
        try {
          const validate2 = (
            /** @type {Function} */
            definition.validate
          );
          validate2.call(definition, object[key]);
        } catch (ex) {
          throw new WrapperError(key, ex);
        }
      }
      for (const [key] of __privateGet(this, _requiredKeys)) {
        if (!(key in object)) {
          throw new MissingKeyError(key);
        }
      }
    }
  };
  _definitions = new WeakMap();
  _requiredKeys = new WeakMap();
  let ObjectSchema = _ObjectSchema;
  cjs.MergeStrategy = MergeStrategy;
  cjs.ObjectSchema = ObjectSchema;
  cjs.ValidationStrategy = ValidationStrategy;
  return cjs;
}
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs$1;
  hasRequiredCjs = 1;
  (function(exports$1) {
    var _namespacedBasePath, _path;
    var posixPath = requirePosix();
    var windowsPath = requireWindows();
    var minimatch = requireMinimatch();
    var createDebug = requireSrc();
    var objectSchema = requireCjs$1();
    function _interopNamespaceDefault(e2) {
      var n2 = /* @__PURE__ */ Object.create(null);
      if (e2) {
        Object.keys(e2).forEach(function(k) {
          if (k !== "default") {
            var d2 = Object.getOwnPropertyDescriptor(e2, k);
            Object.defineProperty(n2, k, d2.get ? d2 : {
              enumerable: true,
              get: function() {
                return e2[k];
              }
            });
          }
        });
      }
      n2.default = e2;
      return Object.freeze(n2);
    }
    var posixPath__namespace = /* @__PURE__ */ _interopNamespaceDefault(posixPath);
    var windowsPath__namespace = /* @__PURE__ */ _interopNamespaceDefault(windowsPath);
    const NOOP_STRATEGY = {
      required: false,
      merge() {
        return void 0;
      },
      validate() {
      }
    };
    const baseSchema = Object.freeze({
      name: {
        required: false,
        merge() {
          return void 0;
        },
        validate(value) {
          if (typeof value !== "string") {
            throw new TypeError("Property must be a string.");
          }
        }
      },
      basePath: NOOP_STRATEGY,
      files: NOOP_STRATEGY,
      ignores: NOOP_STRATEGY
    });
    function assertIsArray(value) {
      if (!Array.isArray(value)) {
        throw new TypeError("Expected value to be an array.");
      }
    }
    function assertIsArrayOfStringsAndFunctions(value) {
      assertIsArray(value);
      if (value.some(
        (item) => typeof item !== "string" && typeof item !== "function"
      )) {
        throw new TypeError(
          "Expected array to only contain strings and functions."
        );
      }
    }
    function assertIsNonEmptyArray(value) {
      if (!Array.isArray(value) || value.length === 0) {
        throw new TypeError("Expected value to be a non-empty array.");
      }
    }
    const filesAndIgnoresSchema = Object.freeze({
      basePath: {
        required: false,
        merge() {
          return void 0;
        },
        validate(value) {
          if (typeof value !== "string") {
            throw new TypeError("Expected value to be a string.");
          }
        }
      },
      files: {
        required: false,
        merge() {
          return void 0;
        },
        validate(value) {
          assertIsNonEmptyArray(value);
          value.forEach((item) => {
            if (Array.isArray(item)) {
              assertIsArrayOfStringsAndFunctions(item);
            } else if (typeof item !== "string" && typeof item !== "function") {
              throw new TypeError(
                "Items must be a string, a function, or an array of strings and functions."
              );
            }
          });
        }
      },
      ignores: {
        required: false,
        merge() {
          return void 0;
        },
        validate: assertIsArrayOfStringsAndFunctions
      }
    });
    const Minimatch = minimatch.Minimatch;
    const debug = createDebug("@eslint/config-array");
    const minimatchCache = /* @__PURE__ */ new Map();
    const negatedMinimatchCache = /* @__PURE__ */ new Map();
    const MINIMATCH_OPTIONS = {
      // matchBase: true,
      dot: true,
      allowWindowsEscape: true
    };
    const CONFIG_TYPES = /* @__PURE__ */ new Set(["array", "function"]);
    const META_FIELDS = /* @__PURE__ */ new Set(["name", "basePath"]);
    const FILES_AND_IGNORES_SCHEMA = new objectSchema.ObjectSchema(filesAndIgnoresSchema);
    const CONFIG_WITH_STATUS_EXTERNAL = Object.freeze({ status: "external" });
    const CONFIG_WITH_STATUS_IGNORED = Object.freeze({ status: "ignored" });
    const CONFIG_WITH_STATUS_UNCONFIGURED = Object.freeze({
      status: "unconfigured"
    });
    const EXTERNAL_PATH_REGEX = /^\.\.(?:\/|$)/u;
    class ConfigError extends Error {
      /**
       * Creates a new instance.
       * @param {string} name The config object name causing the error.
       * @param {number} index The index of the config object in the array.
       * @param {Object} options The options for the error.
       * @param {Error} [options.cause] The error that caused this error.
       * @param {string} [options.message] The message to use for the error.
       */
      constructor(name2, index, { cause, message }) {
        const finalMessage = message || cause.message;
        super(`Config ${name2}: ${finalMessage}`, { cause });
        if (cause) {
          for (const key of Object.keys(cause)) {
            if (!(key in this)) {
              this[key] = cause[key];
            }
          }
        }
        this.name = "ConfigError";
        this.index = index;
      }
    }
    function getConfigName(config2) {
      if (config2 && typeof config2.name === "string" && config2.name) {
        return `"${config2.name}"`;
      }
      return "(unnamed)";
    }
    function rethrowConfigError(config2, index, error) {
      const configName = getConfigName(config2);
      throw new ConfigError(configName, index, { cause: error });
    }
    function isString(value) {
      return typeof value === "string";
    }
    function assertValidBaseConfig(config2, index) {
      if (config2 === null) {
        throw new ConfigError(getConfigName(config2), index, {
          message: "Unexpected null config."
        });
      }
      if (config2 === void 0) {
        throw new ConfigError(getConfigName(config2), index, {
          message: "Unexpected undefined config."
        });
      }
      if (typeof config2 !== "object") {
        throw new ConfigError(getConfigName(config2), index, {
          message: "Unexpected non-object config."
        });
      }
      const validateConfig = {};
      if ("basePath" in config2) {
        validateConfig.basePath = config2.basePath;
      }
      if ("files" in config2) {
        validateConfig.files = config2.files;
      }
      if ("ignores" in config2) {
        validateConfig.ignores = config2.ignores;
      }
      try {
        FILES_AND_IGNORES_SCHEMA.validate(validateConfig);
      } catch (validationError) {
        rethrowConfigError(config2, index, validationError);
      }
    }
    function doMatch(filepath, pattern2, options = {}) {
      let cache2 = minimatchCache;
      if (options.flipNegate) {
        cache2 = negatedMinimatchCache;
      }
      let matcher2 = cache2.get(pattern2);
      if (!matcher2) {
        matcher2 = new Minimatch(
          pattern2,
          Object.assign({}, MINIMATCH_OPTIONS, options)
        );
        cache2.set(pattern2, matcher2);
      }
      return matcher2.match(filepath);
    }
    function normalizePattern(pattern2) {
      if (isString(pattern2)) {
        if (pattern2.startsWith("./")) {
          return pattern2.slice(2);
        }
        if (pattern2.startsWith("!./")) {
          return `!${pattern2.slice(3)}`;
        }
      }
      return pattern2;
    }
    function needsPatternNormalization(pattern2) {
      return isString(pattern2) && (pattern2.startsWith("./") || pattern2.startsWith("!./"));
    }
    function normalizeConfigPatterns(config2, namespacedBasePath, path) {
      if (!config2) {
        return config2;
      }
      const hasBasePath = typeof config2.basePath === "string";
      let needsNormalization = false;
      if (hasBasePath) {
        needsNormalization = true;
      }
      if (!needsNormalization && Array.isArray(config2.files)) {
        needsNormalization = config2.files.some((pattern2) => {
          if (Array.isArray(pattern2)) {
            return pattern2.some(needsPatternNormalization);
          }
          return needsPatternNormalization(pattern2);
        });
      }
      if (!needsNormalization && Array.isArray(config2.ignores)) {
        needsNormalization = config2.ignores.some(needsPatternNormalization);
      }
      if (!needsNormalization) {
        return config2;
      }
      const newConfig = { ...config2 };
      if (hasBasePath) {
        if (path.isAbsolute(config2.basePath)) {
          newConfig.basePath = path.toNamespacedPath(config2.basePath);
        } else {
          newConfig.basePath = path.resolve(
            namespacedBasePath,
            config2.basePath
          );
        }
      }
      if (Array.isArray(newConfig.files)) {
        newConfig.files = newConfig.files.map((pattern2) => {
          if (Array.isArray(pattern2)) {
            return pattern2.map(normalizePattern);
          }
          return normalizePattern(pattern2);
        });
      }
      if (Array.isArray(newConfig.ignores)) {
        newConfig.ignores = newConfig.ignores.map(normalizePattern);
      }
      return newConfig;
    }
    async function normalize2(items2, context, extraConfigTypes, namespacedBasePath, path) {
      const allowFunctions = extraConfigTypes.includes("function");
      const allowArrays = extraConfigTypes.includes("array");
      async function* flatTraverse(array) {
        for (let item of array) {
          if (typeof item === "function") {
            if (!allowFunctions) {
              throw new TypeError("Unexpected function.");
            }
            item = item(context);
            if (item.then) {
              item = await item;
            }
          }
          if (Array.isArray(item)) {
            if (!allowArrays) {
              throw new TypeError("Unexpected array.");
            }
            yield* flatTraverse(item);
          } else if (typeof item === "function") {
            throw new TypeError(
              "A config function can only return an object or array."
            );
          } else {
            yield item;
          }
        }
      }
      const asyncIterable = await flatTraverse(items2);
      const configs = [];
      for await (const config2 of asyncIterable) {
        configs.push(normalizeConfigPatterns(config2, namespacedBasePath, path));
      }
      return configs;
    }
    function normalizeSync(items2, context, extraConfigTypes, namespacedBasePath, path) {
      const allowFunctions = extraConfigTypes.includes("function");
      const allowArrays = extraConfigTypes.includes("array");
      function* flatTraverse(array) {
        for (let item of array) {
          if (typeof item === "function") {
            if (!allowFunctions) {
              throw new TypeError("Unexpected function.");
            }
            item = item(context);
            if (item.then) {
              throw new TypeError(
                "Async config functions are not supported."
              );
            }
          }
          if (Array.isArray(item)) {
            if (!allowArrays) {
              throw new TypeError("Unexpected array.");
            }
            yield* flatTraverse(item);
          } else if (typeof item === "function") {
            throw new TypeError(
              "A config function can only return an object or array."
            );
          } else {
            yield item;
          }
        }
      }
      const configs = [];
      for (const config2 of flatTraverse(items2)) {
        configs.push(normalizeConfigPatterns(config2, namespacedBasePath, path));
      }
      return configs;
    }
    function toRelativePath(fileOrDirPath, namespacedBasePath, path) {
      const fullPath = path.resolve(namespacedBasePath, fileOrDirPath);
      const namespacedFullPath = path.toNamespacedPath(fullPath);
      const relativePath = path.relative(namespacedBasePath, namespacedFullPath);
      return relativePath.replaceAll(path.SEPARATOR, "/");
    }
    function shouldIgnorePath(configs, filePath, relativeFilePath, { basePath, path } = {}) {
      let shouldIgnore = false;
      for (const config2 of configs) {
        let relativeFilePathToCheck = relativeFilePath;
        if (config2.basePath) {
          relativeFilePathToCheck = toRelativePath(
            path.resolve(basePath, relativeFilePath),
            config2.basePath,
            path
          );
          if (relativeFilePathToCheck === "" || EXTERNAL_PATH_REGEX.test(relativeFilePathToCheck)) {
            continue;
          }
          if (relativeFilePath.endsWith("/")) {
            relativeFilePathToCheck += "/";
          }
        }
        shouldIgnore = config2.ignores.reduce((ignored, matcher2) => {
          if (!ignored) {
            if (typeof matcher2 === "function") {
              return matcher2(filePath);
            }
            if (!matcher2.startsWith("!")) {
              return doMatch(relativeFilePathToCheck, matcher2);
            }
            return false;
          }
          if (typeof matcher2 === "string" && matcher2.startsWith("!")) {
            return !doMatch(relativeFilePathToCheck, matcher2, {
              flipNegate: true
            });
          }
          return ignored;
        }, shouldIgnore);
      }
      return shouldIgnore;
    }
    function pathMatches(filePath, relativeFilePath, config2) {
      function match(pattern2) {
        if (isString(pattern2)) {
          return doMatch(relativeFilePath, pattern2);
        }
        if (typeof pattern2 === "function") {
          return pattern2(filePath);
        }
        throw new TypeError(`Unexpected matcher type ${pattern2}.`);
      }
      let filePathMatchesPattern = config2.files.some((pattern2) => {
        if (Array.isArray(pattern2)) {
          return pattern2.every(match);
        }
        return match(pattern2);
      });
      if (filePathMatchesPattern && config2.ignores) {
        filePathMatchesPattern = !shouldIgnorePath(
          [{ ignores: config2.ignores }],
          filePath,
          relativeFilePath
        );
      }
      return filePathMatchesPattern;
    }
    function assertNormalized(configArray) {
      if (!configArray.isNormalized()) {
        throw new Error(
          "ConfigArray must be normalized to perform this operation."
        );
      }
    }
    function assertExtraConfigTypes(extraConfigTypes) {
      if (extraConfigTypes.length > 2) {
        throw new TypeError(
          "configTypes must be an array with at most two items."
        );
      }
      for (const configType of extraConfigTypes) {
        if (!CONFIG_TYPES.has(configType)) {
          throw new TypeError(
            `Unexpected config type "${configType}" found. Expected one of: "object", "array", "function".`
          );
        }
      }
    }
    function getPathImpl(fileOrDirPath) {
      if (fileOrDirPath.startsWith("/")) {
        return posixPath__namespace;
      }
      if (/^(?:[A-Za-z]:[/\\]|[/\\]{2})/u.test(fileOrDirPath)) {
        return windowsPath__namespace;
      }
      throw new Error(
        `Expected an absolute path but received "${fileOrDirPath}"`
      );
    }
    const ConfigArraySymbol = {
      isNormalized: Symbol("isNormalized"),
      configCache: Symbol("configCache"),
      schema: Symbol("schema"),
      finalizeConfig: Symbol("finalizeConfig"),
      preprocessConfig: Symbol("preprocessConfig")
    };
    const dataCache = /* @__PURE__ */ new WeakMap();
    class ConfigArray extends Array {
      /**
       * Creates a new instance of ConfigArray.
       * @param {Iterable|Function|Object} configs An iterable yielding config
       *      objects, or a config function, or a config object.
       * @param {Object} options The options for the ConfigArray.
       * @param {string} [options.basePath="/"] The absolute path of the config file directory.
       * 		Defaults to `"/"`.
       * @param {boolean} [options.normalized=false] Flag indicating if the
       *      configs have already been normalized.
       * @param {Object} [options.schema] The additional schema
       *      definitions to use for the ConfigArray schema.
       * @param {Array<string>} [options.extraConfigTypes] List of config types supported.
       * @throws {TypeError} When the `basePath` is not a non-empty string,
       */
      constructor(configs, {
        basePath = "/",
        normalized = false,
        schema: customSchema,
        extraConfigTypes = []
      } = {}) {
        super();
        /**
         * The namespaced path of the config file directory.
         * @type {string}
         */
        __privateAdd(this, _namespacedBasePath);
        /**
         * Path-handling implementations.
         * @type {PathImpl}
         */
        __privateAdd(this, _path);
        this[ConfigArraySymbol.isNormalized] = normalized;
        this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(
          Object.assign({}, customSchema, baseSchema)
        );
        if (!isString(basePath) || !basePath) {
          throw new TypeError("basePath must be a non-empty string");
        }
        this.basePath = basePath;
        assertExtraConfigTypes(extraConfigTypes);
        this.extraConfigTypes = [...extraConfigTypes];
        Object.freeze(this.extraConfigTypes);
        this[ConfigArraySymbol.configCache] = /* @__PURE__ */ new Map();
        dataCache.set(this, {
          explicitMatches: /* @__PURE__ */ new Map(),
          directoryMatches: /* @__PURE__ */ new Map(),
          files: void 0,
          ignores: void 0
        });
        if (Array.isArray(configs)) {
          this.push(...configs);
        } else {
          this.push(configs);
        }
        __privateSet(this, _path, getPathImpl(basePath));
        __privateSet(this, _namespacedBasePath, __privateGet(this, _path).toNamespacedPath(basePath));
      }
      /**
       * Prevent normal array methods from creating a new `ConfigArray` instance.
       * This is to ensure that methods such as `slice()` won't try to create a
       * new instance of `ConfigArray` behind the scenes as doing so may throw
       * an error due to the different constructor signature.
       * @type {ArrayConstructor} The `Array` constructor.
       */
      static get [Symbol.species]() {
        return Array;
      }
      /**
       * Returns the `files` globs from every config object in the array.
       * This can be used to determine which files will be matched by a
       * config array or to use as a glob pattern when no patterns are provided
       * for a command line interface.
       * @returns {Array<string|Function>} An array of matchers.
       */
      get files() {
        assertNormalized(this);
        const cache2 = dataCache.get(this);
        if (cache2.files) {
          return cache2.files;
        }
        const result = [];
        for (const config2 of this) {
          if (config2.files) {
            config2.files.forEach((filePattern) => {
              result.push(filePattern);
            });
          }
        }
        cache2.files = result;
        dataCache.set(this, cache2);
        return result;
      }
      /**
       * Returns ignore matchers that should always be ignored regardless of
       * the matching `files` fields in any configs. This is necessary to mimic
       * the behavior of things like .gitignore and .eslintignore, allowing a
       * globbing operation to be faster.
       * @returns {Object[]} An array of config objects representing global ignores.
       */
      get ignores() {
        assertNormalized(this);
        const cache2 = dataCache.get(this);
        if (cache2.ignores) {
          return cache2.ignores;
        }
        const result = [];
        for (const config2 of this) {
          if (config2.ignores && Object.keys(config2).filter((key) => !META_FIELDS.has(key)).length === 1) {
            result.push(config2);
          }
        }
        cache2.ignores = result;
        dataCache.set(this, cache2);
        return result;
      }
      /**
       * Indicates if the config array has been normalized.
       * @returns {boolean} True if the config array is normalized, false if not.
       */
      isNormalized() {
        return this[ConfigArraySymbol.isNormalized];
      }
      /**
       * Normalizes a config array by flattening embedded arrays and executing
       * config functions.
       * @param {Object} [context] The context object for config functions.
       * @returns {Promise<ConfigArray>} The current ConfigArray instance.
       */
      async normalize(context = {}) {
        if (!this.isNormalized()) {
          const normalizedConfigs = await normalize2(
            this,
            context,
            this.extraConfigTypes,
            __privateGet(this, _namespacedBasePath),
            __privateGet(this, _path)
          );
          this.length = 0;
          this.push(
            ...normalizedConfigs.map(
              this[ConfigArraySymbol.preprocessConfig].bind(this)
            )
          );
          this.forEach(assertValidBaseConfig);
          this[ConfigArraySymbol.isNormalized] = true;
          Object.freeze(this);
        }
        return this;
      }
      /**
       * Normalizes a config array by flattening embedded arrays and executing
       * config functions.
       * @param {Object} [context] The context object for config functions.
       * @returns {ConfigArray} The current ConfigArray instance.
       */
      normalizeSync(context = {}) {
        if (!this.isNormalized()) {
          const normalizedConfigs = normalizeSync(
            this,
            context,
            this.extraConfigTypes,
            __privateGet(this, _namespacedBasePath),
            __privateGet(this, _path)
          );
          this.length = 0;
          this.push(
            ...normalizedConfigs.map(
              this[ConfigArraySymbol.preprocessConfig].bind(this)
            )
          );
          this.forEach(assertValidBaseConfig);
          this[ConfigArraySymbol.isNormalized] = true;
          Object.freeze(this);
        }
        return this;
      }
      /* eslint-disable class-methods-use-this -- Desired as instance methods */
      /**
       * Finalizes the state of a config before being cached and returned by
       * `getConfig()`. Does nothing by default but is provided to be
       * overridden by subclasses as necessary.
       * @param {Object} config The config to finalize.
       * @returns {Object} The finalized config.
       */
      // Cast key to `never` to prevent TypeScript from adding the signature `[x: symbol]: (config: any) => any` to the type of the class.
      [
        /** @type {never} */
        ConfigArraySymbol.finalizeConfig
      ](config2) {
        return config2;
      }
      /**
       * Preprocesses a config during the normalization process. This is the
       * method to override if you want to convert an array item before it is
       * validated for the first time. For example, if you want to replace a
       * string with an object, this is the method to override.
       * @param {Object} config The config to preprocess.
       * @returns {Object} The config to use in place of the argument.
       */
      // Cast key to `never` to prevent TypeScript from adding the signature `[x: symbol]: (config: any) => any` to the type of the class.
      [
        /** @type {never} */
        ConfigArraySymbol.preprocessConfig
      ](config2) {
        return config2;
      }
      /* eslint-enable class-methods-use-this -- Desired as instance methods */
      /**
       * Returns the config object for a given file path and a status that can be used to determine why a file has no config.
       * @param {string} filePath The path of a file to get a config for.
       * @returns {{ config?: Object, status: "ignored"|"external"|"unconfigured"|"matched" }}
       * An object with an optional property `config` and property `status`.
       * `config` is the config object for the specified file as returned by {@linkcode ConfigArray.getConfig},
       * `status` a is one of the constants returned by {@linkcode ConfigArray.getConfigStatus}.
       */
      getConfigWithStatus(filePath) {
        assertNormalized(this);
        const cache2 = this[ConfigArraySymbol.configCache];
        if (cache2.has(filePath)) {
          return cache2.get(filePath);
        }
        const relativeToBaseFilePath = toRelativePath(
          filePath,
          __privateGet(this, _namespacedBasePath),
          __privateGet(this, _path)
        );
        if (EXTERNAL_PATH_REGEX.test(relativeToBaseFilePath)) {
          debug(`No config for file ${filePath} outside of base path`);
          cache2.set(filePath, CONFIG_WITH_STATUS_EXTERNAL);
          return CONFIG_WITH_STATUS_EXTERNAL;
        }
        if (this.isDirectoryIgnored(__privateGet(this, _path).dirname(filePath))) {
          debug(`Ignoring ${filePath} based on directory pattern`);
          cache2.set(filePath, CONFIG_WITH_STATUS_IGNORED);
          return CONFIG_WITH_STATUS_IGNORED;
        }
        if (shouldIgnorePath(this.ignores, filePath, relativeToBaseFilePath, {
          basePath: __privateGet(this, _namespacedBasePath),
          path: __privateGet(this, _path)
        })) {
          debug(`Ignoring ${filePath} based on file pattern`);
          cache2.set(filePath, CONFIG_WITH_STATUS_IGNORED);
          return CONFIG_WITH_STATUS_IGNORED;
        }
        const matchingConfigIndices = [];
        let matchFound = false;
        const universalPattern = /^\*$|^!|\/\*{1,2}$/u;
        this.forEach((config2, index) => {
          const relativeFilePath = config2.basePath ? toRelativePath(
            __privateGet(this, _path).resolve(__privateGet(this, _namespacedBasePath), filePath),
            config2.basePath,
            __privateGet(this, _path)
          ) : relativeToBaseFilePath;
          if (config2.basePath && EXTERNAL_PATH_REGEX.test(relativeFilePath)) {
            debug(
              `Skipped config found for ${filePath} (based on config's base path: ${config2.basePath}`
            );
            return;
          }
          if (!config2.files) {
            if (!config2.ignores) {
              debug(`Universal config found for ${filePath}`);
              matchingConfigIndices.push(index);
              return;
            }
            if (Object.keys(config2).filter((key) => !META_FIELDS.has(key)).length === 1) {
              debug(
                `Skipped config found for ${filePath} (global ignores)`
              );
              return;
            }
            if (shouldIgnorePath(
              [{ ignores: config2.ignores }],
              filePath,
              relativeFilePath
            )) {
              debug(
                `Skipped config found for ${filePath} (based on ignores: ${config2.ignores})`
              );
              return;
            }
            debug(
              `Matching config found for ${filePath} (based on ignores: ${config2.ignores})`
            );
            matchingConfigIndices.push(index);
            return;
          }
          const nonUniversalFiles = [];
          const universalFiles = config2.files.filter((element) => {
            if (Array.isArray(element)) {
              if (element.every((pattern2) => universalPattern.test(pattern2))) {
                return true;
              }
              nonUniversalFiles.push(element);
              return false;
            }
            if (universalPattern.test(element)) {
              return true;
            }
            nonUniversalFiles.push(element);
            return false;
          });
          if (universalFiles.length) {
            debug("Universal files patterns found. Checking carefully.");
            if (nonUniversalFiles.length && pathMatches(filePath, relativeFilePath, {
              files: nonUniversalFiles,
              ignores: config2.ignores
            })) {
              debug(`Matching config found for ${filePath}`);
              matchingConfigIndices.push(index);
              matchFound = true;
              return;
            }
            if (universalFiles.length && pathMatches(filePath, relativeFilePath, {
              files: universalFiles,
              ignores: config2.ignores
            })) {
              debug(`Matching config found for ${filePath}`);
              matchingConfigIndices.push(index);
              return;
            }
            return;
          }
          if (pathMatches(filePath, relativeFilePath, config2)) {
            debug(`Matching config found for ${filePath}`);
            matchingConfigIndices.push(index);
            matchFound = true;
          }
        });
        if (!matchFound) {
          debug(`No matching configs found for ${filePath}`);
          cache2.set(filePath, CONFIG_WITH_STATUS_UNCONFIGURED);
          return CONFIG_WITH_STATUS_UNCONFIGURED;
        }
        const indicesKey = matchingConfigIndices.toString();
        let configWithStatus = cache2.get(indicesKey);
        if (configWithStatus) {
          cache2.set(filePath, configWithStatus);
          return configWithStatus;
        }
        let finalConfig = matchingConfigIndices.reduce((result, index) => {
          try {
            return this[ConfigArraySymbol.schema].merge(
              result,
              this[index]
            );
          } catch (validationError) {
            rethrowConfigError(this[index], index, validationError);
          }
        }, {});
        finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);
        configWithStatus = Object.freeze({
          config: finalConfig,
          status: "matched"
        });
        cache2.set(filePath, configWithStatus);
        cache2.set(indicesKey, configWithStatus);
        return configWithStatus;
      }
      /**
       * Returns the config object for a given file path.
       * @param {string} filePath The path of a file to get a config for.
       * @returns {Object|undefined} The config object for this file or `undefined`.
       */
      getConfig(filePath) {
        return this.getConfigWithStatus(filePath).config;
      }
      /**
       * Determines whether a file has a config or why it doesn't.
       * @param {string} filePath The path of the file to check.
       * @returns {"ignored"|"external"|"unconfigured"|"matched"} One of the following values:
       * * `"ignored"`: the file is ignored
       * * `"external"`: the file is outside the base path
       * * `"unconfigured"`: the file is not matched by any config
       * * `"matched"`: the file has a matching config
       */
      getConfigStatus(filePath) {
        return this.getConfigWithStatus(filePath).status;
      }
      /**
       * Determines if the given filepath is ignored based on the configs.
       * @param {string} filePath The path of a file to check.
       * @returns {boolean} True if the path is ignored, false if not.
       * @deprecated Use `isFileIgnored` instead.
       */
      isIgnored(filePath) {
        return this.isFileIgnored(filePath);
      }
      /**
       * Determines if the given filepath is ignored based on the configs.
       * @param {string} filePath The path of a file to check.
       * @returns {boolean} True if the path is ignored, false if not.
       */
      isFileIgnored(filePath) {
        return this.getConfigStatus(filePath) === "ignored";
      }
      /**
       * Determines if the given directory is ignored based on the configs.
       * This checks only default `ignores` that don't have `files` in the
       * same config. A pattern such as `/foo` be considered to ignore the directory
       * while a pattern such as `/foo/**` is not considered to ignore the
       * directory because it is matching files.
       * @param {string} directoryPath The path of a directory to check.
       * @returns {boolean} True if the directory is ignored, false if not. Will
       * 		return true for any directory that is not inside of `basePath`.
       * @throws {Error} When the `ConfigArray` is not normalized.
       */
      isDirectoryIgnored(directoryPath) {
        assertNormalized(this);
        const relativeDirectoryPath = toRelativePath(
          directoryPath,
          __privateGet(this, _namespacedBasePath),
          __privateGet(this, _path)
        );
        if (relativeDirectoryPath === "") {
          return false;
        }
        if (EXTERNAL_PATH_REGEX.test(relativeDirectoryPath)) {
          return true;
        }
        const cache2 = dataCache.get(this).directoryMatches;
        if (cache2.has(relativeDirectoryPath)) {
          return cache2.get(relativeDirectoryPath);
        }
        const directoryParts = relativeDirectoryPath.split("/");
        let relativeDirectoryToCheck = "";
        let result;
        do {
          relativeDirectoryToCheck += `${directoryParts.shift()}/`;
          result = shouldIgnorePath(
            this.ignores,
            __privateGet(this, _path).join(this.basePath, relativeDirectoryToCheck),
            relativeDirectoryToCheck,
            {
              basePath: __privateGet(this, _namespacedBasePath),
              path: __privateGet(this, _path)
            }
          );
          cache2.set(relativeDirectoryToCheck, result);
        } while (!result && directoryParts.length);
        cache2.set(relativeDirectoryPath, result);
        return result;
      }
    }
    _namespacedBasePath = new WeakMap();
    _path = new WeakMap();
    Object.defineProperty(exports$1, "ObjectSchema", {
      enumerable: true,
      get: function() {
        return objectSchema.ObjectSchema;
      }
    });
    exports$1.ConfigArray = ConfigArray;
    exports$1.ConfigArraySymbol = ConfigArraySymbol;
  })(cjs$1);
  return cjs$1;
}
var id = "http://json-schema.org/draft-04/schema#";
var $schema = "http://json-schema.org/draft-04/schema#";
var description = "Core schema meta-schema";
var definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: true
  }
};
var type = "object";
var properties = {
  id: {
    type: "string"
  },
  $schema: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: true
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    "default": false
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    "default": false
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    "default": {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    "default": {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  "enum": {
    type: "array",
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var dependencies = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
};
var require$$1 = {
  id,
  $schema,
  description,
  definitions,
  type,
  properties,
  dependencies,
  "default": {}
};
var ajv;
var hasRequiredAjv;
function requireAjv() {
  if (hasRequiredAjv) return ajv;
  hasRequiredAjv = 1;
  const Ajv = requireAjv$1(), metaSchema = require$$1;
  ajv = (additionalOptions = {}) => {
    const ajv2 = new Ajv({
      meta: false,
      useDefaults: true,
      validateSchema: false,
      missingRefs: "ignore",
      verbose: true,
      schemaId: "auto",
      ...additionalOptions
    });
    ajv2.addMetaSchema(metaSchema);
    ajv2._opts.defaultMeta = metaSchema.id;
    return ajv2;
  };
  return ajv;
}
var rules$2 = {
  "generator-star": [
    "generator-star-spacing"
  ],
  "global-strict": [
    "strict"
  ],
  "no-arrow-condition": [
    "no-confusing-arrow",
    "no-constant-condition"
  ],
  "no-comma-dangle": [
    "comma-dangle"
  ],
  "no-empty-class": [
    "no-empty-character-class"
  ],
  "no-empty-label": [
    "no-labels"
  ],
  "no-extra-strict": [
    "strict"
  ],
  "no-reserved-keys": [
    "quote-props"
  ],
  "no-space-before-semi": [
    "semi-spacing"
  ],
  "no-wrap-func": [
    "no-extra-parens"
  ],
  "space-after-function-name": [
    "space-before-function-paren"
  ],
  "space-after-keywords": [
    "keyword-spacing"
  ],
  "space-before-function-parentheses": [
    "space-before-function-paren"
  ],
  "space-before-keywords": [
    "keyword-spacing"
  ],
  "space-in-brackets": [
    "object-curly-spacing",
    "array-bracket-spacing",
    "computed-property-spacing"
  ],
  "space-return-throw-case": [
    "keyword-spacing"
  ],
  "space-unary-word-ops": [
    "space-unary-ops"
  ],
  "spaced-line-comment": [
    "spaced-comment"
  ]
};
var require$$3 = {
  rules: rules$2
};
var config;
var hasRequiredConfig;
function requireConfig() {
  var _languageName, _processorName, _Config_instances, normalizeRulesConfig_fn;
  if (hasRequiredConfig) return config;
  hasRequiredConfig = 1;
  const { deepMergeArrays } = requireDeepMergeArrays();
  const { flatConfigSchema, hasMethod } = requireFlatConfigSchema();
  const { ObjectSchema } = requireCjs();
  const ajvImport = requireAjv();
  const ajv2 = ajvImport();
  const ruleReplacements = require$$3;
  const noOptionsSchema = Object.freeze({
    type: "array",
    minItems: 0,
    maxItems: 0
  });
  const severities = /* @__PURE__ */ new Map([
    [0, 0],
    [1, 1],
    [2, 2],
    ["off", 0],
    ["warn", 1],
    ["error", 2]
  ]);
  const validators = /* @__PURE__ */ new WeakMap();
  function throwRuleNotFoundError({ pluginName, ruleName }, config2) {
    const ruleId = pluginName === "@" ? ruleName : `${pluginName}/${ruleName}`;
    const errorMessageHeader = `Key "rules": Key "${ruleId}"`;
    let errorMessage = `${errorMessageHeader}: Could not find plugin "${pluginName}" in configuration.`;
    const missingPluginErrorMessage = errorMessage;
    if (config2.plugins && config2.plugins[pluginName]) {
      const replacementRuleName = ruleReplacements.rules[ruleName];
      if (pluginName === "@" && replacementRuleName) {
        errorMessage = `${errorMessageHeader}: Rule "${ruleName}" was removed and replaced by "${replacementRuleName}".`;
      } else {
        errorMessage = `${errorMessageHeader}: Could not find "${ruleName}" in plugin "${pluginName}".`;
        for (const [otherPluginName, otherPlugin] of Object.entries(
          config2.plugins
        )) {
          if (otherPlugin.rules && otherPlugin.rules[ruleName]) {
            errorMessage += ` Did you mean "${otherPluginName}/${ruleName}"?`;
            break;
          }
        }
      }
    }
    const error = new TypeError(errorMessage);
    if (errorMessage === missingPluginErrorMessage) {
      error.messageTemplate = "config-plugin-missing";
      error.messageData = { pluginName, ruleId };
    }
    throw error;
  }
  class InvalidRuleOptionsSchemaError extends Error {
    /**
     * Creates a new instance.
     * @param {string} ruleId Id of the rule that has an invalid `meta.schema`.
     * @param {Error} processingError Error caught while processing the `meta.schema`.
     */
    constructor(ruleId, processingError) {
      super(
        `Error while processing options validation schema of rule '${ruleId}': ${processingError.message}`,
        { cause: processingError }
      );
      this.code = "ESLINT_INVALID_RULE_OPTIONS_SCHEMA";
    }
  }
  function parseRuleId(ruleId) {
    let pluginName, ruleName;
    if (ruleId.includes("/")) {
      if (ruleId.startsWith("@")) {
        pluginName = ruleId.slice(0, ruleId.lastIndexOf("/"));
      } else {
        pluginName = ruleId.slice(0, ruleId.indexOf("/"));
      }
      ruleName = ruleId.slice(pluginName.length + 1);
    } else {
      pluginName = "@";
      ruleName = ruleId;
    }
    return {
      pluginName,
      ruleName
    };
  }
  function getRuleFromConfig(ruleId, config2) {
    var _a2, _b, _c;
    const { pluginName, ruleName } = parseRuleId(ruleId);
    return (_c = (_b = (_a2 = config2.plugins) == null ? void 0 : _a2[pluginName]) == null ? void 0 : _b.rules) == null ? void 0 : _c[ruleName];
  }
  function getRuleOptionsSchema(rule) {
    if (!rule.meta) {
      return { ...noOptionsSchema };
    }
    const schema = rule.meta.schema;
    if (typeof schema === "undefined") {
      return { ...noOptionsSchema };
    }
    if (schema === false) {
      return null;
    }
    if (typeof schema !== "object" || schema === null) {
      throw new TypeError("Rule's `meta.schema` must be an array or object");
    }
    if (Array.isArray(schema)) {
      if (schema.length) {
        return {
          type: "array",
          items: schema,
          minItems: 0,
          maxItems: schema.length
        };
      }
      return { ...noOptionsSchema };
    }
    return schema;
  }
  function splitPluginIdentifier(identifier) {
    const parts = identifier.split("/");
    return {
      objectName: parts.pop(),
      pluginName: parts.join("/")
    };
  }
  function getObjectId(object) {
    let name2 = object.name;
    if (!name2) {
      if (!object.meta) {
        return null;
      }
      name2 = object.meta.name;
      if (!name2) {
        return null;
      }
    }
    let version2 = object.version;
    if (!version2) {
      version2 = object.meta && object.meta.version;
    }
    if (version2) {
      return `${name2}@${version2}`;
    }
    return name2;
  }
  function assertNotFunction(value, key, objectKey) {
    if (typeof value === "function") {
      const error = new TypeError(
        `Cannot serialize key "${key}" in "${objectKey}": Function values are not supported.`
      );
      error.messageTemplate = "config-serialize-function";
      error.messageData = { key, objectKey };
      throw error;
    }
  }
  function languageOptionsToJSON(languageOptions, objectKey = "languageOptions") {
    if (typeof languageOptions.toJSON === "function") {
      const result2 = languageOptions.toJSON();
      assertNotFunction(result2, "toJSON", objectKey);
      return result2;
    }
    const result = {};
    for (const [key, value] of Object.entries(languageOptions)) {
      if (value) {
        if (typeof value === "object") {
          const name2 = getObjectId(value);
          if (typeof value.toJSON === "function") {
            result[key] = value.toJSON();
            assertNotFunction(result[key], key, objectKey);
          } else if (name2 && hasMethod(value)) {
            result[key] = name2;
          } else {
            result[key] = languageOptionsToJSON(value, key);
          }
          continue;
        }
        assertNotFunction(value, key, objectKey);
      }
      result[key] = value;
    }
    return result;
  }
  function getOrCreateValidator(rule, ruleId) {
    if (!validators.has(rule)) {
      try {
        const schema = getRuleOptionsSchema(rule);
        if (schema) {
          validators.set(rule, ajv2.compile(schema));
        }
      } catch (err) {
        throw new InvalidRuleOptionsSchemaError(ruleId, err);
      }
    }
    return validators.get(rule);
  }
  class Config {
    /**
     * Creates a new instance.
     * @param {Object} config The configuration object.
     */
    constructor(config2) {
      __privateAdd(this, _Config_instances);
      /**
       * The name to use for the language when serializing to JSON.
       * @type {string|undefined}
       */
      __privateAdd(this, _languageName);
      /**
       * The name to use for the processor when serializing to JSON.
       * @type {string|undefined}
       */
      __privateAdd(this, _processorName);
      const { plugins, language: language2, languageOptions, processor, ...otherKeys } = config2;
      const schema = new ObjectSchema(flatConfigSchema);
      schema.validate(config2);
      Object.assign(this, otherKeys);
      if (!language2) {
        throw new TypeError("Key 'language' is required.");
      }
      this.plugins = plugins;
      this.language = language2;
      const {
        pluginName: languagePluginName,
        objectName: localLanguageName
      } = splitPluginIdentifier(language2);
      __privateSet(this, _languageName, language2);
      if (!plugins || !plugins[languagePluginName] || !plugins[languagePluginName].languages || !plugins[languagePluginName].languages[localLanguageName]) {
        throw new TypeError(
          `Key "language": Could not find "${localLanguageName}" in plugin "${languagePluginName}".`
        );
      }
      this.language = plugins[languagePluginName].languages[localLanguageName];
      if (this.language.defaultLanguageOptions ?? languageOptions) {
        this.languageOptions = flatConfigSchema.languageOptions.merge(
          this.language.defaultLanguageOptions,
          languageOptions
        );
      } else {
        this.languageOptions = {};
      }
      try {
        this.language.validateLanguageOptions(this.languageOptions);
      } catch (error) {
        throw new TypeError(`Key "languageOptions": ${error.message}`, {
          cause: error
        });
      }
      if (this.language.normalizeLanguageOptions) {
        this.languageOptions = this.language.normalizeLanguageOptions(
          this.languageOptions
        );
      }
      if (processor) {
        this.processor = processor;
        if (typeof processor === "string") {
          const { pluginName, objectName: localProcessorName } = splitPluginIdentifier(processor);
          __privateSet(this, _processorName, processor);
          if (!plugins || !plugins[pluginName] || !plugins[pluginName].processors || !plugins[pluginName].processors[localProcessorName]) {
            throw new TypeError(
              `Key "processor": Could not find "${localProcessorName}" in plugin "${pluginName}".`
            );
          }
          this.processor = plugins[pluginName].processors[localProcessorName];
        } else if (typeof processor === "object") {
          __privateSet(this, _processorName, getObjectId(processor));
          this.processor = processor;
        } else {
          throw new TypeError(
            "Key 'processor' must be a string or an object."
          );
        }
      }
      if (this.rules) {
        __privateMethod(this, _Config_instances, normalizeRulesConfig_fn).call(this);
        this.validateRulesConfig(this.rules);
      }
    }
    /**
     * Converts the configuration to a JSON representation.
     * @returns {Record<string, any>} The JSON representation of the configuration.
     * @throws {Error} If the configuration cannot be serialized.
     */
    toJSON() {
      if (this.processor && !__privateGet(this, _processorName)) {
        throw new Error(
          "Could not serialize processor object (missing 'meta' object)."
        );
      }
      if (!__privateGet(this, _languageName)) {
        throw new Error(
          "Could not serialize language object (missing 'meta' object)."
        );
      }
      return {
        ...this,
        plugins: Object.entries(this.plugins).map(([namespace, plugin2]) => {
          const pluginId = getObjectId(plugin2);
          if (!pluginId) {
            return namespace;
          }
          return `${namespace}:${pluginId}`;
        }),
        language: __privateGet(this, _languageName),
        languageOptions: languageOptionsToJSON(this.languageOptions),
        processor: __privateGet(this, _processorName)
      };
    }
    /**
     * Gets a rule configuration by its ID.
     * @param {string} ruleId The ID of the rule to get.
     * @returns {RuleDefinition|undefined} The rule definition from the plugin, or `undefined` if the rule is not found.
     */
    getRuleDefinition(ruleId) {
      return getRuleFromConfig(ruleId, this);
    }
    /**
     * Validates all of the rule configurations in the given rules config
     * against the plugins in this instance. This is used primarily to
     * validate inline configuration rules while inting.
     * @param {Object} rulesConfig The rules config to validate.
     * @returns {void}
     * @throws {Error} If a rule's configuration does not match its schema.
     * @throws {TypeError} If the rulesConfig is not provided or is invalid.
     * @throws {InvalidRuleOptionsSchemaError} If a rule's `meta.schema` is invalid.
     * @throws {TypeError} If a rule is not found in the plugins.
     */
    validateRulesConfig(rulesConfig) {
      if (!rulesConfig) {
        throw new TypeError("Config is required for validation.");
      }
      for (const [ruleId, ruleOptions] of Object.entries(rulesConfig)) {
        if (ruleId === "__proto__") {
          continue;
        }
        if (ruleOptions[0] === 0) {
          continue;
        }
        const rule = getRuleFromConfig(ruleId, this);
        if (!rule) {
          throwRuleNotFoundError(parseRuleId(ruleId), this);
        }
        const validateRule = getOrCreateValidator(rule, ruleId);
        if (validateRule) {
          validateRule(ruleOptions.slice(1));
          if (validateRule.errors) {
            throw new Error(
              `Key "rules": Key "${ruleId}":
${validateRule.errors.map((error) => {
                var _a2, _b;
                if (error.keyword === "additionalProperties" && error.schema === false && typeof ((_a2 = error.parentSchema) == null ? void 0 : _a2.properties) === "object" && typeof ((_b = error.params) == null ? void 0 : _b.additionalProperty) === "string") {
                  const expectedProperties = Object.keys(
                    error.parentSchema.properties
                  ).map((property) => `"${property}"`);
                  return `	Value ${JSON.stringify(error.data)} ${error.message}.
		Unexpected property "${error.params.additionalProperty}". Expected properties: ${expectedProperties.join(", ")}.
`;
                }
                return `	Value ${JSON.stringify(error.data)} ${error.message}.
`;
              }).join("")}`
            );
          }
        }
      }
    }
    /**
     * Gets a complete options schema for a rule.
     * @param {RuleDefinition} ruleDefinition A rule definition object.
     * @throws {TypeError} If `meta.schema` is specified but is not an array, object or `false`.
     * @returns {Object|null} JSON Schema for the rule's options. `null` if `meta.schema` is `false`.
     */
    static getRuleOptionsSchema(ruleDefinition) {
      return getRuleOptionsSchema(ruleDefinition);
    }
    /**
     * Normalizes the severity value of a rule's configuration to a number
     * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally
     * received from the user. A valid config value is either 0, 1, 2, the string "off" (treated the same as 0),
     * the string "warn" (treated the same as 1), the string "error" (treated the same as 2), or an array
     * whose first element is one of the above values. Strings are matched case-insensitively.
     * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.
     */
    static getRuleNumericSeverity(ruleConfig) {
      const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
      if (severities.has(severityValue)) {
        return severities.get(severityValue);
      }
      if (typeof severityValue === "string") {
        return severities.get(severityValue.toLowerCase()) ?? 0;
      }
      return 0;
    }
  }
  _languageName = new WeakMap();
  _processorName = new WeakMap();
  _Config_instances = new WeakSet();
  /**
   * Normalizes the rules configuration. Ensures that each rule config is
   * an array and that the severity is a number. Applies meta.defaultOptions.
   * This function modifies `this.rules`.
   * @returns {void}
   */
  normalizeRulesConfig_fn = function() {
    var _a2;
    for (const [ruleId, originalConfig] of Object.entries(this.rules)) {
      let ruleConfig = Array.isArray(originalConfig) ? originalConfig : [originalConfig];
      ruleConfig[0] = severities.get(ruleConfig[0]);
      const rule = getRuleFromConfig(ruleId, this);
      const slicedOptions = ruleConfig.slice(1);
      const mergedOptions = deepMergeArrays(
        (_a2 = rule == null ? void 0 : rule.meta) == null ? void 0 : _a2.defaultOptions,
        slicedOptions
      );
      if (mergedOptions.length) {
        ruleConfig = [ruleConfig[0], ...mergedOptions];
      }
      this.rules[ruleId] = ruleConfig;
    }
  };
  config = { Config };
  return config;
}
var applyDisableDirectives;
var hasRequiredApplyDisableDirectives;
function requireApplyDisableDirectives() {
  if (hasRequiredApplyDisableDirectives) return applyDisableDirectives;
  hasRequiredApplyDisableDirectives = 1;
  const escapeRegExp = requireEscapeStringRegexp();
  const { Config } = requireConfig();
  function compareLocations(itemA, itemB) {
    return itemA.line - itemB.line || itemA.column - itemB.column;
  }
  function groupByParentDirective(directives2) {
    const groups = /* @__PURE__ */ new Map();
    for (const directive of directives2) {
      const {
        unprocessedDirective: { parentDirective }
      } = directive;
      if (groups.has(parentDirective)) {
        groups.get(parentDirective).push(directive);
      } else {
        groups.set(parentDirective, [directive]);
      }
    }
    return [...groups.values()];
  }
  function createIndividualDirectivesRemoval(directives2, parentDirective, sourceCode2) {
    const listText = parentDirective.value.trim();
    const listStart = sourceCode2.text.indexOf(
      listText,
      sourceCode2.getRange(parentDirective.node)[0]
    );
    return directives2.map((directive) => {
      const { ruleId } = directive;
      const regex = new RegExp(
        String.raw`(?:^|\s*,\s*)(?<quote>['"]?)${escapeRegExp(ruleId)}\k<quote>(?:\s*,\s*|$)`,
        "u"
      );
      const match = regex.exec(listText);
      const matchedText = match[0];
      const matchStart = listStart + match.index;
      const matchEnd = matchStart + matchedText.length;
      const firstIndexOfComma = matchedText.indexOf(",");
      const lastIndexOfComma = matchedText.lastIndexOf(",");
      let removalStart, removalEnd;
      if (firstIndexOfComma !== lastIndexOfComma) {
        removalStart = matchStart + firstIndexOfComma;
        removalEnd = matchStart + lastIndexOfComma;
      } else {
        removalStart = matchStart;
        removalEnd = matchEnd;
      }
      return {
        description: `'${ruleId}'`,
        fix: {
          range: [removalStart, removalEnd],
          text: ""
        },
        unprocessedDirective: directive.unprocessedDirective
      };
    });
  }
  function createDirectiveRemoval(directives2, node2, sourceCode2) {
    const range = sourceCode2.getRange(node2);
    const ruleIds = directives2.filter((directive) => directive.ruleId).map((directive) => `'${directive.ruleId}'`);
    return {
      description: ruleIds.length <= 2 ? ruleIds.join(" or ") : `${ruleIds.slice(0, ruleIds.length - 1).join(", ")}, or ${ruleIds.at(-1)}`,
      fix: {
        range,
        text: " "
      },
      unprocessedDirective: directives2[0].unprocessedDirective
    };
  }
  function processUnusedDirectives(allDirectives, sourceCode2) {
    const directiveGroups = groupByParentDirective(allDirectives);
    return directiveGroups.flatMap((directives2) => {
      const { parentDirective } = directives2[0].unprocessedDirective;
      const remainingRuleIds = new Set(parentDirective.ruleIds);
      for (const directive of directives2) {
        remainingRuleIds.delete(directive.ruleId);
      }
      return remainingRuleIds.size ? createIndividualDirectivesRemoval(
        directives2,
        parentDirective,
        sourceCode2
      ) : [
        createDirectiveRemoval(
          directives2,
          parentDirective.node,
          sourceCode2
        )
      ];
    });
  }
  function collectUsedEnableDirectives(directives2) {
    const enabledRules = /* @__PURE__ */ new Map();
    const usedEnableDirectives = /* @__PURE__ */ new Set();
    for (let index = directives2.length - 1; index >= 0; index--) {
      const directive = directives2[index];
      if (directive.type === "disable") {
        if (enabledRules.size === 0) {
          continue;
        }
        if (directive.ruleId === null) {
          for (const enableDirective of enabledRules.values()) {
            usedEnableDirectives.add(enableDirective);
          }
          enabledRules.clear();
        } else {
          const enableDirective = enabledRules.get(directive.ruleId);
          if (enableDirective) {
            usedEnableDirectives.add(enableDirective);
          } else {
            const enabledDirectiveWithoutRuleId = enabledRules.get(null);
            if (enabledDirectiveWithoutRuleId) {
              usedEnableDirectives.add(enabledDirectiveWithoutRuleId);
            }
          }
        }
      } else if (directive.type === "enable") {
        if (directive.ruleId === null) {
          enabledRules.clear();
          enabledRules.set(null, directive);
        } else {
          enabledRules.set(directive.ruleId, directive);
        }
      }
    }
    return usedEnableDirectives;
  }
  function applyDirectives(options) {
    const problems = [];
    const usedDisableDirectives = /* @__PURE__ */ new Set();
    const { sourceCode: sourceCode2 } = options;
    for (const problem of options.problems) {
      let disableDirectivesForProblem = [];
      let nextDirectiveIndex = 0;
      while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
        const directive = options.directives[nextDirectiveIndex++];
        if (directive.ruleId === null || directive.ruleId === problem.ruleId) {
          switch (directive.type) {
            case "disable":
              disableDirectivesForProblem.push(directive);
              break;
            case "enable":
              disableDirectivesForProblem = [];
              break;
          }
        }
      }
      if (disableDirectivesForProblem.length > 0) {
        const suppressions = disableDirectivesForProblem.map((directive) => ({
          kind: "directive",
          justification: directive.unprocessedDirective.justification
        }));
        if (problem.suppressions) {
          problem.suppressions = problem.suppressions.concat(suppressions);
        } else {
          problem.suppressions = suppressions;
          usedDisableDirectives.add(disableDirectivesForProblem.at(-1));
        }
      }
      problems.push(problem);
    }
    const unusedDisableDirectivesToReport = options.directives.filter(
      (directive) => directive.type === "disable" && !usedDisableDirectives.has(directive) && !options.rulesToIgnore.has(directive.ruleId)
    );
    const unusedEnableDirectivesToReport = new Set(
      options.directives.filter(
        (directive) => directive.unprocessedDirective.type === "enable" && !options.rulesToIgnore.has(directive.ruleId)
      )
    );
    if (unusedEnableDirectivesToReport.size > 0) {
      for (const directive of collectUsedEnableDirectives(
        options.directives
      )) {
        unusedEnableDirectivesToReport.delete(directive);
      }
    }
    const processed = processUnusedDirectives(
      unusedDisableDirectivesToReport,
      sourceCode2
    ).concat(
      processUnusedDirectives(unusedEnableDirectivesToReport, sourceCode2)
    );
    const columnOffset = options.language.columnStart === 1 ? 0 : 1;
    const lineOffset = options.language.lineStart === 1 ? 0 : 1;
    const unusedDirectives = processed.map(
      ({ description: description2, fix, unprocessedDirective }) => {
        const { parentDirective, type: type2, line, column } = unprocessedDirective;
        let message;
        if (type2 === "enable") {
          message = description2 ? `Unused eslint-enable directive (no matching eslint-disable directives were found for ${description2}).` : "Unused eslint-enable directive (no matching eslint-disable directives were found).";
        } else {
          message = description2 ? `Unused eslint-disable directive (no problems were reported from ${description2}).` : "Unused eslint-disable directive (no problems were reported).";
        }
        const loc = sourceCode2.getLoc(parentDirective.node);
        return {
          ruleId: null,
          message,
          line: type2 === "disable-next-line" ? loc.start.line + lineOffset : line,
          column: type2 === "disable-next-line" ? loc.start.column + columnOffset : column,
          severity: options.reportUnusedDisableDirectives === "warn" ? 1 : 2,
          nodeType: null,
          ...options.disableFixes ? {} : { fix }
        };
      }
    );
    return { problems, unusedDirectives };
  }
  applyDisableDirectives = ({
    language: language2,
    sourceCode: sourceCode2,
    directives: directives2,
    disableFixes,
    problems,
    configuredRules,
    ruleFilter,
    reportUnusedDisableDirectives = "off"
  }) => {
    const blockDirectives = directives2.filter(
      (directive) => directive.type === "disable" || directive.type === "enable"
    ).map(
      (directive) => Object.assign({}, directive, { unprocessedDirective: directive })
    ).sort(compareLocations);
    const lineDirectives = directives2.flatMap((directive) => {
      switch (directive.type) {
        case "disable":
        case "enable":
          return [];
        case "disable-line":
          return [
            {
              type: "disable",
              line: directive.line,
              column: 1,
              ruleId: directive.ruleId,
              unprocessedDirective: directive
            },
            {
              type: "enable",
              line: directive.line + 1,
              column: 0,
              ruleId: directive.ruleId,
              unprocessedDirective: directive
            }
          ];
        case "disable-next-line":
          return [
            {
              type: "disable",
              line: directive.line + 1,
              column: 1,
              ruleId: directive.ruleId,
              unprocessedDirective: directive
            },
            {
              type: "enable",
              line: directive.line + 2,
              column: 0,
              ruleId: directive.ruleId,
              unprocessedDirective: directive
            }
          ];
        default:
          throw new TypeError(
            `Unrecognized directive type '${directive.type}'`
          );
      }
    }).sort(compareLocations);
    const rulesToIgnore = configuredRules && ruleFilter ? new Set(
      Object.keys(configuredRules).filter((ruleId) => {
        const severity2 = Config.getRuleNumericSeverity(
          configuredRules[ruleId]
        );
        if (severity2 === 0) {
          return false;
        }
        return !ruleFilter({ severity: severity2, ruleId });
      })
    ) : /* @__PURE__ */ new Set();
    if (rulesToIgnore.size > 0) {
      rulesToIgnore.add(null);
    }
    const blockDirectivesResult = applyDirectives({
      language: language2,
      sourceCode: sourceCode2,
      problems,
      directives: blockDirectives,
      disableFixes,
      reportUnusedDisableDirectives,
      rulesToIgnore
    });
    const lineDirectivesResult = applyDirectives({
      language: language2,
      sourceCode: sourceCode2,
      problems: blockDirectivesResult.problems,
      directives: lineDirectives,
      disableFixes,
      reportUnusedDisableDirectives,
      rulesToIgnore
    });
    return reportUnusedDisableDirectives !== "off" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDirectives).concat(lineDirectivesResult.unusedDirectives).sort(compareLocations) : lineDirectivesResult.problems;
  };
  return applyDisableDirectives;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var lazyLoadingRuleMap;
var hasRequiredLazyLoadingRuleMap;
function requireLazyLoadingRuleMap() {
  if (hasRequiredLazyLoadingRuleMap) return lazyLoadingRuleMap;
  hasRequiredLazyLoadingRuleMap = 1;
  const debug = requireSrc()("eslint:rules");
  class LazyLoadingRuleMap extends Map {
    /**
     * Initialize this map.
     * @param {Array<[string, function(): Rule]>} loaders The rule loaders.
     */
    constructor(loaders) {
      let remaining = loaders.length;
      super(
        debug.enabled ? loaders.map(([ruleId, load]) => {
          let cache2 = null;
          return [
            ruleId,
            () => {
              if (!cache2) {
                debug(
                  "Loading rule %o (remaining=%d)",
                  ruleId,
                  --remaining
                );
                cache2 = load();
              }
              return cache2;
            }
          ];
        }) : loaders
      );
      Object.defineProperty(LazyLoadingRuleMap.prototype, "set", {
        configurable: true,
        value: void 0
      });
    }
    /**
     * Get a rule.
     * Each rule will be loaded on the first access.
     * @param {string} ruleId The rule ID to get.
     * @returns {Rule|undefined} The rule.
     */
    get(ruleId) {
      const load = super.get(ruleId);
      return load && load();
    }
    /**
     * Iterate rules.
     * @returns {IterableIterator<Rule>} Rules.
     */
    *values() {
      for (const load of super.values()) {
        yield load();
      }
    }
    /**
     * Iterate rules.
     * @returns {IterableIterator<[string, Rule]>} Rules.
     */
    *entries() {
      for (const [ruleId, load] of super.entries()) {
        yield [ruleId, load()];
      }
    }
    /**
     * Call a function with each rule.
     * @param {Function} callbackFn The callback function.
     * @param {any} [thisArg] The object to pass to `this` of the callback function.
     * @returns {void}
     */
    forEach(callbackFn, thisArg) {
      for (const [ruleId, load] of super.entries()) {
        callbackFn.call(thisArg, load(), ruleId, this);
      }
    }
  }
  Object.defineProperties(LazyLoadingRuleMap.prototype, {
    clear: { configurable: true, value: void 0 },
    delete: { configurable: true, value: void 0 },
    [Symbol.iterator]: {
      configurable: true,
      writable: true,
      value: LazyLoadingRuleMap.prototype.entries
    }
  });
  lazyLoadingRuleMap = { LazyLoadingRuleMap };
  return lazyLoadingRuleMap;
}
var astUtils = { exports: {} };
var utils = {};
var ast = { exports: {} };
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast.exports;
  hasRequiredAst = 1;
  (function() {
    function isExpression(node2) {
      if (node2 == null) {
        return false;
      }
      switch (node2.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function isIterationStatement(node2) {
      if (node2 == null) {
        return false;
      }
      switch (node2.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function isStatement(node2) {
      if (node2 == null) {
        return false;
      }
      switch (node2.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function isSourceElement(node2) {
      return isStatement(node2) || node2 != null && node2.type === "FunctionDeclaration";
    }
    function trailingStatement(node2) {
      switch (node2.type) {
        case "IfStatement":
          if (node2.alternate != null) {
            return node2.alternate;
          }
          return node2.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return node2.body;
      }
      return null;
    }
    function isProblematicIfStatement(node2) {
      var current;
      if (node2.type !== "IfStatement") {
        return false;
      }
      if (node2.alternate == null) {
        return false;
      }
      current = node2.consequent;
      do {
        if (current.type === "IfStatement") {
          if (current.alternate == null) {
            return true;
          }
        }
        current = trailingStatement(current);
      } while (current);
      return false;
    }
    ast.exports = {
      isExpression,
      isStatement,
      isIterationStatement,
      isSourceElement,
      isProblematicIfStatement,
      trailingStatement
    };
  })();
  return ast.exports;
}
var code = { exports: {} };
var hasRequiredCode;
function requireCode() {
  if (hasRequiredCode) return code.exports;
  hasRequiredCode = 1;
  (function() {
    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
    ES5Regex = {
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };
    ES6Regex = {
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function isDecimalDigit(ch2) {
      return 48 <= ch2 && ch2 <= 57;
    }
    function isHexDigit(ch2) {
      return 48 <= ch2 && ch2 <= 57 || // 0..9
      97 <= ch2 && ch2 <= 102 || // a..f
      65 <= ch2 && ch2 <= 70;
    }
    function isOctalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    NON_ASCII_WHITESPACES = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function isWhiteSpace(ch2) {
      return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
    }
    function isLineTerminator(ch2) {
      return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
    }
    function fromCodePoint2(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      }
      var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
      var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
      return cu1 + cu2;
    }
    IDENTIFIER_START = new Array(128);
    for (ch = 0; ch < 128; ++ch) {
      IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
      ch >= 65 && ch <= 90 || // A..Z
      ch === 36 || ch === 95;
    }
    IDENTIFIER_PART = new Array(128);
    for (ch = 0; ch < 128; ++ch) {
      IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
      ch >= 65 && ch <= 90 || // A..Z
      ch >= 48 && ch <= 57 || // 0..9
      ch === 36 || ch === 95;
    }
    function isIdentifierStartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint2(ch2));
    }
    function isIdentifierPartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint2(ch2));
    }
    function isIdentifierStartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint2(ch2));
    }
    function isIdentifierPartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint2(ch2));
    }
    code.exports = {
      isDecimalDigit,
      isHexDigit,
      isOctalDigit,
      isWhiteSpace,
      isLineTerminator,
      isIdentifierStartES5,
      isIdentifierPartES5,
      isIdentifierStartES6,
      isIdentifierPartES6
    };
  })();
  return code.exports;
}
var keyword = { exports: {} };
var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword.exports;
  hasRequiredKeyword = 1;
  (function() {
    var code2 = requireCode();
    function isStrictModeReservedWordES6(id2) {
      switch (id2) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function isKeywordES5(id2, strict2) {
      if (!strict2 && id2 === "yield") {
        return false;
      }
      return isKeywordES6(id2, strict2);
    }
    function isKeywordES6(id2, strict2) {
      if (strict2 && isStrictModeReservedWordES6(id2)) {
        return true;
      }
      switch (id2.length) {
        case 2:
          return id2 === "if" || id2 === "in" || id2 === "do";
        case 3:
          return id2 === "var" || id2 === "for" || id2 === "new" || id2 === "try";
        case 4:
          return id2 === "this" || id2 === "else" || id2 === "case" || id2 === "void" || id2 === "with" || id2 === "enum";
        case 5:
          return id2 === "while" || id2 === "break" || id2 === "catch" || id2 === "throw" || id2 === "const" || id2 === "yield" || id2 === "class" || id2 === "super";
        case 6:
          return id2 === "return" || id2 === "typeof" || id2 === "delete" || id2 === "switch" || id2 === "export" || id2 === "import";
        case 7:
          return id2 === "default" || id2 === "finally" || id2 === "extends";
        case 8:
          return id2 === "function" || id2 === "continue" || id2 === "debugger";
        case 10:
          return id2 === "instanceof";
        default:
          return false;
      }
    }
    function isReservedWordES5(id2, strict2) {
      return id2 === "null" || id2 === "true" || id2 === "false" || isKeywordES5(id2, strict2);
    }
    function isReservedWordES6(id2, strict2) {
      return id2 === "null" || id2 === "true" || id2 === "false" || isKeywordES6(id2, strict2);
    }
    function isRestrictedWord(id2) {
      return id2 === "eval" || id2 === "arguments";
    }
    function isIdentifierNameES5(id2) {
      var i2, iz, ch;
      if (id2.length === 0) {
        return false;
      }
      ch = id2.charCodeAt(0);
      if (!code2.isIdentifierStartES5(ch)) {
        return false;
      }
      for (i2 = 1, iz = id2.length; i2 < iz; ++i2) {
        ch = id2.charCodeAt(i2);
        if (!code2.isIdentifierPartES5(ch)) {
          return false;
        }
      }
      return true;
    }
    function decodeUtf16(lead, trail) {
      return (lead - 55296) * 1024 + (trail - 56320) + 65536;
    }
    function isIdentifierNameES6(id2) {
      var i2, iz, ch, lowCh, check2;
      if (id2.length === 0) {
        return false;
      }
      check2 = code2.isIdentifierStartES6;
      for (i2 = 0, iz = id2.length; i2 < iz; ++i2) {
        ch = id2.charCodeAt(i2);
        if (55296 <= ch && ch <= 56319) {
          ++i2;
          if (i2 >= iz) {
            return false;
          }
          lowCh = id2.charCodeAt(i2);
          if (!(56320 <= lowCh && lowCh <= 57343)) {
            return false;
          }
          ch = decodeUtf16(ch, lowCh);
        }
        if (!check2(ch)) {
          return false;
        }
        check2 = code2.isIdentifierPartES6;
      }
      return true;
    }
    function isIdentifierES5(id2, strict2) {
      return isIdentifierNameES5(id2) && !isReservedWordES5(id2, strict2);
    }
    function isIdentifierES6(id2, strict2) {
      return isIdentifierNameES6(id2) && !isReservedWordES6(id2, strict2);
    }
    keyword.exports = {
      isKeywordES5,
      isKeywordES6,
      isReservedWordES5,
      isReservedWordES6,
      isRestrictedWord,
      isIdentifierNameES5,
      isIdentifierNameES6,
      isIdentifierES5,
      isIdentifierES6
    };
  })();
  return keyword.exports;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function() {
    utils.ast = requireAst();
    utils.code = requireCode();
    utils.keyword = requireKeyword();
  })();
  return utils;
}
var ecmaVersion;
var hasRequiredEcmaVersion;
function requireEcmaVersion() {
  if (hasRequiredEcmaVersion) return ecmaVersion;
  hasRequiredEcmaVersion = 1;
  const LATEST_ECMA_VERSION = 2026;
  ecmaVersion = {
    LATEST_ECMA_VERSION
  };
  return ecmaVersion;
}
var hasRequiredAstUtils;
function requireAstUtils() {
  if (hasRequiredAstUtils) return astUtils.exports;
  hasRequiredAstUtils = 1;
  (function(module) {
    const { KEYS: eslintVisitorKeys2 } = requireEslintVisitorKeys$2();
    const esutils = requireUtils();
    const espree2 = requireEspree();
    const escapeRegExp = requireEscapeStringRegexp();
    const {
      breakableTypePattern,
      createGlobalLinebreakMatcher,
      lineBreakPattern,
      shebangPattern
    } = requireAstUtils$1();
    const globals2 = requireGlobals();
    const { LATEST_ECMA_VERSION } = requireEcmaVersion();
    const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
    const anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;
    const arrayMethodWithThisArgPattern = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|some)$/u;
    const arrayOrTypedArrayPattern = /Array$/u;
    const bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;
    const thisTagPattern = /^[\s*]*@this/mu;
    const COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
    const ESLINT_DIRECTIVE_PATTERN = /^(?:eslint[- ]|(?:globals?|exported) )/u;
    const LINEBREAKS = /* @__PURE__ */ new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
    const STATEMENT_LIST_PARENTS = /* @__PURE__ */ new Set([
      "Program",
      "BlockStatement",
      "StaticBlock",
      "SwitchCase"
    ]);
    const LEXICAL_DECLARATION_KINDS = /* @__PURE__ */ new Set([
      "let",
      "const",
      "using",
      "await using"
    ]);
    const DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u;
    const OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\]|\\.)*\\(?:[1-9]|0\d)/su;
    const LOGICAL_ASSIGNMENT_OPERATORS = /* @__PURE__ */ new Set(["&&=", "||=", "??="]);
    const ECMASCRIPT_GLOBALS = globals2[`es${LATEST_ECMA_VERSION}`];
    function isModifyingReference(reference, index, references) {
      const identifier = reference.identifier;
      const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;
      return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
    }
    function startsWithUpperCase(s2) {
      return s2[0] !== s2[0].toLocaleLowerCase();
    }
    function isES5Constructor(node2) {
      return node2.id && startsWithUpperCase(node2.id.name);
    }
    function getUpperFunction(node2) {
      for (let currentNode = node2; currentNode; currentNode = currentNode.parent) {
        if (anyFunctionPattern.test(currentNode.type)) {
          return currentNode;
        }
      }
      return null;
    }
    function isFunction(node2) {
      return Boolean(node2 && anyFunctionPattern.test(node2.type));
    }
    function isLoop(node2) {
      return Boolean(node2 && anyLoopPattern.test(node2.type));
    }
    function isInLoop(node2) {
      for (let currentNode = node2; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {
        if (isLoop(currentNode)) {
          return true;
        }
      }
      return false;
    }
    function isNullLiteral(node2) {
      return node2.type === "Literal" && node2.value === null && !node2.regex && !node2.bigint;
    }
    function isNullOrUndefined(node2) {
      return isNullLiteral(node2) || node2.type === "Identifier" && node2.name === "undefined" || node2.type === "UnaryExpression" && node2.operator === "void";
    }
    function isCallee(node2) {
      return node2.parent.type === "CallExpression" && node2.parent.callee === node2;
    }
    function getStaticStringValue(node2) {
      switch (node2.type) {
        case "Literal":
          if (node2.value === null) {
            if (isNullLiteral(node2)) {
              return String(node2.value);
            }
            if (node2.regex) {
              return `/${node2.regex.pattern}/${node2.regex.flags}`;
            }
            if (node2.bigint) {
              return node2.bigint;
            }
          } else {
            return String(node2.value);
          }
          break;
        case "TemplateLiteral":
          if (node2.expressions.length === 0 && node2.quasis.length === 1) {
            return node2.quasis[0].value.cooked;
          }
          break;
      }
      return null;
    }
    function getStaticPropertyName(node2) {
      let prop;
      switch (node2 && node2.type) {
        case "ChainExpression":
          return getStaticPropertyName(node2.expression);
        case "Property":
        case "PropertyDefinition":
        case "MethodDefinition":
        case "TSPropertySignature":
        case "TSMethodSignature":
          prop = node2.key;
          break;
        case "MemberExpression":
          prop = node2.property;
          break;
      }
      if (prop) {
        if (prop.type === "Identifier" && !node2.computed) {
          return prop.name;
        }
        return getStaticStringValue(prop);
      }
      return null;
    }
    function skipChainExpression(node2) {
      return node2 && node2.type === "ChainExpression" ? node2.expression : node2;
    }
    function checkText(actual, expected) {
      return typeof expected === "string" ? actual === expected : expected.test(actual);
    }
    function isSpecificId(node2, name2) {
      return node2.type === "Identifier" && checkText(node2.name, name2);
    }
    function isSpecificMemberAccess(node2, objectName, propertyName2) {
      const checkNode = skipChainExpression(node2);
      if (checkNode.type !== "MemberExpression") {
        return false;
      }
      if (objectName && !isSpecificId(checkNode.object, objectName)) {
        return false;
      }
      if (propertyName2) {
        const actualPropertyName = getStaticPropertyName(checkNode);
        if (typeof actualPropertyName !== "string" || !checkText(actualPropertyName, propertyName2)) {
          return false;
        }
      }
      return true;
    }
    function equalLiteralValue(left, right) {
      if (left.regex || right.regex) {
        return Boolean(
          left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags
        );
      }
      if (left.bigint || right.bigint) {
        return left.bigint === right.bigint;
      }
      return left.value === right.value;
    }
    function isSameReference(left, right, disableStaticComputedKey = false) {
      if (left.type !== right.type) {
        if (left.type === "ChainExpression") {
          return isSameReference(
            left.expression,
            right,
            disableStaticComputedKey
          );
        }
        if (right.type === "ChainExpression") {
          return isSameReference(
            left,
            right.expression,
            disableStaticComputedKey
          );
        }
        return false;
      }
      switch (left.type) {
        case "Super":
        case "ThisExpression":
          return true;
        case "Identifier":
        case "PrivateIdentifier":
          return left.name === right.name;
        case "Literal":
          return equalLiteralValue(left, right);
        case "ChainExpression":
          return isSameReference(
            left.expression,
            right.expression,
            disableStaticComputedKey
          );
        case "MemberExpression": {
          if (!disableStaticComputedKey) {
            const nameA = getStaticPropertyName(left);
            if (nameA !== null) {
              return isSameReference(
                left.object,
                right.object,
                disableStaticComputedKey
              ) && nameA === getStaticPropertyName(right);
            }
          }
          return left.computed === right.computed && isSameReference(
            left.object,
            right.object,
            disableStaticComputedKey
          ) && isSameReference(
            left.property,
            right.property,
            disableStaticComputedKey
          );
        }
        default:
          return false;
      }
    }
    function isReflectApply(node2) {
      return isSpecificMemberAccess(node2, "Reflect", "apply");
    }
    function isArrayFromMethod(node2) {
      return isSpecificMemberAccess(node2, arrayOrTypedArrayPattern, "from");
    }
    function isMethodWhichHasThisArg(node2) {
      return isSpecificMemberAccess(node2, null, arrayMethodWithThisArgPattern);
    }
    function negate(f2) {
      return (token) => !f2(token);
    }
    function hasJSDocThisTag(node2, sourceCode2) {
      const jsdocComment = sourceCode2.getJSDocComment(node2);
      if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
        return true;
      }
      return sourceCode2.getCommentsBefore(node2).some((comment2) => thisTagPattern.test(comment2.value));
    }
    function isParenthesised(sourceCode2, node2) {
      const previousToken = sourceCode2.getTokenBefore(node2), nextToken = sourceCode2.getTokenAfter(node2);
      return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node2.range[0] && nextToken.value === ")" && nextToken.range[0] >= node2.range[1];
    }
    function isEqToken(token) {
      return token.value === "=" && token.type === "Punctuator";
    }
    function isArrowToken(token) {
      return token.value === "=>" && token.type === "Punctuator";
    }
    function isCommaToken(token) {
      return token.value === "," && token.type === "Punctuator";
    }
    function isDotToken(token) {
      return token.value === "." && token.type === "Punctuator";
    }
    function isQuestionDotToken(token) {
      return token.value === "?." && token.type === "Punctuator";
    }
    function isSemicolonToken(token) {
      return token.value === ";" && token.type === "Punctuator";
    }
    function isColonToken(token) {
      return token.value === ":" && token.type === "Punctuator";
    }
    function isOpeningParenToken(token) {
      return token.value === "(" && token.type === "Punctuator";
    }
    function isClosingParenToken(token) {
      return token.value === ")" && token.type === "Punctuator";
    }
    function isOpeningBracketToken(token) {
      return token.value === "[" && token.type === "Punctuator";
    }
    function isClosingBracketToken(token) {
      return token.value === "]" && token.type === "Punctuator";
    }
    function isOpeningBraceToken(token) {
      return token.value === "{" && token.type === "Punctuator";
    }
    function isClosingBraceToken(token) {
      return token.value === "}" && token.type === "Punctuator";
    }
    function isCommentToken(token) {
      return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
    }
    function isKeywordToken(token) {
      return token.type === "Keyword";
    }
    function getOpeningParenOfParams(node2, sourceCode2) {
      if (node2.type === "ArrowFunctionExpression" && node2.params.length === 1) {
        const argToken = sourceCode2.getFirstToken(node2.params[0]);
        const maybeParenToken = sourceCode2.getTokenBefore(argToken);
        return isOpeningParenToken(maybeParenToken) ? maybeParenToken : argToken;
      }
      return node2.id ? sourceCode2.getTokenAfter(node2.id, isOpeningParenToken) : sourceCode2.getFirstToken(node2, isOpeningParenToken);
    }
    function equalTokens(left, right, sourceCode2) {
      const tokensL = sourceCode2.getTokens(left);
      const tokensR = sourceCode2.getTokens(right);
      if (tokensL.length !== tokensR.length) {
        return false;
      }
      for (let i2 = 0; i2 < tokensL.length; ++i2) {
        if (tokensL[i2].type !== tokensR[i2].type || tokensL[i2].value !== tokensR[i2].value) {
          return false;
        }
      }
      return true;
    }
    function isLogicalExpression(node2) {
      return node2.type === "LogicalExpression" && (node2.operator === "&&" || node2.operator === "||");
    }
    function isCoalesceExpression(node2) {
      return node2.type === "LogicalExpression" && node2.operator === "??";
    }
    function isMixedLogicalAndCoalesceExpressions(left, right) {
      return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);
    }
    function isLogicalAssignmentOperator(operator2) {
      return LOGICAL_ASSIGNMENT_OPERATORS.has(operator2);
    }
    function getSwitchCaseColonToken(node2, sourceCode2) {
      if (node2.test) {
        return sourceCode2.getTokenAfter(node2.test, isColonToken);
      }
      return sourceCode2.getFirstToken(node2, 1);
    }
    function getModuleExportName(node2) {
      if (node2.type === "Identifier") {
        return node2.name;
      }
      return node2.value;
    }
    function getBooleanValue(node2) {
      if (node2.value === null) {
        if (node2.raw === "null") {
          return false;
        }
        if (typeof node2.regex === "object") {
          return true;
        }
        return null;
      }
      return !!node2.value;
    }
    function isLogicalIdentity(node2, operator2) {
      switch (node2.type) {
        case "Literal":
          return operator2 === "||" && getBooleanValue(node2) === true || operator2 === "&&" && getBooleanValue(node2) === false;
        case "UnaryExpression":
          return operator2 === "&&" && node2.operator === "void";
        case "LogicalExpression":
          return operator2 === node2.operator && (isLogicalIdentity(node2.left, operator2) || isLogicalIdentity(node2.right, operator2));
        case "AssignmentExpression":
          return ["||=", "&&="].includes(node2.operator) && operator2 === node2.operator.slice(0, -1) && isLogicalIdentity(node2.right, operator2);
      }
      return false;
    }
    function isReferenceToGlobalVariable(scope, node2) {
      const reference = scope.references.find((ref2) => ref2.identifier === node2);
      return Boolean(
        reference && reference.resolved && reference.resolved.scope.type === "global" && reference.resolved.defs.length === 0
      );
    }
    function isConstant(scope, node2, inBooleanPosition) {
      if (!node2) {
        return true;
      }
      switch (node2.type) {
        case "Literal":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return true;
        case "ClassExpression":
        case "ObjectExpression":
          return true;
        case "TemplateLiteral":
          return inBooleanPosition && node2.quasis.some((quasi) => quasi.value.cooked.length) || node2.expressions.every((exp) => isConstant(scope, exp, false));
        case "ArrayExpression": {
          if (!inBooleanPosition) {
            return node2.elements.every(
              (element) => isConstant(scope, element, false)
            );
          }
          return true;
        }
        case "UnaryExpression":
          if (node2.operator === "void" || node2.operator === "typeof" && inBooleanPosition) {
            return true;
          }
          if (node2.operator === "!") {
            return isConstant(scope, node2.argument, true);
          }
          return isConstant(scope, node2.argument, false);
        case "BinaryExpression":
          return isConstant(scope, node2.left, false) && isConstant(scope, node2.right, false) && node2.operator !== "in";
        case "LogicalExpression": {
          const isLeftConstant = isConstant(
            scope,
            node2.left,
            inBooleanPosition
          );
          const isRightConstant = isConstant(
            scope,
            node2.right,
            inBooleanPosition
          );
          const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node2.left, node2.operator);
          const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node2.right, node2.operator);
          return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;
        }
        case "NewExpression":
          return inBooleanPosition;
        case "AssignmentExpression":
          if (node2.operator === "=") {
            return isConstant(scope, node2.right, inBooleanPosition);
          }
          if (["||=", "&&="].includes(node2.operator) && inBooleanPosition) {
            return isLogicalIdentity(
              node2.right,
              node2.operator.slice(0, -1)
            );
          }
          return false;
        case "SequenceExpression":
          return isConstant(
            scope,
            node2.expressions.at(-1),
            inBooleanPosition
          );
        case "SpreadElement":
          return isConstant(scope, node2.argument, inBooleanPosition);
        case "CallExpression":
          if (node2.callee.type === "Identifier" && node2.callee.name === "Boolean") {
            if (node2.arguments.length === 0 || isConstant(scope, node2.arguments[0], true)) {
              return isReferenceToGlobalVariable(scope, node2.callee);
            }
          }
          return false;
        case "Identifier":
          return node2.name === "undefined" && isReferenceToGlobalVariable(scope, node2);
      }
      return false;
    }
    function isTopLevelExpressionStatement(node2) {
      if (node2.type !== "ExpressionStatement") {
        return false;
      }
      const parent = node2.parent;
      return parent.type === "Program" || parent.type === "TSModuleBlock" || parent.type === "BlockStatement" && isFunction(parent.parent);
    }
    function isDirective(node2) {
      return node2.type === "ExpressionStatement" && typeof node2.directive === "string";
    }
    function isStartOfExpressionStatement(node2) {
      const start = node2.range[0];
      let ancestor = node2;
      while ((ancestor = ancestor.parent) && ancestor.range[0] === start) {
        if (ancestor.type === "ExpressionStatement") {
          return true;
        }
      }
      return false;
    }
    let needsPrecedingSemicolon;
    {
      let isInType = function(node2) {
        for (let currNode = node2; ; ) {
          const { parent } = currNode;
          if (!parent) {
            break;
          }
          if (TS_TYPE_NODE_TYPES.has(parent.type) && currNode === parent.typeAnnotation) {
            return true;
          }
          currNode = parent;
        }
        return false;
      };
      const BREAK_OR_CONTINUE = /* @__PURE__ */ new Set(["BreakStatement", "ContinueStatement"]);
      const DECLARATIONS = /* @__PURE__ */ new Set([
        "ExportAllDeclaration",
        "ExportNamedDeclaration",
        "ImportDeclaration"
      ]);
      const IDENTIFIER_OR_KEYWORD = /* @__PURE__ */ new Set(["Identifier", "Keyword"]);
      const NODE_TYPES_BY_KEYWORD = {
        __proto__: null,
        break: "BreakStatement",
        continue: "ContinueStatement",
        debugger: "DebuggerStatement",
        do: "DoWhileStatement",
        else: "IfStatement",
        return: "ReturnStatement",
        yield: "YieldExpression"
      };
      const PUNCTUATORS = /* @__PURE__ */ new Set([":", ";", "{", "=>", "++", "--"]);
      const STATEMENTS = /* @__PURE__ */ new Set([
        "DoWhileStatement",
        "ForInStatement",
        "ForOfStatement",
        "ForStatement",
        "IfStatement",
        "WhileStatement",
        "WithStatement"
      ]);
      const TS_TYPE_NODE_TYPES = /* @__PURE__ */ new Set([
        "TSAsExpression",
        "TSSatisfiesExpression",
        "TSTypeAliasDeclaration",
        "TSTypeAnnotation"
      ]);
      needsPrecedingSemicolon = function(sourceCode2, node2) {
        var _a2;
        const prevToken = sourceCode2.getTokenBefore(node2);
        if (!prevToken || prevToken.type === "Punctuator" && PUNCTUATORS.has(prevToken.value)) {
          return false;
        }
        const prevNode = sourceCode2.getNodeByRangeIndex(prevToken.range[0]);
        if (prevNode.type === "TSDeclareFunction" || prevNode.parent.type === "TSImportEqualsDeclaration" || ((_a2 = prevNode.parent.parent) == null ? void 0 : _a2.type) === "TSImportEqualsDeclaration" || TS_TYPE_NODE_TYPES.has(prevNode.type) || isInType(prevNode)) {
          return false;
        }
        if (isClosingParenToken(prevToken)) {
          return !STATEMENTS.has(prevNode.type);
        }
        if (isClosingBraceToken(prevToken)) {
          return prevNode.type === "BlockStatement" && prevNode.parent.type === "FunctionExpression" && prevNode.parent.parent.type !== "MethodDefinition" || prevNode.type === "ClassBody" && prevNode.parent.type === "ClassExpression" || prevNode.type === "ObjectExpression";
        }
        if (IDENTIFIER_OR_KEYWORD.has(prevToken.type)) {
          if (prevNode.parent.type === "VariableDeclarator" && !prevNode.parent.init) {
            return false;
          }
          if (BREAK_OR_CONTINUE.has(prevNode.parent.type)) {
            return false;
          }
          const keyword2 = prevToken.value;
          const nodeType = NODE_TYPES_BY_KEYWORD[keyword2];
          return prevNode.type !== nodeType;
        }
        if (prevToken.type === "String") {
          return !DECLARATIONS.has(prevNode.parent.type);
        }
        return true;
      };
    }
    function isImportAttributeKey(node2) {
      const { parent } = node2;
      if (parent.type === "ImportAttribute" && parent.key === node2) {
        return true;
      }
      if (parent.type === "Property" && !parent.computed && (parent.key === node2 || parent.value === node2 && parent.shorthand && !parent.method) && parent.parent.type === "ObjectExpression") {
        const objectExpression = parent.parent;
        const objectExpressionParent = objectExpression.parent;
        if (objectExpressionParent.type === "ImportExpression" && objectExpressionParent.options === objectExpression) {
          return true;
        }
        if (objectExpressionParent.type === "Property" && objectExpressionParent.value === objectExpression) {
          return isImportAttributeKey(objectExpressionParent.key);
        }
      }
      return false;
    }
    module.exports = {
      COMMENTS_IGNORE_PATTERN,
      LINEBREAKS,
      LINEBREAK_MATCHER: lineBreakPattern,
      SHEBANG_MATCHER: shebangPattern,
      STATEMENT_LIST_PARENTS,
      ECMASCRIPT_GLOBALS,
      /**
       * Determines whether two adjacent tokens are on the same line.
       * @param {Object} left The left token object.
       * @param {Object} right The right token object.
       * @returns {boolean} Whether or not the tokens are on the same line.
       * @public
       */
      isTokenOnSameLine(left, right) {
        return left.loc.end.line === right.loc.start.line;
      },
      isNullOrUndefined,
      isCallee,
      isES5Constructor,
      getUpperFunction,
      isFunction,
      isLoop,
      isInLoop,
      isArrayFromMethod,
      isParenthesised,
      createGlobalLinebreakMatcher,
      equalTokens,
      isArrowToken,
      isClosingBraceToken,
      isClosingBracketToken,
      isClosingParenToken,
      isColonToken,
      isCommaToken,
      isCommentToken,
      isDotToken,
      isQuestionDotToken,
      isKeywordToken,
      isNotClosingBraceToken: negate(isClosingBraceToken),
      isNotClosingBracketToken: negate(isClosingBracketToken),
      isNotClosingParenToken: negate(isClosingParenToken),
      isNotColonToken: negate(isColonToken),
      isNotCommaToken: negate(isCommaToken),
      isNotDotToken: negate(isDotToken),
      isNotQuestionDotToken: negate(isQuestionDotToken),
      isNotOpeningBraceToken: negate(isOpeningBraceToken),
      isNotOpeningBracketToken: negate(isOpeningBracketToken),
      isNotOpeningParenToken: negate(isOpeningParenToken),
      isNotSemicolonToken: negate(isSemicolonToken),
      isOpeningBraceToken,
      isOpeningBracketToken,
      isOpeningParenToken,
      isSemicolonToken,
      isEqToken,
      /**
       * Checks whether or not a given node is a string literal.
       * @param {ASTNode} node A node to check.
       * @returns {boolean} `true` if the node is a string literal.
       */
      isStringLiteral(node2) {
        return node2.type === "Literal" && typeof node2.value === "string" || node2.type === "TemplateLiteral";
      },
      /**
       * Checks whether a given node is a breakable statement or not.
       * The node is breakable if the node is one of the following type:
       *
       * - DoWhileStatement
       * - ForInStatement
       * - ForOfStatement
       * - ForStatement
       * - SwitchStatement
       * - WhileStatement
       * @param {ASTNode} node A node to check.
       * @returns {boolean} `true` if the node is breakable.
       */
      isBreakableStatement(node2) {
        return breakableTypePattern.test(node2.type);
      },
      /**
       * Gets references which are non initializer and writable.
       * @param {Reference[]} references An array of references.
       * @returns {Reference[]} An array of only references which are non initializer and writable.
       * @public
       */
      getModifyingReferences(references) {
        return references.filter(isModifyingReference);
      },
      /**
       * Validate that a string passed in is surrounded by the specified character
       * @param {string} val The text to check.
       * @param {string} character The character to see if it's surrounded by.
       * @returns {boolean} True if the text is surrounded by the character, false if not.
       * @private
       */
      isSurroundedBy(val, character) {
        return val[0] === character && val.at(-1) === character;
      },
      /**
       * Returns whether the provided node is an ESLint directive comment or not
       * @param {Line|Block} node The comment token to be checked
       * @returns {boolean} `true` if the node is an ESLint directive comment
       */
      isDirectiveComment(node2) {
        const comment2 = node2.value.trim();
        return node2.type === "Line" && comment2.startsWith("eslint-") || node2.type === "Block" && ESLINT_DIRECTIVE_PATTERN.test(comment2);
      },
      /**
       * Gets the trailing statement of a given node.
       *
       *     if (code)
       *         consequent;
       *
       * When taking this `IfStatement`, returns `consequent;` statement.
       * @param {ASTNode} A node to get.
       * @returns {ASTNode|null} The trailing statement's node.
       */
      getTrailingStatement: esutils.ast.trailingStatement,
      /**
       * Finds the variable by a given name in a given scope and its upper scopes.
       * @param {eslint-scope.Scope} initScope A scope to start find.
       * @param {string} name A variable name to find.
       * @returns {eslint-scope.Variable|null} A found variable or `null`.
       */
      getVariableByName(initScope, name2) {
        let scope = initScope;
        while (scope) {
          const variable = scope.set.get(name2);
          if (variable) {
            return variable;
          }
          scope = scope.upper;
        }
        return null;
      },
      /**
       * Checks whether or not a given function node is the default `this` binding.
       *
       * First, this checks the node:
       *
       * - The given node is not in `PropertyDefinition#value` position.
       * - The given node is not `StaticBlock`.
       * - The function name does not start with uppercase. It's a convention to capitalize the names
       *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.
       * - The function does not have a JSDoc comment that has a @this tag.
       *
       * Next, this checks the location of the node.
       * If the location is below, this judges `this` is valid.
       *
       * - The location is not on an object literal.
       * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous
       *   functions only, as the name of the variable is considered to be the name of the function in this case.
       *   This check is not performed if `capIsConstructor` is set to `false`.
       * - The location is not on an ES2015 class.
       * - Its `bind`/`call`/`apply` method is not called directly.
       * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
       * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`
       * or any expression that is `PropertyDefinition#value` node.
       * @param {SourceCode} sourceCode A SourceCode instance to get comments.
       * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts
       * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.
       * @returns {boolean} The function node is the default `this` binding.
       */
      isDefaultThisBinding(node2, sourceCode2, { capIsConstructor = true } = {}) {
        if (node2.parent.type === "PropertyDefinition" && node2.parent.value === node2) {
          return false;
        }
        if (node2.type === "StaticBlock") {
          return false;
        }
        if ((node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression") && node2.params.some(
          (param) => param.type === "Identifier" && param.name === "this"
        )) {
          return false;
        }
        if (capIsConstructor && isES5Constructor(node2) || hasJSDocThisTag(node2, sourceCode2)) {
          return false;
        }
        const isAnonymous = node2.id === null;
        let currentNode = node2;
        while (currentNode) {
          const parent = currentNode.parent;
          switch (parent.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
            case "ChainExpression":
              currentNode = parent;
              break;
            case "ReturnStatement": {
              const func = getUpperFunction(parent);
              if (func === null || !isCallee(func)) {
                return true;
              }
              currentNode = func.parent;
              break;
            }
            case "ArrowFunctionExpression":
              if (currentNode !== parent.body || !isCallee(parent)) {
                return true;
              }
              currentNode = parent.parent;
              break;
            case "Property":
            case "PropertyDefinition":
            case "MethodDefinition":
              return parent.value !== currentNode;
            case "AssignmentExpression":
            case "AssignmentPattern":
              if (parent.left.type === "MemberExpression") {
                return false;
              }
              if (capIsConstructor && isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
                return false;
              }
              return true;
            case "VariableDeclarator":
              return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));
            case "MemberExpression":
              if (parent.object === currentNode && isSpecificMemberAccess(
                parent,
                null,
                bindOrCallOrApplyPattern
              )) {
                const maybeCalleeNode = parent.parent.type === "ChainExpression" ? parent.parent : parent;
                return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(
                  maybeCalleeNode.parent.arguments[0]
                ));
              }
              return true;
            case "CallExpression":
              if (isReflectApply(parent.callee)) {
                return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
              }
              if (isArrayFromMethod(parent.callee)) {
                return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);
              }
              if (isMethodWhichHasThisArg(parent.callee)) {
                return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
              }
              return true;
            default:
              return true;
          }
        }
        return true;
      },
      /**
       * Get the precedence level based on the node type
       * @param {ASTNode} node node to evaluate
       * @returns {number} precedence level
       * @private
       */
      getPrecedence(node2) {
        switch (node2.type) {
          case "SequenceExpression":
            return 0;
          case "AssignmentExpression":
          case "ArrowFunctionExpression":
          case "YieldExpression":
            return 1;
          case "ConditionalExpression":
            return 3;
          case "LogicalExpression":
            switch (node2.operator) {
              case "||":
              case "??":
                return 4;
              case "&&":
                return 5;
            }
          case "BinaryExpression":
            switch (node2.operator) {
              case "|":
                return 6;
              case "^":
                return 7;
              case "&":
                return 8;
              case "==":
              case "!=":
              case "===":
              case "!==":
                return 9;
              case "<":
              case "<=":
              case ">":
              case ">=":
              case "in":
              case "instanceof":
                return 10;
              case "<<":
              case ">>":
              case ">>>":
                return 11;
              case "+":
              case "-":
                return 12;
              case "*":
              case "/":
              case "%":
                return 13;
              case "**":
                return 15;
            }
          case "UnaryExpression":
          case "AwaitExpression":
            return 16;
          case "UpdateExpression":
            return 17;
          case "CallExpression":
          case "ChainExpression":
          case "ImportExpression":
            return 18;
          case "NewExpression":
            return 19;
          default:
            if (node2.type in eslintVisitorKeys2) {
              return 20;
            }
            return -1;
        }
      },
      /**
       * Checks whether the given node is an empty block node or not.
       * @param {ASTNode|null} node The node to check.
       * @returns {boolean} `true` if the node is an empty block.
       */
      isEmptyBlock(node2) {
        return Boolean(
          node2 && node2.type === "BlockStatement" && node2.body.length === 0
        );
      },
      /**
       * Checks whether the given node is an empty function node or not.
       * @param {ASTNode|null} node The node to check.
       * @returns {boolean} `true` if the node is an empty function.
       */
      isEmptyFunction(node2) {
        return isFunction(node2) && module.exports.isEmptyBlock(node2.body);
      },
      /**
       * Get directives from directive prologue of a Program or Function node.
       * @param {ASTNode} node The node to check.
       * @returns {ASTNode[]} The directives found in the directive prologue.
       */
      getDirectivePrologue(node2) {
        const directives2 = [];
        if (node2.type === "Program" || node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression" || /*
         * Do not check arrow functions with implicit return.
         * `() => "use strict";` returns the string `"use strict"`.
         */
        node2.type === "ArrowFunctionExpression" && node2.body.type === "BlockStatement") {
          const statements = node2.type === "Program" ? node2.body : node2.body.body;
          for (const statement of statements) {
            if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
              directives2.push(statement);
            } else {
              break;
            }
          }
        }
        return directives2;
      },
      /**
       * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
       * after the node will be parsed as a decimal point, rather than a property-access dot.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if this node is a decimal integer.
       * @example
       *
       * 0         // true
       * 5         // true
       * 50        // true
       * 5_000     // true
       * 1_234_56  // true
       * 08        // true
       * 0192      // true
       * 5.        // false
       * .5        // false
       * 5.0       // false
       * 5.00_00   // false
       * 05        // false
       * 0x5       // false
       * 0b101     // false
       * 0b11_01   // false
       * 0o5       // false
       * 5e0       // false
       * 5e1_000   // false
       * 5n        // false
       * 1_000n    // false
       * "5"       // false
       *
       */
      isDecimalInteger(node2) {
        return node2.type === "Literal" && typeof node2.value === "number" && DECIMAL_INTEGER_PATTERN.test(node2.raw);
      },
      /**
       * Determines whether this token is a decimal integer numeric token.
       * This is similar to isDecimalInteger(), but for tokens.
       * @param {Token} token The token to check.
       * @returns {boolean} `true` if this token is a decimal integer.
       */
      isDecimalIntegerNumericToken(token) {
        return token.type === "Numeric" && DECIMAL_INTEGER_PATTERN.test(token.value);
      },
      /**
       * Gets the name and kind of the given function node.
       *
       * - `function foo() {}`  .................... `function 'foo'`
       * - `(function foo() {})`  .................. `function 'foo'`
       * - `(function() {})`  ...................... `function`
       * - `function* foo() {}`  ................... `generator function 'foo'`
       * - `(function* foo() {})`  ................. `generator function 'foo'`
       * - `(function*() {})`  ..................... `generator function`
       * - `() => {}`  ............................. `arrow function`
       * - `async () => {}`  ....................... `async arrow function`
       * - `({ foo: function foo() {} })`  ......... `method 'foo'`
       * - `({ foo: function() {} })`  ............. `method 'foo'`
       * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
       * - `({ [foo]: function() {} })`  ........... `method`
       * - `({ foo() {} })`  ....................... `method 'foo'`
       * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
       * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
       * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
       * - `({ [foo]: function*() {} })`  .......... `generator method`
       * - `({ *foo() {} })`  ...................... `generator method 'foo'`
       * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
       * - `({ foo: async function() {} })`  ....... `async method 'foo'`
       * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
       * - `({ [foo]: async function() {} })`  ..... `async method`
       * - `({ async foo() {} })`  ................. `async method 'foo'`
       * - `({ get foo() {} })`  ................... `getter 'foo'`
       * - `({ set foo(a) {} })`  .................. `setter 'foo'`
       * - `class A { constructor() {} }`  ......... `constructor`
       * - `class A { foo() {} }`  ................. `method 'foo'`
       * - `class A { *foo() {} }`  ................ `generator method 'foo'`
       * - `class A { async foo() {} }`  ........... `async method 'foo'`
       * - `class A { ['foo']() {} }`  ............. `method 'foo'`
       * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
       * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
       * - `class A { [foo]() {} }`  ............... `method`
       * - `class A { *[foo]() {} }`  .............. `generator method`
       * - `class A { async [foo]() {} }`  ......... `async method`
       * - `class A { get foo() {} }`  ............. `getter 'foo'`
       * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
       * - `class A { static foo() {} }`  .......... `static method 'foo'`
       * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
       * - `class A { static async foo() {} }`  .... `static async method 'foo'`
       * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
       * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
       * - `class A { foo = () => {}; }`  .......... `method 'foo'`
       * - `class A { foo = function() {}; }`  ..... `method 'foo'`
       * - `class A { foo = function bar() {}; }`  . `method 'foo'`
       * - `class A { static foo = () => {}; }`  ... `static method 'foo'`
       * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`
       * - `class A { #foo = () => {}; }`  ......... `private method #foo`
       * - `class A { static #foo = () => {}; }`  .. `static private method #foo`
       * - `class A { '#foo'() {} }`  .............. `method '#foo'`
       * - `class A { #foo() {} }`  ................ `private method #foo`
       * - `class A { static #foo() {} }`  ......... `static private method #foo`
       * @param {ASTNode} node The function node to get.
       * @returns {string} The name and kind of the function node.
       */
      getFunctionNameWithKind(node2) {
        var _a2;
        const parent = node2.parent;
        const tokens = [];
        if (parent.type === "MethodDefinition" || parent.type === "PropertyDefinition" || node2.type === "TSPropertySignature" || node2.type === "TSMethodSignature") {
          if (parent.static) {
            tokens.push("static");
          }
          if (!parent.computed && ((_a2 = parent.key) == null ? void 0 : _a2.type) === "PrivateIdentifier") {
            tokens.push("private");
          }
        }
        if (node2.async) {
          tokens.push("async");
        }
        if (node2.generator) {
          tokens.push("generator");
        }
        if (parent.type === "Property" || parent.type === "MethodDefinition") {
          if (parent.kind === "constructor") {
            return "constructor";
          }
          if (parent.kind === "get") {
            tokens.push("getter");
          } else if (parent.kind === "set") {
            tokens.push("setter");
          } else {
            tokens.push("method");
          }
        } else if (node2.type === "TSMethodSignature") {
          if (node2.kind === "get") {
            tokens.push("getter");
          } else if (node2.kind === "set") {
            tokens.push("setter");
          } else {
            tokens.push("method");
          }
        } else if (parent.type === "PropertyDefinition") {
          tokens.push("method");
        } else {
          if (node2.type === "ArrowFunctionExpression") {
            tokens.push("arrow");
          }
          tokens.push("function");
        }
        if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
          if (!parent.computed && parent.key.type === "PrivateIdentifier") {
            tokens.push(`#${parent.key.name}`);
          } else {
            const name2 = getStaticPropertyName(parent);
            if (name2 !== null) {
              tokens.push(`'${name2}'`);
            } else if (node2.id) {
              tokens.push(`'${node2.id.name}'`);
            }
          }
        } else if (node2.type === "TSMethodSignature") {
          tokens.push(`'${getStaticPropertyName(node2)}'`);
        } else if (node2.id) {
          tokens.push(`'${node2.id.name}'`);
        }
        return tokens.join(" ");
      },
      /**
       * Gets the location of the given function node for reporting.
       *
       * - `function foo() {}`
       *    ^^^^^^^^^^^^
       * - `(function foo() {})`
       *     ^^^^^^^^^^^^
       * - `(function() {})`
       *     ^^^^^^^^
       * - `function* foo() {}`
       *    ^^^^^^^^^^^^^
       * - `(function* foo() {})`
       *     ^^^^^^^^^^^^^
       * - `(function*() {})`
       *     ^^^^^^^^^
       * - `() => {}`
       *       ^^
       * - `async () => {}`
       *             ^^
       * - `({ foo: function foo() {} })`
       *       ^^^^^^^^^^^^^^^^^
       * - `({ foo: function() {} })`
       *       ^^^^^^^^^^^^^
       * - `({ ['foo']: function() {} })`
       *       ^^^^^^^^^^^^^^^^^
       * - `({ [foo]: function() {} })`
       *       ^^^^^^^^^^^^^^^
       * - `({ foo() {} })`
       *       ^^^
       * - `({ foo: function* foo() {} })`
       *       ^^^^^^^^^^^^^^^^^^
       * - `({ foo: function*() {} })`
       *       ^^^^^^^^^^^^^^
       * - `({ ['foo']: function*() {} })`
       *       ^^^^^^^^^^^^^^^^^^
       * - `({ [foo]: function*() {} })`
       *       ^^^^^^^^^^^^^^^^
       * - `({ *foo() {} })`
       *       ^^^^
       * - `({ foo: async function foo() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^^^
       * - `({ foo: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^
       * - `({ ['foo']: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^^^
       * - `({ [foo]: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^
       * - `({ async foo() {} })`
       *       ^^^^^^^^^
       * - `({ get foo() {} })`
       *       ^^^^^^^
       * - `({ set foo(a) {} })`
       *       ^^^^^^^
       * - `class A { constructor() {} }`
       *              ^^^^^^^^^^^
       * - `class A { foo() {} }`
       *              ^^^
       * - `class A { *foo() {} }`
       *              ^^^^
       * - `class A { async foo() {} }`
       *              ^^^^^^^^^
       * - `class A { ['foo']() {} }`
       *              ^^^^^^^
       * - `class A { *['foo']() {} }`
       *              ^^^^^^^^
       * - `class A { async ['foo']() {} }`
       *              ^^^^^^^^^^^^^
       * - `class A { [foo]() {} }`
       *              ^^^^^
       * - `class A { *[foo]() {} }`
       *              ^^^^^^
       * - `class A { async [foo]() {} }`
       *              ^^^^^^^^^^^
       * - `class A { get foo() {} }`
       *              ^^^^^^^
       * - `class A { set foo(a) {} }`
       *              ^^^^^^^
       * - `class A { static foo() {} }`
       *              ^^^^^^^^^^
       * - `class A { static *foo() {} }`
       *              ^^^^^^^^^^^
       * - `class A { static async foo() {} }`
       *              ^^^^^^^^^^^^^^^^
       * - `class A { static get foo() {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { static set foo(a) {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { foo = function() {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { static foo = function() {} }`
       *              ^^^^^^^^^^^^^^^^^^^^^
       * - `class A { foo = (a, b) => {} }`
       *              ^^^^^^
       * @param {ASTNode} node The function node to get.
       * @param {SourceCode} sourceCode The source code object to get tokens.
       * @returns {string} The location of the function node for reporting.
       */
      getFunctionHeadLoc(node2, sourceCode2) {
        const parent = node2.parent;
        let start;
        let end;
        if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition" || parent.type === "TSPropertySignature" || parent.type === "TSMethodSignature") {
          start = parent.loc.start;
          end = getOpeningParenOfParams(node2, sourceCode2).loc.start;
        } else if (node2.type === "ArrowFunctionExpression") {
          const arrowToken = sourceCode2.getTokenBefore(
            node2.body,
            isArrowToken
          );
          start = arrowToken.loc.start;
          end = arrowToken.loc.end;
        } else {
          start = node2.loc.start;
          end = getOpeningParenOfParams(node2, sourceCode2).loc.start;
        }
        return {
          start: Object.assign({}, start),
          end: Object.assign({}, end)
        };
      },
      /**
       * Gets next location when the result is not out of bound, otherwise returns null.
       *
       * Assumptions:
       *
       * - The given location represents a valid location in the given source code.
       * - Columns are 0-based.
       * - Lines are 1-based.
       * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.
       * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.
       *   The start (column 0) of that extra line is considered to be a valid location.
       *
       * Examples of successive locations (line, column):
       *
       * code: foo
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null
       *
       * code: foo<LF>
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null
       *
       * code: foo<CR><LF>
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null
       *
       * code: a<LF>b
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null
       *
       * code: a<LF>b<LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null
       *
       * code: a<CR><LF>b<CR><LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null
       *
       * code: a<LF><LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null
       *
       * code: <LF>
       * locations: (1, 0) -> (2, 0) -> null
       *
       * code:
       * locations: (1, 0) -> null
       * @param {SourceCode} sourceCode The sourceCode
       * @param {{line: number, column: number}} location The location
       * @returns {{line: number, column: number} | null} Next location
       */
      getNextLocation(sourceCode2, { line, column }) {
        if (column < sourceCode2.lines[line - 1].length) {
          return {
            line,
            column: column + 1
          };
        }
        if (line < sourceCode2.lines.length) {
          return {
            line: line + 1,
            column: 0
          };
        }
        return null;
      },
      /**
       * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses
       * surrounding the node.
       * @param {SourceCode} sourceCode The source code object
       * @param {ASTNode} node An expression node
       * @returns {string} The text representing the node, with all surrounding parentheses included
       */
      getParenthesisedText(sourceCode2, node2) {
        let leftToken = sourceCode2.getFirstToken(node2);
        let rightToken = sourceCode2.getLastToken(node2);
        while (sourceCode2.getTokenBefore(leftToken) && sourceCode2.getTokenBefore(leftToken).type === "Punctuator" && sourceCode2.getTokenBefore(leftToken).value === "(" && sourceCode2.getTokenAfter(rightToken) && sourceCode2.getTokenAfter(rightToken).type === "Punctuator" && sourceCode2.getTokenAfter(rightToken).value === ")") {
          leftToken = sourceCode2.getTokenBefore(leftToken);
          rightToken = sourceCode2.getTokenAfter(rightToken);
        }
        return sourceCode2.getText().slice(leftToken.range[0], rightToken.range[1]);
      },
      /**
       * Determine if a node has a possibility to be an Error object
       * @param {ASTNode} node ASTNode to check
       * @returns {boolean} True if there is a chance it contains an Error obj
       */
      couldBeError(node2) {
        switch (node2.type) {
          case "Identifier":
          case "CallExpression":
          case "NewExpression":
          case "MemberExpression":
          case "TaggedTemplateExpression":
          case "YieldExpression":
          case "AwaitExpression":
          case "ChainExpression":
            return true;
          case "AssignmentExpression":
            if (["=", "&&="].includes(node2.operator)) {
              return module.exports.couldBeError(node2.right);
            }
            if (["||=", "??="].includes(node2.operator)) {
              return module.exports.couldBeError(node2.left) || module.exports.couldBeError(node2.right);
            }
            return false;
          case "SequenceExpression": {
            const exprs = node2.expressions;
            return exprs.length !== 0 && module.exports.couldBeError(exprs.at(-1));
          }
          case "LogicalExpression":
            if (node2.operator === "&&") {
              return module.exports.couldBeError(node2.right);
            }
            return module.exports.couldBeError(node2.left) || module.exports.couldBeError(node2.right);
          case "ConditionalExpression":
            return module.exports.couldBeError(node2.consequent) || module.exports.couldBeError(node2.alternate);
          default:
            return false;
        }
      },
      /**
       * Check if a given node is a numeric literal or not.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if the node is a number or bigint literal.
       */
      isNumericLiteral(node2) {
        return node2.type === "Literal" && (typeof node2.value === "number" || Boolean(node2.bigint));
      },
      /**
       * Determines whether two tokens can safely be placed next to each other without merging into a single token
       * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
       * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
       * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
       * next to each other, behavior is undefined (although it should return `true` in most cases).
       */
      canTokensBeAdjacent(leftValue, rightValue) {
        const espreeOptions = {
          ecmaVersion: espree2.latestEcmaVersion,
          comment: true,
          range: true
        };
        let leftToken;
        if (typeof leftValue === "string") {
          let tokens;
          try {
            tokens = espree2.tokenize(leftValue, espreeOptions);
          } catch {
            return false;
          }
          const comments = tokens.comments;
          leftToken = tokens.at(-1);
          if (comments.length) {
            const lastComment = comments.at(-1);
            if (!leftToken || lastComment.range[0] > leftToken.range[0]) {
              leftToken = lastComment;
            }
          }
        } else {
          leftToken = leftValue;
        }
        if (leftToken.type === "Shebang" || leftToken.type === "Hashbang") {
          return false;
        }
        let rightToken;
        if (typeof rightValue === "string") {
          let tokens;
          try {
            tokens = espree2.tokenize(rightValue, espreeOptions);
          } catch {
            return false;
          }
          const comments = tokens.comments;
          rightToken = tokens[0];
          if (comments.length) {
            const firstComment = comments[0];
            if (!rightToken || firstComment.range[0] < rightToken.range[0]) {
              rightToken = firstComment;
            }
          }
        } else {
          rightToken = rightValue;
        }
        if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
          if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
            const PLUS_TOKENS = /* @__PURE__ */ new Set(["+", "++"]);
            const MINUS_TOKENS = /* @__PURE__ */ new Set(["-", "--"]);
            return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
          }
          if (leftToken.type === "Punctuator" && leftToken.value === "/") {
            return !["Block", "Line", "RegularExpression"].includes(
              rightToken.type
            );
          }
          return true;
        }
        if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
          return true;
        }
        if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
          return true;
        }
        if (leftToken.type === "Block" || rightToken.type === "Block" || rightToken.type === "Line") {
          return true;
        }
        if (rightToken.type === "PrivateIdentifier") {
          return true;
        }
        return false;
      },
      /**
       * Get the `loc` object of a given name in a `/*globals` directive comment.
       * @param {SourceCode} sourceCode The source code to convert index to loc.
       * @param {Comment} comment The `/*globals` directive comment which include the name.
       * @param {string} name The name to find.
       * @returns {SourceLocation} The `loc` object.
       */
      getNameLocationInGlobalDirectiveComment(sourceCode2, comment2, name2) {
        const namePattern = new RegExp(
          `[\\s,]${escapeRegExp(name2)}(?:$|[\\s,:])`,
          "gu"
        );
        namePattern.lastIndex = comment2.value.indexOf("global") + 6;
        const match = namePattern.exec(comment2.value);
        const start = sourceCode2.getLocFromIndex(
          comment2.range[0] + "/*".length + (match ? match.index + 1 : 0)
        );
        const end = {
          line: start.line,
          column: start.column + (match ? name2.length : 1)
        };
        return { start, end };
      },
      /**
       * Determines whether the given raw string contains an octal escape sequence
       * or a non-octal decimal escape sequence ("\8", "\9").
       *
       * "\1", "\2" ... "\7", "\8", "\9"
       * "\00", "\01" ... "\07", "\08", "\09"
       *
       * "\0", when not followed by a digit, is not an octal escape sequence.
       * @param {string} rawString A string in its raw representation.
       * @returns {boolean} `true` if the string contains at least one octal escape sequence
       * or at least one non-octal decimal escape sequence.
       */
      hasOctalOrNonOctalDecimalEscapeSequence(rawString) {
        return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);
      },
      /**
       * Determines whether the given node is a template literal without expressions.
       * @param {ASTNode} node Node to check.
       * @returns {boolean} True if the node is a template literal without expressions.
       */
      isStaticTemplateLiteral(node2) {
        return node2.type === "TemplateLiteral" && node2.expressions.length === 0;
      },
      /**
       * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.
       * The braces, which make the given block body, are necessary in either of the following situations:
       *
       * 1. The statement is a lexical declaration.
       * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:
       *
       *     if (a) {
       *         if (b)
       *             foo();
       *     }
       *     else
       *         bar();
       *
       *     if (a)
       *         while (b)
       *             while (c) {
       *                 while (d)
       *                     if (e)
       *                         while(f)
       *                             foo();
       *            }
       *     else
       *         bar();
       * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.
       * @param {SourceCode} sourceCode The source code
       * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)
       * would change the semantics of the code or produce a syntax error.
       */
      areBracesNecessary(node2, sourceCode2) {
        function isLexicalDeclaration(nodeToCheck) {
          if (nodeToCheck.type === "VariableDeclaration") {
            return LEXICAL_DECLARATION_KINDS.has(nodeToCheck.kind);
          }
          return nodeToCheck.type === "FunctionDeclaration" || nodeToCheck.type === "ClassDeclaration";
        }
        function isElseKeywordToken(token) {
          return token.value === "else" && token.type === "Keyword";
        }
        function isFollowedByElseKeyword(nodeToCheck) {
          const nextToken = sourceCode2.getTokenAfter(nodeToCheck);
          return Boolean(nextToken) && isElseKeywordToken(nextToken);
        }
        function hasUnsafeIf(nodeToCheck) {
          switch (nodeToCheck.type) {
            case "IfStatement":
              if (!nodeToCheck.alternate) {
                return true;
              }
              return hasUnsafeIf(nodeToCheck.alternate);
            case "ForStatement":
            case "ForInStatement":
            case "ForOfStatement":
            case "LabeledStatement":
            case "WithStatement":
            case "WhileStatement":
              return hasUnsafeIf(nodeToCheck.body);
            default:
              return false;
          }
        }
        const statement = node2.body[0];
        return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node2);
      },
      isReferenceToGlobalVariable,
      isLogicalExpression,
      isCoalesceExpression,
      isMixedLogicalAndCoalesceExpressions,
      isNullLiteral,
      getStaticStringValue,
      getStaticPropertyName,
      skipChainExpression,
      isSpecificId,
      isSpecificMemberAccess,
      equalLiteralValue,
      isSameReference,
      isLogicalAssignmentOperator,
      getSwitchCaseColonToken,
      getModuleExportName,
      isConstant,
      isTopLevelExpressionStatement,
      isDirective,
      isStartOfExpressionStatement,
      needsPrecedingSemicolon,
      isImportAttributeKey,
      getOpeningParenOfParams
    };
  })(astUtils);
  return astUtils.exports;
}
var accessorPairs;
var hasRequiredAccessorPairs;
function requireAccessorPairs() {
  if (hasRequiredAccessorPairs) return accessorPairs;
  hasRequiredAccessorPairs = 1;
  const astUtils2 = requireAstUtils();
  function areEqualTokenLists(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i2 = 0; i2 < left.length; i2++) {
      const leftToken = left[i2], rightToken = right[i2];
      if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
        return false;
      }
    }
    return true;
  }
  function areEqualKeys(left, right) {
    if (typeof left === "string" && typeof right === "string") {
      return left === right;
    }
    if (Array.isArray(left) && Array.isArray(right)) {
      return areEqualTokenLists(left, right);
    }
    return false;
  }
  function isAccessorKind(node2) {
    return node2.kind === "get" || node2.kind === "set";
  }
  function isArgumentOfMethodCall(node2, index, object, property) {
    const parent = node2.parent;
    return parent.type === "CallExpression" && astUtils2.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node2;
  }
  function isPropertyDescriptor(node2) {
    if (isArgumentOfMethodCall(node2, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node2, 2, "Reflect", "defineProperty")) {
      return true;
    }
    const grandparent = node2.parent.parent;
    return grandparent.type === "ObjectExpression" && (isArgumentOfMethodCall(grandparent, 1, "Object", "create") || isArgumentOfMethodCall(
      grandparent,
      1,
      "Object",
      "defineProperties"
    ));
  }
  accessorPairs = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          enforceForTSTypes: false,
          enforceForClassMembers: true,
          getWithoutSet: false,
          setWithoutGet: true
        }
      ],
      docs: {
        description: "Enforce getter and setter pairs in objects and classes",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/accessor-pairs"
      },
      schema: [
        {
          type: "object",
          properties: {
            getWithoutSet: {
              type: "boolean"
            },
            setWithoutGet: {
              type: "boolean"
            },
            enforceForClassMembers: {
              type: "boolean"
            },
            enforceForTSTypes: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
        missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
        missingGetterInObjectLiteral: "Getter is not present for {{ name }}.",
        missingSetterInObjectLiteral: "Setter is not present for {{ name }}.",
        missingGetterInClass: "Getter is not present for class {{ name }}.",
        missingSetterInClass: "Setter is not present for class {{ name }}.",
        missingGetterInType: "Getter is not present for type {{ name }}.",
        missingSetterInType: "Setter is not present for type {{ name }}."
      }
    },
    create(context) {
      const [
        {
          getWithoutSet: checkGetWithoutSet,
          setWithoutGet: checkSetWithoutGet,
          enforceForClassMembers,
          enforceForTSTypes
        }
      ] = context.options;
      const sourceCode2 = context.sourceCode;
      function report(node2, messageKind) {
        if (node2.type === "Property") {
          context.report({
            node: node2,
            messageId: `${messageKind}InObjectLiteral`,
            loc: astUtils2.getFunctionHeadLoc(node2.value, sourceCode2),
            data: {
              name: astUtils2.getFunctionNameWithKind(node2.value)
            }
          });
        } else if (node2.type === "MethodDefinition") {
          context.report({
            node: node2,
            messageId: `${messageKind}InClass`,
            loc: astUtils2.getFunctionHeadLoc(node2.value, sourceCode2),
            data: {
              name: astUtils2.getFunctionNameWithKind(node2.value)
            }
          });
        } else if (node2.type === "TSMethodSignature") {
          context.report({
            node: node2,
            messageId: `${messageKind}InType`,
            loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
            data: {
              name: astUtils2.getFunctionNameWithKind(node2)
            }
          });
        } else {
          context.report({
            node: node2,
            messageId: `${messageKind}InPropertyDescriptor`
          });
        }
      }
      function reportList(nodes, messageKind) {
        for (const node2 of nodes) {
          report(node2, messageKind);
        }
      }
      function checkList(nodes) {
        const accessors = [];
        let found = false;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node2 = nodes[i2];
          if (isAccessorKind(node2)) {
            const name2 = astUtils2.getStaticPropertyName(node2);
            const key = name2 !== null ? name2 : sourceCode2.getTokens(node2.key);
            for (let j = 0; j < accessors.length; j++) {
              const accessor = accessors[j];
              if (areEqualKeys(accessor.key, key)) {
                accessor.getters.push(
                  ...node2.kind === "get" ? [node2] : []
                );
                accessor.setters.push(
                  ...node2.kind === "set" ? [node2] : []
                );
                found = true;
                break;
              }
            }
            if (!found) {
              accessors.push({
                key,
                getters: node2.kind === "get" ? [node2] : [],
                setters: node2.kind === "set" ? [node2] : []
              });
            }
            found = false;
          }
        }
        for (const { getters, setters } of accessors) {
          if (checkSetWithoutGet && setters.length && !getters.length) {
            reportList(setters, "missingGetter");
          }
          if (checkGetWithoutSet && getters.length && !setters.length) {
            reportList(getters, "missingSetter");
          }
        }
      }
      function checkObjectLiteral(node2) {
        checkList(node2.properties.filter((p2) => p2.type === "Property"));
      }
      function checkPropertyDescriptor(node2) {
        const namesToCheck = new Set(
          node2.properties.filter(
            (p2) => p2.type === "Property" && p2.kind === "init" && !p2.computed
          ).map(({ key }) => key.name)
        );
        const hasGetter = namesToCheck.has("get");
        const hasSetter = namesToCheck.has("set");
        if (checkSetWithoutGet && hasSetter && !hasGetter) {
          report(node2, "missingGetter");
        }
        if (checkGetWithoutSet && hasGetter && !hasSetter) {
          report(node2, "missingSetter");
        }
      }
      function checkObjectExpression(node2) {
        checkObjectLiteral(node2);
        if (isPropertyDescriptor(node2)) {
          checkPropertyDescriptor(node2);
        }
      }
      function checkClassBody(node2) {
        const methodDefinitions = node2.body.filter(
          (m2) => m2.type === "MethodDefinition"
        );
        checkList(methodDefinitions.filter((m2) => m2.static));
        checkList(methodDefinitions.filter((m2) => !m2.static));
      }
      function checkType(node2) {
        const members = node2.type === "TSTypeLiteral" ? node2.members : node2.body;
        const methodDefinitions = members.filter(
          (m2) => m2.type === "TSMethodSignature"
        );
        checkList(methodDefinitions);
      }
      const listeners = {};
      if (checkSetWithoutGet || checkGetWithoutSet) {
        listeners.ObjectExpression = checkObjectExpression;
        if (enforceForClassMembers) {
          listeners.ClassBody = checkClassBody;
        }
        if (enforceForTSTypes) {
          listeners["TSTypeLiteral, TSInterfaceBody"] = checkType;
        }
      }
      return listeners;
    }
  };
  return accessorPairs;
}
var arrayBracketNewline;
var hasRequiredArrayBracketNewline;
function requireArrayBracketNewline() {
  if (hasRequiredArrayBracketNewline) return arrayBracketNewline;
  hasRequiredArrayBracketNewline = 1;
  const astUtils2 = requireAstUtils();
  arrayBracketNewline = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "array-bracket-newline",
              url: "https://eslint.style/rules/array-bracket-newline"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce linebreaks after opening and before closing array brackets",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/array-bracket-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consistent"]
            },
            {
              type: "object",
              properties: {
                multiline: {
                  type: "boolean"
                },
                minItems: {
                  type: ["integer", "null"],
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
        unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
        missingOpeningLinebreak: "A linebreak is required after '['.",
        missingClosingLinebreak: "A linebreak is required before ']'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function normalizeOptionValue(option) {
        let consistent = false;
        let multiline = false;
        let minItems;
        if (option) {
          if (option === "consistent") {
            consistent = true;
            minItems = Number.POSITIVE_INFINITY;
          } else if (option === "always" || option.minItems === 0) {
            minItems = 0;
          } else if (option === "never") {
            minItems = Number.POSITIVE_INFINITY;
          } else {
            multiline = Boolean(option.multiline);
            minItems = option.minItems || Number.POSITIVE_INFINITY;
          }
        } else {
          consistent = false;
          multiline = true;
          minItems = Number.POSITIVE_INFINITY;
        }
        return { consistent, multiline, minItems };
      }
      function normalizeOptions(options) {
        const value = normalizeOptionValue(options);
        return { ArrayExpression: value, ArrayPattern: value };
      }
      function reportNoBeginningLinebreak(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "unexpectedOpeningLinebreak",
          fix(fixer) {
            const nextToken = sourceCode2.getTokenAfter(token, {
              includeComments: true
            });
            if (astUtils2.isCommentToken(nextToken)) {
              return null;
            }
            return fixer.removeRange([
              token.range[1],
              nextToken.range[0]
            ]);
          }
        });
      }
      function reportNoEndingLinebreak(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "unexpectedClosingLinebreak",
          fix(fixer) {
            const previousToken = sourceCode2.getTokenBefore(token, {
              includeComments: true
            });
            if (astUtils2.isCommentToken(previousToken)) {
              return null;
            }
            return fixer.removeRange([
              previousToken.range[1],
              token.range[0]
            ]);
          }
        });
      }
      function reportRequiredBeginningLinebreak(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "missingOpeningLinebreak",
          fix(fixer) {
            return fixer.insertTextAfter(token, "\n");
          }
        });
      }
      function reportRequiredEndingLinebreak(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "missingClosingLinebreak",
          fix(fixer) {
            return fixer.insertTextBefore(token, "\n");
          }
        });
      }
      function check2(node2) {
        const elements = node2.elements;
        const normalizedOptions = normalizeOptions(context.options[0]);
        const options = normalizedOptions[node2.type];
        const openBracket = sourceCode2.getFirstToken(node2);
        const closeBracket = sourceCode2.getLastToken(node2);
        const firstIncComment = sourceCode2.getTokenAfter(openBracket, {
          includeComments: true
        });
        const lastIncComment = sourceCode2.getTokenBefore(closeBracket, {
          includeComments: true
        });
        const first = sourceCode2.getTokenAfter(openBracket);
        const last = sourceCode2.getTokenBefore(closeBracket);
        const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;
        if (needsLinebreaks) {
          if (astUtils2.isTokenOnSameLine(openBracket, first)) {
            reportRequiredBeginningLinebreak(node2, openBracket);
          }
          if (astUtils2.isTokenOnSameLine(last, closeBracket)) {
            reportRequiredEndingLinebreak(node2, closeBracket);
          }
        } else {
          if (!astUtils2.isTokenOnSameLine(openBracket, first)) {
            reportNoBeginningLinebreak(node2, openBracket);
          }
          if (!astUtils2.isTokenOnSameLine(last, closeBracket)) {
            reportNoEndingLinebreak(node2, closeBracket);
          }
        }
      }
      return {
        ArrayPattern: check2,
        ArrayExpression: check2
      };
    }
  };
  return arrayBracketNewline;
}
var arrayBracketSpacing;
var hasRequiredArrayBracketSpacing;
function requireArrayBracketSpacing() {
  if (hasRequiredArrayBracketSpacing) return arrayBracketSpacing;
  hasRequiredArrayBracketSpacing = 1;
  const astUtils2 = requireAstUtils();
  arrayBracketSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "array-bracket-spacing",
              url: "https://eslint.style/rules/array-bracket-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside array brackets",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/array-bracket-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            singleValue: {
              type: "boolean"
            },
            objectsInArrays: {
              type: "boolean"
            },
            arraysInArrays: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'."
      }
    },
    create(context) {
      const spaced = context.options[0] === "always", sourceCode2 = context.sourceCode;
      function isOptionSet(option) {
        return context.options[1] ? context.options[1][option] === !spaced : false;
      }
      const options = {
        spaced,
        singleElementException: isOptionSet("singleValue"),
        objectsInArraysException: isOptionSet("objectsInArrays"),
        arraysInArraysException: isOptionSet("arraysInArrays")
      };
      function reportNoBeginningSpace(node2, token) {
        const nextToken = sourceCode2.getTokenAfter(token);
        context.report({
          node: node2,
          loc: { start: token.loc.end, end: nextToken.loc.start },
          messageId: "unexpectedSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([
              token.range[1],
              nextToken.range[0]
            ]);
          }
        });
      }
      function reportNoEndingSpace(node2, token) {
        const previousToken = sourceCode2.getTokenBefore(token);
        context.report({
          node: node2,
          loc: { start: previousToken.loc.end, end: token.loc.start },
          messageId: "unexpectedSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([
              previousToken.range[1],
              token.range[0]
            ]);
          }
        });
      }
      function reportRequiredBeginningSpace(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "missingSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
      function reportRequiredEndingSpace(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "missingSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
      function isObjectType(node2) {
        return node2 && (node2.type === "ObjectExpression" || node2.type === "ObjectPattern");
      }
      function isArrayType(node2) {
        return node2 && (node2.type === "ArrayExpression" || node2.type === "ArrayPattern");
      }
      function validateArraySpacing(node2) {
        if (options.spaced && node2.elements.length === 0) {
          return;
        }
        const first = sourceCode2.getFirstToken(node2), second = sourceCode2.getFirstToken(node2, 1), last = node2.typeAnnotation ? sourceCode2.getTokenBefore(node2.typeAnnotation) : sourceCode2.getLastToken(node2), penultimate = sourceCode2.getTokenBefore(last), firstElement = node2.elements[0], lastElement = node2.elements.at(-1);
        const openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node2.elements.length === 1 ? !options.spaced : options.spaced;
        const closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node2.elements.length === 1 ? !options.spaced : options.spaced;
        if (astUtils2.isTokenOnSameLine(first, second)) {
          if (openingBracketMustBeSpaced && !sourceCode2.isSpaceBetweenTokens(first, second)) {
            reportRequiredBeginningSpace(node2, first);
          }
          if (!openingBracketMustBeSpaced && sourceCode2.isSpaceBetweenTokens(first, second)) {
            reportNoBeginningSpace(node2, first);
          }
        }
        if (first !== penultimate && astUtils2.isTokenOnSameLine(penultimate, last)) {
          if (closingBracketMustBeSpaced && !sourceCode2.isSpaceBetweenTokens(penultimate, last)) {
            reportRequiredEndingSpace(node2, last);
          }
          if (!closingBracketMustBeSpaced && sourceCode2.isSpaceBetweenTokens(penultimate, last)) {
            reportNoEndingSpace(node2, last);
          }
        }
      }
      return {
        ArrayPattern: validateArraySpacing,
        ArrayExpression: validateArraySpacing
      };
    }
  };
  return arrayBracketSpacing;
}
var arrayCallbackReturn;
var hasRequiredArrayCallbackReturn;
function requireArrayCallbackReturn() {
  if (hasRequiredArrayCallbackReturn) return arrayCallbackReturn;
  hasRequiredArrayCallbackReturn = 1;
  const astUtils2 = requireAstUtils();
  const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
  const TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;
  function isTargetMethod(node2) {
    return astUtils2.isSpecificMemberAccess(node2, null, TARGET_METHODS);
  }
  function isAnySegmentReachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return true;
      }
    }
    return false;
  }
  function fullMethodName(arrayMethodName) {
    if (["from", "of", "isArray"].includes(arrayMethodName)) {
      return "Array.".concat(arrayMethodName);
    }
    return "Array.prototype.".concat(arrayMethodName);
  }
  function getArrayMethodName(node2) {
    let currentNode = node2;
    while (currentNode) {
      const parent = currentNode.parent;
      switch (parent.type) {
        case "LogicalExpression":
        case "ConditionalExpression":
        case "ChainExpression":
          currentNode = parent;
          break;
        case "ReturnStatement": {
          const func = astUtils2.getUpperFunction(parent);
          if (func === null || !astUtils2.isCallee(func)) {
            return null;
          }
          currentNode = func.parent;
          break;
        }
        case "CallExpression":
          if (astUtils2.isArrayFromMethod(parent.callee)) {
            if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {
              return "from";
            }
          }
          if (isTargetMethod(parent.callee)) {
            if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {
              return astUtils2.getStaticPropertyName(parent.callee);
            }
          }
          return null;
        default:
          return null;
      }
    }
    return null;
  }
  function isExpressionVoid(node2) {
    return node2.type === "UnaryExpression" && node2.operator === "void";
  }
  function voidPrependFixer(sourceCode2, node2, fixer) {
    const requiresParens = (
      // prepending `void ` will fail if the node has a lower precedence than void
      astUtils2.getPrecedence(node2) < astUtils2.getPrecedence({
        type: "UnaryExpression",
        operator: "void"
      }) && // check if there are parentheses around the node to avoid redundant parentheses
      !astUtils2.isParenthesised(sourceCode2, node2)
    );
    const returnOrArrowToken = sourceCode2.getTokenBefore(
      node2,
      node2.parent.type === "ArrowFunctionExpression" ? astUtils2.isArrowToken : (
        // isReturnToken
        (token) => token.type === "Keyword" && token.value === "return"
      )
    );
    const firstToken = sourceCode2.getTokenAfter(returnOrArrowToken);
    const prependSpace = (
      // is return token, as => allows void to be adjacent
      returnOrArrowToken.value === "return" && // If two tokens (return and "(") are adjacent
      returnOrArrowToken.range[1] === firstToken.range[0]
    );
    return [
      fixer.insertTextBefore(
        firstToken,
        `${prependSpace ? " " : ""}void ${requiresParens ? "(" : ""}`
      ),
      fixer.insertTextAfter(node2, requiresParens ? ")" : "")
    ];
  }
  function curlyWrapFixer(sourceCode2, node2, fixer) {
    const arrowToken = sourceCode2.getTokenBefore(
      node2.body,
      astUtils2.isArrowToken
    );
    const firstToken = sourceCode2.getTokenAfter(arrowToken);
    const lastToken = sourceCode2.getLastToken(node2);
    return [
      fixer.insertTextBefore(firstToken, "{"),
      fixer.insertTextAfter(lastToken, "}")
    ];
  }
  arrayCallbackReturn = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowImplicit: false,
          checkForEach: false,
          allowVoid: false
        }
      ],
      docs: {
        description: "Enforce `return` statements in callbacks of array methods",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/array-callback-return"
      },
      hasSuggestions: true,
      schema: [
        {
          type: "object",
          properties: {
            allowImplicit: {
              type: "boolean"
            },
            checkForEach: {
              type: "boolean"
            },
            allowVoid: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",
        expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.",
        expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.",
        expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}.",
        wrapBraces: "Wrap the expression in `{}`.",
        prependVoid: "Prepend `void` to the expression."
      }
    },
    create(context) {
      const [options] = context.options;
      const sourceCode2 = context.sourceCode;
      let funcInfo = {
        arrayMethodName: null,
        upper: null,
        codePath: null,
        hasReturn: false,
        shouldCheck: false,
        node: null
      };
      function checkLastSegment(node2) {
        if (!funcInfo.shouldCheck) {
          return;
        }
        const messageAndSuggestions = { messageId: "", suggest: [] };
        if (funcInfo.arrayMethodName === "forEach") {
          if (options.checkForEach && node2.type === "ArrowFunctionExpression" && node2.expression) {
            if (options.allowVoid) {
              if (isExpressionVoid(node2.body)) {
                return;
              }
              messageAndSuggestions.messageId = "expectedNoReturnValue";
              messageAndSuggestions.suggest = [
                {
                  messageId: "wrapBraces",
                  fix(fixer) {
                    return curlyWrapFixer(
                      sourceCode2,
                      node2,
                      fixer
                    );
                  }
                },
                {
                  messageId: "prependVoid",
                  fix(fixer) {
                    return voidPrependFixer(
                      sourceCode2,
                      node2.body,
                      fixer
                    );
                  }
                }
              ];
            } else {
              messageAndSuggestions.messageId = "expectedNoReturnValue";
              messageAndSuggestions.suggest = [
                {
                  messageId: "wrapBraces",
                  fix(fixer) {
                    return curlyWrapFixer(
                      sourceCode2,
                      node2,
                      fixer
                    );
                  }
                }
              ];
            }
          }
        } else {
          if (node2.body.type === "BlockStatement" && isAnySegmentReachable(funcInfo.currentSegments)) {
            messageAndSuggestions.messageId = funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside";
          }
        }
        if (messageAndSuggestions.messageId) {
          const name2 = astUtils2.getFunctionNameWithKind(node2);
          context.report({
            node: node2,
            loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
            messageId: messageAndSuggestions.messageId,
            data: {
              name: name2,
              arrayMethodName: fullMethodName(
                funcInfo.arrayMethodName
              )
            },
            suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null
          });
        }
      }
      return {
        // Stacks this function's information.
        onCodePathStart(codePath2, node2) {
          let methodName = null;
          if (TARGET_NODE_TYPE.test(node2.type)) {
            methodName = getArrayMethodName(node2);
          }
          funcInfo = {
            arrayMethodName: methodName,
            upper: funcInfo,
            codePath: codePath2,
            hasReturn: false,
            shouldCheck: methodName && !node2.async && !node2.generator,
            node: node2,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        // Pops this function's information.
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        onUnreachableCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        onCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        // Checks the return statement is valid.
        ReturnStatement(node2) {
          if (!funcInfo.shouldCheck) {
            return;
          }
          funcInfo.hasReturn = true;
          const messageAndSuggestions = { messageId: "", suggest: [] };
          if (funcInfo.arrayMethodName === "forEach") {
            if (options.checkForEach && node2.argument) {
              if (options.allowVoid) {
                if (isExpressionVoid(node2.argument)) {
                  return;
                }
                messageAndSuggestions.messageId = "expectedNoReturnValue";
                messageAndSuggestions.suggest = [
                  {
                    messageId: "prependVoid",
                    fix(fixer) {
                      return voidPrependFixer(
                        sourceCode2,
                        node2.argument,
                        fixer
                      );
                    }
                  }
                ];
              } else {
                messageAndSuggestions.messageId = "expectedNoReturnValue";
              }
            }
          } else {
            if (!options.allowImplicit && !node2.argument) {
              messageAndSuggestions.messageId = "expectedReturnValue";
            }
          }
          if (messageAndSuggestions.messageId) {
            context.report({
              node: node2,
              messageId: messageAndSuggestions.messageId,
              data: {
                name: astUtils2.getFunctionNameWithKind(
                  funcInfo.node
                ),
                arrayMethodName: fullMethodName(
                  funcInfo.arrayMethodName
                )
              },
              suggest: messageAndSuggestions.suggest.length !== 0 ? messageAndSuggestions.suggest : null
            });
          }
        },
        // Reports a given function if the last path is reachable.
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
      };
    }
  };
  return arrayCallbackReturn;
}
var arrayElementNewline;
var hasRequiredArrayElementNewline;
function requireArrayElementNewline() {
  if (hasRequiredArrayElementNewline) return arrayElementNewline;
  hasRequiredArrayElementNewline = 1;
  const astUtils2 = requireAstUtils();
  arrayElementNewline = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "array-element-newline",
              url: "https://eslint.style/rules/array-element-newline"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce line breaks after each array element",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/array-element-newline"
      },
      fixable: "whitespace",
      schema: {
        definitions: {
          basicConfig: {
            oneOf: [
              {
                enum: ["always", "never", "consistent"]
              },
              {
                type: "object",
                properties: {
                  multiline: {
                    type: "boolean"
                  },
                  minItems: {
                    type: ["integer", "null"],
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        },
        type: "array",
        items: [
          {
            oneOf: [
              {
                $ref: "#/definitions/basicConfig"
              },
              {
                type: "object",
                properties: {
                  ArrayExpression: {
                    $ref: "#/definitions/basicConfig"
                  },
                  ArrayPattern: {
                    $ref: "#/definitions/basicConfig"
                  }
                },
                additionalProperties: false,
                minProperties: 1
              }
            ]
          }
        ]
      },
      messages: {
        unexpectedLineBreak: "There should be no linebreak here.",
        missingLineBreak: "There should be a linebreak after this element."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function normalizeOptionValue(providedOption) {
        let consistent = false;
        let multiline = false;
        let minItems;
        const option = providedOption || "always";
        if (option === "always" || option.minItems === 0) {
          minItems = 0;
        } else if (option === "never") {
          minItems = Number.POSITIVE_INFINITY;
        } else if (option === "consistent") {
          consistent = true;
          minItems = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(option.multiline);
          minItems = option.minItems || Number.POSITIVE_INFINITY;
        }
        return { consistent, multiline, minItems };
      }
      function normalizeOptions(options) {
        if (options && (options.ArrayExpression || options.ArrayPattern)) {
          let expressionOptions, patternOptions;
          if (options.ArrayExpression) {
            expressionOptions = normalizeOptionValue(
              options.ArrayExpression
            );
          }
          if (options.ArrayPattern) {
            patternOptions = normalizeOptionValue(options.ArrayPattern);
          }
          return {
            ArrayExpression: expressionOptions,
            ArrayPattern: patternOptions
          };
        }
        const value = normalizeOptionValue(options);
        return { ArrayExpression: value, ArrayPattern: value };
      }
      function reportNoLineBreak(token) {
        const tokenBefore = sourceCode2.getTokenBefore(token, {
          includeComments: true
        });
        context.report({
          loc: {
            start: tokenBefore.loc.end,
            end: token.loc.start
          },
          messageId: "unexpectedLineBreak",
          fix(fixer) {
            if (astUtils2.isCommentToken(tokenBefore)) {
              return null;
            }
            if (!astUtils2.isTokenOnSameLine(tokenBefore, token)) {
              return fixer.replaceTextRange(
                [tokenBefore.range[1], token.range[0]],
                " "
              );
            }
            const twoTokensBefore = sourceCode2.getTokenBefore(
              tokenBefore,
              { includeComments: true }
            );
            if (astUtils2.isCommentToken(twoTokensBefore)) {
              return null;
            }
            return fixer.replaceTextRange(
              [twoTokensBefore.range[1], tokenBefore.range[0]],
              ""
            );
          }
        });
      }
      function reportRequiredLineBreak(token) {
        const tokenBefore = sourceCode2.getTokenBefore(token, {
          includeComments: true
        });
        context.report({
          loc: {
            start: tokenBefore.loc.end,
            end: token.loc.start
          },
          messageId: "missingLineBreak",
          fix(fixer) {
            return fixer.replaceTextRange(
              [tokenBefore.range[1], token.range[0]],
              "\n"
            );
          }
        });
      }
      function check2(node2) {
        const elements = node2.elements;
        const normalizedOptions = normalizeOptions(context.options[0]);
        const options = normalizedOptions[node2.type];
        if (!options) {
          return;
        }
        let elementBreak = false;
        if (options.multiline) {
          elementBreak = elements.filter((element) => element !== null).some(
            (element) => element.loc.start.line !== element.loc.end.line
          );
        }
        let linebreaksCount = 0;
        for (let i2 = 0; i2 < node2.elements.length; i2++) {
          const element = node2.elements[i2];
          const previousElement = elements[i2 - 1];
          if (i2 === 0 || element === null || previousElement === null) {
            continue;
          }
          const commaToken = sourceCode2.getFirstTokenBetween(
            previousElement,
            element,
            astUtils2.isCommaToken
          );
          const lastTokenOfPreviousElement = sourceCode2.getTokenBefore(commaToken);
          const firstTokenOfCurrentElement = sourceCode2.getTokenAfter(commaToken);
          if (!astUtils2.isTokenOnSameLine(
            lastTokenOfPreviousElement,
            firstTokenOfCurrentElement
          )) {
            linebreaksCount++;
          }
        }
        const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node2.elements.length;
        elements.forEach((element, i2) => {
          const previousElement = elements[i2 - 1];
          if (i2 === 0 || element === null || previousElement === null) {
            return;
          }
          const commaToken = sourceCode2.getFirstTokenBetween(
            previousElement,
            element,
            astUtils2.isCommaToken
          );
          const lastTokenOfPreviousElement = sourceCode2.getTokenBefore(commaToken);
          const firstTokenOfCurrentElement = sourceCode2.getTokenAfter(commaToken);
          if (needsLinebreaks) {
            if (astUtils2.isTokenOnSameLine(
              lastTokenOfPreviousElement,
              firstTokenOfCurrentElement
            )) {
              reportRequiredLineBreak(firstTokenOfCurrentElement);
            }
          } else {
            if (!astUtils2.isTokenOnSameLine(
              lastTokenOfPreviousElement,
              firstTokenOfCurrentElement
            )) {
              reportNoLineBreak(firstTokenOfCurrentElement);
            }
          }
        });
      }
      return {
        ArrayPattern: check2,
        ArrayExpression: check2
      };
    }
  };
  return arrayElementNewline;
}
var arrowBodyStyle;
var hasRequiredArrowBodyStyle;
function requireArrowBodyStyle() {
  if (hasRequiredArrowBodyStyle) return arrowBodyStyle;
  hasRequiredArrowBodyStyle = 1;
  const astUtils2 = requireAstUtils();
  arrowBodyStyle = {
    meta: {
      type: "suggestion",
      defaultOptions: ["as-needed"],
      docs: {
        description: "Require braces around arrow function bodies",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/arrow-body-style"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["as-needed"]
              },
              {
                type: "object",
                properties: {
                  requireReturnForObjectLiteral: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
        unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
        unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
        unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
        expectedBlock: "Expected block statement surrounding arrow body."
      }
    },
    create(context) {
      const options = context.options;
      const always = options[0] === "always";
      const asNeeded = options[0] === "as-needed";
      const never = options[0] === "never";
      const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
      const sourceCode2 = context.sourceCode;
      let funcInfo = null;
      function hasASIProblem(token) {
        return token && token.type === "Punctuator" && /^[([/`+-]/u.test(token.value);
      }
      function findClosingParen(node2) {
        let nodeToCheck = node2;
        while (!astUtils2.isParenthesised(sourceCode2, nodeToCheck)) {
          nodeToCheck = nodeToCheck.parent;
        }
        return sourceCode2.getTokenAfter(nodeToCheck);
      }
      function isInsideForLoopInitializer(node2) {
        if (node2 && node2.parent) {
          if (node2.parent.type === "ForStatement" && node2.parent.init === node2) {
            return true;
          }
          return isInsideForLoopInitializer(node2.parent);
        }
        return false;
      }
      function validate2(node2) {
        const arrowBody = node2.body;
        if (arrowBody.type === "BlockStatement") {
          const blockBody = arrowBody.body;
          if (blockBody.length !== 1 && !never) {
            return;
          }
          if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
            return;
          }
          if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
            let messageId;
            if (blockBody.length === 0) {
              messageId = "unexpectedEmptyBlock";
            } else if (blockBody.length > 1 || blockBody[0].type !== "ReturnStatement") {
              messageId = "unexpectedOtherBlock";
            } else if (blockBody[0].argument === null) {
              messageId = "unexpectedSingleBlock";
            } else if (astUtils2.isOpeningBraceToken(
              sourceCode2.getFirstToken(blockBody[0], { skip: 1 })
            )) {
              messageId = "unexpectedObjectBlock";
            } else {
              messageId = "unexpectedSingleBlock";
            }
            context.report({
              node: node2,
              loc: arrowBody.loc,
              messageId,
              fix(fixer) {
                const fixes = [];
                if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(
                  sourceCode2.getTokenAfter(arrowBody)
                )) {
                  return fixes;
                }
                const openingBrace = sourceCode2.getFirstToken(arrowBody);
                const closingBrace = sourceCode2.getLastToken(arrowBody);
                const firstValueToken = sourceCode2.getFirstToken(
                  blockBody[0],
                  1
                );
                const lastValueToken = sourceCode2.getLastToken(
                  blockBody[0]
                );
                const commentsExist = sourceCode2.commentsExistBetween(
                  openingBrace,
                  firstValueToken
                ) || sourceCode2.commentsExistBetween(
                  lastValueToken,
                  closingBrace
                );
                if (commentsExist) {
                  fixes.push(
                    fixer.remove(openingBrace),
                    fixer.remove(closingBrace),
                    fixer.remove(
                      sourceCode2.getTokenAfter(openingBrace)
                    )
                    // return keyword
                  );
                } else {
                  fixes.push(
                    fixer.removeRange([
                      openingBrace.range[0],
                      firstValueToken.range[0]
                    ]),
                    fixer.removeRange([
                      lastValueToken.range[1],
                      closingBrace.range[1]
                    ])
                  );
                }
                if (astUtils2.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === "SequenceExpression" || funcInfo.hasInOperator && isInsideForLoopInitializer(node2)) {
                  if (!astUtils2.isParenthesised(
                    sourceCode2,
                    blockBody[0].argument
                  )) {
                    fixes.push(
                      fixer.insertTextBefore(
                        firstValueToken,
                        "("
                      ),
                      fixer.insertTextAfter(
                        lastValueToken,
                        ")"
                      )
                    );
                  }
                }
                if (astUtils2.isSemicolonToken(lastValueToken)) {
                  fixes.push(fixer.remove(lastValueToken));
                }
                return fixes;
              }
            });
          }
        } else {
          if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
            context.report({
              node: node2,
              loc: arrowBody.loc,
              messageId: "expectedBlock",
              fix(fixer) {
                const fixes = [];
                const arrowToken = sourceCode2.getTokenBefore(
                  arrowBody,
                  astUtils2.isArrowToken
                );
                const [
                  firstTokenAfterArrow,
                  secondTokenAfterArrow
                ] = sourceCode2.getTokensAfter(arrowToken, {
                  count: 2
                });
                const lastToken = sourceCode2.getLastToken(node2);
                let parenthesisedObjectLiteral = null;
                if (astUtils2.isOpeningParenToken(
                  firstTokenAfterArrow
                ) && astUtils2.isOpeningBraceToken(
                  secondTokenAfterArrow
                )) {
                  const braceNode = sourceCode2.getNodeByRangeIndex(
                    secondTokenAfterArrow.range[0]
                  );
                  if (braceNode.type === "ObjectExpression") {
                    parenthesisedObjectLiteral = braceNode;
                  }
                }
                if (parenthesisedObjectLiteral) {
                  const openingParenToken = firstTokenAfterArrow;
                  const openingBraceToken = secondTokenAfterArrow;
                  if (astUtils2.isTokenOnSameLine(
                    openingParenToken,
                    openingBraceToken
                  )) {
                    fixes.push(
                      fixer.replaceText(
                        openingParenToken,
                        "{return "
                      )
                    );
                  } else {
                    fixes.push(
                      fixer.replaceText(
                        openingParenToken,
                        "{"
                      ),
                      fixer.insertTextBefore(
                        openingBraceToken,
                        "return "
                      )
                    );
                  }
                  fixes.push(
                    fixer.remove(
                      findClosingParen(
                        parenthesisedObjectLiteral
                      )
                    )
                  );
                  fixes.push(
                    fixer.insertTextAfter(lastToken, "}")
                  );
                } else {
                  fixes.push(
                    fixer.insertTextBefore(
                      firstTokenAfterArrow,
                      "{return "
                    )
                  );
                  fixes.push(
                    fixer.insertTextAfter(lastToken, "}")
                  );
                }
                return fixes;
              }
            });
          }
        }
      }
      return {
        "BinaryExpression[operator='in']"() {
          let info = funcInfo;
          while (info) {
            info.hasInOperator = true;
            info = info.upper;
          }
        },
        ArrowFunctionExpression() {
          funcInfo = {
            upper: funcInfo,
            hasInOperator: false
          };
        },
        "ArrowFunctionExpression:exit"(node2) {
          validate2(node2);
          funcInfo = funcInfo.upper;
        }
      };
    }
  };
  return arrowBodyStyle;
}
var arrowParens;
var hasRequiredArrowParens;
function requireArrowParens() {
  if (hasRequiredArrowParens) return arrowParens;
  hasRequiredArrowParens = 1;
  const astUtils2 = requireAstUtils();
  function hasBlockBody(node2) {
    return node2.body.type === "BlockStatement";
  }
  arrowParens = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "arrow-parens",
              url: "https://eslint.style/rules/arrow-parens"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require parentheses around arrow function arguments",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/arrow-parens"
      },
      fixable: "code",
      schema: [
        {
          enum: ["always", "as-needed"]
        },
        {
          type: "object",
          properties: {
            requireForBlockBody: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedParens: "Unexpected parentheses around single function argument.",
        expectedParens: "Expected parentheses around arrow function argument.",
        unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
        expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
      }
    },
    create(context) {
      const asNeeded = context.options[0] === "as-needed";
      const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;
      const sourceCode2 = context.sourceCode;
      function findOpeningParenOfParams(node2) {
        const tokenBeforeParams = sourceCode2.getTokenBefore(node2.params[0]);
        if (tokenBeforeParams && astUtils2.isOpeningParenToken(tokenBeforeParams) && node2.range[0] <= tokenBeforeParams.range[0]) {
          return tokenBeforeParams;
        }
        return null;
      }
      function getClosingParenOfParams(node2) {
        return sourceCode2.getTokenAfter(
          node2.params[0],
          astUtils2.isClosingParenToken
        );
      }
      function hasCommentsInParensOfParams(node2, openingParen) {
        return sourceCode2.commentsExistBetween(
          openingParen,
          getClosingParenOfParams(node2)
        );
      }
      function hasUnexpectedTokensBeforeOpeningParen(node2, openingParen) {
        const expectedCount = node2.async ? 1 : 0;
        return sourceCode2.getFirstToken(node2, { skip: expectedCount }) !== openingParen;
      }
      return {
        "ArrowFunctionExpression[params.length=1]"(node2) {
          const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node2);
          const openingParen = findOpeningParenOfParams(node2);
          const hasParens = openingParen !== null;
          const [param] = node2.params;
          if (shouldHaveParens && !hasParens) {
            context.report({
              node: node2,
              messageId: requireForBlockBody ? "expectedParensBlock" : "expectedParens",
              loc: param.loc,
              *fix(fixer) {
                yield fixer.insertTextBefore(param, "(");
                yield fixer.insertTextAfter(param, ")");
              }
            });
          }
          if (!shouldHaveParens && hasParens && param.type === "Identifier" && !param.typeAnnotation && !node2.returnType && !hasCommentsInParensOfParams(node2, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node2, openingParen)) {
            context.report({
              node: node2,
              messageId: requireForBlockBody ? "unexpectedParensInline" : "unexpectedParens",
              loc: param.loc,
              *fix(fixer) {
                const tokenBeforeOpeningParen = sourceCode2.getTokenBefore(openingParen);
                const closingParen = getClosingParenOfParams(node2);
                if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils2.canTokensBeAdjacent(
                  tokenBeforeOpeningParen,
                  sourceCode2.getFirstToken(param)
                )) {
                  yield fixer.insertTextBefore(openingParen, " ");
                }
                yield fixer.removeRange([
                  openingParen.range[0],
                  param.range[0]
                ]);
                yield fixer.removeRange([
                  param.range[1],
                  closingParen.range[1]
                ]);
              }
            });
          }
        }
      };
    }
  };
  return arrowParens;
}
var arrowSpacing;
var hasRequiredArrowSpacing;
function requireArrowSpacing() {
  if (hasRequiredArrowSpacing) return arrowSpacing;
  hasRequiredArrowSpacing = 1;
  const astUtils2 = requireAstUtils();
  arrowSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "arrow-spacing",
              url: "https://eslint.style/rules/arrow-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after the arrow in arrow functions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/arrow-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: true
            },
            after: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedBefore: "Missing space before =>.",
        unexpectedBefore: "Unexpected space before =>.",
        expectedAfter: "Missing space after =>.",
        unexpectedAfter: "Unexpected space after =>."
      }
    },
    create(context) {
      const rule = Object.assign({}, context.options[0]);
      rule.before = rule.before !== false;
      rule.after = rule.after !== false;
      const sourceCode2 = context.sourceCode;
      function getTokens(node2) {
        const arrow = sourceCode2.getTokenBefore(
          node2.body,
          astUtils2.isArrowToken
        );
        return {
          before: sourceCode2.getTokenBefore(arrow),
          arrow,
          after: sourceCode2.getTokenAfter(arrow)
        };
      }
      function countSpaces(tokens) {
        const before = tokens.arrow.range[0] - tokens.before.range[1];
        const after = tokens.after.range[0] - tokens.arrow.range[1];
        return { before, after };
      }
      function spaces2(node2) {
        const tokens = getTokens(node2);
        const countSpace = countSpaces(tokens);
        if (rule.before) {
          if (countSpace.before === 0) {
            context.report({
              node: tokens.before,
              messageId: "expectedBefore",
              fix(fixer) {
                return fixer.insertTextBefore(tokens.arrow, " ");
              }
            });
          }
        } else {
          if (countSpace.before > 0) {
            context.report({
              node: tokens.before,
              messageId: "unexpectedBefore",
              fix(fixer) {
                return fixer.removeRange([
                  tokens.before.range[1],
                  tokens.arrow.range[0]
                ]);
              }
            });
          }
        }
        if (rule.after) {
          if (countSpace.after === 0) {
            context.report({
              node: tokens.after,
              messageId: "expectedAfter",
              fix(fixer) {
                return fixer.insertTextAfter(tokens.arrow, " ");
              }
            });
          }
        } else {
          if (countSpace.after > 0) {
            context.report({
              node: tokens.after,
              messageId: "unexpectedAfter",
              fix(fixer) {
                return fixer.removeRange([
                  tokens.arrow.range[1],
                  tokens.after.range[0]
                ]);
              }
            });
          }
        }
      }
      return {
        ArrowFunctionExpression: spaces2
      };
    }
  };
  return arrowSpacing;
}
var blockScopedVar;
var hasRequiredBlockScopedVar;
function requireBlockScopedVar() {
  if (hasRequiredBlockScopedVar) return blockScopedVar;
  hasRequiredBlockScopedVar = 1;
  blockScopedVar = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce the use of variables within the scope they are defined",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/block-scoped-var"
      },
      schema: [],
      messages: {
        outOfScope: "'{{name}}' declared on line {{definitionLine}} column {{definitionColumn}} is used outside of binding context."
      }
    },
    create(context) {
      let stack = [];
      const sourceCode2 = context.sourceCode;
      function enterScope(node2) {
        stack.push(node2.range);
      }
      function exitScope() {
        stack.pop();
      }
      function report(reference, definition) {
        const identifier = reference.identifier;
        const definitionPosition = definition.name.loc.start;
        context.report({
          node: identifier,
          messageId: "outOfScope",
          data: {
            name: identifier.name,
            definitionLine: definitionPosition.line,
            definitionColumn: definitionPosition.column + 1
          }
        });
      }
      function checkForVariables(node2) {
        if (node2.kind !== "var") {
          return;
        }
        const scopeRange = stack.at(-1);
        function isOutsideOfScope(reference) {
          const idRange = reference.identifier.range;
          return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
        }
        const variables = sourceCode2.getDeclaredVariables(node2);
        for (let i2 = 0; i2 < variables.length; ++i2) {
          variables[i2].references.filter(isOutsideOfScope).forEach(
            (ref2) => report(
              ref2,
              variables[i2].defs.find((def) => def.parent === node2)
            )
          );
        }
      }
      return {
        Program(node2) {
          stack = [node2.range];
        },
        // Manages scopes.
        BlockStatement: enterScope,
        "BlockStatement:exit": exitScope,
        ForStatement: enterScope,
        "ForStatement:exit": exitScope,
        ForInStatement: enterScope,
        "ForInStatement:exit": exitScope,
        ForOfStatement: enterScope,
        "ForOfStatement:exit": exitScope,
        SwitchStatement: enterScope,
        "SwitchStatement:exit": exitScope,
        CatchClause: enterScope,
        "CatchClause:exit": exitScope,
        StaticBlock: enterScope,
        "StaticBlock:exit": exitScope,
        // Finds and reports references which are outside of valid scope.
        VariableDeclaration: checkForVariables
      };
    }
  };
  return blockScopedVar;
}
var blockSpacing;
var hasRequiredBlockSpacing;
function requireBlockSpacing() {
  if (hasRequiredBlockSpacing) return blockSpacing;
  hasRequiredBlockSpacing = 1;
  const util2 = requireAstUtils();
  blockSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "block-spacing",
              url: "https://eslint.style/rules/block-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow or enforce spaces inside of blocks after opening block and before closing block",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/block-spacing"
      },
      fixable: "whitespace",
      schema: [{ enum: ["always", "never"] }],
      messages: {
        missing: "Requires a space {{location}} '{{token}}'.",
        extra: "Unexpected space(s) {{location}} '{{token}}'."
      }
    },
    create(context) {
      const always = context.options[0] !== "never", messageId = always ? "missing" : "extra", sourceCode2 = context.sourceCode;
      function getOpenBrace(node2) {
        if (node2.type === "SwitchStatement") {
          if (node2.cases.length > 0) {
            return sourceCode2.getTokenBefore(node2.cases[0]);
          }
          return sourceCode2.getLastToken(node2, 1);
        }
        if (node2.type === "StaticBlock") {
          return sourceCode2.getFirstToken(node2, { skip: 1 });
        }
        return sourceCode2.getFirstToken(node2);
      }
      function isValid(left, right) {
        return !util2.isTokenOnSameLine(left, right) || sourceCode2.isSpaceBetweenTokens(left, right) === always;
      }
      function checkSpacingInsideBraces(node2) {
        const openBrace = getOpenBrace(node2);
        const closeBrace = sourceCode2.getLastToken(node2);
        const firstToken = sourceCode2.getTokenAfter(openBrace, {
          includeComments: true
        });
        const lastToken = sourceCode2.getTokenBefore(closeBrace, {
          includeComments: true
        });
        if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
          return;
        }
        if (!always && firstToken.type === "Line") {
          return;
        }
        if (!isValid(openBrace, firstToken)) {
          let loc = openBrace.loc;
          if (messageId === "extra") {
            loc = {
              start: openBrace.loc.end,
              end: firstToken.loc.start
            };
          }
          context.report({
            node: node2,
            loc,
            messageId,
            data: {
              location: "after",
              token: openBrace.value
            },
            fix(fixer) {
              if (always) {
                return fixer.insertTextBefore(firstToken, " ");
              }
              return fixer.removeRange([
                openBrace.range[1],
                firstToken.range[0]
              ]);
            }
          });
        }
        if (!isValid(lastToken, closeBrace)) {
          let loc = closeBrace.loc;
          if (messageId === "extra") {
            loc = {
              start: lastToken.loc.end,
              end: closeBrace.loc.start
            };
          }
          context.report({
            node: node2,
            loc,
            messageId,
            data: {
              location: "before",
              token: closeBrace.value
            },
            fix(fixer) {
              if (always) {
                return fixer.insertTextAfter(lastToken, " ");
              }
              return fixer.removeRange([
                lastToken.range[1],
                closeBrace.range[0]
              ]);
            }
          });
        }
      }
      return {
        BlockStatement: checkSpacingInsideBraces,
        StaticBlock: checkSpacingInsideBraces,
        SwitchStatement: checkSpacingInsideBraces
      };
    }
  };
  return blockSpacing;
}
var braceStyle;
var hasRequiredBraceStyle;
function requireBraceStyle() {
  if (hasRequiredBraceStyle) return braceStyle;
  hasRequiredBraceStyle = 1;
  const astUtils2 = requireAstUtils();
  braceStyle = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "brace-style",
              url: "https://eslint.style/rules/brace-style"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent brace style for blocks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/brace-style"
      },
      schema: [
        {
          enum: ["1tbs", "stroustrup", "allman"]
        },
        {
          type: "object",
          properties: {
            allowSingleLine: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "whitespace",
      messages: {
        nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
        sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
        blockSameLine: "Statement inside of curly braces should be on next line.",
        nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
        singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
        sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
      }
    },
    create(context) {
      const style = context.options[0] || "1tbs", params = context.options[1] || {}, sourceCode2 = context.sourceCode;
      function removeNewlineBetween(firstToken, secondToken) {
        const textRange2 = [firstToken.range[1], secondToken.range[0]];
        const textBetween = sourceCode2.text.slice(
          textRange2[0],
          textRange2[1]
        );
        if (textBetween.trim()) {
          return null;
        }
        return (fixer) => fixer.replaceTextRange(textRange2, " ");
      }
      function validateCurlyPair(openingCurly, closingCurly) {
        const tokenBeforeOpeningCurly = sourceCode2.getTokenBefore(openingCurly);
        const tokenAfterOpeningCurly = sourceCode2.getTokenAfter(openingCurly);
        const tokenBeforeClosingCurly = sourceCode2.getTokenBefore(closingCurly);
        const singleLineException = params.allowSingleLine && astUtils2.isTokenOnSameLine(openingCurly, closingCurly);
        if (style !== "allman" && !astUtils2.isTokenOnSameLine(
          tokenBeforeOpeningCurly,
          openingCurly
        )) {
          context.report({
            node: openingCurly,
            messageId: "nextLineOpen",
            fix: removeNewlineBetween(
              tokenBeforeOpeningCurly,
              openingCurly
            )
          });
        }
        if (style === "allman" && astUtils2.isTokenOnSameLine(
          tokenBeforeOpeningCurly,
          openingCurly
        ) && !singleLineException) {
          context.report({
            node: openingCurly,
            messageId: "sameLineOpen",
            fix: (fixer) => fixer.insertTextBefore(openingCurly, "\n")
          });
        }
        if (astUtils2.isTokenOnSameLine(
          openingCurly,
          tokenAfterOpeningCurly
        ) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
          context.report({
            node: openingCurly,
            messageId: "blockSameLine",
            fix: (fixer) => fixer.insertTextAfter(openingCurly, "\n")
          });
        }
        if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils2.isTokenOnSameLine(
          tokenBeforeClosingCurly,
          closingCurly
        )) {
          context.report({
            node: closingCurly,
            messageId: "singleLineClose",
            fix: (fixer) => fixer.insertTextBefore(closingCurly, "\n")
          });
        }
      }
      function validateCurlyBeforeKeyword(curlyToken) {
        const keywordToken = sourceCode2.getTokenAfter(curlyToken);
        if (style === "1tbs" && !astUtils2.isTokenOnSameLine(curlyToken, keywordToken)) {
          context.report({
            node: curlyToken,
            messageId: "nextLineClose",
            fix: removeNewlineBetween(curlyToken, keywordToken)
          });
        }
        if (style !== "1tbs" && astUtils2.isTokenOnSameLine(curlyToken, keywordToken)) {
          context.report({
            node: curlyToken,
            messageId: "sameLineClose",
            fix: (fixer) => fixer.insertTextAfter(curlyToken, "\n")
          });
        }
      }
      return {
        BlockStatement(node2) {
          if (!astUtils2.STATEMENT_LIST_PARENTS.has(node2.parent.type)) {
            validateCurlyPair(
              sourceCode2.getFirstToken(node2),
              sourceCode2.getLastToken(node2)
            );
          }
        },
        StaticBlock(node2) {
          validateCurlyPair(
            sourceCode2.getFirstToken(node2, { skip: 1 }),
            // skip the `static` token
            sourceCode2.getLastToken(node2)
          );
        },
        ClassBody(node2) {
          validateCurlyPair(
            sourceCode2.getFirstToken(node2),
            sourceCode2.getLastToken(node2)
          );
        },
        SwitchStatement(node2) {
          const closingCurly = sourceCode2.getLastToken(node2);
          const openingCurly = sourceCode2.getTokenBefore(
            node2.cases.length ? node2.cases[0] : closingCurly
          );
          validateCurlyPair(openingCurly, closingCurly);
        },
        IfStatement(node2) {
          if (node2.consequent.type === "BlockStatement" && node2.alternate) {
            validateCurlyBeforeKeyword(
              sourceCode2.getLastToken(node2.consequent)
            );
          }
        },
        TryStatement(node2) {
          validateCurlyBeforeKeyword(sourceCode2.getLastToken(node2.block));
          if (node2.handler && node2.finalizer) {
            validateCurlyBeforeKeyword(
              sourceCode2.getLastToken(node2.handler.body)
            );
          }
        }
      };
    }
  };
  return braceStyle;
}
var callbackReturn;
var hasRequiredCallbackReturn;
function requireCallbackReturn() {
  if (hasRequiredCallbackReturn) return callbackReturn;
  hasRequiredCallbackReturn = 1;
  callbackReturn = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "callback-return",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/callback-return.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Require `return` statements after callbacks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/callback-return"
      },
      schema: [
        {
          type: "array",
          items: { type: "string" }
        }
      ],
      messages: {
        missingReturn: "Expected return with your callback function."
      }
    },
    create(context) {
      const callbacks = context.options[0] || ["callback", "cb", "next"], sourceCode2 = context.sourceCode;
      function findClosestParentOfType(node2, types2) {
        if (!node2.parent) {
          return null;
        }
        if (!types2.includes(node2.parent.type)) {
          return findClosestParentOfType(node2.parent, types2);
        }
        return node2.parent;
      }
      function containsOnlyIdentifiers(node2) {
        if (node2.type === "Identifier") {
          return true;
        }
        if (node2.type === "MemberExpression") {
          if (node2.object.type === "Identifier") {
            return true;
          }
          if (node2.object.type === "MemberExpression") {
            return containsOnlyIdentifiers(node2.object);
          }
        }
        return false;
      }
      function isCallback(node2) {
        return containsOnlyIdentifiers(node2.callee) && callbacks.includes(sourceCode2.getText(node2.callee));
      }
      function isCallbackExpression(node2, parentNode) {
        if (!parentNode || parentNode.type !== "ExpressionStatement") {
          return false;
        }
        if (parentNode.expression === node2) {
          return true;
        }
        if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
          if (parentNode.expression.right === node2) {
            return true;
          }
        }
        return false;
      }
      return {
        CallExpression(node2) {
          if (!isCallback(node2)) {
            return;
          }
          const closestBlock = findClosestParentOfType(node2, [
            "BlockStatement",
            "ReturnStatement",
            "ArrowFunctionExpression"
          ]) || {};
          if (closestBlock.type === "ReturnStatement") {
            return;
          }
          if (closestBlock.type === "ArrowFunctionExpression") {
            return;
          }
          if (closestBlock.type === "BlockStatement") {
            const lastItem = closestBlock.body.at(-1);
            if (isCallbackExpression(node2, lastItem)) {
              const parentType = closestBlock.parent.type;
              if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
                return;
              }
            }
            if (lastItem.type === "ReturnStatement") {
              if (isCallbackExpression(node2, closestBlock.body.at(-2))) {
                return;
              }
            }
          }
          if (findClosestParentOfType(node2, [
            "FunctionDeclaration",
            "FunctionExpression",
            "ArrowFunctionExpression"
          ])) {
            context.report({ node: node2, messageId: "missingReturn" });
          }
        }
      };
    }
  };
  return callbackReturn;
}
var camelcase;
var hasRequiredCamelcase;
function requireCamelcase() {
  if (hasRequiredCamelcase) return camelcase;
  hasRequiredCamelcase = 1;
  const astUtils2 = requireAstUtils();
  camelcase = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allow: [],
          ignoreDestructuring: false,
          ignoreGlobals: false,
          ignoreImports: false,
          properties: "always"
        }
      ],
      docs: {
        description: "Enforce camelcase naming convention",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/camelcase"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreDestructuring: {
              type: "boolean"
            },
            ignoreImports: {
              type: "boolean"
            },
            ignoreGlobals: {
              type: "boolean"
            },
            properties: {
              enum: ["always", "never"]
            },
            allow: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 0,
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        notCamelCase: "Identifier '{{name}}' is not in camel case.",
        notCamelCasePrivate: "#{{name}} is not in camel case."
      }
    },
    create(context) {
      const [
        {
          allow,
          ignoreDestructuring,
          ignoreGlobals,
          ignoreImports,
          properties: properties2
        }
      ] = context.options;
      const sourceCode2 = context.sourceCode;
      const reported = /* @__PURE__ */ new Set();
      function isUnderscored(name2) {
        const nameBody = name2.replace(/^_+|_+$/gu, "");
        return nameBody.includes("_") && nameBody !== nameBody.toUpperCase();
      }
      function isAllowed(name2) {
        return allow.some(
          (entry) => name2 === entry || name2.match(new RegExp(entry, "u"))
        );
      }
      function isGoodName(name2) {
        return !isUnderscored(name2) || isAllowed(name2);
      }
      function isAssignmentTarget(node2) {
        const parent = node2.parent;
        switch (parent.type) {
          case "AssignmentExpression":
          case "AssignmentPattern":
            return parent.left === node2;
          case "Property":
            return parent.parent.type === "ObjectPattern" && parent.value === node2;
          case "ArrayPattern":
          case "RestElement":
            return true;
          default:
            return false;
        }
      }
      function equalsToOriginalName(node2) {
        const localName = node2.name;
        const valueNode = node2.parent.type === "AssignmentPattern" ? node2.parent : node2;
        const parent = valueNode.parent;
        switch (parent.type) {
          case "Property":
            return (parent.parent.type === "ObjectPattern" || parent.parent.type === "ObjectExpression") && parent.value === valueNode && !parent.computed && parent.key.type === "Identifier" && parent.key.name === localName;
          case "ImportSpecifier":
            return parent.local === node2 && astUtils2.getModuleExportName(parent.imported) === localName;
          default:
            return false;
        }
      }
      function report(node2) {
        if (reported.has(node2.range[0])) {
          return;
        }
        reported.add(node2.range[0]);
        context.report({
          node: node2,
          messageId: node2.type === "PrivateIdentifier" ? "notCamelCasePrivate" : "notCamelCase",
          data: { name: node2.name }
        });
      }
      function reportReferenceId(node2) {
        if (node2.parent.type === "CallExpression" || node2.parent.type === "NewExpression") {
          return;
        }
        if (node2.parent.type === "AssignmentPattern" && node2.parent.right === node2) {
          return;
        }
        if (ignoreDestructuring && equalsToOriginalName(node2)) {
          return;
        }
        if (astUtils2.isImportAttributeKey(node2)) {
          return;
        }
        report(node2);
      }
      return {
        // Report camelcase of global variable references ------------------
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          if (!ignoreGlobals) {
            for (const variable of scope.variables) {
              if (variable.identifiers.length > 0 || isGoodName(variable.name)) {
                continue;
              }
              for (const reference of variable.references) {
                reportReferenceId(reference.identifier);
              }
            }
          }
          for (const reference of scope.through) {
            const id2 = reference.identifier;
            if (isGoodName(id2.name) || astUtils2.isImportAttributeKey(id2)) {
              continue;
            }
            reportReferenceId(id2);
          }
        },
        // Report camelcase of declared variables --------------------------
        [[
          "VariableDeclaration",
          "FunctionDeclaration",
          "FunctionExpression",
          "ArrowFunctionExpression",
          "ClassDeclaration",
          "ClassExpression",
          "CatchClause"
        ]](node2) {
          for (const variable of sourceCode2.getDeclaredVariables(node2)) {
            if (isGoodName(variable.name)) {
              continue;
            }
            const id2 = variable.identifiers[0];
            if (!(ignoreDestructuring && equalsToOriginalName(id2))) {
              report(id2);
            }
            for (const reference of variable.references) {
              if (reference.init) {
                continue;
              }
              reportReferenceId(reference.identifier);
            }
          }
        },
        // Report camelcase in properties ----------------------------------
        [[
          "ObjectExpression > Property[computed!=true] > Identifier.key",
          "MethodDefinition[computed!=true] > Identifier.key",
          "PropertyDefinition[computed!=true] > Identifier.key",
          "MethodDefinition > PrivateIdentifier.key",
          "PropertyDefinition > PrivateIdentifier.key"
        ]](node2) {
          if (properties2 === "never" || astUtils2.isImportAttributeKey(node2) || isGoodName(node2.name)) {
            return;
          }
          report(node2);
        },
        "MemberExpression[computed!=true] > Identifier.property"(node2) {
          if (properties2 === "never" || !isAssignmentTarget(node2.parent) || // ← ignore read-only references.
          isGoodName(node2.name)) {
            return;
          }
          report(node2);
        },
        // Report camelcase in import --------------------------------------
        ImportDeclaration(node2) {
          for (const variable of sourceCode2.getDeclaredVariables(node2)) {
            if (isGoodName(variable.name)) {
              continue;
            }
            const id2 = variable.identifiers[0];
            if (!(ignoreImports && equalsToOriginalName(id2))) {
              report(id2);
            }
            for (const reference of variable.references) {
              reportReferenceId(reference.identifier);
            }
          }
        },
        // Report camelcase in re-export -----------------------------------
        [[
          "ExportAllDeclaration > Identifier.exported",
          "ExportSpecifier > Identifier.exported"
        ]](node2) {
          if (isGoodName(node2.name)) {
            return;
          }
          report(node2);
        },
        // Report camelcase in labels --------------------------------------
        [[
          "LabeledStatement > Identifier.label",
          /*
           * For backward compatibility, report references as well.
           * It looks unnecessary because declarations are reported.
           */
          "BreakStatement > Identifier.label",
          "ContinueStatement > Identifier.label"
        ]](node2) {
          if (isGoodName(node2.name)) {
            return;
          }
          report(node2);
        }
      };
    }
  };
  return camelcase;
}
var capitalizedComments;
var hasRequiredCapitalizedComments;
function requireCapitalizedComments() {
  if (hasRequiredCapitalizedComments) return capitalizedComments;
  hasRequiredCapitalizedComments = 1;
  const astUtils2 = requireAstUtils();
  const DEFAULT_IGNORE_PATTERN = astUtils2.COMMENTS_IGNORE_PATTERN, WHITESPACE = /\s/gu, MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/u, LETTER_PATTERN = new RegExp("\\p{L}", "u");
  const SCHEMA_BODY = {
    type: "object",
    properties: {
      ignorePattern: {
        type: "string"
      },
      ignoreInlineComments: {
        type: "boolean"
      },
      ignoreConsecutiveComments: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  const DEFAULTS = {
    ignorePattern: "",
    ignoreInlineComments: false,
    ignoreConsecutiveComments: false
  };
  function getNormalizedOptions(rawOptions, which) {
    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
  }
  function getAllNormalizedOptions(rawOptions = {}) {
    return {
      Line: getNormalizedOptions(rawOptions, "line"),
      Block: getNormalizedOptions(rawOptions, "block")
    };
  }
  function createRegExpForIgnorePatterns(normalizedOptions) {
    Object.keys(normalizedOptions).forEach((key) => {
      const ignorePatternStr = normalizedOptions[key].ignorePattern;
      if (ignorePatternStr) {
        const regExp = RegExp(`^\\s*(?:${ignorePatternStr})`, "u");
        normalizedOptions[key].ignorePatternRegExp = regExp;
      }
    });
  }
  capitalizedComments = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce or disallow capitalization of the first letter of a comment",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/capitalized-comments"
      },
      fixable: "code",
      schema: [
        { enum: ["always", "never"] },
        {
          oneOf: [
            SCHEMA_BODY,
            {
              type: "object",
              properties: {
                line: SCHEMA_BODY,
                block: SCHEMA_BODY
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
        unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
      }
    },
    create(context) {
      const capitalize = context.options[0] || "always", normalizedOptions = getAllNormalizedOptions(context.options[1]), sourceCode2 = context.sourceCode;
      createRegExpForIgnorePatterns(normalizedOptions);
      function isInlineComment(comment2) {
        const previousToken = sourceCode2.getTokenBefore(comment2, {
          includeComments: true
        }), nextToken = sourceCode2.getTokenAfter(comment2, {
          includeComments: true
        });
        return Boolean(
          previousToken && nextToken && comment2.loc.start.line === previousToken.loc.end.line && comment2.loc.end.line === nextToken.loc.start.line
        );
      }
      function isConsecutiveComment(comment2) {
        const previousTokenOrComment = sourceCode2.getTokenBefore(comment2, {
          includeComments: true
        });
        return Boolean(
          previousTokenOrComment && ["Block", "Line"].includes(previousTokenOrComment.type)
        );
      }
      function isCommentValid(comment2, options) {
        if (DEFAULT_IGNORE_PATTERN.test(comment2.value)) {
          return true;
        }
        const commentWithoutAsterisks = comment2.value.replace(/\*/gu, "");
        if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
          return true;
        }
        if (options.ignoreInlineComments && isInlineComment(comment2)) {
          return true;
        }
        if (options.ignoreConsecutiveComments && isConsecutiveComment(comment2)) {
          return true;
        }
        if (MAYBE_URL.test(commentWithoutAsterisks)) {
          return true;
        }
        const commentWordCharsOnly = commentWithoutAsterisks.replace(
          WHITESPACE,
          ""
        );
        if (commentWordCharsOnly.length === 0) {
          return true;
        }
        const [firstWordChar] = commentWordCharsOnly;
        if (!LETTER_PATTERN.test(firstWordChar)) {
          return true;
        }
        const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(), isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();
        if (capitalize === "always" && isLowercase) {
          return false;
        }
        if (capitalize === "never" && isUppercase) {
          return false;
        }
        return true;
      }
      function processComment(comment2) {
        const options = normalizedOptions[comment2.type], commentValid = isCommentValid(comment2, options);
        if (!commentValid) {
          const messageId = capitalize === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
          context.report({
            node: null,
            // Intentionally using loc instead
            loc: comment2.loc,
            messageId,
            fix(fixer) {
              const match = comment2.value.match(LETTER_PATTERN);
              const char = match[0];
              const charIndex = comment2.range[0] + match.index + 2;
              return fixer.replaceTextRange(
                [charIndex, charIndex + char.length],
                capitalize === "always" ? char.toLocaleUpperCase() : char.toLocaleLowerCase()
              );
            }
          });
        }
      }
      return {
        Program() {
          const comments = sourceCode2.getAllComments();
          comments.filter((token) => token.type !== "Shebang").forEach(processComment);
        }
      };
    }
  };
  return capitalizedComments;
}
var classMethodsUseThis;
var hasRequiredClassMethodsUseThis;
function requireClassMethodsUseThis() {
  if (hasRequiredClassMethodsUseThis) return classMethodsUseThis;
  hasRequiredClassMethodsUseThis = 1;
  const astUtils2 = requireAstUtils();
  classMethodsUseThis = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      defaultOptions: [
        {
          enforceForClassFields: true,
          exceptMethods: [],
          ignoreOverrideMethods: false
        }
      ],
      docs: {
        description: "Enforce that class methods utilize `this`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/class-methods-use-this"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptMethods: {
              type: "array",
              items: {
                type: "string"
              }
            },
            enforceForClassFields: {
              type: "boolean"
            },
            ignoreOverrideMethods: {
              type: "boolean"
            },
            ignoreClassesWithImplements: {
              enum: ["all", "public-fields"]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingThis: "Expected 'this' to be used by class {{name}}."
      }
    },
    create(context) {
      const [options] = context.options;
      const {
        enforceForClassFields,
        ignoreOverrideMethods,
        ignoreClassesWithImplements
      } = options;
      const exceptMethods = new Set(options.exceptMethods);
      const stack = [];
      function pushContext() {
        stack.push(false);
      }
      function popContext() {
        return stack.pop();
      }
      function enterFunction() {
        pushContext();
      }
      function isInstanceMethod(node2) {
        switch (node2.type) {
          case "MethodDefinition":
            return !node2.static && node2.kind !== "constructor";
          case "AccessorProperty":
          case "PropertyDefinition":
            return !node2.static && enforceForClassFields;
          default:
            return false;
        }
      }
      function hasImplements(node2) {
        var _a2;
        const classNode = node2.parent.parent;
        return (classNode == null ? void 0 : classNode.type) === "ClassDeclaration" && ((_a2 = classNode.implements) == null ? void 0 : _a2.length) > 0;
      }
      function isIncludedInstanceMethod(node2) {
        if (isInstanceMethod(node2)) {
          if (node2.computed) {
            return true;
          }
          if (ignoreOverrideMethods && node2.override) {
            return false;
          }
          if (ignoreClassesWithImplements) {
            const implementsInterfaces = hasImplements(node2);
            if (implementsInterfaces) {
              if (ignoreClassesWithImplements === "all" || ignoreClassesWithImplements === "public-fields" && node2.key.type !== "PrivateIdentifier" && (!node2.accessibility || node2.accessibility === "public")) {
                return false;
              }
            }
          }
          const hashIfNeeded = node2.key.type === "PrivateIdentifier" ? "#" : "";
          const name2 = node2.key.type === "Literal" ? astUtils2.getStaticStringValue(node2.key) : node2.key.name || "";
          return !exceptMethods.has(hashIfNeeded + name2);
        }
        return false;
      }
      function exitFunction(node2) {
        const methodUsesThis = popContext();
        if (isIncludedInstanceMethod(node2.parent) && !methodUsesThis) {
          context.report({
            node: node2,
            loc: astUtils2.getFunctionHeadLoc(node2, context.sourceCode),
            messageId: "missingThis",
            data: {
              name: astUtils2.getFunctionNameWithKind(node2)
            }
          });
        }
      }
      function markThisUsed() {
        if (stack.length) {
          stack[stack.length - 1] = true;
        }
      }
      return {
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        /*
         * Class field value are implicit functions.
         */
        "AccessorProperty > *.key:exit": pushContext,
        "AccessorProperty:exit": popContext,
        "PropertyDefinition > *.key:exit": pushContext,
        "PropertyDefinition:exit": popContext,
        /*
         * Class static blocks are implicit functions. They aren't required to use `this`,
         * but we have to push context so that it captures any use of `this` in the static block
         * separately from enclosing contexts, because static blocks have their own `this` and it
         * shouldn't count as used `this` in enclosing contexts.
         */
        StaticBlock: pushContext,
        "StaticBlock:exit": popContext,
        ThisExpression: markThisUsed,
        Super: markThisUsed,
        ...enforceForClassFields && {
          "AccessorProperty > ArrowFunctionExpression.value": enterFunction,
          "AccessorProperty > ArrowFunctionExpression.value:exit": exitFunction,
          "PropertyDefinition > ArrowFunctionExpression.value": enterFunction,
          "PropertyDefinition > ArrowFunctionExpression.value:exit": exitFunction
        }
      };
    }
  };
  return classMethodsUseThis;
}
var commaDangle;
var hasRequiredCommaDangle;
function requireCommaDangle() {
  if (hasRequiredCommaDangle) return commaDangle;
  hasRequiredCommaDangle = 1;
  const astUtils2 = requireAstUtils();
  const DEFAULT_OPTIONS = Object.freeze({
    arrays: "never",
    objects: "never",
    imports: "never",
    exports: "never",
    functions: "never"
  });
  function isTrailingCommaAllowed(lastItem) {
    return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
  }
  function normalizeOptions(optionValue, ecmaVersion2) {
    if (typeof optionValue === "string") {
      return {
        arrays: optionValue,
        objects: optionValue,
        imports: optionValue,
        exports: optionValue,
        functions: ecmaVersion2 < 2017 ? "ignore" : optionValue
      };
    }
    if (typeof optionValue === "object" && optionValue !== null) {
      return {
        arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
        objects: optionValue.objects || DEFAULT_OPTIONS.objects,
        imports: optionValue.imports || DEFAULT_OPTIONS.imports,
        exports: optionValue.exports || DEFAULT_OPTIONS.exports,
        functions: optionValue.functions || DEFAULT_OPTIONS.functions
      };
    }
    return DEFAULT_OPTIONS;
  }
  commaDangle = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "comma-dangle",
              url: "https://eslint.style/rules/comma-dangle"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow trailing commas",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/comma-dangle"
      },
      fixable: "code",
      schema: {
        definitions: {
          value: {
            enum: [
              "always-multiline",
              "always",
              "never",
              "only-multiline"
            ]
          },
          valueWithIgnore: {
            enum: [
              "always-multiline",
              "always",
              "ignore",
              "never",
              "only-multiline"
            ]
          }
        },
        type: "array",
        items: [
          {
            oneOf: [
              {
                $ref: "#/definitions/value"
              },
              {
                type: "object",
                properties: {
                  arrays: {
                    $ref: "#/definitions/valueWithIgnore"
                  },
                  objects: {
                    $ref: "#/definitions/valueWithIgnore"
                  },
                  imports: {
                    $ref: "#/definitions/valueWithIgnore"
                  },
                  exports: {
                    $ref: "#/definitions/valueWithIgnore"
                  },
                  functions: {
                    $ref: "#/definitions/valueWithIgnore"
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        additionalItems: false
      },
      messages: {
        unexpected: "Unexpected trailing comma.",
        missing: "Missing trailing comma."
      }
    },
    create(context) {
      const options = normalizeOptions(
        context.options[0],
        context.languageOptions.ecmaVersion
      );
      const sourceCode2 = context.sourceCode;
      function getLastItem(node2) {
        function last(array) {
          return array.at(-1);
        }
        switch (node2.type) {
          case "ObjectExpression":
          case "ObjectPattern":
            return last(node2.properties);
          case "ArrayExpression":
          case "ArrayPattern":
            return last(node2.elements);
          case "ImportDeclaration":
          case "ExportNamedDeclaration":
            return last(node2.specifiers);
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
            return last(node2.params);
          case "CallExpression":
          case "NewExpression":
            return last(node2.arguments);
          default:
            return null;
        }
      }
      function getTrailingToken(node2, lastItem) {
        switch (node2.type) {
          case "ObjectExpression":
          case "ArrayExpression":
          case "CallExpression":
          case "NewExpression":
            return sourceCode2.getLastToken(node2, 1);
          default: {
            const nextToken = sourceCode2.getTokenAfter(lastItem);
            if (astUtils2.isCommaToken(nextToken)) {
              return nextToken;
            }
            return sourceCode2.getLastToken(lastItem);
          }
        }
      }
      function isMultiline(node2) {
        const lastItem = getLastItem(node2);
        if (!lastItem) {
          return false;
        }
        const penultimateToken = getTrailingToken(node2, lastItem);
        const lastToken = sourceCode2.getTokenAfter(penultimateToken);
        return lastToken.loc.end.line !== penultimateToken.loc.end.line;
      }
      function forbidTrailingComma(node2) {
        const lastItem = getLastItem(node2);
        if (!lastItem || node2.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
          return;
        }
        const trailingToken = getTrailingToken(node2, lastItem);
        if (astUtils2.isCommaToken(trailingToken)) {
          context.report({
            node: lastItem,
            loc: trailingToken.loc,
            messageId: "unexpected",
            *fix(fixer) {
              yield fixer.remove(trailingToken);
              yield fixer.insertTextBefore(
                sourceCode2.getTokenBefore(trailingToken),
                ""
              );
              yield fixer.insertTextAfter(
                sourceCode2.getTokenAfter(trailingToken),
                ""
              );
            }
          });
        }
      }
      function forceTrailingComma(node2) {
        const lastItem = getLastItem(node2);
        if (!lastItem || node2.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
          return;
        }
        if (!isTrailingCommaAllowed(lastItem)) {
          forbidTrailingComma(node2);
          return;
        }
        const trailingToken = getTrailingToken(node2, lastItem);
        if (trailingToken.value !== ",") {
          context.report({
            node: lastItem,
            loc: {
              start: trailingToken.loc.end,
              end: astUtils2.getNextLocation(
                sourceCode2,
                trailingToken.loc.end
              )
            },
            messageId: "missing",
            *fix(fixer) {
              yield fixer.insertTextAfter(trailingToken, ",");
              yield fixer.insertTextBefore(trailingToken, "");
              yield fixer.insertTextAfter(
                sourceCode2.getTokenAfter(trailingToken),
                ""
              );
            }
          });
        }
      }
      function forceTrailingCommaIfMultiline(node2) {
        if (isMultiline(node2)) {
          forceTrailingComma(node2);
        } else {
          forbidTrailingComma(node2);
        }
      }
      function allowTrailingCommaIfMultiline(node2) {
        if (!isMultiline(node2)) {
          forbidTrailingComma(node2);
        }
      }
      const predicate = {
        always: forceTrailingComma,
        "always-multiline": forceTrailingCommaIfMultiline,
        "only-multiline": allowTrailingCommaIfMultiline,
        never: forbidTrailingComma,
        ignore() {
        }
      };
      return {
        ObjectExpression: predicate[options.objects],
        ObjectPattern: predicate[options.objects],
        ArrayExpression: predicate[options.arrays],
        ArrayPattern: predicate[options.arrays],
        ImportDeclaration: predicate[options.imports],
        ExportNamedDeclaration: predicate[options.exports],
        FunctionDeclaration: predicate[options.functions],
        FunctionExpression: predicate[options.functions],
        ArrowFunctionExpression: predicate[options.functions],
        CallExpression: predicate[options.functions],
        NewExpression: predicate[options.functions]
      };
    }
  };
  return commaDangle;
}
var commaSpacing;
var hasRequiredCommaSpacing;
function requireCommaSpacing() {
  if (hasRequiredCommaSpacing) return commaSpacing;
  hasRequiredCommaSpacing = 1;
  const astUtils2 = requireAstUtils();
  commaSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "comma-spacing",
              url: "https://eslint.style/rules/comma-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after commas",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/comma-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: false
            },
            after: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missing: "A space is required {{loc}} ','.",
        unexpected: "There should be no space {{loc}} ','."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const tokensAndComments = sourceCode2.tokensAndComments;
      const options = {
        before: context.options[0] ? context.options[0].before : false,
        after: context.options[0] ? context.options[0].after : true
      };
      const commaTokensToIgnore = [];
      function report(node2, loc, otherNode) {
        context.report({
          node: node2,
          fix(fixer) {
            if (options[loc]) {
              if (loc === "before") {
                return fixer.insertTextBefore(node2, " ");
              }
              return fixer.insertTextAfter(node2, " ");
            }
            let start, end;
            const newText = "";
            if (loc === "before") {
              start = otherNode.range[1];
              end = node2.range[0];
            } else {
              start = node2.range[1];
              end = otherNode.range[0];
            }
            return fixer.replaceTextRange([start, end], newText);
          },
          messageId: options[loc] ? "missing" : "unexpected",
          data: {
            loc
          }
        });
      }
      function addNullElementsToIgnoreList(node2) {
        let previousToken = sourceCode2.getFirstToken(node2);
        node2.elements.forEach((element) => {
          let token;
          if (element === null) {
            token = sourceCode2.getTokenAfter(previousToken);
            if (astUtils2.isCommaToken(token)) {
              commaTokensToIgnore.push(token);
            }
          } else {
            token = sourceCode2.getTokenAfter(element);
          }
          previousToken = token;
        });
      }
      return {
        "Program:exit"() {
          tokensAndComments.forEach((token, i2) => {
            if (!astUtils2.isCommaToken(token)) {
              return;
            }
            const previousToken = tokensAndComments[i2 - 1];
            const nextToken = tokensAndComments[i2 + 1];
            if (previousToken && !astUtils2.isCommaToken(previousToken) && // ignore spacing between two commas
            /*
             * `commaTokensToIgnore` are ending commas of `null` elements (array holes/elisions).
             * In addition to spacing between two commas, this can also ignore:
             *
             *   - Spacing after `[` (controlled by array-bracket-spacing)
             *       Example: [ , ]
             *                 ^
             *   - Spacing after a comment (for backwards compatibility, this was possibly unintentional)
             *       Example: [a, /* * / ,]
             *                          ^
             */
            !commaTokensToIgnore.includes(token) && astUtils2.isTokenOnSameLine(previousToken, token) && options.before !== sourceCode2.isSpaceBetweenTokens(
              previousToken,
              token
            )) {
              report(token, "before", previousToken);
            }
            if (nextToken && !astUtils2.isCommaToken(nextToken) && // ignore spacing between two commas
            !astUtils2.isClosingParenToken(nextToken) && // controlled by space-in-parens
            !astUtils2.isClosingBracketToken(nextToken) && // controlled by array-bracket-spacing
            !astUtils2.isClosingBraceToken(nextToken) && // controlled by object-curly-spacing
            !(!options.after && nextToken.type === "Line") && // special case, allow space before line comment
            astUtils2.isTokenOnSameLine(token, nextToken) && options.after !== sourceCode2.isSpaceBetweenTokens(token, nextToken)) {
              report(token, "after", nextToken);
            }
          });
        },
        ArrayExpression: addNullElementsToIgnoreList,
        ArrayPattern: addNullElementsToIgnoreList
      };
    }
  };
  return commaSpacing;
}
var commaStyle;
var hasRequiredCommaStyle;
function requireCommaStyle() {
  if (hasRequiredCommaStyle) return commaStyle;
  hasRequiredCommaStyle = 1;
  const astUtils2 = requireAstUtils();
  commaStyle = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "comma-style",
              url: "https://eslint.style/rules/comma-style"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent comma style",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/comma-style"
      },
      fixable: "code",
      schema: [
        {
          enum: ["first", "last"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "object",
              additionalProperties: {
                type: "boolean"
              }
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
        expectedCommaFirst: "',' should be placed first.",
        expectedCommaLast: "',' should be placed last."
      }
    },
    create(context) {
      const style = context.options[0] || "last", sourceCode2 = context.sourceCode;
      const exceptions = {
        ArrayPattern: true,
        ArrowFunctionExpression: true,
        CallExpression: true,
        FunctionDeclaration: true,
        FunctionExpression: true,
        ImportDeclaration: true,
        ObjectPattern: true,
        NewExpression: true
      };
      if (context.options.length === 2 && Object.hasOwn(context.options[1], "exceptions")) {
        const keys2 = Object.keys(context.options[1].exceptions);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          exceptions[keys2[i2]] = context.options[1].exceptions[keys2[i2]];
        }
      }
      function getReplacedText(styleType, text) {
        switch (styleType) {
          case "between":
            return `,${text.replace(astUtils2.LINEBREAK_MATCHER, "")}`;
          case "first":
            return `${text},`;
          case "last":
            return `,${text}`;
          default:
            return "";
        }
      }
      function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
        const text = sourceCode2.text.slice(
          previousItemToken.range[1],
          commaToken.range[0]
        ) + sourceCode2.text.slice(
          commaToken.range[1],
          currentItemToken.range[0]
        );
        const range = [
          previousItemToken.range[1],
          currentItemToken.range[0]
        ];
        return function(fixer) {
          return fixer.replaceTextRange(
            range,
            getReplacedText(styleType, text)
          );
        };
      }
      function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
        if (astUtils2.isTokenOnSameLine(commaToken, currentItemToken) && astUtils2.isTokenOnSameLine(previousItemToken, commaToken)) ;
        else if (!astUtils2.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils2.isTokenOnSameLine(previousItemToken, commaToken)) {
          const comment2 = sourceCode2.getCommentsAfter(commaToken)[0];
          const styleType = comment2 && comment2.type === "Block" && astUtils2.isTokenOnSameLine(commaToken, comment2) ? style : "between";
          context.report({
            node: reportItem,
            loc: commaToken.loc,
            messageId: "unexpectedLineBeforeAndAfterComma",
            fix: getFixerFunction(
              styleType,
              previousItemToken,
              commaToken,
              currentItemToken
            )
          });
        } else if (style === "first" && !astUtils2.isTokenOnSameLine(commaToken, currentItemToken)) {
          context.report({
            node: reportItem,
            loc: commaToken.loc,
            messageId: "expectedCommaFirst",
            fix: getFixerFunction(
              style,
              previousItemToken,
              commaToken,
              currentItemToken
            )
          });
        } else if (style === "last" && astUtils2.isTokenOnSameLine(commaToken, currentItemToken)) {
          context.report({
            node: reportItem,
            loc: commaToken.loc,
            messageId: "expectedCommaLast",
            fix: getFixerFunction(
              style,
              previousItemToken,
              commaToken,
              currentItemToken
            )
          });
        }
      }
      function validateComma(node2, property) {
        const items2 = node2[property], arrayLiteral = node2.type === "ArrayExpression" || node2.type === "ArrayPattern";
        if (items2.length > 1 || arrayLiteral) {
          let previousItemToken = sourceCode2.getFirstToken(node2);
          items2.forEach((item) => {
            const commaToken = item ? sourceCode2.getTokenBefore(item) : previousItemToken, currentItemToken = item ? sourceCode2.getFirstToken(item) : sourceCode2.getTokenAfter(commaToken), reportItem = item || currentItemToken;
            if (astUtils2.isCommaToken(commaToken)) {
              validateCommaItemSpacing(
                previousItemToken,
                commaToken,
                currentItemToken,
                reportItem
              );
            }
            if (item) {
              const tokenAfterItem = sourceCode2.getTokenAfter(
                item,
                astUtils2.isNotClosingParenToken
              );
              previousItemToken = tokenAfterItem ? sourceCode2.getTokenBefore(tokenAfterItem) : sourceCode2.ast.tokens.at(-1);
            } else {
              previousItemToken = currentItemToken;
            }
          });
          if (arrayLiteral) {
            const lastToken = sourceCode2.getLastToken(node2), nextToLastToken = sourceCode2.getTokenBefore(lastToken);
            if (astUtils2.isCommaToken(nextToLastToken)) {
              validateCommaItemSpacing(
                sourceCode2.getTokenBefore(nextToLastToken),
                nextToLastToken,
                lastToken,
                lastToken
              );
            }
          }
        }
      }
      const nodes = {};
      if (!exceptions.VariableDeclaration) {
        nodes.VariableDeclaration = function(node2) {
          validateComma(node2, "declarations");
        };
      }
      if (!exceptions.ObjectExpression) {
        nodes.ObjectExpression = function(node2) {
          validateComma(node2, "properties");
        };
      }
      if (!exceptions.ObjectPattern) {
        nodes.ObjectPattern = function(node2) {
          validateComma(node2, "properties");
        };
      }
      if (!exceptions.ArrayExpression) {
        nodes.ArrayExpression = function(node2) {
          validateComma(node2, "elements");
        };
      }
      if (!exceptions.ArrayPattern) {
        nodes.ArrayPattern = function(node2) {
          validateComma(node2, "elements");
        };
      }
      if (!exceptions.FunctionDeclaration) {
        nodes.FunctionDeclaration = function(node2) {
          validateComma(node2, "params");
        };
      }
      if (!exceptions.FunctionExpression) {
        nodes.FunctionExpression = function(node2) {
          validateComma(node2, "params");
        };
      }
      if (!exceptions.ArrowFunctionExpression) {
        nodes.ArrowFunctionExpression = function(node2) {
          validateComma(node2, "params");
        };
      }
      if (!exceptions.CallExpression) {
        nodes.CallExpression = function(node2) {
          validateComma(node2, "arguments");
        };
      }
      if (!exceptions.ImportDeclaration) {
        nodes.ImportDeclaration = function(node2) {
          validateComma(node2, "specifiers");
        };
      }
      if (!exceptions.NewExpression) {
        nodes.NewExpression = function(node2) {
          validateComma(node2, "arguments");
        };
      }
      return nodes;
    }
  };
  return commaStyle;
}
var stringUtils;
var hasRequiredStringUtils;
function requireStringUtils() {
  if (hasRequiredStringUtils) return stringUtils;
  hasRequiredStringUtils = 1;
  const ASCII_REGEX = /^[\u0000-\u007f]*$/u;
  let segmenter2;
  function upperCaseFirst(string2) {
    if (string2.length <= 1) {
      return string2.toUpperCase();
    }
    return string2[0].toUpperCase() + string2.slice(1);
  }
  function getGraphemeCount(value) {
    if (ASCII_REGEX.test(value)) {
      return value.length;
    }
    segmenter2 ?? (segmenter2 = new Intl.Segmenter("en-US"));
    let graphemeCount = 0;
    for (const unused of segmenter2.segment(value)) {
      graphemeCount++;
    }
    return graphemeCount;
  }
  stringUtils = {
    upperCaseFirst,
    getGraphemeCount
  };
  return stringUtils;
}
var complexity;
var hasRequiredComplexity;
function requireComplexity() {
  if (hasRequiredComplexity) return complexity;
  hasRequiredComplexity = 1;
  const astUtils2 = requireAstUtils();
  const { upperCaseFirst } = requireStringUtils();
  const THRESHOLD_DEFAULT = 20;
  complexity = {
    meta: {
      type: "suggestion",
      defaultOptions: [THRESHOLD_DEFAULT],
      docs: {
        description: "Enforce a maximum cyclomatic complexity allowed in a program",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/complexity"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                },
                variant: {
                  enum: ["classic", "modified"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const option = context.options[0];
      let threshold = THRESHOLD_DEFAULT;
      let VARIANT = "classic";
      if (typeof option === "object") {
        if (Object.hasOwn(option, "maximum") || Object.hasOwn(option, "max")) {
          threshold = option.maximum || option.max;
        }
        if (Object.hasOwn(option, "variant")) {
          VARIANT = option.variant;
        }
      } else if (typeof option === "number") {
        threshold = option;
      }
      const IS_MODIFIED_COMPLEXITY = VARIANT === "modified";
      const complexities = [];
      function increaseComplexity() {
        complexities[complexities.length - 1]++;
      }
      return {
        onCodePathStart() {
          complexities.push(1);
        },
        // Each branching in the code adds 1 to the complexity
        CatchClause: increaseComplexity,
        ConditionalExpression: increaseComplexity,
        LogicalExpression: increaseComplexity,
        ForStatement: increaseComplexity,
        ForInStatement: increaseComplexity,
        ForOfStatement: increaseComplexity,
        IfStatement: increaseComplexity,
        WhileStatement: increaseComplexity,
        DoWhileStatement: increaseComplexity,
        AssignmentPattern: increaseComplexity,
        // Avoid `default`
        "SwitchCase[test]": () => IS_MODIFIED_COMPLEXITY || increaseComplexity(),
        SwitchStatement: () => IS_MODIFIED_COMPLEXITY && increaseComplexity(),
        // Logical assignment operators have short-circuiting behavior
        AssignmentExpression(node2) {
          if (astUtils2.isLogicalAssignmentOperator(node2.operator)) {
            increaseComplexity();
          }
        },
        MemberExpression(node2) {
          if (node2.optional === true) {
            increaseComplexity();
          }
        },
        CallExpression(node2) {
          if (node2.optional === true) {
            increaseComplexity();
          }
        },
        onCodePathEnd(codePath2, node2) {
          const complexity2 = complexities.pop();
          if (codePath2.origin !== "function" && codePath2.origin !== "class-field-initializer" && codePath2.origin !== "class-static-block") {
            return;
          }
          if (complexity2 > threshold) {
            let name2;
            let loc = node2.loc;
            if (codePath2.origin === "class-field-initializer") {
              name2 = "class field initializer";
            } else if (codePath2.origin === "class-static-block") {
              name2 = "class static block";
              loc = sourceCode2.getFirstToken(node2).loc;
            } else {
              name2 = astUtils2.getFunctionNameWithKind(node2);
              loc = astUtils2.getFunctionHeadLoc(node2, sourceCode2);
            }
            context.report({
              node: node2,
              loc,
              messageId: "complex",
              data: {
                name: upperCaseFirst(name2),
                complexity: complexity2,
                max: threshold
              }
            });
          }
        }
      };
    }
  };
  return complexity;
}
var computedPropertySpacing;
var hasRequiredComputedPropertySpacing;
function requireComputedPropertySpacing() {
  if (hasRequiredComputedPropertySpacing) return computedPropertySpacing;
  hasRequiredComputedPropertySpacing = 1;
  const astUtils2 = requireAstUtils();
  computedPropertySpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "computed-property-spacing",
              url: "https://eslint.style/rules/computed-property-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside computed property brackets",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/computed-property-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            enforceForClassMembers: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const propertyNameMustBeSpaced = context.options[0] === "always";
      const enforceForClassMembers = !context.options[1] || context.options[1].enforceForClassMembers;
      function reportNoBeginningSpace(node2, token, tokenAfter) {
        context.report({
          node: node2,
          loc: { start: token.loc.end, end: tokenAfter.loc.start },
          messageId: "unexpectedSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([
              token.range[1],
              tokenAfter.range[0]
            ]);
          }
        });
      }
      function reportNoEndingSpace(node2, token, tokenBefore) {
        context.report({
          node: node2,
          loc: { start: tokenBefore.loc.end, end: token.loc.start },
          messageId: "unexpectedSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([
              tokenBefore.range[1],
              token.range[0]
            ]);
          }
        });
      }
      function reportRequiredBeginningSpace(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "missingSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
      function reportRequiredEndingSpace(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "missingSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
      function checkSpacing(propertyName2) {
        return function(node2) {
          if (!node2.computed) {
            return;
          }
          const property = node2[propertyName2];
          const before = sourceCode2.getTokenBefore(
            property,
            astUtils2.isOpeningBracketToken
          ), first = sourceCode2.getTokenAfter(before, {
            includeComments: true
          }), after = sourceCode2.getTokenAfter(
            property,
            astUtils2.isClosingBracketToken
          ), last = sourceCode2.getTokenBefore(after, {
            includeComments: true
          });
          if (astUtils2.isTokenOnSameLine(before, first)) {
            if (propertyNameMustBeSpaced) {
              if (!sourceCode2.isSpaceBetweenTokens(before, first) && astUtils2.isTokenOnSameLine(before, first)) {
                reportRequiredBeginningSpace(node2, before);
              }
            } else {
              if (sourceCode2.isSpaceBetweenTokens(before, first)) {
                reportNoBeginningSpace(node2, before, first);
              }
            }
          }
          if (astUtils2.isTokenOnSameLine(last, after)) {
            if (propertyNameMustBeSpaced) {
              if (!sourceCode2.isSpaceBetweenTokens(last, after) && astUtils2.isTokenOnSameLine(last, after)) {
                reportRequiredEndingSpace(node2, after);
              }
            } else {
              if (sourceCode2.isSpaceBetweenTokens(last, after)) {
                reportNoEndingSpace(node2, after, last);
              }
            }
          }
        };
      }
      const listeners = {
        Property: checkSpacing("key"),
        MemberExpression: checkSpacing("property")
      };
      if (enforceForClassMembers) {
        listeners.MethodDefinition = listeners.PropertyDefinition = listeners.Property;
      }
      return listeners;
    }
  };
  return computedPropertySpacing;
}
var consistentReturn;
var hasRequiredConsistentReturn;
function requireConsistentReturn() {
  if (hasRequiredConsistentReturn) return consistentReturn;
  hasRequiredConsistentReturn = 1;
  const astUtils2 = requireAstUtils();
  const { upperCaseFirst } = requireStringUtils();
  function areAllSegmentsUnreachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return false;
      }
    }
    return true;
  }
  function isClassConstructor(node2) {
    return node2.type === "FunctionExpression" && node2.parent && node2.parent.type === "MethodDefinition" && node2.parent.kind === "constructor";
  }
  consistentReturn = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `return` statements to either always or never specify values",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/consistent-return"
      },
      schema: [
        {
          type: "object",
          properties: {
            treatUndefinedAsUnspecified: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      defaultOptions: [{ treatUndefinedAsUnspecified: false }],
      messages: {
        missingReturn: "Expected to return a value at the end of {{name}}.",
        missingReturnValue: "{{name}} expected a return value.",
        unexpectedReturnValue: "{{name}} expected no return value."
      }
    },
    create(context) {
      const [{ treatUndefinedAsUnspecified }] = context.options;
      let funcInfo = null;
      function checkLastSegment(node2) {
        let loc, name2;
        if (!funcInfo.hasReturnValue || areAllSegmentsUnreachable(funcInfo.currentSegments) || astUtils2.isES5Constructor(node2) || isClassConstructor(node2)) {
          return;
        }
        if (node2.type === "Program") {
          loc = { line: 1, column: 0 };
          name2 = "program";
        } else if (node2.type === "ArrowFunctionExpression") {
          loc = context.sourceCode.getTokenBefore(
            node2.body,
            astUtils2.isArrowToken
          ).loc;
        } else if (node2.parent.type === "MethodDefinition" || node2.parent.type === "Property" && node2.parent.method) {
          loc = node2.parent.key.loc;
        } else {
          loc = (node2.id || context.sourceCode.getFirstToken(node2)).loc;
        }
        if (!name2) {
          name2 = astUtils2.getFunctionNameWithKind(node2);
        }
        context.report({
          node: node2,
          loc,
          messageId: "missingReturn",
          data: { name: name2 }
        });
      }
      return {
        // Initializes/Disposes state of each code path.
        onCodePathStart(codePath2, node2) {
          funcInfo = {
            upper: funcInfo,
            codePath: codePath2,
            hasReturn: false,
            hasReturnValue: false,
            messageId: "",
            node: node2,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        onUnreachableCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        onCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        // Reports a given return statement if it's inconsistent.
        ReturnStatement(node2) {
          const argument = node2.argument;
          let hasReturnValue = Boolean(argument);
          if (treatUndefinedAsUnspecified && hasReturnValue) {
            hasReturnValue = !astUtils2.isSpecificId(argument, "undefined") && argument.operator !== "void";
          }
          if (!funcInfo.hasReturn) {
            funcInfo.hasReturn = true;
            funcInfo.hasReturnValue = hasReturnValue;
            funcInfo.messageId = hasReturnValue ? "missingReturnValue" : "unexpectedReturnValue";
            funcInfo.data = {
              name: funcInfo.node.type === "Program" ? "Program" : upperCaseFirst(
                astUtils2.getFunctionNameWithKind(
                  funcInfo.node
                )
              )
            };
          } else if (funcInfo.hasReturnValue !== hasReturnValue) {
            context.report({
              node: node2,
              messageId: funcInfo.messageId,
              data: funcInfo.data
            });
          }
        },
        // Reports a given program/function if the implicit returning is not consistent.
        "Program:exit": checkLastSegment,
        "FunctionDeclaration:exit": checkLastSegment,
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
      };
    }
  };
  return consistentReturn;
}
var consistentThis;
var hasRequiredConsistentThis;
function requireConsistentThis() {
  if (hasRequiredConsistentThis) return consistentThis;
  hasRequiredConsistentThis = 1;
  consistentThis = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce consistent naming when capturing the current execution context",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/consistent-this"
      },
      schema: {
        type: "array",
        items: {
          type: "string",
          minLength: 1
        },
        uniqueItems: true
      },
      defaultOptions: ["that"],
      messages: {
        aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
        unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
      }
    },
    create(context) {
      const aliases = context.options;
      const sourceCode2 = context.sourceCode;
      function reportBadAssignment(node2, name2) {
        context.report({
          node: node2,
          messageId: "aliasNotAssignedToThis",
          data: { name: name2 }
        });
      }
      function checkAssignment(node2, name2, value) {
        const isThis = value.type === "ThisExpression";
        if (aliases.includes(name2)) {
          if (!isThis || node2.operator && node2.operator !== "=") {
            reportBadAssignment(node2, name2);
          }
        } else if (isThis) {
          context.report({
            node: node2,
            messageId: "unexpectedAlias",
            data: { name: name2 }
          });
        }
      }
      function checkWasAssigned(alias, scope) {
        const variable = scope.set.get(alias);
        if (!variable) {
          return;
        }
        if (variable.defs.some(
          (def) => def.node.type === "VariableDeclarator" && def.node.init !== null
        )) {
          return;
        }
        if (!variable.references.some((reference) => {
          const write = reference.writeExpr;
          return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
        })) {
          variable.defs.map((def) => def.node).forEach((node2) => {
            reportBadAssignment(node2, alias);
          });
        }
      }
      function ensureWasAssigned(node2) {
        const scope = sourceCode2.getScope(node2);
        const extraScope = node2.type === "Program" && node2.sourceType === "module" ? scope.childScopes[0] : null;
        aliases.forEach((alias) => {
          checkWasAssigned(alias, scope);
          if (extraScope) {
            checkWasAssigned(alias, extraScope);
          }
        });
      }
      return {
        "Program:exit": ensureWasAssigned,
        "FunctionExpression:exit": ensureWasAssigned,
        "FunctionDeclaration:exit": ensureWasAssigned,
        VariableDeclarator(node2) {
          const id2 = node2.id;
          const isDestructuring = id2.type === "ArrayPattern" || id2.type === "ObjectPattern";
          if (node2.init !== null && !isDestructuring) {
            checkAssignment(node2, id2.name, node2.init);
          }
        },
        AssignmentExpression(node2) {
          if (node2.left.type === "Identifier") {
            checkAssignment(node2, node2.left.name, node2.right);
          }
        }
      };
    }
  };
  return consistentThis;
}
var constructorSuper;
var hasRequiredConstructorSuper;
function requireConstructorSuper() {
  if (hasRequiredConstructorSuper) return constructorSuper;
  hasRequiredConstructorSuper = 1;
  function isConstructorFunction(node2) {
    return node2.type === "FunctionExpression" && node2.parent.type === "MethodDefinition" && node2.parent.kind === "constructor";
  }
  function isPossibleConstructor(node2) {
    if (!node2) {
      return false;
    }
    switch (node2.type) {
      case "ClassExpression":
      case "FunctionExpression":
      case "ThisExpression":
      case "MemberExpression":
      case "CallExpression":
      case "NewExpression":
      case "ChainExpression":
      case "YieldExpression":
      case "TaggedTemplateExpression":
      case "MetaProperty":
        return true;
      case "Identifier":
        return node2.name !== "undefined";
      case "AssignmentExpression":
        if (["=", "&&="].includes(node2.operator)) {
          return isPossibleConstructor(node2.right);
        }
        if (["||=", "??="].includes(node2.operator)) {
          return isPossibleConstructor(node2.left) || isPossibleConstructor(node2.right);
        }
        return false;
      case "LogicalExpression":
        if (node2.operator === "&&") {
          return isPossibleConstructor(node2.right);
        }
        return isPossibleConstructor(node2.left) || isPossibleConstructor(node2.right);
      case "ConditionalExpression":
        return isPossibleConstructor(node2.alternate) || isPossibleConstructor(node2.consequent);
      case "SequenceExpression": {
        const lastExpression = node2.expressions.at(-1);
        return isPossibleConstructor(lastExpression);
      }
      default:
        return false;
    }
  }
  class SegmentInfo {
    constructor() {
      /**
       * Indicates if super() is called in all code paths.
       * @type {boolean}
       */
      __publicField(this, "calledInEveryPaths", false);
      /**
       * Indicates if super() is called in any code paths.
       * @type {boolean}
       */
      __publicField(this, "calledInSomePaths", false);
      /**
       * The nodes which have been validated and don't need to be reconsidered.
       * @type {ASTNode[]}
       */
      __publicField(this, "validNodes", []);
    }
  }
  constructorSuper = {
    meta: {
      type: "problem",
      docs: {
        description: "Require `super()` calls in constructors",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/constructor-super"
      },
      schema: [],
      messages: {
        missingSome: "Lacked a call of 'super()' in some code paths.",
        missingAll: "Expected to call 'super()'.",
        duplicate: "Unexpected duplicate 'super()'.",
        badSuper: "Unexpected 'super()' because 'super' is not a constructor."
      }
    },
    create(context) {
      let funcInfo = null;
      const segInfoMap = /* @__PURE__ */ Object.create(null);
      function isCalledInSomePath(segment) {
        return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
      }
      function hasSegmentBeenSeen(segment) {
        return !!segInfoMap[segment.id];
      }
      function isCalledInEveryPath(segment) {
        return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
      }
      return {
        /**
         * Stacks a constructor information.
         * @param {CodePath} codePath A code path which was started.
         * @param {ASTNode} node The current node.
         * @returns {void}
         */
        onCodePathStart(codePath2, node2) {
          if (isConstructorFunction(node2)) {
            const classNode = node2.parent.parent.parent;
            const superClass = classNode.superClass;
            funcInfo = {
              upper: funcInfo,
              isConstructor: true,
              hasExtends: Boolean(superClass),
              superIsConstructor: isPossibleConstructor(superClass),
              codePath: codePath2,
              currentSegments: /* @__PURE__ */ new Set()
            };
          } else {
            funcInfo = {
              upper: funcInfo,
              isConstructor: false,
              hasExtends: false,
              superIsConstructor: false,
              codePath: codePath2,
              currentSegments: /* @__PURE__ */ new Set()
            };
          }
        },
        /**
         * Pops a constructor information.
         * And reports if `super()` lacked.
         * @param {CodePath} codePath A code path which was ended.
         * @param {ASTNode} node The current node.
         * @returns {void}
         */
        onCodePathEnd(codePath2, node2) {
          const hasExtends = funcInfo.hasExtends;
          funcInfo = funcInfo.upper;
          if (!hasExtends) {
            return;
          }
          const returnedSegments = codePath2.returnedSegments;
          const calledInEveryPaths = returnedSegments.every(isCalledInEveryPath);
          const calledInSomePaths = returnedSegments.some(isCalledInSomePath);
          if (!calledInEveryPaths) {
            context.report({
              messageId: calledInSomePaths ? "missingSome" : "missingAll",
              node: node2.parent
            });
          }
        },
        /**
         * Initialize information of a given code path segment.
         * @param {CodePathSegment} segment A code path segment to initialize.
         * @param {CodePathSegment} node Node that starts the segment.
         * @returns {void}
         */
        onCodePathSegmentStart(segment, node2) {
          funcInfo.currentSegments.add(segment);
          if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          const info = segInfoMap[segment.id] = new SegmentInfo();
          const seenPrevSegments = segment.prevSegments.filter(hasSegmentBeenSeen);
          if (seenPrevSegments.length > 0) {
            info.calledInSomePaths = seenPrevSegments.some(isCalledInSomePath);
            info.calledInEveryPaths = seenPrevSegments.every(isCalledInEveryPath);
          }
          if (node2.parent && node2.parent.type === "ForStatement" && node2.parent.update === node2) {
            info.calledInEveryPaths = true;
          }
        },
        onUnreachableCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        onCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        /**
         * Update information of the code path segment when a code path was
         * looped.
         * @param {CodePathSegment} fromSegment The code path segment of the
         *      end of a loop.
         * @param {CodePathSegment} toSegment A code path segment of the head
         *      of a loop.
         * @returns {void}
         */
        onCodePathSegmentLoop(fromSegment, toSegment) {
          if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          funcInfo.codePath.traverseSegments(
            { first: toSegment, last: fromSegment },
            (segment, controller) => {
              const info = segInfoMap[segment.id];
              if (!info) {
                controller.skip();
                return;
              }
              const seenPrevSegments = segment.prevSegments.filter(hasSegmentBeenSeen);
              const calledInSomePreviousPaths = seenPrevSegments.some(isCalledInSomePath);
              const calledInEveryPreviousPaths = seenPrevSegments.every(isCalledInEveryPath);
              info.calledInSomePaths || (info.calledInSomePaths = calledInSomePreviousPaths);
              info.calledInEveryPaths || (info.calledInEveryPaths = calledInEveryPreviousPaths);
              if (calledInSomePreviousPaths) {
                const nodes = info.validNodes;
                info.validNodes = [];
                for (let i2 = 0; i2 < nodes.length; ++i2) {
                  const node2 = nodes[i2];
                  context.report({
                    messageId: "duplicate",
                    node: node2
                  });
                }
              }
            }
          );
        },
        /**
         * Checks for a call of `super()`.
         * @param {ASTNode} node A CallExpression node to check.
         * @returns {void}
         */
        "CallExpression:exit"(node2) {
          if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          if (node2.callee.type !== "Super") {
            return;
          }
          const segments = funcInfo.currentSegments;
          let duplicate = false;
          let info = null;
          for (const segment of segments) {
            if (segment.reachable) {
              info = segInfoMap[segment.id];
              duplicate = duplicate || info.calledInSomePaths;
              info.calledInSomePaths = info.calledInEveryPaths = true;
            }
          }
          if (info) {
            if (duplicate) {
              context.report({
                messageId: "duplicate",
                node: node2
              });
            } else if (!funcInfo.superIsConstructor) {
              context.report({
                messageId: "badSuper",
                node: node2
              });
            } else {
              info.validNodes.push(node2);
            }
          }
        },
        /**
         * Set the mark to the returned path as `super()` was called.
         * @param {ASTNode} node A ReturnStatement node to check.
         * @returns {void}
         */
        ReturnStatement(node2) {
          if (!(funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          if (!node2.argument) {
            return;
          }
          const segments = funcInfo.currentSegments;
          for (const segment of segments) {
            if (segment.reachable) {
              const info = segInfoMap[segment.id];
              info.calledInSomePaths = info.calledInEveryPaths = true;
            }
          }
        }
      };
    }
  };
  return constructorSuper;
}
var curly;
var hasRequiredCurly;
function requireCurly() {
  if (hasRequiredCurly) return curly;
  hasRequiredCurly = 1;
  const astUtils2 = requireAstUtils();
  curly = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce consistent brace style for all control statements",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/curly"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["all"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["multi", "multi-line", "multi-or-nest"]
              },
              {
                enum: ["consistent"]
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      defaultOptions: ["all"],
      fixable: "code",
      messages: {
        missingCurlyAfter: "Expected { after '{{name}}'.",
        missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
        unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
        unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
      }
    },
    create(context) {
      const multiOnly = context.options[0] === "multi";
      const multiLine = context.options[0] === "multi-line";
      const multiOrNest = context.options[0] === "multi-or-nest";
      const consistent = context.options[1] === "consistent";
      const sourceCode2 = context.sourceCode;
      function isCollapsedOneLiner(node2) {
        const before = sourceCode2.getTokenBefore(node2);
        const last = sourceCode2.getLastToken(node2);
        const lastExcludingSemicolon = astUtils2.isSemicolonToken(last) ? sourceCode2.getTokenBefore(last) : last;
        return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
      }
      function isOneLiner(node2) {
        if (node2.type === "EmptyStatement") {
          return true;
        }
        const first = sourceCode2.getFirstToken(node2);
        const last = sourceCode2.getLastToken(node2);
        const lastExcludingSemicolon = astUtils2.isSemicolonToken(last) ? sourceCode2.getTokenBefore(last) : last;
        return first.loc.start.line === lastExcludingSemicolon.loc.end.line;
      }
      function needsSemicolon(closingBracket) {
        const tokenBefore = sourceCode2.getTokenBefore(closingBracket);
        const tokenAfter = sourceCode2.getTokenAfter(closingBracket);
        const lastBlockNode = sourceCode2.getNodeByRangeIndex(
          tokenBefore.range[0]
        );
        if (astUtils2.isSemicolonToken(tokenBefore)) {
          return false;
        }
        if (!tokenAfter) {
          return false;
        }
        if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
          return false;
        }
        if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
          return true;
        }
        if (/^[([/`+-]/u.test(tokenAfter.value)) {
          return true;
        }
        if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
          return true;
        }
        return false;
      }
      function prepareCheck(node2, body, name2, opts) {
        const hasBlock = body.type === "BlockStatement";
        let expected = null;
        if (hasBlock && (body.body.length !== 1 || astUtils2.areBracesNecessary(body, sourceCode2))) {
          expected = true;
        } else if (multiOnly) {
          expected = false;
        } else if (multiLine) {
          if (!isCollapsedOneLiner(body)) {
            expected = true;
          }
        } else if (multiOrNest) {
          if (hasBlock) {
            const statement = body.body[0];
            const leadingCommentsInBlock = sourceCode2.getCommentsBefore(statement);
            expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;
          } else {
            expected = !isOneLiner(body);
          }
        } else {
          expected = true;
        }
        return {
          actual: hasBlock,
          expected,
          check() {
            if (this.expected !== null && this.expected !== this.actual) {
              if (this.expected) {
                context.report({
                  node: node2,
                  loc: body.loc,
                  messageId: opts && opts.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
                  data: {
                    name: name2
                  },
                  fix: (fixer) => fixer.replaceText(
                    body,
                    `{${sourceCode2.getText(body)}}`
                  )
                });
              } else {
                context.report({
                  node: node2,
                  loc: body.loc,
                  messageId: opts && opts.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
                  data: {
                    name: name2
                  },
                  fix(fixer) {
                    const needsPrecedingSpace = node2.type === "DoWhileStatement" && sourceCode2.getTokenBefore(body).range[1] === body.range[0] && !astUtils2.canTokensBeAdjacent(
                      "do",
                      sourceCode2.getFirstToken(body, {
                        skip: 1
                      })
                    );
                    const openingBracket = sourceCode2.getFirstToken(body);
                    const closingBracket = sourceCode2.getLastToken(body);
                    const lastTokenInBlock = sourceCode2.getTokenBefore(
                      closingBracket
                    );
                    if (needsSemicolon(closingBracket)) {
                      return null;
                    }
                    const resultingBodyText = sourceCode2.getText().slice(
                      openingBracket.range[1],
                      lastTokenInBlock.range[0]
                    ) + sourceCode2.getText(lastTokenInBlock) + sourceCode2.getText().slice(
                      lastTokenInBlock.range[1],
                      closingBracket.range[0]
                    );
                    return fixer.replaceText(
                      body,
                      (needsPrecedingSpace ? " " : "") + resultingBodyText
                    );
                  }
                });
              }
            }
          }
        };
      }
      function prepareIfChecks(node2) {
        const preparedChecks = [];
        for (let currentNode = node2; currentNode; currentNode = currentNode.alternate) {
          preparedChecks.push(
            prepareCheck(currentNode, currentNode.consequent, "if", {
              condition: true
            })
          );
          if (currentNode.alternate && currentNode.alternate.type !== "IfStatement") {
            preparedChecks.push(
              prepareCheck(
                currentNode,
                currentNode.alternate,
                "else"
              )
            );
            break;
          }
        }
        if (consistent) {
          const expected = preparedChecks.some((preparedCheck) => {
            if (preparedCheck.expected !== null) {
              return preparedCheck.expected;
            }
            return preparedCheck.actual;
          });
          preparedChecks.forEach((preparedCheck) => {
            preparedCheck.expected = expected;
          });
        }
        return preparedChecks;
      }
      return {
        IfStatement(node2) {
          const parent = node2.parent;
          const isElseIf = parent.type === "IfStatement" && parent.alternate === node2;
          if (!isElseIf) {
            prepareIfChecks(node2).forEach((preparedCheck) => {
              preparedCheck.check();
            });
          }
        },
        WhileStatement(node2) {
          prepareCheck(node2, node2.body, "while", {
            condition: true
          }).check();
        },
        DoWhileStatement(node2) {
          prepareCheck(node2, node2.body, "do").check();
        },
        ForStatement(node2) {
          prepareCheck(node2, node2.body, "for", {
            condition: true
          }).check();
        },
        ForInStatement(node2) {
          prepareCheck(node2, node2.body, "for-in").check();
        },
        ForOfStatement(node2) {
          prepareCheck(node2, node2.body, "for-of").check();
        }
      };
    }
  };
  return curly;
}
var defaultCase;
var hasRequiredDefaultCase;
function requireDefaultCase() {
  if (hasRequiredDefaultCase) return defaultCase;
  hasRequiredDefaultCase = 1;
  const DEFAULT_COMMENT_PATTERN = /^no default$/iu;
  defaultCase = {
    meta: {
      type: "suggestion",
      defaultOptions: [{}],
      docs: {
        description: "Require `default` cases in `switch` statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/default-case"
      },
      schema: [
        {
          type: "object",
          properties: {
            commentPattern: {
              type: "string"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingDefaultCase: "Expected a default case."
      }
    },
    create(context) {
      const [options] = context.options;
      const commentPattern = options.commentPattern ? new RegExp(options.commentPattern, "u") : DEFAULT_COMMENT_PATTERN;
      const sourceCode2 = context.sourceCode;
      function last(collection) {
        return collection.at(-1);
      }
      return {
        SwitchStatement(node2) {
          if (!node2.cases.length) {
            return;
          }
          const hasDefault = node2.cases.some((v2) => v2.test === null);
          if (!hasDefault) {
            let comment2;
            const lastCase = last(node2.cases);
            const comments = sourceCode2.getCommentsAfter(lastCase);
            if (comments.length) {
              comment2 = last(comments);
            }
            if (!comment2 || !commentPattern.test(comment2.value.trim())) {
              context.report({
                node: node2,
                messageId: "missingDefaultCase"
              });
            }
          }
        }
      };
    }
  };
  return defaultCase;
}
var defaultCaseLast;
var hasRequiredDefaultCaseLast;
function requireDefaultCaseLast() {
  if (hasRequiredDefaultCaseLast) return defaultCaseLast;
  hasRequiredDefaultCaseLast = 1;
  defaultCaseLast = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce `default` clauses in `switch` statements to be last",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/default-case-last"
      },
      schema: [],
      messages: {
        notLast: "Default clause should be the last clause."
      }
    },
    create(context) {
      return {
        SwitchStatement(node2) {
          const cases = node2.cases, indexOfDefault = cases.findIndex((c2) => c2.test === null);
          if (indexOfDefault !== -1 && indexOfDefault !== cases.length - 1) {
            const defaultClause = cases[indexOfDefault];
            context.report({
              node: defaultClause,
              messageId: "notLast"
            });
          }
        }
      };
    }
  };
  return defaultCaseLast;
}
var defaultParamLast;
var hasRequiredDefaultParamLast;
function requireDefaultParamLast() {
  if (hasRequiredDefaultParamLast) return defaultParamLast;
  hasRequiredDefaultParamLast = 1;
  function isRequiredParameter(node2) {
    return !(node2.type === "AssignmentPattern" || node2.type === "RestElement" || node2.optional);
  }
  defaultParamLast = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      docs: {
        description: "Enforce default parameters to be last",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/default-param-last"
      },
      schema: [],
      messages: {
        shouldBeLast: "Default parameters should be last."
      }
    },
    create(context) {
      function handleFunction(node2) {
        let hasSeenRequiredParameter = false;
        for (let i2 = node2.params.length - 1; i2 >= 0; i2 -= 1) {
          const current = node2.params[i2];
          const param = current.type === "TSParameterProperty" ? current.parameter : current;
          if (isRequiredParameter(param)) {
            hasSeenRequiredParameter = true;
            continue;
          }
          if (hasSeenRequiredParameter) {
            context.report({
              node: current,
              messageId: "shouldBeLast"
            });
          }
        }
      }
      return {
        FunctionDeclaration: handleFunction,
        FunctionExpression: handleFunction,
        ArrowFunctionExpression: handleFunction
      };
    }
  };
  return defaultParamLast;
}
var dotLocation;
var hasRequiredDotLocation;
function requireDotLocation() {
  if (hasRequiredDotLocation) return dotLocation;
  hasRequiredDotLocation = 1;
  const astUtils2 = requireAstUtils();
  dotLocation = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "dot-location",
              url: "https://eslint.style/rules/dot-location"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent newlines before and after dots",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/dot-location"
      },
      schema: [
        {
          enum: ["object", "property"]
        }
      ],
      fixable: "code",
      messages: {
        expectedDotAfterObject: "Expected dot to be on same line as object.",
        expectedDotBeforeProperty: "Expected dot to be on same line as property."
      }
    },
    create(context) {
      const config2 = context.options[0];
      const onObject = config2 === "object" || !config2;
      const sourceCode2 = context.sourceCode;
      function checkDotLocation(node2) {
        const property = node2.property;
        const dotToken = sourceCode2.getTokenBefore(property);
        if (onObject) {
          const tokenBeforeDot = sourceCode2.getTokenBefore(dotToken);
          if (!astUtils2.isTokenOnSameLine(tokenBeforeDot, dotToken)) {
            context.report({
              node: node2,
              loc: dotToken.loc,
              messageId: "expectedDotAfterObject",
              *fix(fixer) {
                if (dotToken.value.startsWith(".") && astUtils2.isDecimalIntegerNumericToken(
                  tokenBeforeDot
                )) {
                  yield fixer.insertTextAfter(
                    tokenBeforeDot,
                    ` ${dotToken.value}`
                  );
                } else {
                  yield fixer.insertTextAfter(
                    tokenBeforeDot,
                    dotToken.value
                  );
                }
                yield fixer.remove(dotToken);
              }
            });
          }
        } else if (!astUtils2.isTokenOnSameLine(dotToken, property)) {
          context.report({
            node: node2,
            loc: dotToken.loc,
            messageId: "expectedDotBeforeProperty",
            *fix(fixer) {
              yield fixer.remove(dotToken);
              yield fixer.insertTextBefore(property, dotToken.value);
            }
          });
        }
      }
      function checkNode(node2) {
        if (!node2.computed) {
          checkDotLocation(node2);
        }
      }
      return {
        MemberExpression: checkNode
      };
    }
  };
  return dotLocation;
}
var keywords;
var hasRequiredKeywords;
function requireKeywords() {
  if (hasRequiredKeywords) return keywords;
  hasRequiredKeywords = 1;
  keywords = [
    "abstract",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "double",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "goto",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "volatile",
    "while",
    "with"
  ];
  return keywords;
}
var dotNotation;
var hasRequiredDotNotation;
function requireDotNotation() {
  if (hasRequiredDotNotation) return dotNotation;
  hasRequiredDotNotation = 1;
  const astUtils2 = requireAstUtils();
  const keywords2 = requireKeywords();
  const validIdentifier = /^[a-zA-Z_$][\w$]*$/u;
  const literalTypesToCheck = /* @__PURE__ */ new Set(["string", "boolean"]);
  dotNotation = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowKeywords: true,
          allowPattern: ""
        }
      ],
      docs: {
        description: "Enforce dot notation whenever possible",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/dot-notation"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowKeywords: {
              type: "boolean"
            },
            allowPattern: {
              type: "string"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        useDot: "[{{key}}] is better written in dot notation.",
        useBrackets: ".{{key}} is a syntax error."
      }
    },
    create(context) {
      const [options] = context.options;
      const allowKeywords = options.allowKeywords;
      const sourceCode2 = context.sourceCode;
      let allowPattern;
      if (options.allowPattern) {
        allowPattern = new RegExp(options.allowPattern, "u");
      }
      function checkComputedProperty(node2, value) {
        if (validIdentifier.test(value) && (allowKeywords || !keywords2.includes(String(value))) && !(allowPattern && allowPattern.test(value))) {
          const formattedValue = node2.property.type === "Literal" ? JSON.stringify(value) : `\`${value}\``;
          context.report({
            node: node2.property,
            messageId: "useDot",
            data: {
              key: formattedValue
            },
            *fix(fixer) {
              const leftBracket = sourceCode2.getTokenAfter(
                node2.object,
                astUtils2.isOpeningBracketToken
              );
              const rightBracket = sourceCode2.getLastToken(node2);
              const nextToken = sourceCode2.getTokenAfter(node2);
              if (sourceCode2.commentsExistBetween(
                leftBracket,
                rightBracket
              )) {
                return;
              }
              if (!node2.optional) {
                yield fixer.insertTextBefore(
                  leftBracket,
                  astUtils2.isDecimalInteger(node2.object) ? " ." : "."
                );
              }
              yield fixer.replaceTextRange(
                [leftBracket.range[0], rightBracket.range[1]],
                value
              );
              if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils2.canTokensBeAdjacent(
                String(value),
                nextToken
              )) {
                yield fixer.insertTextAfter(node2, " ");
              }
            }
          });
        }
      }
      return {
        MemberExpression(node2) {
          if (node2.computed && node2.property.type === "Literal" && (literalTypesToCheck.has(typeof node2.property.value) || astUtils2.isNullLiteral(node2.property))) {
            checkComputedProperty(node2, node2.property.value);
          }
          if (node2.computed && astUtils2.isStaticTemplateLiteral(node2.property)) {
            checkComputedProperty(
              node2,
              node2.property.quasis[0].value.cooked
            );
          }
          if (!allowKeywords && !node2.computed && node2.property.type === "Identifier" && keywords2.includes(String(node2.property.name))) {
            context.report({
              node: node2.property,
              messageId: "useBrackets",
              data: {
                key: node2.property.name
              },
              *fix(fixer) {
                const dotToken = sourceCode2.getTokenBefore(
                  node2.property
                );
                if (node2.object.type === "Identifier" && node2.object.name === "let" && !node2.optional) {
                  return;
                }
                if (sourceCode2.commentsExistBetween(
                  dotToken,
                  node2.property
                )) {
                  return;
                }
                if (!node2.optional) {
                  yield fixer.remove(dotToken);
                }
                yield fixer.replaceText(
                  node2.property,
                  `["${node2.property.name}"]`
                );
              }
            });
          }
        }
      };
    }
  };
  return dotNotation;
}
var eolLast;
var hasRequiredEolLast;
function requireEolLast() {
  if (hasRequiredEolLast) return eolLast;
  hasRequiredEolLast = 1;
  eolLast = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "eol-last",
              url: "https://eslint.style/rules/eol-last"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow newline at the end of files",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/eol-last"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never", "unix", "windows"]
        }
      ],
      messages: {
        missing: "Newline required at end of file but not found.",
        unexpected: "Newline not allowed at end of file."
      }
    },
    create(context) {
      return {
        Program: function checkBadEOF(node2) {
          const sourceCode2 = context.sourceCode, src2 = sourceCode2.getText(), lastLine = sourceCode2.lines.at(-1), location = {
            column: lastLine.length,
            line: sourceCode2.lines.length
          }, LF = "\n", CRLF = `\r${LF}`, endsWithNewline = src2.endsWith(LF);
          if (!src2.length) {
            return;
          }
          let mode = context.options[0] || "always", appendCRLF = false;
          if (mode === "unix") {
            mode = "always";
          }
          if (mode === "windows") {
            mode = "always";
            appendCRLF = true;
          }
          if (mode === "always" && !endsWithNewline) {
            context.report({
              node: node2,
              loc: location,
              messageId: "missing",
              fix(fixer) {
                return fixer.insertTextAfterRange(
                  [0, src2.length],
                  appendCRLF ? CRLF : LF
                );
              }
            });
          } else if (mode === "never" && endsWithNewline) {
            const secondLastLine = sourceCode2.lines.at(-2);
            context.report({
              node: node2,
              loc: {
                start: {
                  line: sourceCode2.lines.length - 1,
                  column: secondLastLine.length
                },
                end: { line: sourceCode2.lines.length, column: 0 }
              },
              messageId: "unexpected",
              fix(fixer) {
                const finalEOLs = /(?:\r?\n)+$/u, match = finalEOLs.exec(sourceCode2.text), start = match.index, end = sourceCode2.text.length;
                return fixer.replaceTextRange([start, end], "");
              }
            });
          }
        }
      };
    }
  };
  return eolLast;
}
var eqeqeq;
var hasRequiredEqeqeq;
function requireEqeqeq() {
  if (hasRequiredEqeqeq) return eqeqeq;
  hasRequiredEqeqeq = 1;
  const astUtils2 = requireAstUtils();
  eqeqeq = {
    meta: {
      type: "suggestion",
      hasSuggestions: true,
      docs: {
        description: "Require the use of `===` and `!==`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/eqeqeq"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  null: {
                    enum: ["always", "never", "ignore"]
                  }
                },
                additionalProperties: false
              }
            ],
            additionalItems: false
          },
          {
            type: "array",
            items: [
              {
                enum: ["smart", "allow-null"]
              }
            ],
            additionalItems: false
          }
        ]
      },
      fixable: "code",
      messages: {
        unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.",
        replaceOperator: "Use '{{expectedOperator}}' instead of '{{actualOperator}}'."
      }
    },
    create(context) {
      const config2 = context.options[0] || "always";
      const options = context.options[1] || {};
      const sourceCode2 = context.sourceCode;
      const nullOption = config2 === "always" ? options.null || "always" : "ignore";
      const enforceRuleForNull = nullOption === "always";
      const enforceInverseRuleForNull = nullOption === "never";
      function isTypeOf(node2) {
        return node2.type === "UnaryExpression" && node2.operator === "typeof";
      }
      function isTypeOfBinary(node2) {
        return isTypeOf(node2.left) || isTypeOf(node2.right);
      }
      function areLiteralsAndSameType(node2) {
        return node2.left.type === "Literal" && node2.right.type === "Literal" && typeof node2.left.value === typeof node2.right.value;
      }
      function isNullCheck(node2) {
        return astUtils2.isNullLiteral(node2.right) || astUtils2.isNullLiteral(node2.left);
      }
      function report(node2, expectedOperator) {
        const operatorToken2 = sourceCode2.getFirstTokenBetween(
          node2.left,
          node2.right,
          (token) => token.value === node2.operator
        );
        const commonReportParams = {
          node: node2,
          loc: operatorToken2.loc,
          messageId: "unexpected",
          data: { expectedOperator, actualOperator: node2.operator }
        };
        if (isTypeOfBinary(node2) || areLiteralsAndSameType(node2)) {
          context.report({
            ...commonReportParams,
            fix(fixer) {
              return fixer.replaceText(
                operatorToken2,
                expectedOperator
              );
            }
          });
        } else {
          context.report({
            ...commonReportParams,
            suggest: [
              {
                messageId: "replaceOperator",
                data: {
                  expectedOperator,
                  actualOperator: node2.operator
                },
                fix: (fixer) => fixer.replaceText(
                  operatorToken2,
                  expectedOperator
                )
              }
            ]
          });
        }
      }
      return {
        BinaryExpression(node2) {
          const isNull = isNullCheck(node2);
          if (node2.operator !== "==" && node2.operator !== "!=") {
            if (enforceInverseRuleForNull && isNull) {
              report(node2, node2.operator.slice(0, -1));
            }
            return;
          }
          if (config2 === "smart" && (isTypeOfBinary(node2) || areLiteralsAndSameType(node2) || isNull)) {
            return;
          }
          if (!enforceRuleForNull && isNull) {
            return;
          }
          report(node2, `${node2.operator}=`);
        }
      };
    }
  };
  return eqeqeq;
}
var forDirection;
var hasRequiredForDirection;
function requireForDirection() {
  if (hasRequiredForDirection) return forDirection;
  hasRequiredForDirection = 1;
  const { getStaticValue } = /* @__PURE__ */ requireEslintUtils();
  forDirection = {
    meta: {
      type: "problem",
      docs: {
        description: "Enforce `for` loop update clause moving the counter in the right direction",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/for-direction"
      },
      fixable: null,
      schema: [],
      messages: {
        incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
      }
    },
    create(context) {
      const { sourceCode: sourceCode2 } = context;
      function report(node2) {
        context.report({
          loc: {
            start: node2.loc.start,
            end: sourceCode2.getTokenBefore(node2.body).loc.end
          },
          messageId: "incorrectDirection"
        });
      }
      function getRightDirection(update, dir) {
        const staticValue = getStaticValue(
          update.right,
          sourceCode2.getScope(update)
        );
        if (staticValue && ["bigint", "boolean", "number"].includes(
          typeof staticValue.value
        )) {
          const sign = Math.sign(Number(staticValue.value)) || 0;
          return dir * sign;
        }
        return 0;
      }
      function getUpdateDirection(update, counter) {
        if (update.argument.type === "Identifier" && update.argument.name === counter) {
          if (update.operator === "++") {
            return 1;
          }
          if (update.operator === "--") {
            return -1;
          }
        }
        return 0;
      }
      function getAssignmentDirection(update, counter) {
        if (update.left.name === counter) {
          if (update.operator === "+=") {
            return getRightDirection(update, 1);
          }
          if (update.operator === "-=") {
            return getRightDirection(update, -1);
          }
        }
        return 0;
      }
      return {
        ForStatement(node2) {
          if (node2.test && node2.test.type === "BinaryExpression" && node2.update) {
            for (const counterPosition of ["left", "right"]) {
              if (node2.test[counterPosition].type !== "Identifier") {
                continue;
              }
              const counter = node2.test[counterPosition].name;
              const operator2 = node2.test.operator;
              const update = node2.update;
              let wrongDirection;
              if (operator2 === "<" || operator2 === "<=") {
                wrongDirection = counterPosition === "left" ? -1 : 1;
              } else if (operator2 === ">" || operator2 === ">=") {
                wrongDirection = counterPosition === "left" ? 1 : -1;
              } else {
                return;
              }
              if (update.type === "UpdateExpression") {
                if (getUpdateDirection(update, counter) === wrongDirection) {
                  report(node2);
                }
              } else if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) === wrongDirection) {
                report(node2);
              }
            }
          }
        }
      };
    }
  };
  return forDirection;
}
var funcCallSpacing;
var hasRequiredFuncCallSpacing;
function requireFuncCallSpacing() {
  if (hasRequiredFuncCallSpacing) return funcCallSpacing;
  hasRequiredFuncCallSpacing = 1;
  const astUtils2 = requireAstUtils();
  funcCallSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "function-call-spacing",
              url: "https://eslint.style/rules/function-call-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow spacing between function identifiers and their invocations",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/func-call-spacing"
      },
      fixable: "whitespace",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  allowNewlines: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
        unexpectedNewline: "Unexpected newline between function name and paren.",
        missing: "Missing space between function name and paren."
      }
    },
    create(context) {
      const never = context.options[0] !== "always";
      const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
      const sourceCode2 = context.sourceCode;
      const text = sourceCode2.getText();
      function checkSpacing(node2, leftToken, rightToken) {
        const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\/\*.*?\*\//gu, "");
        const hasWhitespace = /\s/u.test(textBetweenTokens);
        const hasNewline = hasWhitespace && astUtils2.LINEBREAK_MATCHER.test(textBetweenTokens);
        if (never && hasWhitespace) {
          context.report({
            node: node2,
            loc: {
              start: leftToken.loc.end,
              end: {
                line: rightToken.loc.start.line,
                column: rightToken.loc.start.column - 1
              }
            },
            messageId: "unexpectedWhitespace",
            fix(fixer) {
              if (sourceCode2.commentsExistBetween(
                leftToken,
                rightToken
              )) {
                return null;
              }
              if (node2.optional) {
                return fixer.replaceTextRange(
                  [leftToken.range[1], rightToken.range[0]],
                  "?."
                );
              }
              if (hasNewline) {
                return null;
              }
              return fixer.removeRange([
                leftToken.range[1],
                rightToken.range[0]
              ]);
            }
          });
        } else if (!never && !hasWhitespace) {
          context.report({
            node: node2,
            loc: {
              start: {
                line: leftToken.loc.end.line,
                column: leftToken.loc.end.column - 1
              },
              end: rightToken.loc.start
            },
            messageId: "missing",
            fix(fixer) {
              if (node2.optional) {
                return null;
              }
              return fixer.insertTextBefore(rightToken, " ");
            }
          });
        } else if (!never && !allowNewlines && hasNewline) {
          context.report({
            node: node2,
            loc: {
              start: leftToken.loc.end,
              end: rightToken.loc.start
            },
            messageId: "unexpectedNewline",
            fix(fixer) {
              if (!node2.optional) {
                return null;
              }
              if (sourceCode2.commentsExistBetween(
                leftToken,
                rightToken
              )) {
                return null;
              }
              const range = [leftToken.range[1], rightToken.range[0]];
              const qdToken = sourceCode2.getTokenAfter(leftToken);
              if (qdToken.range[0] === leftToken.range[1]) {
                return fixer.replaceTextRange(range, "?. ");
              }
              if (qdToken.range[1] === rightToken.range[0]) {
                return fixer.replaceTextRange(range, " ?.");
              }
              return fixer.replaceTextRange(range, " ?. ");
            }
          });
        }
      }
      return {
        "CallExpression, NewExpression"(node2) {
          const lastToken = sourceCode2.getLastToken(node2);
          const lastCalleeToken = sourceCode2.getLastToken(node2.callee);
          const parenToken = sourceCode2.getFirstTokenBetween(
            lastCalleeToken,
            lastToken,
            astUtils2.isOpeningParenToken
          );
          const prevToken = parenToken && sourceCode2.getTokenBefore(
            parenToken,
            astUtils2.isNotQuestionDotToken
          );
          if (!(parenToken && parenToken.range[1] < node2.range[1])) {
            return;
          }
          checkSpacing(node2, prevToken, parenToken);
        },
        ImportExpression(node2) {
          const leftToken = sourceCode2.getFirstToken(node2);
          const rightToken = sourceCode2.getTokenAfter(leftToken);
          checkSpacing(node2, leftToken, rightToken);
        }
      };
    }
  };
  return funcCallSpacing;
}
var funcNameMatching;
var hasRequiredFuncNameMatching;
function requireFuncNameMatching() {
  if (hasRequiredFuncNameMatching) return funcNameMatching;
  hasRequiredFuncNameMatching = 1;
  const astUtils2 = requireAstUtils();
  const esutils = requireUtils();
  function isModuleExports(pattern2) {
    if (pattern2.type === "MemberExpression" && pattern2.object.type === "Identifier" && pattern2.object.name === "module") {
      if (pattern2.property.type === "Identifier" && pattern2.property.name === "exports") {
        return true;
      }
      if (pattern2.property.type === "Literal" && pattern2.property.value === "exports") {
        return true;
      }
    }
    return false;
  }
  function isIdentifier(name2, ecmaVersion2) {
    if (ecmaVersion2 >= 2015) {
      return esutils.keyword.isIdentifierES6(name2);
    }
    return esutils.keyword.isIdentifierES5(name2);
  }
  const alwaysOrNever = { enum: ["always", "never"] };
  const optionsObject = {
    type: "object",
    properties: {
      considerPropertyDescriptor: {
        type: "boolean"
      },
      includeCommonJSModuleExports: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  funcNameMatching = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require function names to match the name of the variable or property to which they are assigned",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/func-name-matching"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            additionalItems: false,
            items: [alwaysOrNever, optionsObject]
          },
          {
            type: "array",
            additionalItems: false,
            items: [optionsObject]
          }
        ]
      },
      messages: {
        matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
        matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
        notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
        notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
      }
    },
    create(context) {
      const options = (typeof context.options[0] === "object" ? context.options[0] : context.options[1]) || {};
      const nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
      const considerPropertyDescriptor = options.considerPropertyDescriptor;
      const includeModuleExports = options.includeCommonJSModuleExports;
      const ecmaVersion2 = context.languageOptions.ecmaVersion;
      function isPropertyCall(objName, funcName, node2) {
        if (!node2) {
          return false;
        }
        return node2.type === "CallExpression" && astUtils2.isSpecificMemberAccess(node2.callee, objName, funcName);
      }
      function shouldWarn(x2, y2) {
        return nameMatches === "always" && x2 !== y2 || nameMatches === "never" && x2 === y2;
      }
      function report(node2, name2, funcName, isProp) {
        let messageId;
        if (nameMatches === "always" && isProp) {
          messageId = "matchProperty";
        } else if (nameMatches === "always") {
          messageId = "matchVariable";
        } else if (isProp) {
          messageId = "notMatchProperty";
        } else {
          messageId = "notMatchVariable";
        }
        context.report({
          node: node2,
          messageId,
          data: {
            name: name2,
            funcName
          }
        });
      }
      function isStringLiteral(node2) {
        return node2.type === "Literal" && typeof node2.value === "string";
      }
      return {
        VariableDeclarator(node2) {
          if (!node2.init || node2.init.type !== "FunctionExpression" || node2.id.type !== "Identifier") {
            return;
          }
          if (node2.init.id && shouldWarn(node2.id.name, node2.init.id.name)) {
            report(node2, node2.id.name, node2.init.id.name, false);
          }
        },
        AssignmentExpression(node2) {
          if (node2.right.type !== "FunctionExpression" || node2.left.computed && node2.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node2.left) || node2.left.type !== "Identifier" && node2.left.type !== "MemberExpression") {
            return;
          }
          const isProp = node2.left.type === "MemberExpression";
          const name2 = isProp ? astUtils2.getStaticPropertyName(node2.left) : node2.left.name;
          if (node2.right.id && name2 && isIdentifier(name2) && shouldWarn(name2, node2.right.id.name)) {
            report(node2, name2, node2.right.id.name, isProp);
          }
        },
        "Property, PropertyDefinition[value]"(node2) {
          if (!(node2.value.type === "FunctionExpression" && node2.value.id)) {
            return;
          }
          if (node2.key.type === "Identifier" && !node2.computed) {
            const functionName = node2.value.id.name;
            let propertyName2 = node2.key.name;
            if (considerPropertyDescriptor && propertyName2 === "value" && node2.parent.type === "ObjectExpression") {
              if (isPropertyCall(
                "Object",
                "defineProperty",
                node2.parent.parent
              ) || isPropertyCall(
                "Reflect",
                "defineProperty",
                node2.parent.parent
              )) {
                const property = node2.parent.parent.arguments[1];
                if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {
                  report(
                    node2,
                    property.value,
                    functionName,
                    true
                  );
                }
              } else if (isPropertyCall(
                "Object",
                "defineProperties",
                node2.parent.parent.parent.parent
              )) {
                propertyName2 = node2.parent.parent.key.name;
                if (!node2.parent.parent.computed && shouldWarn(propertyName2, functionName)) {
                  report(node2, propertyName2, functionName, true);
                }
              } else if (isPropertyCall(
                "Object",
                "create",
                node2.parent.parent.parent.parent
              )) {
                propertyName2 = node2.parent.parent.key.name;
                if (!node2.parent.parent.computed && shouldWarn(propertyName2, functionName)) {
                  report(node2, propertyName2, functionName, true);
                }
              } else if (shouldWarn(propertyName2, functionName)) {
                report(node2, propertyName2, functionName, true);
              }
            } else if (shouldWarn(propertyName2, functionName)) {
              report(node2, propertyName2, functionName, true);
            }
            return;
          }
          if (isStringLiteral(node2.key) && isIdentifier(node2.key.value, ecmaVersion2) && shouldWarn(node2.key.value, node2.value.id.name)) {
            report(node2, node2.key.value, node2.value.id.name, true);
          }
        }
      };
    }
  };
  return funcNameMatching;
}
var funcNames;
var hasRequiredFuncNames;
function requireFuncNames() {
  if (hasRequiredFuncNames) return funcNames;
  hasRequiredFuncNames = 1;
  const astUtils2 = requireAstUtils();
  function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
  }
  funcNames = {
    meta: {
      type: "suggestion",
      defaultOptions: ["always", {}],
      docs: {
        description: "Require or disallow named `function` expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/func-names"
      },
      schema: {
        definitions: {
          value: {
            enum: ["always", "as-needed", "never"]
          }
        },
        items: [
          {
            $ref: "#/definitions/value"
          },
          {
            type: "object",
            properties: {
              generators: {
                $ref: "#/definitions/value"
              }
            },
            additionalProperties: false
          }
        ]
      },
      messages: {
        unnamed: "Unexpected unnamed {{name}}.",
        named: "Unexpected named {{name}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function getConfigForNode(node2) {
        if (node2.generator && context.options[1].generators) {
          return context.options[1].generators;
        }
        return context.options[0];
      }
      function isObjectOrClassMethod(node2) {
        const parent = node2.parent;
        return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
      }
      function hasInferredName(node2) {
        const parent = node2.parent;
        return isObjectOrClassMethod(node2) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node2 || parent.type === "Property" && parent.value === node2 || parent.type === "PropertyDefinition" && parent.value === node2 || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node2 || parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node2;
      }
      function reportUnexpectedUnnamedFunction(node2) {
        context.report({
          node: node2,
          messageId: "unnamed",
          loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
          data: { name: astUtils2.getFunctionNameWithKind(node2) }
        });
      }
      function reportUnexpectedNamedFunction(node2) {
        context.report({
          node: node2,
          messageId: "named",
          loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
          data: { name: astUtils2.getFunctionNameWithKind(node2) }
        });
      }
      function handleFunction(node2) {
        const nameVar = sourceCode2.getDeclaredVariables(node2)[0];
        if (isFunctionName(nameVar) && nameVar.references.length > 0) {
          return;
        }
        const hasName = Boolean(node2.id && node2.id.name);
        const config2 = getConfigForNode(node2);
        if (config2 === "never") {
          if (hasName && node2.type !== "FunctionDeclaration") {
            reportUnexpectedNamedFunction(node2);
          }
        } else if (config2 === "as-needed") {
          if (!hasName && !hasInferredName(node2)) {
            reportUnexpectedUnnamedFunction(node2);
          }
        } else {
          if (!hasName && !isObjectOrClassMethod(node2)) {
            reportUnexpectedUnnamedFunction(node2);
          }
        }
      }
      return {
        "FunctionExpression:exit": handleFunction,
        "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
      };
    }
  };
  return funcNames;
}
var funcStyle;
var hasRequiredFuncStyle;
function requireFuncStyle() {
  if (hasRequiredFuncStyle) return funcStyle;
  hasRequiredFuncStyle = 1;
  funcStyle = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      defaultOptions: [
        "expression",
        {
          allowArrowFunctions: false,
          allowTypeAnnotation: false,
          overrides: {}
        }
      ],
      docs: {
        description: "Enforce the consistent use of either `function` declarations or expressions assigned to variables",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/func-style"
      },
      schema: [
        {
          enum: ["declaration", "expression"]
        },
        {
          type: "object",
          properties: {
            allowArrowFunctions: {
              type: "boolean"
            },
            allowTypeAnnotation: {
              type: "boolean"
            },
            overrides: {
              type: "object",
              properties: {
                namedExports: {
                  enum: ["declaration", "expression", "ignore"]
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expression: "Expected a function expression.",
        declaration: "Expected a function declaration."
      }
    },
    create(context) {
      const [style, { allowArrowFunctions, allowTypeAnnotation, overrides: overrides2 }] = context.options;
      const enforceDeclarations = style === "declaration";
      const { namedExports: exportFunctionStyle } = overrides2;
      const stack = [];
      function isOverloadedFunction(node2) {
        const functionName = node2.id.name;
        if (node2.parent.type === "ExportNamedDeclaration") {
          return node2.parent.parent.body.some(
            (member) => {
              var _a2;
              return member.type === "ExportNamedDeclaration" && ((_a2 = member.declaration) == null ? void 0 : _a2.type) === "TSDeclareFunction" && member.declaration.id.name === functionName;
            }
          );
        }
        if (node2.parent.type === "SwitchCase") {
          return node2.parent.parent.cases.some(
            (switchCase) => switchCase.consequent.some(
              (member) => member.type === "TSDeclareFunction" && member.id.name === functionName
            )
          );
        }
        return Array.isArray(node2.parent.body) && node2.parent.body.some(
          (member) => member.type === "TSDeclareFunction" && member.id.name === functionName
        );
      }
      const nodesToCheck = {
        FunctionDeclaration(node2) {
          stack.push(false);
          if (!enforceDeclarations && node2.parent.type !== "ExportDefaultDeclaration" && (typeof exportFunctionStyle === "undefined" || node2.parent.type !== "ExportNamedDeclaration") && !isOverloadedFunction(node2)) {
            context.report({ node: node2, messageId: "expression" });
          }
          if (node2.parent.type === "ExportNamedDeclaration" && exportFunctionStyle === "expression" && !isOverloadedFunction(node2)) {
            context.report({ node: node2, messageId: "expression" });
          }
        },
        "FunctionDeclaration:exit"() {
          stack.pop();
        },
        FunctionExpression(node2) {
          stack.push(false);
          if (enforceDeclarations && node2.parent.type === "VariableDeclarator" && (typeof exportFunctionStyle === "undefined" || node2.parent.parent.parent.type !== "ExportNamedDeclaration") && !(allowTypeAnnotation && node2.parent.id.typeAnnotation)) {
            context.report({
              node: node2.parent,
              messageId: "declaration"
            });
          }
          if (node2.parent.type === "VariableDeclarator" && node2.parent.parent.parent.type === "ExportNamedDeclaration" && exportFunctionStyle === "declaration" && !(allowTypeAnnotation && node2.parent.id.typeAnnotation)) {
            context.report({
              node: node2.parent,
              messageId: "declaration"
            });
          }
        },
        "FunctionExpression:exit"() {
          stack.pop();
        },
        "ThisExpression, Super"() {
          if (stack.length > 0) {
            stack[stack.length - 1] = true;
          }
        }
      };
      if (!allowArrowFunctions) {
        nodesToCheck.ArrowFunctionExpression = function() {
          stack.push(false);
        };
        nodesToCheck["ArrowFunctionExpression:exit"] = function(node2) {
          const hasThisOrSuperExpr = stack.pop();
          if (!hasThisOrSuperExpr && node2.parent.type === "VariableDeclarator") {
            if (enforceDeclarations && (typeof exportFunctionStyle === "undefined" || node2.parent.parent.parent.type !== "ExportNamedDeclaration") && !(allowTypeAnnotation && node2.parent.id.typeAnnotation)) {
              context.report({
                node: node2.parent,
                messageId: "declaration"
              });
            }
            if (node2.parent.parent.parent.type === "ExportNamedDeclaration" && exportFunctionStyle === "declaration" && !(allowTypeAnnotation && node2.parent.id.typeAnnotation)) {
              context.report({
                node: node2.parent,
                messageId: "declaration"
              });
            }
          }
        };
      }
      return nodesToCheck;
    }
  };
  return funcStyle;
}
var functionCallArgumentNewline;
var hasRequiredFunctionCallArgumentNewline;
function requireFunctionCallArgumentNewline() {
  if (hasRequiredFunctionCallArgumentNewline) return functionCallArgumentNewline;
  hasRequiredFunctionCallArgumentNewline = 1;
  functionCallArgumentNewline = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "function-call-argument-newline",
              url: "https://eslint.style/rules/function-call-argument-newline"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce line breaks between arguments of a function call",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/function-call-argument-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never", "consistent"]
        }
      ],
      messages: {
        unexpectedLineBreak: "There should be no line break here.",
        missingLineBreak: "There should be a line break after this argument."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const checkers = {
        unexpected: {
          messageId: "unexpectedLineBreak",
          check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,
          createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange(
            [tokenBefore.range[1], token.range[0]],
            " "
          )
        },
        missing: {
          messageId: "missingLineBreak",
          check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,
          createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange(
            [tokenBefore.range[1], token.range[0]],
            "\n"
          )
        }
      };
      function checkArguments(node2, checker) {
        for (let i2 = 1; i2 < node2.arguments.length; i2++) {
          const prevArgToken = sourceCode2.getLastToken(
            node2.arguments[i2 - 1]
          );
          const currentArgToken = sourceCode2.getFirstToken(
            node2.arguments[i2]
          );
          if (checker.check(prevArgToken, currentArgToken)) {
            const tokenBefore = sourceCode2.getTokenBefore(
              currentArgToken,
              { includeComments: true }
            );
            const hasLineCommentBefore = tokenBefore.type === "Line";
            context.report({
              node: node2,
              loc: {
                start: tokenBefore.loc.end,
                end: currentArgToken.loc.start
              },
              messageId: checker.messageId,
              fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)
            });
          }
        }
      }
      function check2(node2) {
        if (node2.arguments.length < 2) {
          return;
        }
        const option = context.options[0] || "always";
        if (option === "never") {
          checkArguments(node2, checkers.unexpected);
        } else if (option === "always") {
          checkArguments(node2, checkers.missing);
        } else if (option === "consistent") {
          const firstArgToken = sourceCode2.getLastToken(
            node2.arguments[0]
          );
          const secondArgToken = sourceCode2.getFirstToken(
            node2.arguments[1]
          );
          if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {
            checkArguments(node2, checkers.unexpected);
          } else {
            checkArguments(node2, checkers.missing);
          }
        }
      }
      return {
        CallExpression: check2,
        NewExpression: check2
      };
    }
  };
  return functionCallArgumentNewline;
}
var functionParenNewline;
var hasRequiredFunctionParenNewline;
function requireFunctionParenNewline() {
  if (hasRequiredFunctionParenNewline) return functionParenNewline;
  hasRequiredFunctionParenNewline = 1;
  const astUtils2 = requireAstUtils();
  functionParenNewline = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "function-paren-newline",
              url: "https://eslint.style/rules/function-paren-newline"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent line breaks inside function parentheses",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/function-paren-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: [
                "always",
                "never",
                "consistent",
                "multiline",
                "multiline-arguments"
              ]
            },
            {
              type: "object",
              properties: {
                minItems: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        expectedBefore: "Expected newline before ')'.",
        expectedAfter: "Expected newline after '('.",
        expectedBetween: "Expected newline between arguments/params.",
        unexpectedBefore: "Unexpected newline before ')'.",
        unexpectedAfter: "Unexpected newline after '('."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const rawOption = context.options[0] || "multiline";
      const multilineOption = rawOption === "multiline";
      const multilineArgumentsOption = rawOption === "multiline-arguments";
      const consistentOption = rawOption === "consistent";
      let minItems;
      if (typeof rawOption === "object") {
        minItems = rawOption.minItems;
      } else if (rawOption === "always") {
        minItems = 0;
      } else if (rawOption === "never") {
        minItems = Infinity;
      } else {
        minItems = null;
      }
      function shouldHaveNewlines(elements, hasLeftNewline) {
        if (multilineArgumentsOption && elements.length === 1) {
          return hasLeftNewline;
        }
        if (multilineOption || multilineArgumentsOption) {
          return elements.some(
            (element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line
          );
        }
        if (consistentOption) {
          return hasLeftNewline;
        }
        return elements.length >= minItems;
      }
      function validateParens(parens, elements) {
        const leftParen = parens.leftParen;
        const rightParen = parens.rightParen;
        const tokenAfterLeftParen = sourceCode2.getTokenAfter(leftParen);
        const tokenBeforeRightParen = sourceCode2.getTokenBefore(rightParen);
        const hasLeftNewline = !astUtils2.isTokenOnSameLine(
          leftParen,
          tokenAfterLeftParen
        );
        const hasRightNewline = !astUtils2.isTokenOnSameLine(
          tokenBeforeRightParen,
          rightParen
        );
        const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
        if (hasLeftNewline && !needsNewlines) {
          context.report({
            node: leftParen,
            messageId: "unexpectedAfter",
            fix(fixer) {
              return sourceCode2.getText().slice(
                leftParen.range[1],
                tokenAfterLeftParen.range[0]
              ).trim() ? (
                // If there is a comment between the ( and the first element, don't do a fix.
                null
              ) : fixer.removeRange([
                leftParen.range[1],
                tokenAfterLeftParen.range[0]
              ]);
            }
          });
        } else if (!hasLeftNewline && needsNewlines) {
          context.report({
            node: leftParen,
            messageId: "expectedAfter",
            fix: (fixer) => fixer.insertTextAfter(leftParen, "\n")
          });
        }
        if (hasRightNewline && !needsNewlines) {
          context.report({
            node: rightParen,
            messageId: "unexpectedBefore",
            fix(fixer) {
              return sourceCode2.getText().slice(
                tokenBeforeRightParen.range[1],
                rightParen.range[0]
              ).trim() ? (
                // If there is a comment between the last element and the ), don't do a fix.
                null
              ) : fixer.removeRange([
                tokenBeforeRightParen.range[1],
                rightParen.range[0]
              ]);
            }
          });
        } else if (!hasRightNewline && needsNewlines) {
          context.report({
            node: rightParen,
            messageId: "expectedBefore",
            fix: (fixer) => fixer.insertTextBefore(rightParen, "\n")
          });
        }
      }
      function validateArguments(parens, elements) {
        const leftParen = parens.leftParen;
        const tokenAfterLeftParen = sourceCode2.getTokenAfter(leftParen);
        const hasLeftNewline = !astUtils2.isTokenOnSameLine(
          leftParen,
          tokenAfterLeftParen
        );
        const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
        for (let i2 = 0; i2 <= elements.length - 2; i2++) {
          const currentElement = elements[i2];
          const nextElement = elements[i2 + 1];
          const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;
          if (!hasNewLine && needsNewlines) {
            context.report({
              node: currentElement,
              messageId: "expectedBetween",
              fix: (fixer) => fixer.insertTextBefore(nextElement, "\n")
            });
          }
        }
      }
      function getParenTokens(node2) {
        switch (node2.type) {
          case "NewExpression":
            if (!node2.arguments.length && !(astUtils2.isOpeningParenToken(
              sourceCode2.getLastToken(node2, { skip: 1 })
            ) && astUtils2.isClosingParenToken(
              sourceCode2.getLastToken(node2)
            ) && node2.callee.range[1] < node2.range[1])) {
              return null;
            }
          case "CallExpression":
            return {
              leftParen: sourceCode2.getTokenAfter(
                node2.callee,
                astUtils2.isOpeningParenToken
              ),
              rightParen: sourceCode2.getLastToken(node2)
            };
          case "FunctionDeclaration":
          case "FunctionExpression": {
            const leftParen = sourceCode2.getFirstToken(
              node2,
              astUtils2.isOpeningParenToken
            );
            const rightParen = node2.params.length ? sourceCode2.getTokenAfter(
              node2.params.at(-1),
              astUtils2.isClosingParenToken
            ) : sourceCode2.getTokenAfter(leftParen);
            return { leftParen, rightParen };
          }
          case "ArrowFunctionExpression": {
            const firstToken = sourceCode2.getFirstToken(node2, {
              skip: node2.async ? 1 : 0
            });
            if (!astUtils2.isOpeningParenToken(firstToken)) {
              return null;
            }
            const rightParen = node2.params.length ? sourceCode2.getTokenAfter(
              node2.params.at(-1),
              astUtils2.isClosingParenToken
            ) : sourceCode2.getTokenAfter(firstToken);
            return {
              leftParen: firstToken,
              rightParen
            };
          }
          case "ImportExpression": {
            const leftParen = sourceCode2.getFirstToken(node2, 1);
            const rightParen = sourceCode2.getLastToken(node2);
            return { leftParen, rightParen };
          }
          default:
            throw new TypeError(
              `unexpected node with type ${node2.type}`
            );
        }
      }
      return {
        [[
          "ArrowFunctionExpression",
          "CallExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "ImportExpression",
          "NewExpression"
        ]](node2) {
          const parens = getParenTokens(node2);
          let params;
          if (node2.type === "ImportExpression") {
            params = [node2.source];
          } else if (astUtils2.isFunction(node2)) {
            params = node2.params;
          } else {
            params = node2.arguments;
          }
          if (parens) {
            validateParens(parens, params);
            if (multilineArgumentsOption) {
              validateArguments(parens, params);
            }
          }
        }
      };
    }
  };
  return functionParenNewline;
}
var generatorStarSpacing;
var hasRequiredGeneratorStarSpacing;
function requireGeneratorStarSpacing() {
  if (hasRequiredGeneratorStarSpacing) return generatorStarSpacing;
  hasRequiredGeneratorStarSpacing = 1;
  const OVERRIDE_SCHEMA = {
    oneOf: [
      {
        enum: ["before", "after", "both", "neither"]
      },
      {
        type: "object",
        properties: {
          before: { type: "boolean" },
          after: { type: "boolean" }
        },
        additionalProperties: false
      }
    ]
  };
  generatorStarSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "generator-star-spacing",
              url: "https://eslint.style/rules/generator-star-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing around `*` operators in generator functions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/generator-star-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["before", "after", "both", "neither"]
            },
            {
              type: "object",
              properties: {
                before: { type: "boolean" },
                after: { type: "boolean" },
                named: OVERRIDE_SCHEMA,
                anonymous: OVERRIDE_SCHEMA,
                method: OVERRIDE_SCHEMA
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        missingBefore: "Missing space before *.",
        missingAfter: "Missing space after *.",
        unexpectedBefore: "Unexpected space before *.",
        unexpectedAfter: "Unexpected space after *."
      }
    },
    create(context) {
      const optionDefinitions = {
        before: { before: true, after: false },
        after: { before: false, after: true },
        both: { before: true, after: true },
        neither: { before: false, after: false }
      };
      function optionToDefinition(option, defaults2) {
        if (!option) {
          return defaults2;
        }
        return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults2, option);
      }
      const modes = function(option) {
        const defaults2 = optionToDefinition(
          option,
          optionDefinitions.before
        );
        return {
          named: optionToDefinition(option.named, defaults2),
          anonymous: optionToDefinition(option.anonymous, defaults2),
          method: optionToDefinition(option.method, defaults2)
        };
      }(context.options[0] || {});
      const sourceCode2 = context.sourceCode;
      function isStarToken(token) {
        return token.value === "*" && token.type === "Punctuator";
      }
      function getStarToken(node2) {
        return sourceCode2.getFirstToken(
          node2.parent.method || node2.parent.type === "MethodDefinition" ? node2.parent : node2,
          isStarToken
        );
      }
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      function checkSpacing(kind, side, leftToken, rightToken) {
        if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
          const after = leftToken.value === "*";
          const spaceRequired = modes[kind][side];
          const node2 = after ? leftToken : rightToken;
          const messageId = `${spaceRequired ? "missing" : "unexpected"}${capitalize(side)}`;
          context.report({
            node: node2,
            messageId,
            fix(fixer) {
              if (spaceRequired) {
                if (after) {
                  return fixer.insertTextAfter(node2, " ");
                }
                return fixer.insertTextBefore(node2, " ");
              }
              return fixer.removeRange([
                leftToken.range[1],
                rightToken.range[0]
              ]);
            }
          });
        }
      }
      function checkFunction(node2) {
        if (!node2.generator) {
          return;
        }
        const starToken = getStarToken(node2);
        const prevToken = sourceCode2.getTokenBefore(starToken);
        const nextToken = sourceCode2.getTokenAfter(starToken);
        let kind = "named";
        if (node2.parent.type === "MethodDefinition" || node2.parent.type === "Property" && node2.parent.method) {
          kind = "method";
        } else if (!node2.id) {
          kind = "anonymous";
        }
        if (!(kind === "method" && starToken === sourceCode2.getFirstToken(node2.parent))) {
          checkSpacing(kind, "before", prevToken, starToken);
        }
        checkSpacing(kind, "after", starToken, nextToken);
      }
      return {
        FunctionDeclaration: checkFunction,
        FunctionExpression: checkFunction
      };
    }
  };
  return generatorStarSpacing;
}
var getterReturn;
var hasRequiredGetterReturn;
function requireGetterReturn() {
  if (hasRequiredGetterReturn) return getterReturn;
  hasRequiredGetterReturn = 1;
  const astUtils2 = requireAstUtils();
  const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
  function isAnySegmentReachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return true;
      }
    }
    return false;
  }
  getterReturn = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowImplicit: false
        }
      ],
      docs: {
        description: "Enforce `return` statements in getters",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/getter-return"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowImplicit: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expected: "Expected to return a value in {{name}}.",
        expectedAlways: "Expected {{name}} to always return a value."
      }
    },
    create(context) {
      const [{ allowImplicit }] = context.options;
      const sourceCode2 = context.sourceCode;
      let funcInfo = {
        upper: null,
        codePath: null,
        hasReturn: false,
        shouldCheck: false,
        node: null,
        currentSegments: []
      };
      function checkLastSegment(node2) {
        if (funcInfo.shouldCheck && isAnySegmentReachable(funcInfo.currentSegments)) {
          context.report({
            node: node2,
            loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
            messageId: funcInfo.hasReturn ? "expectedAlways" : "expected",
            data: {
              name: astUtils2.getFunctionNameWithKind(funcInfo.node)
            }
          });
        }
      }
      function isGetter(node2) {
        const parent = node2.parent;
        if (TARGET_NODE_TYPE.test(node2.type) && node2.body.type === "BlockStatement") {
          if (parent.kind === "get") {
            return true;
          }
          if (parent.type === "Property" && astUtils2.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
            if (parent.parent.parent.type === "CallExpression") {
              const callNode = parent.parent.parent.callee;
              if (astUtils2.isSpecificMemberAccess(
                callNode,
                "Object",
                "defineProperty"
              ) || astUtils2.isSpecificMemberAccess(
                callNode,
                "Reflect",
                "defineProperty"
              )) {
                return true;
              }
            }
            if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression") {
              const callNode = parent.parent.parent.parent.parent.callee;
              return astUtils2.isSpecificMemberAccess(
                callNode,
                "Object",
                "defineProperties"
              ) || astUtils2.isSpecificMemberAccess(
                callNode,
                "Object",
                "create"
              );
            }
          }
        }
        return false;
      }
      return {
        // Stacks this function's information.
        onCodePathStart(codePath2, node2) {
          funcInfo = {
            upper: funcInfo,
            codePath: codePath2,
            hasReturn: false,
            shouldCheck: isGetter(node2),
            node: node2,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        // Pops this function's information.
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        onUnreachableCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        onCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        // Checks the return statement is valid.
        ReturnStatement(node2) {
          if (funcInfo.shouldCheck) {
            funcInfo.hasReturn = true;
            if (!allowImplicit && !node2.argument) {
              context.report({
                node: node2,
                messageId: "expected",
                data: {
                  name: astUtils2.getFunctionNameWithKind(
                    funcInfo.node
                  )
                }
              });
            }
          }
        },
        // Reports a given function if the last path is reachable.
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
      };
    }
  };
  return getterReturn;
}
var globalRequire;
var hasRequiredGlobalRequire;
function requireGlobalRequire() {
  if (hasRequiredGlobalRequire) return globalRequire;
  hasRequiredGlobalRequire = 1;
  const ACCEPTABLE_PARENTS = /* @__PURE__ */ new Set([
    "AssignmentExpression",
    "VariableDeclarator",
    "MemberExpression",
    "ExpressionStatement",
    "CallExpression",
    "ConditionalExpression",
    "Program",
    "VariableDeclaration",
    "ChainExpression"
  ]);
  function findReference(scope, node2) {
    const references = scope.references.filter(
      (reference) => reference.identifier.range[0] === node2.range[0] && reference.identifier.range[1] === node2.range[1]
    );
    if (references.length === 1) {
      return references[0];
    }
    return null;
  }
  function isShadowed(scope, node2) {
    const reference = findReference(scope, node2);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
  }
  globalRequire = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "global-require",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/global-require.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Require `require()` calls to be placed at top-level module scope",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/global-require"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected require()."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        CallExpression(node2) {
          const currentScope = sourceCode2.getScope(node2);
          if (node2.callee.name === "require" && !isShadowed(currentScope, node2.callee)) {
            const isGoodRequire = sourceCode2.getAncestors(node2).every((parent) => ACCEPTABLE_PARENTS.has(parent.type));
            if (!isGoodRequire) {
              context.report({ node: node2, messageId: "unexpected" });
            }
          }
        }
      };
    }
  };
  return globalRequire;
}
var groupedAccessorPairs;
var hasRequiredGroupedAccessorPairs;
function requireGroupedAccessorPairs() {
  if (hasRequiredGroupedAccessorPairs) return groupedAccessorPairs;
  hasRequiredGroupedAccessorPairs = 1;
  const astUtils2 = requireAstUtils();
  function areEqualTokenLists(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i2 = 0; i2 < left.length; i2++) {
      const leftToken = left[i2], rightToken = right[i2];
      if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
        return false;
      }
    }
    return true;
  }
  function areEqualKeys(left, right) {
    if (typeof left === "string" && typeof right === "string") {
      return left === right;
    }
    if (Array.isArray(left) && Array.isArray(right)) {
      return areEqualTokenLists(left, right);
    }
    return false;
  }
  function isAccessorKind(node2) {
    return node2.kind === "get" || node2.kind === "set";
  }
  groupedAccessorPairs = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        "anyOrder",
        {
          enforceForTSTypes: false
        }
      ],
      docs: {
        description: "Require grouped accessor pairs in object literals and classes",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/grouped-accessor-pairs"
      },
      schema: [
        { enum: ["anyOrder", "getBeforeSet", "setBeforeGet"] },
        {
          type: "object",
          properties: {
            enforceForTSTypes: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
        invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
      }
    },
    create(context) {
      const [order, { enforceForTSTypes }] = context.options;
      const { sourceCode: sourceCode2 } = context;
      function report(messageId, formerNode, latterNode) {
        context.report({
          node: latterNode,
          messageId,
          loc: astUtils2.getFunctionHeadLoc(
            latterNode.type !== "TSMethodSignature" ? latterNode.value : latterNode,
            sourceCode2
          ),
          data: {
            formerName: astUtils2.getFunctionNameWithKind(
              formerNode.type !== "TSMethodSignature" ? formerNode.value : formerNode
            ),
            latterName: astUtils2.getFunctionNameWithKind(
              latterNode.type !== "TSMethodSignature" ? latterNode.value : latterNode
            )
          }
        });
      }
      function checkList(nodes, shouldCheck) {
        const accessors = [];
        let found = false;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node2 = nodes[i2];
          if (shouldCheck(node2) && isAccessorKind(node2)) {
            const name2 = astUtils2.getStaticPropertyName(node2);
            const key = name2 !== null ? name2 : sourceCode2.getTokens(node2.key);
            for (let j = 0; j < accessors.length; j++) {
              const accessor = accessors[j];
              if (areEqualKeys(accessor.key, key)) {
                accessor.getters.push(
                  ...node2.kind === "get" ? [node2] : []
                );
                accessor.setters.push(
                  ...node2.kind === "set" ? [node2] : []
                );
                found = true;
                break;
              }
            }
            if (!found) {
              accessors.push({
                key,
                getters: node2.kind === "get" ? [node2] : [],
                setters: node2.kind === "set" ? [node2] : []
              });
            }
            found = false;
          }
        }
        for (const { getters, setters } of accessors) {
          if (getters.length === 1 && setters.length === 1) {
            const [getter] = getters, [setter] = setters, getterIndex = nodes.indexOf(getter), setterIndex = nodes.indexOf(setter), formerNode = getterIndex < setterIndex ? getter : setter, latterNode = getterIndex < setterIndex ? setter : getter;
            if (Math.abs(getterIndex - setterIndex) > 1) {
              report("notGrouped", formerNode, latterNode);
            } else if (order === "getBeforeSet" && getterIndex > setterIndex || order === "setBeforeGet" && getterIndex < setterIndex) {
              report("invalidOrder", formerNode, latterNode);
            }
          }
        }
      }
      return {
        ObjectExpression(node2) {
          checkList(node2.properties, (n2) => n2.type === "Property");
        },
        ClassBody(node2) {
          checkList(
            node2.body,
            (n2) => n2.type === "MethodDefinition" && !n2.static
          );
          checkList(
            node2.body,
            (n2) => n2.type === "MethodDefinition" && n2.static
          );
        },
        "TSTypeLiteral, TSInterfaceBody"(node2) {
          if (enforceForTSTypes) {
            checkList(
              node2.type === "TSTypeLiteral" ? node2.members : node2.body,
              (n2) => n2.type === "TSMethodSignature"
            );
          }
        }
      };
    }
  };
  return groupedAccessorPairs;
}
var guardForIn;
var hasRequiredGuardForIn;
function requireGuardForIn() {
  if (hasRequiredGuardForIn) return guardForIn;
  hasRequiredGuardForIn = 1;
  guardForIn = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `for-in` loops to include an `if` statement",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/guard-for-in"
      },
      schema: [],
      messages: {
        wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
      }
    },
    create(context) {
      return {
        ForInStatement(node2) {
          const body = node2.body;
          if (body.type === "EmptyStatement") {
            return;
          }
          if (body.type === "IfStatement") {
            return;
          }
          if (body.type === "BlockStatement" && body.body.length === 0) {
            return;
          }
          if (body.type === "BlockStatement" && body.body.length === 1 && body.body[0].type === "IfStatement") {
            return;
          }
          if (body.type === "BlockStatement" && body.body.length >= 1 && body.body[0].type === "IfStatement") {
            const i2 = body.body[0];
            if (i2.consequent.type === "ContinueStatement") {
              return;
            }
            if (i2.consequent.type === "BlockStatement" && i2.consequent.body.length === 1 && i2.consequent.body[0].type === "ContinueStatement") {
              return;
            }
          }
          context.report({ node: node2, messageId: "wrap" });
        }
      };
    }
  };
  return guardForIn;
}
var handleCallbackErr;
var hasRequiredHandleCallbackErr;
function requireHandleCallbackErr() {
  if (hasRequiredHandleCallbackErr) return handleCallbackErr;
  hasRequiredHandleCallbackErr = 1;
  handleCallbackErr = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "handle-callback-err",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/handle-callback-err.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Require error handling in callbacks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/handle-callback-err"
      },
      schema: [
        {
          type: "string"
        }
      ],
      messages: {
        expected: "Expected error to be handled."
      }
    },
    create(context) {
      const errorArgument = context.options[0] || "err";
      const sourceCode2 = context.sourceCode;
      function isPattern(stringToCheck) {
        const firstChar = stringToCheck[0];
        return firstChar === "^";
      }
      function matchesConfiguredErrorName(name2) {
        if (isPattern(errorArgument)) {
          const regexp = new RegExp(errorArgument, "u");
          return regexp.test(name2);
        }
        return name2 === errorArgument;
      }
      function getParameters(scope) {
        return scope.variables.filter(
          (variable) => variable.defs[0] && variable.defs[0].type === "Parameter"
        );
      }
      function checkForError(node2) {
        const scope = sourceCode2.getScope(node2), parameters = getParameters(scope), firstParameter = parameters[0];
        if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
          if (firstParameter.references.length === 0) {
            context.report({ node: node2, messageId: "expected" });
          }
        }
      }
      return {
        FunctionDeclaration: checkForError,
        FunctionExpression: checkForError,
        ArrowFunctionExpression: checkForError
      };
    }
  };
  return handleCallbackErr;
}
var idBlacklist;
var hasRequiredIdBlacklist;
function requireIdBlacklist() {
  if (hasRequiredIdBlacklist) return idBlacklist;
  hasRequiredIdBlacklist = 1;
  function isAssignmentTarget(node2) {
    const parent = node2.parent;
    return (
      // normal assignment
      parent.type === "AssignmentExpression" && parent.left === node2 || // destructuring
      parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node2 && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node2
    );
  }
  function isRenamedImport(node2) {
    const parent = node2.parent;
    return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node2 || parent.type === "ExportSpecifier" && parent.parent.source && // re-export
    parent.local !== parent.exported && parent.local === node2;
  }
  function isRenamedInDestructuring(node2) {
    const parent = node2.parent;
    return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.value !== node2 && parent.key === node2;
  }
  function isShorthandPropertyDefinition(node2) {
    const parent = node2.parent;
    return parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.shorthand;
  }
  idBlacklist = {
    meta: {
      deprecated: {
        message: "The rule was renamed.",
        url: "https://eslint.org/blog/2020/07/eslint-v7.5.0-released/#deprecating-id-blacklist",
        deprecatedSince: "7.5.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            rule: {
              name: "id-denylist",
              url: "https://eslint.org/docs/rules/id-denylist"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow specified identifiers",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/id-blacklist"
      },
      schema: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true
      },
      messages: {
        restricted: "Identifier '{{name}}' is restricted."
      }
    },
    create(context) {
      const denyList = new Set(context.options);
      const reportedNodes = /* @__PURE__ */ new Set();
      const sourceCode2 = context.sourceCode;
      let globalScope;
      function isRestricted(name2) {
        return denyList.has(name2);
      }
      function isReferenceToGlobalVariable(node2) {
        const variable = globalScope.set.get(node2.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref2) => ref2.identifier === node2);
      }
      function shouldCheck(node2) {
        const parent = node2.parent;
        if (parent.type === "MemberExpression" && parent.property === node2 && !parent.computed) {
          return isAssignmentTarget(parent);
        }
        return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node2) && !isRenamedInDestructuring(node2) && !(isReferenceToGlobalVariable(node2) && !isShorthandPropertyDefinition(node2));
      }
      function report(node2) {
        if (!reportedNodes.has(node2.range.toString())) {
          context.report({
            node: node2,
            messageId: "restricted",
            data: {
              name: node2.name
            }
          });
          reportedNodes.add(node2.range.toString());
        }
      }
      return {
        Program(node2) {
          globalScope = sourceCode2.getScope(node2);
        },
        Identifier(node2) {
          if (isRestricted(node2.name) && shouldCheck(node2)) {
            report(node2);
          }
        }
      };
    }
  };
  return idBlacklist;
}
var idDenylist;
var hasRequiredIdDenylist;
function requireIdDenylist() {
  if (hasRequiredIdDenylist) return idDenylist;
  hasRequiredIdDenylist = 1;
  const astUtils2 = requireAstUtils();
  function isAssignmentTarget(node2) {
    const parent = node2.parent;
    return (
      // normal assignment
      parent.type === "AssignmentExpression" && parent.left === node2 || // destructuring
      parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node2 && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node2
    );
  }
  function isRenamedImport(node2) {
    const parent = node2.parent;
    return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node2 || parent.type === "ExportSpecifier" && parent.parent.source && // re-export
    parent.local !== parent.exported && parent.local === node2;
  }
  function isPropertyNameInDestructuring(node2) {
    const parent = node2.parent;
    return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.key === node2;
  }
  idDenylist = {
    meta: {
      type: "suggestion",
      defaultOptions: [],
      docs: {
        description: "Disallow specified identifiers",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/id-denylist"
      },
      schema: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true
      },
      messages: {
        restricted: "Identifier '{{name}}' is restricted.",
        restrictedPrivate: "Identifier '#{{name}}' is restricted."
      }
    },
    create(context) {
      const denyList = new Set(context.options);
      const reportedNodes = /* @__PURE__ */ new Set();
      const sourceCode2 = context.sourceCode;
      let globalScope;
      function isRestricted(name2) {
        return denyList.has(name2);
      }
      function isReferenceToGlobalVariable(node2) {
        const variable = globalScope.set.get(node2.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref2) => ref2.identifier === node2);
      }
      function shouldCheck(node2) {
        if (astUtils2.isImportAttributeKey(node2)) {
          return false;
        }
        const parent = node2.parent;
        if (parent.type === "MemberExpression" && parent.property === node2 && !parent.computed) {
          return isAssignmentTarget(parent);
        }
        return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node2) && !isPropertyNameInDestructuring(node2) && !isReferenceToGlobalVariable(node2);
      }
      function report(node2) {
        if (!reportedNodes.has(node2.range.toString())) {
          const isPrivate = node2.type === "PrivateIdentifier";
          context.report({
            node: node2,
            messageId: isPrivate ? "restrictedPrivate" : "restricted",
            data: {
              name: node2.name
            }
          });
          reportedNodes.add(node2.range.toString());
        }
      }
      return {
        Program(node2) {
          globalScope = sourceCode2.getScope(node2);
        },
        [["Identifier", "PrivateIdentifier"]](node2) {
          if (isRestricted(node2.name) && shouldCheck(node2)) {
            report(node2);
          }
        }
      };
    }
  };
  return idDenylist;
}
var idLength;
var hasRequiredIdLength;
function requireIdLength() {
  if (hasRequiredIdLength) return idLength;
  hasRequiredIdLength = 1;
  const { getGraphemeCount } = requireStringUtils();
  const {
    getModuleExportName,
    isImportAttributeKey
  } = requireAstUtils();
  idLength = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          exceptionPatterns: [],
          exceptions: [],
          min: 2,
          properties: "always"
        }
      ],
      docs: {
        description: "Enforce minimum and maximum identifier lengths",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/id-length"
      },
      schema: [
        {
          type: "object",
          properties: {
            min: {
              type: "integer"
            },
            max: {
              type: "integer"
            },
            exceptions: {
              type: "array",
              uniqueItems: true,
              items: {
                type: "string"
              }
            },
            exceptionPatterns: {
              type: "array",
              uniqueItems: true,
              items: {
                type: "string"
              }
            },
            properties: {
              enum: ["always", "never"]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
        tooShortPrivate: "Identifier name '#{{name}}' is too short (< {{min}}).",
        tooLong: "Identifier name '{{name}}' is too long (> {{max}}).",
        tooLongPrivate: "Identifier name #'{{name}}' is too long (> {{max}})."
      }
    },
    create(context) {
      const [options] = context.options;
      const { max: maxLength = Infinity, min: minLength } = options;
      const properties2 = options.properties !== "never";
      const exceptions = new Set(options.exceptions);
      const exceptionPatterns = options.exceptionPatterns.map(
        (pattern2) => new RegExp(pattern2, "u")
      );
      const reportedNodes = /* @__PURE__ */ new Set();
      function matchesExceptionPattern(name2) {
        return exceptionPatterns.some((pattern2) => pattern2.test(name2));
      }
      const SUPPORTED_EXPRESSIONS = {
        MemberExpression: properties2 && function(parent) {
          return !parent.computed && // regular property assignment
          (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" || // or the last identifier in an ObjectPattern destructuring
          parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
        },
        AssignmentPattern(parent, node2) {
          return parent.left === node2;
        },
        VariableDeclarator(parent, node2) {
          return parent.id === node2;
        },
        Property(parent, node2) {
          if (parent.parent.type === "ObjectPattern") {
            const isKeyAndValueSame = parent.value.name === parent.key.name;
            return !isKeyAndValueSame && parent.value === node2 || isKeyAndValueSame && parent.key === node2 && properties2;
          }
          return properties2 && !isImportAttributeKey(node2) && !parent.computed && parent.key.name === node2.name;
        },
        ImportSpecifier(parent, node2) {
          return parent.local === node2 && getModuleExportName(parent.imported) !== getModuleExportName(parent.local);
        },
        ImportDefaultSpecifier: true,
        ImportNamespaceSpecifier: true,
        RestElement: true,
        FunctionExpression: true,
        ArrowFunctionExpression: true,
        ClassDeclaration: true,
        FunctionDeclaration: true,
        MethodDefinition: true,
        PropertyDefinition: true,
        CatchClause: true,
        ArrayPattern: true
      };
      return {
        [["Identifier", "PrivateIdentifier"]](node2) {
          const name2 = node2.name;
          const parent = node2.parent;
          const nameLength = getGraphemeCount(name2);
          const isShort = nameLength < minLength;
          const isLong = nameLength > maxLength;
          if (!(isShort || isLong) || exceptions.has(name2) || matchesExceptionPattern(name2)) {
            return;
          }
          const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];
          if (isValidExpression && !reportedNodes.has(node2.range.toString()) && (isValidExpression === true || isValidExpression(parent, node2))) {
            reportedNodes.add(node2.range.toString());
            let messageId = isShort ? "tooShort" : "tooLong";
            if (node2.type === "PrivateIdentifier") {
              messageId += "Private";
            }
            context.report({
              node: node2,
              messageId,
              data: { name: name2, min: minLength, max: maxLength }
            });
          }
        }
      };
    }
  };
  return idLength;
}
var idMatch;
var hasRequiredIdMatch;
function requireIdMatch() {
  if (hasRequiredIdMatch) return idMatch;
  hasRequiredIdMatch = 1;
  const astUtils2 = requireAstUtils();
  idMatch = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        "^.+$",
        {
          classFields: false,
          ignoreDestructuring: false,
          onlyDeclarations: false,
          properties: false
        }
      ],
      docs: {
        description: "Require identifiers to match a specified regular expression",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/id-match"
      },
      schema: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            properties: {
              type: "boolean"
            },
            classFields: {
              type: "boolean"
            },
            onlyDeclarations: {
              type: "boolean"
            },
            ignoreDestructuring: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
        notMatchPrivate: "Identifier '#{{name}}' does not match the pattern '{{pattern}}'."
      }
    },
    create(context) {
      const [
        pattern2,
        {
          classFields: checkClassFields,
          ignoreDestructuring,
          onlyDeclarations,
          properties: checkProperties
        }
      ] = context.options;
      const regexp = new RegExp(pattern2, "u");
      const sourceCode2 = context.sourceCode;
      let globalScope;
      const reportedNodes = /* @__PURE__ */ new Set();
      const ALLOWED_PARENT_TYPES = /* @__PURE__ */ new Set([
        "CallExpression",
        "NewExpression"
      ]);
      const DECLARATION_TYPES = /* @__PURE__ */ new Set([
        "FunctionDeclaration",
        "VariableDeclarator"
      ]);
      const IMPORT_TYPES = /* @__PURE__ */ new Set([
        "ImportSpecifier",
        "ImportNamespaceSpecifier",
        "ImportDefaultSpecifier"
      ]);
      function isReferenceToGlobalVariable(node2) {
        const variable = globalScope.set.get(node2.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref2) => ref2.identifier === node2);
      }
      function isInvalid(name2) {
        return !regexp.test(name2);
      }
      function isInsideObjectPattern(node2) {
        let { parent } = node2;
        while (parent) {
          if (parent.type === "ObjectPattern") {
            return true;
          }
          parent = parent.parent;
        }
        return false;
      }
      function shouldReport(effectiveParent, name2) {
        return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name2);
      }
      function report(node2) {
        if (!reportedNodes.has(node2.range.toString())) {
          const messageId = node2.type === "PrivateIdentifier" ? "notMatchPrivate" : "notMatch";
          context.report({
            node: node2,
            messageId,
            data: {
              name: node2.name,
              pattern: pattern2
            }
          });
          reportedNodes.add(node2.range.toString());
        }
      }
      return {
        Program(node2) {
          globalScope = sourceCode2.getScope(node2);
        },
        Identifier(node2) {
          const name2 = node2.name, parent = node2.parent, effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;
          if (isReferenceToGlobalVariable(node2) || astUtils2.isImportAttributeKey(node2)) {
            return;
          }
          if (parent.type === "MemberExpression") {
            if (!checkProperties) {
              return;
            }
            if (parent.object.type === "Identifier" && parent.object.name === name2) {
              if (isInvalid(name2)) {
                report(node2);
              }
            } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node2.name) {
              if (isInvalid(name2)) {
                report(node2);
              }
            } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.right.type !== "MemberExpression") {
              if (isInvalid(name2)) {
                report(node2);
              }
            }
          } else if (parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.key === node2 && !parent.computed) {
            if (checkProperties && isInvalid(name2)) {
              report(node2);
            }
          } else if (parent.type === "Property" || parent.type === "AssignmentPattern") {
            if (parent.parent && parent.parent.type === "ObjectPattern") {
              if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name2)) {
                report(node2);
              }
              const assignmentKeyEqualsValue = parent.key.name === parent.value.name;
              if (!assignmentKeyEqualsValue && parent.key === node2) {
                return;
              }
              const valueIsInvalid = parent.value.name && isInvalid(name2);
              if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
                report(node2);
              }
            }
            if (!checkProperties && !parent.computed || ignoreDestructuring && isInsideObjectPattern(node2)) {
              return;
            }
            if (parent.right !== node2 && shouldReport(effectiveParent, name2)) {
              report(node2);
            }
          } else if (IMPORT_TYPES.has(parent.type)) {
            if (parent.local && parent.local.name === node2.name && isInvalid(name2)) {
              report(node2);
            }
          } else if (parent.type === "PropertyDefinition") {
            if (checkClassFields && isInvalid(name2)) {
              report(node2);
            }
          } else if (shouldReport(effectiveParent, name2)) {
            report(node2);
          }
        },
        PrivateIdentifier(node2) {
          const isClassField = node2.parent.type === "PropertyDefinition";
          if (isClassField && !checkClassFields) {
            return;
          }
          if (isInvalid(node2.name)) {
            report(node2);
          }
        }
      };
    }
  };
  return idMatch;
}
var implicitArrowLinebreak;
var hasRequiredImplicitArrowLinebreak;
function requireImplicitArrowLinebreak() {
  if (hasRequiredImplicitArrowLinebreak) return implicitArrowLinebreak;
  hasRequiredImplicitArrowLinebreak = 1;
  const { isCommentToken, isNotOpeningParenToken } = requireAstUtils();
  implicitArrowLinebreak = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "implicit-arrow-linebreak",
              url: "https://eslint.style/rules/implicit-arrow-linebreak"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce the location of arrow function bodies",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/implicit-arrow-linebreak"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["beside", "below"]
        }
      ],
      messages: {
        expected: "Expected a linebreak before this expression.",
        unexpected: "Expected no linebreak before this expression."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const option = context.options[0] || "beside";
      function validateExpression(node2) {
        if (node2.body.type === "BlockStatement") {
          return;
        }
        const arrowToken = sourceCode2.getTokenBefore(
          node2.body,
          isNotOpeningParenToken
        );
        const firstTokenOfBody = sourceCode2.getTokenAfter(arrowToken);
        if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === "below") {
          context.report({
            node: firstTokenOfBody,
            messageId: "expected",
            fix: (fixer) => fixer.insertTextBefore(firstTokenOfBody, "\n")
          });
        } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === "beside") {
          context.report({
            node: firstTokenOfBody,
            messageId: "unexpected",
            fix(fixer) {
              if (sourceCode2.getFirstTokenBetween(
                arrowToken,
                firstTokenOfBody,
                {
                  includeComments: true,
                  filter: isCommentToken
                }
              )) {
                return null;
              }
              return fixer.replaceTextRange(
                [arrowToken.range[1], firstTokenOfBody.range[0]],
                " "
              );
            }
          });
        }
      }
      return {
        ArrowFunctionExpression: (node2) => validateExpression(node2)
      };
    }
  };
  return implicitArrowLinebreak;
}
var indent;
var hasRequiredIndent;
function requireIndent() {
  if (hasRequiredIndent) return indent;
  hasRequiredIndent = 1;
  const astUtils2 = requireAstUtils();
  const KNOWN_NODES = /* @__PURE__ */ new Set([
    "AssignmentExpression",
    "AssignmentPattern",
    "ArrayExpression",
    "ArrayPattern",
    "ArrowFunctionExpression",
    "AwaitExpression",
    "BlockStatement",
    "BinaryExpression",
    "BreakStatement",
    "CallExpression",
    "CatchClause",
    "ChainExpression",
    "ClassBody",
    "ClassDeclaration",
    "ClassExpression",
    "ConditionalExpression",
    "ContinueStatement",
    "DoWhileStatement",
    "DebuggerStatement",
    "EmptyStatement",
    "ExperimentalRestProperty",
    "ExperimentalSpreadProperty",
    "ExpressionStatement",
    "ForStatement",
    "ForInStatement",
    "ForOfStatement",
    "FunctionDeclaration",
    "FunctionExpression",
    "Identifier",
    "IfStatement",
    "Literal",
    "LabeledStatement",
    "LogicalExpression",
    "MemberExpression",
    "MetaProperty",
    "MethodDefinition",
    "NewExpression",
    "ObjectExpression",
    "ObjectPattern",
    "PrivateIdentifier",
    "Program",
    "Property",
    "PropertyDefinition",
    "RestElement",
    "ReturnStatement",
    "SequenceExpression",
    "SpreadElement",
    "StaticBlock",
    "Super",
    "SwitchCase",
    "SwitchStatement",
    "TaggedTemplateExpression",
    "TemplateElement",
    "TemplateLiteral",
    "ThisExpression",
    "ThrowStatement",
    "TryStatement",
    "UnaryExpression",
    "UpdateExpression",
    "VariableDeclaration",
    "VariableDeclarator",
    "WhileStatement",
    "WithStatement",
    "YieldExpression",
    "JSXFragment",
    "JSXOpeningFragment",
    "JSXClosingFragment",
    "JSXIdentifier",
    "JSXNamespacedName",
    "JSXMemberExpression",
    "JSXEmptyExpression",
    "JSXExpressionContainer",
    "JSXElement",
    "JSXClosingElement",
    "JSXOpeningElement",
    "JSXAttribute",
    "JSXSpreadAttribute",
    "JSXText",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration",
    "ExportSpecifier",
    "ImportDeclaration",
    "ImportSpecifier",
    "ImportDefaultSpecifier",
    "ImportNamespaceSpecifier",
    "ImportExpression"
  ]);
  class IndexMap {
    /**
     * Creates an empty map
     * @param {number} maxKey The maximum key
     */
    constructor(maxKey) {
      this._values = Array(maxKey + 1);
    }
    /**
     * Inserts an entry into the map.
     * @param {number} key The entry's key
     * @param {any} value The entry's value
     * @returns {void}
     */
    insert(key, value) {
      this._values[key] = value;
    }
    /**
     * Finds the value of the entry with the largest key less than or equal to the provided key
     * @param {number} key The provided key
     * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.
     */
    findLastNotAfter(key) {
      const values = this._values;
      for (let index = key; index >= 0; index--) {
        const value = values[index];
        if (value) {
          return value;
        }
      }
      return void 0;
    }
    /**
     * Deletes all of the keys in the interval [start, end)
     * @param {number} start The start of the range
     * @param {number} end The end of the range
     * @returns {void}
     */
    deleteRange(start, end) {
      this._values.fill(void 0, start, end);
    }
  }
  class TokenInfo {
    /**
     * @param {SourceCode} sourceCode A SourceCode object
     */
    constructor(sourceCode2) {
      this.sourceCode = sourceCode2;
      this.firstTokensByLineNumber = /* @__PURE__ */ new Map();
      const tokens = sourceCode2.tokensAndComments;
      for (let i2 = 0; i2 < tokens.length; i2++) {
        const token = tokens[i2];
        if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {
          this.firstTokensByLineNumber.set(token.loc.start.line, token);
        }
        if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode2.text.slice(
          token.range[1] - token.loc.end.column,
          token.range[1]
        ).trim()) {
          this.firstTokensByLineNumber.set(token.loc.end.line, token);
        }
      }
    }
    /**
     * Gets the first token on a given token's line
     * @param {Token|ASTNode} token a node or token
     * @returns {Token} The first token on the given line
     */
    getFirstTokenOfLine(token) {
      return this.firstTokensByLineNumber.get(token.loc.start.line);
    }
    /**
     * Determines whether a token is the first token in its line
     * @param {Token} token The token
     * @returns {boolean} `true` if the token is the first on its line
     */
    isFirstTokenOfLine(token) {
      return this.getFirstTokenOfLine(token) === token;
    }
    /**
     * Get the actual indent of a token
     * @param {Token} token Token to examine. This should be the first token on its line.
     * @returns {string} The indentation characters that precede the token
     */
    getTokenIndent(token) {
      return this.sourceCode.text.slice(
        token.range[0] - token.loc.start.column,
        token.range[0]
      );
    }
  }
  class OffsetStorage {
    /**
     * @param {TokenInfo} tokenInfo a TokenInfo instance
     * @param {number} indentSize The desired size of each indentation level
     * @param {string} indentType The indentation character
     * @param {number} maxIndex The maximum end index of any token
     */
    constructor(tokenInfo, indentSize, indentType, maxIndex) {
      this._tokenInfo = tokenInfo;
      this._indentSize = indentSize;
      this._indentType = indentType;
      this._indexMap = new IndexMap(maxIndex);
      this._indexMap.insert(0, { offset: 0, from: null, force: false });
      this._lockedFirstTokens = /* @__PURE__ */ new WeakMap();
      this._desiredIndentCache = /* @__PURE__ */ new WeakMap();
      this._ignoredTokens = /* @__PURE__ */ new WeakSet();
    }
    _getOffsetDescriptor(token) {
      return this._indexMap.findLastNotAfter(token.range[0]);
    }
    /**
     * Sets the offset column of token B to match the offset column of token A.
     * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
     * most cases, `setDesiredOffset` should be used instead.
     * @param {Token} baseToken The first token
     * @param {Token} offsetToken The second token, whose offset should be matched to the first token
     * @returns {void}
     */
    matchOffsetOf(baseToken, offsetToken) {
      this._lockedFirstTokens.set(offsetToken, baseToken);
    }
    /**
     * Sets the desired offset of a token.
     *
     * This uses a line-based offset collapsing behavior to handle tokens on the same line.
     * For example, consider the following two cases:
     *
     * (
     *     [
     *         bar
     *     ]
     * )
     *
     * ([
     *     bar
     * ])
     *
     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
     * from the start of its line.
     *
     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
     * between the `(` and the `[` tokens gets "collapsed" because the two tokens are on the same line. As a result, the
     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
     * by 1 indent level from the start of the line.
     *
     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
     * without needing to check which lines those tokens are on.
     *
     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
     * behavior can occur. For example, consider the following cases:
     *
     * foo(
     * ).
     *     bar(
     *         baz
     *     )
     *
     * foo(
     * ).bar(
     *     baz
     * )
     *
     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
     * collapsing would occur).
     *
     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
     * in the second case.
     * @param {Token} token The token
     * @param {Token} fromToken The token that `token` should be offset from
     * @param {number} offset The desired indent level
     * @returns {void}
     */
    setDesiredOffset(token, fromToken, offset) {
      return this.setDesiredOffsets(token.range, fromToken, offset);
    }
    /**
     * Sets the desired offset of all tokens in a range
     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
     * it). This means that the offset of each token is updated O(AST depth) times.
     * It would not be performant to store and update the offsets for each token independently, because the rule would end
     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
     *
     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
     * list could represent the state of the offset tree at a given point:
     *
     * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file
     * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
     * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
     * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
     * - Tokens starting in the interval [820, ∞) are offset by 1 indent level from the `baz` token
     *
     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
     * `setDesiredOffsets([30, 43], fooToken, 1);`
     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.
     * @param {Token} fromToken The token that this is offset from
     * @param {number} offset The desired indent level
     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
     * @returns {void}
     */
    setDesiredOffsets(range, fromToken, offset, force) {
      const descriptorToInsert = { offset, from: fromToken, force };
      const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);
      const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
      const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
      this._indexMap.deleteRange(range[0] + 1, range[1]);
      this._indexMap.insert(range[0], descriptorToInsert);
      if (fromTokenIsInRange) {
        this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);
        this._indexMap.insert(fromToken.range[1], descriptorToInsert);
      }
      this._indexMap.insert(range[1], descriptorAfterRange);
    }
    /**
     * Gets the desired indent of a token
     * @param {Token} token The token
     * @returns {string} The desired indent of the token
     */
    getDesiredIndent(token) {
      if (!this._desiredIndentCache.has(token)) {
        if (this._ignoredTokens.has(token)) {
          this._desiredIndentCache.set(
            token,
            this._tokenInfo.getTokenIndent(token)
          );
        } else if (this._lockedFirstTokens.has(token)) {
          const firstToken = this._lockedFirstTokens.get(token);
          this._desiredIndentCache.set(
            token,
            // (indentation for the first element's line)
            this.getDesiredIndent(
              this._tokenInfo.getFirstTokenOfLine(firstToken)
            ) + // (space between the start of the first element's line and the first element)
            this._indentType.repeat(
              firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column
            )
          );
        } else {
          const offsetInfo = this._getOffsetDescriptor(token);
          const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\s*?\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;
          this._desiredIndentCache.set(
            token,
            (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset)
          );
        }
      }
      return this._desiredIndentCache.get(token);
    }
    /**
     * Ignores a token, preventing it from being reported.
     * @param {Token} token The token
     * @returns {void}
     */
    ignoreToken(token) {
      if (this._tokenInfo.isFirstTokenOfLine(token)) {
        this._ignoredTokens.add(token);
      }
    }
    /**
     * Gets the first token that the given token's indentation is dependent on
     * @param {Token} token The token
     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
     */
    getFirstDependency(token) {
      return this._getOffsetDescriptor(token).from;
    }
  }
  const ELEMENT_LIST_SCHEMA = {
    oneOf: [
      {
        type: "integer",
        minimum: 0
      },
      {
        enum: ["first", "off"]
      }
    ]
  };
  indent = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "indent",
              url: "https://eslint.style/rules/indent"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent indentation",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/indent"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["tab"]
            },
            {
              type: "integer",
              minimum: 0
            }
          ]
        },
        {
          type: "object",
          properties: {
            SwitchCase: {
              type: "integer",
              minimum: 0,
              default: 0
            },
            VariableDeclarator: {
              oneOf: [
                ELEMENT_LIST_SCHEMA,
                {
                  type: "object",
                  properties: {
                    var: ELEMENT_LIST_SCHEMA,
                    let: ELEMENT_LIST_SCHEMA,
                    const: ELEMENT_LIST_SCHEMA
                  },
                  additionalProperties: false
                }
              ]
            },
            outerIIFEBody: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["off"]
                }
              ]
            },
            MemberExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["off"]
                }
              ]
            },
            FunctionDeclaration: {
              type: "object",
              properties: {
                parameters: ELEMENT_LIST_SCHEMA,
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            },
            FunctionExpression: {
              type: "object",
              properties: {
                parameters: ELEMENT_LIST_SCHEMA,
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            },
            StaticBlock: {
              type: "object",
              properties: {
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            },
            CallExpression: {
              type: "object",
              properties: {
                arguments: ELEMENT_LIST_SCHEMA
              },
              additionalProperties: false
            },
            ArrayExpression: ELEMENT_LIST_SCHEMA,
            ObjectExpression: ELEMENT_LIST_SCHEMA,
            ImportDeclaration: ELEMENT_LIST_SCHEMA,
            flatTernaryExpressions: {
              type: "boolean",
              default: false
            },
            offsetTernaryExpressions: {
              type: "boolean",
              default: false
            },
            ignoredNodes: {
              type: "array",
              items: {
                type: "string",
                not: {
                  pattern: ":exit$"
                }
              }
            },
            ignoreComments: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
      }
    },
    create(context) {
      const DEFAULT_VARIABLE_INDENT = 1;
      const DEFAULT_PARAMETER_INDENT = 1;
      const DEFAULT_FUNCTION_BODY_INDENT = 1;
      let indentType = "space";
      let indentSize = 4;
      const options = {
        SwitchCase: 0,
        VariableDeclarator: {
          var: DEFAULT_VARIABLE_INDENT,
          let: DEFAULT_VARIABLE_INDENT,
          const: DEFAULT_VARIABLE_INDENT
        },
        outerIIFEBody: 1,
        FunctionDeclaration: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        FunctionExpression: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        StaticBlock: {
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        CallExpression: {
          arguments: DEFAULT_PARAMETER_INDENT
        },
        MemberExpression: 1,
        ArrayExpression: 1,
        ObjectExpression: 1,
        ImportDeclaration: 1,
        flatTernaryExpressions: false,
        ignoredNodes: [],
        ignoreComments: false
      };
      if (context.options.length) {
        if (context.options[0] === "tab") {
          indentSize = 1;
          indentType = "tab";
        } else {
          indentSize = context.options[0];
          indentType = "space";
        }
        if (context.options[1]) {
          Object.assign(options, context.options[1]);
          if (typeof options.VariableDeclarator === "number" || options.VariableDeclarator === "first") {
            options.VariableDeclarator = {
              var: options.VariableDeclarator,
              let: options.VariableDeclarator,
              const: options.VariableDeclarator
            };
          }
        }
      }
      const sourceCode2 = context.sourceCode;
      const tokenInfo = new TokenInfo(sourceCode2);
      const offsets = new OffsetStorage(
        tokenInfo,
        indentSize,
        indentType === "space" ? " " : "	",
        sourceCode2.text.length
      );
      const parameterParens = /* @__PURE__ */ new WeakSet();
      function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
        const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
        const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
        const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
        let foundStatement;
        if (actualSpaces > 0) {
          foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
        } else if (actualTabs > 0) {
          foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
        } else {
          foundStatement = "0";
        }
        return {
          expected: expectedStatement,
          actual: foundStatement
        };
      }
      function report(token, neededIndent) {
        const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
        const numSpaces = actualIndent.filter((char) => char === " ").length;
        const numTabs = actualIndent.filter((char) => char === "	").length;
        context.report({
          node: token,
          messageId: "wrongIndentation",
          data: createErrorMessageData(
            neededIndent.length,
            numSpaces,
            numTabs
          ),
          loc: {
            start: { line: token.loc.start.line, column: 0 },
            end: {
              line: token.loc.start.line,
              column: token.loc.start.column
            }
          },
          fix(fixer) {
            const range = [
              token.range[0] - token.loc.start.column,
              token.range[0]
            ];
            const newText = neededIndent;
            return fixer.replaceTextRange(range, newText);
          }
        });
      }
      function validateTokenIndent(token, desiredIndent) {
        const indentation = tokenInfo.getTokenIndent(token);
        return indentation === desiredIndent || // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.
        indentation.includes(" ") && indentation.includes("	");
      }
      function isOuterIIFE(node2) {
        if (!node2.parent || node2.parent.type !== "CallExpression" || node2.parent.callee !== node2) {
          return false;
        }
        let statement = node2.parent && node2.parent.parent;
        while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].includes(statement.operator) || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
          statement = statement.parent;
        }
        return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
      }
      function countTrailingLinebreaks(string2) {
        const trailingWhitespace = string2.match(/\s*$/u)[0];
        const linebreakMatches = trailingWhitespace.match(
          astUtils2.createGlobalLinebreakMatcher()
        );
        return linebreakMatches === null ? 0 : linebreakMatches.length;
      }
      function addElementListIndent(elements, startToken, endToken, offset) {
        function getFirstToken(element) {
          let token = sourceCode2.getTokenBefore(element);
          while (astUtils2.isOpeningParenToken(token) && token !== startToken) {
            token = sourceCode2.getTokenBefore(token);
          }
          return sourceCode2.getTokenAfter(token);
        }
        offsets.setDesiredOffsets(
          [startToken.range[1], endToken.range[0]],
          startToken,
          typeof offset === "number" ? offset : 1
        );
        offsets.setDesiredOffset(endToken, startToken, 0);
        if (offset === "first" && elements.length && !elements[0]) {
          return;
        }
        elements.forEach((element, index) => {
          if (!element) {
            return;
          }
          if (offset === "off") {
            offsets.ignoreToken(getFirstToken(element));
          }
          if (index === 0) {
            return;
          }
          if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
            offsets.matchOffsetOf(
              getFirstToken(elements[0]),
              getFirstToken(element)
            );
          } else {
            const previousElement = elements[index - 1];
            const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
            const previousElementLastToken = previousElement && sourceCode2.getLastToken(previousElement);
            if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(
              previousElementLastToken.value
            ) > startToken.loc.end.line) {
              offsets.setDesiredOffsets(
                [previousElement.range[1], element.range[1]],
                firstTokenOfPreviousElement,
                0
              );
            }
          }
        });
      }
      function addBlocklessNodeIndent(node2) {
        if (node2.type !== "BlockStatement") {
          const lastParentToken = sourceCode2.getTokenBefore(
            node2,
            astUtils2.isNotOpeningParenToken
          );
          let firstBodyToken = sourceCode2.getFirstToken(node2);
          let lastBodyToken = sourceCode2.getLastToken(node2);
          while (astUtils2.isOpeningParenToken(
            sourceCode2.getTokenBefore(firstBodyToken)
          ) && astUtils2.isClosingParenToken(
            sourceCode2.getTokenAfter(lastBodyToken)
          )) {
            firstBodyToken = sourceCode2.getTokenBefore(firstBodyToken);
            lastBodyToken = sourceCode2.getTokenAfter(lastBodyToken);
          }
          offsets.setDesiredOffsets(
            [firstBodyToken.range[0], lastBodyToken.range[1]],
            lastParentToken,
            1
          );
        }
      }
      function addFunctionCallIndent(node2) {
        let openingParen;
        if (node2.arguments.length) {
          openingParen = sourceCode2.getFirstTokenBetween(
            node2.callee,
            node2.arguments[0],
            astUtils2.isOpeningParenToken
          );
        } else {
          openingParen = sourceCode2.getLastToken(node2, 1);
        }
        const closingParen = sourceCode2.getLastToken(node2);
        parameterParens.add(openingParen);
        parameterParens.add(closingParen);
        if (node2.optional) {
          const dotToken = sourceCode2.getTokenAfter(
            node2.callee,
            astUtils2.isQuestionDotToken
          );
          const calleeParenCount = sourceCode2.getTokensBetween(
            node2.callee,
            dotToken,
            { filter: astUtils2.isClosingParenToken }
          ).length;
          const firstTokenOfCallee = calleeParenCount ? sourceCode2.getTokenBefore(node2.callee, {
            skip: calleeParenCount - 1
          }) : sourceCode2.getFirstToken(node2.callee);
          const lastTokenOfCallee = sourceCode2.getTokenBefore(dotToken);
          const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;
          offsets.setDesiredOffset(dotToken, offsetBase, 1);
        }
        const offsetAfterToken = node2.callee.type === "TaggedTemplateExpression" ? sourceCode2.getFirstToken(node2.callee.quasi) : openingParen;
        const offsetToken = sourceCode2.getTokenBefore(offsetAfterToken);
        offsets.setDesiredOffset(openingParen, offsetToken, 0);
        addElementListIndent(
          node2.arguments,
          openingParen,
          closingParen,
          options.CallExpression.arguments
        );
      }
      function addParensIndent(tokens) {
        const parenStack = [];
        const parenPairs = [];
        for (let i2 = 0; i2 < tokens.length; i2++) {
          const nextToken = tokens[i2];
          if (astUtils2.isOpeningParenToken(nextToken)) {
            parenStack.push(nextToken);
          } else if (astUtils2.isClosingParenToken(nextToken)) {
            parenPairs.push({
              left: parenStack.pop(),
              right: nextToken
            });
          }
        }
        for (let i2 = parenPairs.length - 1; i2 >= 0; i2--) {
          const leftParen = parenPairs[i2].left;
          const rightParen = parenPairs[i2].right;
          if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
            const parenthesizedTokens = new Set(
              sourceCode2.getTokensBetween(leftParen, rightParen)
            );
            parenthesizedTokens.forEach((token) => {
              if (!parenthesizedTokens.has(
                offsets.getFirstDependency(token)
              )) {
                offsets.setDesiredOffset(token, leftParen, 1);
              }
            });
          }
          offsets.setDesiredOffset(rightParen, leftParen, 0);
        }
      }
      function ignoreNode(node2) {
        const unknownNodeTokens = new Set(
          sourceCode2.getTokens(node2, { includeComments: true })
        );
        unknownNodeTokens.forEach((token) => {
          if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
            const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);
            if (token === firstTokenOfLine) {
              offsets.ignoreToken(token);
            } else {
              offsets.setDesiredOffset(token, firstTokenOfLine, 0);
            }
          }
        });
      }
      function isOnFirstLineOfStatement(token, leafNode) {
        let node2 = leafNode;
        while (node2.parent && !node2.parent.type.endsWith("Statement") && !node2.parent.type.endsWith("Declaration")) {
          node2 = node2.parent;
        }
        node2 = node2.parent;
        return !node2 || node2.loc.start.line === token.loc.start.line;
      }
      function hasBlankLinesBetween(firstToken, secondToken) {
        const firstTokenLine = firstToken.loc.end.line;
        const secondTokenLine = secondToken.loc.start.line;
        if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {
          return false;
        }
        for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {
          if (!tokenInfo.firstTokensByLineNumber.has(line)) {
            return true;
          }
        }
        return false;
      }
      const ignoredNodeFirstTokens = /* @__PURE__ */ new Set();
      const baseOffsetListeners = {
        "ArrayExpression, ArrayPattern"(node2) {
          const openingBracket = sourceCode2.getFirstToken(node2);
          const closingBracket = sourceCode2.getTokenAfter(
            [...node2.elements].reverse().find((_) => _) || openingBracket,
            astUtils2.isClosingBracketToken
          );
          addElementListIndent(
            node2.elements,
            openingBracket,
            closingBracket,
            options.ArrayExpression
          );
        },
        "ObjectExpression, ObjectPattern"(node2) {
          const openingCurly = sourceCode2.getFirstToken(node2);
          const closingCurly = sourceCode2.getTokenAfter(
            node2.properties.length ? node2.properties.at(-1) : openingCurly,
            astUtils2.isClosingBraceToken
          );
          addElementListIndent(
            node2.properties,
            openingCurly,
            closingCurly,
            options.ObjectExpression
          );
        },
        ArrowFunctionExpression(node2) {
          const maybeOpeningParen = sourceCode2.getFirstToken(node2, {
            skip: node2.async ? 1 : 0
          });
          if (astUtils2.isOpeningParenToken(maybeOpeningParen)) {
            const openingParen = maybeOpeningParen;
            const closingParen = sourceCode2.getTokenBefore(
              node2.body,
              astUtils2.isClosingParenToken
            );
            parameterParens.add(openingParen);
            parameterParens.add(closingParen);
            addElementListIndent(
              node2.params,
              openingParen,
              closingParen,
              options.FunctionExpression.parameters
            );
          }
          addBlocklessNodeIndent(node2.body);
        },
        AssignmentExpression(node2) {
          const operator2 = sourceCode2.getFirstTokenBetween(
            node2.left,
            node2.right,
            (token) => token.value === node2.operator
          );
          offsets.setDesiredOffsets(
            [operator2.range[0], node2.range[1]],
            sourceCode2.getLastToken(node2.left),
            1
          );
          offsets.ignoreToken(operator2);
          offsets.ignoreToken(sourceCode2.getTokenAfter(operator2));
        },
        "BinaryExpression, LogicalExpression"(node2) {
          const operator2 = sourceCode2.getFirstTokenBetween(
            node2.left,
            node2.right,
            (token) => token.value === node2.operator
          );
          const tokenAfterOperator = sourceCode2.getTokenAfter(operator2);
          offsets.ignoreToken(operator2);
          offsets.ignoreToken(tokenAfterOperator);
          offsets.setDesiredOffset(tokenAfterOperator, operator2, 0);
        },
        "BlockStatement, ClassBody"(node2) {
          let blockIndentLevel;
          if (node2.parent && isOuterIIFE(node2.parent)) {
            blockIndentLevel = options.outerIIFEBody;
          } else if (node2.parent && (node2.parent.type === "FunctionExpression" || node2.parent.type === "ArrowFunctionExpression")) {
            blockIndentLevel = options.FunctionExpression.body;
          } else if (node2.parent && node2.parent.type === "FunctionDeclaration") {
            blockIndentLevel = options.FunctionDeclaration.body;
          } else {
            blockIndentLevel = 1;
          }
          if (!astUtils2.STATEMENT_LIST_PARENTS.has(node2.parent.type)) {
            offsets.setDesiredOffset(
              sourceCode2.getFirstToken(node2),
              sourceCode2.getFirstToken(node2.parent),
              0
            );
          }
          addElementListIndent(
            node2.body,
            sourceCode2.getFirstToken(node2),
            sourceCode2.getLastToken(node2),
            blockIndentLevel
          );
        },
        CallExpression: addFunctionCallIndent,
        "ClassDeclaration[superClass], ClassExpression[superClass]"(node2) {
          const classToken = sourceCode2.getFirstToken(node2);
          const extendsToken = sourceCode2.getTokenBefore(
            node2.superClass,
            astUtils2.isNotOpeningParenToken
          );
          offsets.setDesiredOffsets(
            [extendsToken.range[0], node2.body.range[0]],
            classToken,
            1
          );
        },
        ConditionalExpression(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          if (!options.flatTernaryExpressions || !astUtils2.isTokenOnSameLine(node2.test, node2.consequent) || isOnFirstLineOfStatement(firstToken, node2)) {
            const questionMarkToken = sourceCode2.getFirstTokenBetween(
              node2.test,
              node2.consequent,
              (token) => token.type === "Punctuator" && token.value === "?"
            );
            const colonToken = sourceCode2.getFirstTokenBetween(
              node2.consequent,
              node2.alternate,
              (token) => token.type === "Punctuator" && token.value === ":"
            );
            const firstConsequentToken = sourceCode2.getTokenAfter(questionMarkToken);
            const lastConsequentToken = sourceCode2.getTokenBefore(colonToken);
            const firstAlternateToken = sourceCode2.getTokenAfter(colonToken);
            offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
            offsets.setDesiredOffset(colonToken, firstToken, 1);
            offsets.setDesiredOffset(
              firstConsequentToken,
              firstToken,
              firstConsequentToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1
            );
            if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
              offsets.setDesiredOffset(
                firstAlternateToken,
                firstConsequentToken,
                0
              );
            } else {
              offsets.setDesiredOffset(
                firstAlternateToken,
                firstToken,
                firstAlternateToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1
              );
            }
          }
        },
        "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement": (node2) => addBlocklessNodeIndent(node2.body),
        ExportNamedDeclaration(node2) {
          if (node2.declaration === null) {
            const closingCurly = sourceCode2.getLastToken(
              node2,
              astUtils2.isClosingBraceToken
            );
            addElementListIndent(
              node2.specifiers,
              sourceCode2.getFirstToken(node2, { skip: 1 }),
              closingCurly,
              1
            );
            if (node2.source) {
              offsets.setDesiredOffsets(
                [closingCurly.range[1], node2.range[1]],
                sourceCode2.getFirstToken(node2),
                1
              );
            }
          }
        },
        ForStatement(node2) {
          const forOpeningParen = sourceCode2.getFirstToken(node2, 1);
          if (node2.init) {
            offsets.setDesiredOffsets(
              node2.init.range,
              forOpeningParen,
              1
            );
          }
          if (node2.test) {
            offsets.setDesiredOffsets(
              node2.test.range,
              forOpeningParen,
              1
            );
          }
          if (node2.update) {
            offsets.setDesiredOffsets(
              node2.update.range,
              forOpeningParen,
              1
            );
          }
          addBlocklessNodeIndent(node2.body);
        },
        "FunctionDeclaration, FunctionExpression"(node2) {
          const closingParen = sourceCode2.getTokenBefore(node2.body);
          const openingParen = sourceCode2.getTokenBefore(
            node2.params.length ? node2.params[0] : closingParen
          );
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          addElementListIndent(
            node2.params,
            openingParen,
            closingParen,
            options[node2.type].parameters
          );
        },
        IfStatement(node2) {
          addBlocklessNodeIndent(node2.consequent);
          if (node2.alternate) {
            addBlocklessNodeIndent(node2.alternate);
          }
        },
        /*
         * For blockless nodes with semicolon-first style, don't indent the semicolon.
         * e.g.
         * if (foo)
         *     bar()
         * ; [1, 2, 3].map(foo)
         *
         * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.
         */
        ":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit"(node2) {
          let nodesToCheck;
          if (node2.type === "IfStatement") {
            nodesToCheck = [node2.consequent];
            if (node2.alternate) {
              nodesToCheck.push(node2.alternate);
            }
          } else {
            nodesToCheck = [node2.body];
          }
          for (const nodeToCheck of nodesToCheck) {
            const lastToken = sourceCode2.getLastToken(nodeToCheck);
            if (astUtils2.isSemicolonToken(lastToken)) {
              const tokenBeforeLast = sourceCode2.getTokenBefore(lastToken);
              const tokenAfterLast = sourceCode2.getTokenAfter(lastToken);
              if (!astUtils2.isTokenOnSameLine(
                tokenBeforeLast,
                lastToken
              ) && tokenAfterLast && astUtils2.isTokenOnSameLine(
                lastToken,
                tokenAfterLast
              )) {
                offsets.setDesiredOffset(
                  lastToken,
                  sourceCode2.getFirstToken(node2),
                  0
                );
              }
            }
          }
        },
        ImportDeclaration(node2) {
          if (node2.specifiers.some(
            (specifier) => specifier.type === "ImportSpecifier"
          )) {
            const openingCurly = sourceCode2.getFirstToken(
              node2,
              astUtils2.isOpeningBraceToken
            );
            const closingCurly = sourceCode2.getLastToken(
              node2,
              astUtils2.isClosingBraceToken
            );
            addElementListIndent(
              node2.specifiers.filter(
                (specifier) => specifier.type === "ImportSpecifier"
              ),
              openingCurly,
              closingCurly,
              options.ImportDeclaration
            );
          }
          const fromToken = sourceCode2.getLastToken(
            node2,
            (token) => token.type === "Identifier" && token.value === "from"
          );
          const sourceToken = sourceCode2.getLastToken(
            node2,
            (token) => token.type === "String"
          );
          const semiToken = sourceCode2.getLastToken(
            node2,
            (token) => token.type === "Punctuator" && token.value === ";"
          );
          if (fromToken) {
            const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node2.range[1] : sourceToken.range[1];
            offsets.setDesiredOffsets(
              [fromToken.range[0], end],
              sourceCode2.getFirstToken(node2),
              1
            );
          }
        },
        ImportExpression(node2) {
          const openingParen = sourceCode2.getFirstToken(node2, 1);
          const closingParen = sourceCode2.getLastToken(node2);
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          offsets.setDesiredOffset(
            openingParen,
            sourceCode2.getTokenBefore(openingParen),
            0
          );
          addElementListIndent(
            [node2.source],
            openingParen,
            closingParen,
            options.CallExpression.arguments
          );
        },
        "MemberExpression, JSXMemberExpression, MetaProperty"(node2) {
          const object = node2.type === "MetaProperty" ? node2.meta : node2.object;
          const firstNonObjectToken = sourceCode2.getFirstTokenBetween(
            object,
            node2.property,
            astUtils2.isNotClosingParenToken
          );
          const secondNonObjectToken = sourceCode2.getTokenAfter(firstNonObjectToken);
          const objectParenCount = sourceCode2.getTokensBetween(
            object,
            node2.property,
            { filter: astUtils2.isClosingParenToken }
          ).length;
          const firstObjectToken = objectParenCount ? sourceCode2.getTokenBefore(object, {
            skip: objectParenCount - 1
          }) : sourceCode2.getFirstToken(object);
          const lastObjectToken = sourceCode2.getTokenBefore(firstNonObjectToken);
          const firstPropertyToken = node2.computed ? firstNonObjectToken : secondNonObjectToken;
          if (node2.computed) {
            offsets.setDesiredOffset(
              sourceCode2.getLastToken(node2),
              firstNonObjectToken,
              0
            );
            offsets.setDesiredOffsets(
              node2.property.range,
              firstNonObjectToken,
              1
            );
          }
          const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;
          if (typeof options.MemberExpression === "number") {
            offsets.setDesiredOffset(
              firstNonObjectToken,
              offsetBase,
              options.MemberExpression
            );
            offsets.setDesiredOffset(
              secondNonObjectToken,
              node2.computed ? firstNonObjectToken : offsetBase,
              options.MemberExpression
            );
          } else {
            offsets.ignoreToken(firstNonObjectToken);
            offsets.ignoreToken(secondNonObjectToken);
            offsets.setDesiredOffset(
              firstNonObjectToken,
              offsetBase,
              0
            );
            offsets.setDesiredOffset(
              secondNonObjectToken,
              firstNonObjectToken,
              0
            );
          }
        },
        NewExpression(node2) {
          if (node2.arguments.length > 0 || astUtils2.isClosingParenToken(
            sourceCode2.getLastToken(node2)
          ) && astUtils2.isOpeningParenToken(
            sourceCode2.getLastToken(node2, 1)
          )) {
            addFunctionCallIndent(node2);
          }
        },
        Property(node2) {
          if (!node2.shorthand && !node2.method && node2.kind === "init") {
            const colon = sourceCode2.getFirstTokenBetween(
              node2.key,
              node2.value,
              astUtils2.isColonToken
            );
            offsets.ignoreToken(sourceCode2.getTokenAfter(colon));
          }
        },
        PropertyDefinition(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          const maybeSemicolonToken = sourceCode2.getLastToken(node2);
          let keyLastToken;
          if (node2.computed) {
            const bracketTokenL = sourceCode2.getTokenBefore(
              node2.key,
              astUtils2.isOpeningBracketToken
            );
            const bracketTokenR = keyLastToken = sourceCode2.getTokenAfter(
              node2.key,
              astUtils2.isClosingBracketToken
            );
            const keyRange = [
              bracketTokenL.range[1],
              bracketTokenR.range[0]
            ];
            if (bracketTokenL !== firstToken) {
              offsets.setDesiredOffset(bracketTokenL, firstToken, 0);
            }
            offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);
            offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);
          } else {
            const idToken = keyLastToken = sourceCode2.getFirstToken(
              node2.key
            );
            if (idToken !== firstToken) {
              offsets.setDesiredOffset(idToken, firstToken, 1);
            }
          }
          if (node2.value) {
            const eqToken = sourceCode2.getTokenBefore(
              node2.value,
              astUtils2.isEqToken
            );
            const valueToken = sourceCode2.getTokenAfter(eqToken);
            offsets.setDesiredOffset(eqToken, keyLastToken, 1);
            offsets.setDesiredOffset(valueToken, eqToken, 1);
            if (astUtils2.isSemicolonToken(maybeSemicolonToken)) {
              offsets.setDesiredOffset(
                maybeSemicolonToken,
                eqToken,
                1
              );
            }
          } else if (astUtils2.isSemicolonToken(maybeSemicolonToken)) {
            offsets.setDesiredOffset(
              maybeSemicolonToken,
              keyLastToken,
              1
            );
          }
        },
        StaticBlock(node2) {
          const openingCurly = sourceCode2.getFirstToken(node2, {
            skip: 1
          });
          const closingCurly = sourceCode2.getLastToken(node2);
          addElementListIndent(
            node2.body,
            openingCurly,
            closingCurly,
            options.StaticBlock.body
          );
        },
        SwitchStatement(node2) {
          const openingCurly = sourceCode2.getTokenAfter(
            node2.discriminant,
            astUtils2.isOpeningBraceToken
          );
          const closingCurly = sourceCode2.getLastToken(node2);
          offsets.setDesiredOffsets(
            [openingCurly.range[1], closingCurly.range[0]],
            openingCurly,
            options.SwitchCase
          );
          if (node2.cases.length) {
            sourceCode2.getTokensBetween(node2.cases.at(-1), closingCurly, {
              includeComments: true,
              filter: astUtils2.isCommentToken
            }).forEach((token) => offsets.ignoreToken(token));
          }
        },
        SwitchCase(node2) {
          if (!(node2.consequent.length === 1 && node2.consequent[0].type === "BlockStatement")) {
            const caseKeyword = sourceCode2.getFirstToken(node2);
            const tokenAfterCurrentCase = sourceCode2.getTokenAfter(node2);
            offsets.setDesiredOffsets(
              [caseKeyword.range[1], tokenAfterCurrentCase.range[0]],
              caseKeyword,
              1
            );
          }
        },
        TemplateLiteral(node2) {
          node2.expressions.forEach((expression, index) => {
            const previousQuasi = node2.quasis[index];
            const nextQuasi = node2.quasis[index + 1];
            const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode2.getFirstToken(previousQuasi) : null;
            offsets.setDesiredOffsets(
              [previousQuasi.range[1], nextQuasi.range[0]],
              tokenToAlignFrom,
              1
            );
            offsets.setDesiredOffset(
              sourceCode2.getFirstToken(nextQuasi),
              tokenToAlignFrom,
              0
            );
          });
        },
        VariableDeclaration(node2) {
          let variableIndent = Object.hasOwn(
            options.VariableDeclarator,
            node2.kind
          ) ? options.VariableDeclarator[node2.kind] : DEFAULT_VARIABLE_INDENT;
          const firstToken = sourceCode2.getFirstToken(node2), lastToken = sourceCode2.getLastToken(node2);
          if (options.VariableDeclarator[node2.kind] === "first") {
            if (node2.declarations.length > 1) {
              addElementListIndent(
                node2.declarations,
                firstToken,
                lastToken,
                "first"
              );
              return;
            }
            variableIndent = DEFAULT_VARIABLE_INDENT;
          }
          if (node2.declarations.at(-1).loc.start.line > node2.loc.start.line) {
            offsets.setDesiredOffsets(
              node2.range,
              firstToken,
              variableIndent,
              true
            );
          } else {
            offsets.setDesiredOffsets(
              node2.range,
              firstToken,
              variableIndent
            );
          }
          if (astUtils2.isSemicolonToken(lastToken)) {
            offsets.ignoreToken(lastToken);
          }
        },
        VariableDeclarator(node2) {
          if (node2.init) {
            const equalOperator = sourceCode2.getTokenBefore(
              node2.init,
              astUtils2.isNotOpeningParenToken
            );
            const tokenAfterOperator = sourceCode2.getTokenAfter(equalOperator);
            offsets.ignoreToken(equalOperator);
            offsets.ignoreToken(tokenAfterOperator);
            offsets.setDesiredOffsets(
              [tokenAfterOperator.range[0], node2.range[1]],
              equalOperator,
              1
            );
            offsets.setDesiredOffset(
              equalOperator,
              sourceCode2.getLastToken(node2.id),
              0
            );
          }
        },
        "JSXAttribute[value]"(node2) {
          const equalsToken = sourceCode2.getFirstTokenBetween(
            node2.name,
            node2.value,
            (token) => token.type === "Punctuator" && token.value === "="
          );
          offsets.setDesiredOffsets(
            [equalsToken.range[0], node2.value.range[1]],
            sourceCode2.getFirstToken(node2.name),
            1
          );
        },
        JSXElement(node2) {
          if (node2.closingElement) {
            addElementListIndent(
              node2.children,
              sourceCode2.getFirstToken(node2.openingElement),
              sourceCode2.getFirstToken(node2.closingElement),
              1
            );
          }
        },
        JSXOpeningElement(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          let closingToken;
          if (node2.selfClosing) {
            closingToken = sourceCode2.getLastToken(node2, { skip: 1 });
            offsets.setDesiredOffset(
              sourceCode2.getLastToken(node2),
              closingToken,
              0
            );
          } else {
            closingToken = sourceCode2.getLastToken(node2);
          }
          offsets.setDesiredOffsets(
            node2.name.range,
            sourceCode2.getFirstToken(node2)
          );
          addElementListIndent(
            node2.attributes,
            firstToken,
            closingToken,
            1
          );
        },
        JSXClosingElement(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          offsets.setDesiredOffsets(node2.name.range, firstToken, 1);
        },
        JSXFragment(node2) {
          const firstOpeningToken = sourceCode2.getFirstToken(
            node2.openingFragment
          );
          const firstClosingToken = sourceCode2.getFirstToken(
            node2.closingFragment
          );
          addElementListIndent(
            node2.children,
            firstOpeningToken,
            firstClosingToken,
            1
          );
        },
        JSXOpeningFragment(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          const closingToken = sourceCode2.getLastToken(node2);
          offsets.setDesiredOffsets(node2.range, firstToken, 1);
          offsets.matchOffsetOf(firstToken, closingToken);
        },
        JSXClosingFragment(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          const slashToken = sourceCode2.getLastToken(node2, { skip: 1 });
          const closingToken = sourceCode2.getLastToken(node2);
          const tokenToMatch = astUtils2.isTokenOnSameLine(
            slashToken,
            closingToken
          ) ? slashToken : closingToken;
          offsets.setDesiredOffsets(node2.range, firstToken, 1);
          offsets.matchOffsetOf(firstToken, tokenToMatch);
        },
        JSXExpressionContainer(node2) {
          const openingCurly = sourceCode2.getFirstToken(node2);
          const closingCurly = sourceCode2.getLastToken(node2);
          offsets.setDesiredOffsets(
            [openingCurly.range[1], closingCurly.range[0]],
            openingCurly,
            1
          );
        },
        JSXSpreadAttribute(node2) {
          const openingCurly = sourceCode2.getFirstToken(node2);
          const closingCurly = sourceCode2.getLastToken(node2);
          offsets.setDesiredOffsets(
            [openingCurly.range[1], closingCurly.range[0]],
            openingCurly,
            1
          );
        },
        "*"(node2) {
          const firstToken = sourceCode2.getFirstToken(node2);
          if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {
            offsets.setDesiredOffsets(node2.range, firstToken, 0);
          }
        }
      };
      const listenerCallQueue = [];
      const offsetListeners = {};
      for (const [selector, listener] of Object.entries(
        baseOffsetListeners
      )) {
        offsetListeners[selector] = (node2) => listenerCallQueue.push({ listener, node: node2 });
      }
      const ignoredNodes = /* @__PURE__ */ new Set();
      function addToIgnoredNodes(node2) {
        ignoredNodes.add(node2);
        ignoredNodeFirstTokens.add(sourceCode2.getFirstToken(node2));
      }
      const ignoredNodeListeners = options.ignoredNodes.reduce(
        (listeners, ignoredSelector) => Object.assign(listeners, {
          [ignoredSelector]: addToIgnoredNodes
        }),
        {}
      );
      return Object.assign(offsetListeners, ignoredNodeListeners, {
        "*:exit"(node2) {
          if (!KNOWN_NODES.has(node2.type)) {
            addToIgnoredNodes(node2);
          }
        },
        "Program:exit"() {
          if (options.ignoreComments) {
            sourceCode2.getAllComments().forEach((comment2) => offsets.ignoreToken(comment2));
          }
          for (let i2 = 0; i2 < listenerCallQueue.length; i2++) {
            const nodeInfo = listenerCallQueue[i2];
            if (!ignoredNodes.has(nodeInfo.node)) {
              nodeInfo.listener(nodeInfo.node);
            }
          }
          ignoredNodes.forEach(ignoreNode);
          addParensIndent(sourceCode2.ast.tokens);
          const precedingTokens = /* @__PURE__ */ new WeakMap();
          for (let i2 = 0; i2 < sourceCode2.ast.comments.length; i2++) {
            const comment2 = sourceCode2.ast.comments[i2];
            const tokenOrCommentBefore = sourceCode2.getTokenBefore(
              comment2,
              { includeComments: true }
            );
            const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;
            precedingTokens.set(comment2, hasToken);
          }
          for (let i2 = 1; i2 < sourceCode2.lines.length + 1; i2++) {
            if (!tokenInfo.firstTokensByLineNumber.has(i2)) {
              continue;
            }
            const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i2);
            if (firstTokenOfLine.loc.start.line !== i2) {
              continue;
            }
            if (astUtils2.isCommentToken(firstTokenOfLine)) {
              const tokenBefore = precedingTokens.get(firstTokenOfLine);
              const tokenAfter = tokenBefore ? sourceCode2.getTokenAfter(tokenBefore) : sourceCode2.ast.tokens[0];
              const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(
                tokenBefore,
                firstTokenOfLine
              );
              const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);
              if (tokenAfter && astUtils2.isSemicolonToken(tokenAfter) && !astUtils2.isTokenOnSameLine(
                firstTokenOfLine,
                tokenAfter
              )) {
                offsets.setDesiredOffset(
                  firstTokenOfLine,
                  tokenAfter,
                  0
                );
              }
              if (mayAlignWithBefore && validateTokenIndent(
                firstTokenOfLine,
                offsets.getDesiredIndent(tokenBefore)
              ) || mayAlignWithAfter && validateTokenIndent(
                firstTokenOfLine,
                offsets.getDesiredIndent(tokenAfter)
              )) {
                continue;
              }
            }
            if (validateTokenIndent(
              firstTokenOfLine,
              offsets.getDesiredIndent(firstTokenOfLine)
            )) {
              continue;
            }
            report(
              firstTokenOfLine,
              offsets.getDesiredIndent(firstTokenOfLine)
            );
          }
        }
      });
    }
  };
  return indent;
}
var indentLegacy;
var hasRequiredIndentLegacy;
function requireIndentLegacy() {
  if (hasRequiredIndentLegacy) return indentLegacy;
  hasRequiredIndentLegacy = 1;
  const astUtils2 = requireAstUtils();
  indentLegacy = {
    meta: {
      type: "layout",
      docs: {
        description: "Enforce consistent indentation",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/indent-legacy"
      },
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "4.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "indent",
              url: "https://eslint.style/rules/indent"
            }
          }
        ]
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["tab"]
            },
            {
              type: "integer",
              minimum: 0
            }
          ]
        },
        {
          type: "object",
          properties: {
            SwitchCase: {
              type: "integer",
              minimum: 0
            },
            VariableDeclarator: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  type: "object",
                  properties: {
                    var: {
                      type: "integer",
                      minimum: 0
                    },
                    let: {
                      type: "integer",
                      minimum: 0
                    },
                    const: {
                      type: "integer",
                      minimum: 0
                    }
                  }
                }
              ]
            },
            outerIIFEBody: {
              type: "integer",
              minimum: 0
            },
            MemberExpression: {
              type: "integer",
              minimum: 0
            },
            FunctionDeclaration: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                },
                body: {
                  type: "integer",
                  minimum: 0
                }
              }
            },
            FunctionExpression: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                },
                body: {
                  type: "integer",
                  minimum: 0
                }
              }
            },
            CallExpression: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                }
              }
            },
            ArrayExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["first"]
                }
              ]
            },
            ObjectExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["first"]
                }
              ]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expected: "Expected indentation of {{expected}} but found {{actual}}."
      }
    },
    create(context) {
      const DEFAULT_VARIABLE_INDENT = 1;
      const DEFAULT_PARAMETER_INDENT = null;
      const DEFAULT_FUNCTION_BODY_INDENT = 1;
      let indentType = "space";
      let indentSize = 4;
      const options = {
        SwitchCase: 0,
        VariableDeclarator: {
          var: DEFAULT_VARIABLE_INDENT,
          let: DEFAULT_VARIABLE_INDENT,
          const: DEFAULT_VARIABLE_INDENT
        },
        outerIIFEBody: null,
        FunctionDeclaration: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        FunctionExpression: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        CallExpression: {
          arguments: DEFAULT_PARAMETER_INDENT
        },
        ArrayExpression: 1,
        ObjectExpression: 1
      };
      const sourceCode2 = context.sourceCode;
      if (context.options.length) {
        if (context.options[0] === "tab") {
          indentSize = 1;
          indentType = "tab";
        } else if (typeof context.options[0] === "number") {
          indentSize = context.options[0];
          indentType = "space";
        }
        if (context.options[1]) {
          const opts = context.options[1];
          options.SwitchCase = opts.SwitchCase || 0;
          const variableDeclaratorRules = opts.VariableDeclarator;
          if (typeof variableDeclaratorRules === "number") {
            options.VariableDeclarator = {
              var: variableDeclaratorRules,
              let: variableDeclaratorRules,
              const: variableDeclaratorRules
            };
          } else if (typeof variableDeclaratorRules === "object") {
            Object.assign(
              options.VariableDeclarator,
              variableDeclaratorRules
            );
          }
          if (typeof opts.outerIIFEBody === "number") {
            options.outerIIFEBody = opts.outerIIFEBody;
          }
          if (typeof opts.MemberExpression === "number") {
            options.MemberExpression = opts.MemberExpression;
          }
          if (typeof opts.FunctionDeclaration === "object") {
            Object.assign(
              options.FunctionDeclaration,
              opts.FunctionDeclaration
            );
          }
          if (typeof opts.FunctionExpression === "object") {
            Object.assign(
              options.FunctionExpression,
              opts.FunctionExpression
            );
          }
          if (typeof opts.CallExpression === "object") {
            Object.assign(options.CallExpression, opts.CallExpression);
          }
          if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
            options.ArrayExpression = opts.ArrayExpression;
          }
          if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
            options.ObjectExpression = opts.ObjectExpression;
          }
        }
      }
      const caseIndentStore = {};
      function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
        const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
        const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
        const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
        let foundStatement;
        if (actualSpaces > 0 && actualTabs > 0) {
          foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`;
        } else if (actualSpaces > 0) {
          foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
        } else if (actualTabs > 0) {
          foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
        } else {
          foundStatement = "0";
        }
        return {
          expected: expectedStatement,
          actual: foundStatement
        };
      }
      function report(node2, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
        if (gottenSpaces && gottenTabs) {
          return;
        }
        const desiredIndent = (indentType === "space" ? " " : "	").repeat(
          needed
        );
        const textRange2 = isLastNodeCheck ? [
          node2.range[1] - node2.loc.end.column,
          node2.range[1] - node2.loc.end.column + gottenSpaces + gottenTabs
        ] : [
          node2.range[0] - node2.loc.start.column,
          node2.range[0] - node2.loc.start.column + gottenSpaces + gottenTabs
        ];
        context.report({
          node: node2,
          loc,
          messageId: "expected",
          data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
          fix: (fixer) => fixer.replaceTextRange(textRange2, desiredIndent)
        });
      }
      function getNodeIndent(node2, byLastLine) {
        const token = byLastLine ? sourceCode2.getLastToken(node2) : sourceCode2.getFirstToken(node2);
        const srcCharsBeforeNode = sourceCode2.getText(token, token.loc.start.column).split("");
        const indentChars = srcCharsBeforeNode.slice(
          0,
          srcCharsBeforeNode.findIndex(
            (char) => char !== " " && char !== "	"
          )
        );
        const spaces2 = indentChars.filter((char) => char === " ").length;
        const tabs = indentChars.filter((char) => char === "	").length;
        return {
          space: spaces2,
          tab: tabs,
          goodChar: indentType === "space" ? spaces2 : tabs,
          badChar: indentType === "space" ? tabs : spaces2
        };
      }
      function isNodeFirstInLine(node2, byEndLocation) {
        const firstToken = byEndLocation === true ? sourceCode2.getLastToken(node2, 1) : sourceCode2.getTokenBefore(node2), startLine = byEndLocation === true ? node2.loc.end.line : node2.loc.start.line, endLine = firstToken ? firstToken.loc.end.line : -1;
        return startLine !== endLine;
      }
      function checkNodeIndent(node2, neededIndent) {
        const actualIndent = getNodeIndent(node2, false);
        if (node2.type !== "ArrayExpression" && node2.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node2)) {
          report(
            node2,
            neededIndent,
            actualIndent.space,
            actualIndent.tab
          );
        }
        if (node2.type === "IfStatement" && node2.alternate) {
          const elseToken = sourceCode2.getTokenBefore(node2.alternate);
          checkNodeIndent(elseToken, neededIndent);
          if (!isNodeFirstInLine(node2.alternate)) {
            checkNodeIndent(node2.alternate, neededIndent);
          }
        }
        if (node2.type === "TryStatement" && node2.handler) {
          const catchToken = sourceCode2.getFirstToken(node2.handler);
          checkNodeIndent(catchToken, neededIndent);
        }
        if (node2.type === "TryStatement" && node2.finalizer) {
          const finallyToken = sourceCode2.getTokenBefore(node2.finalizer);
          checkNodeIndent(finallyToken, neededIndent);
        }
        if (node2.type === "DoWhileStatement") {
          const whileToken = sourceCode2.getTokenAfter(node2.body);
          checkNodeIndent(whileToken, neededIndent);
        }
      }
      function checkNodesIndent(nodes, indent2) {
        nodes.forEach((node2) => checkNodeIndent(node2, indent2));
      }
      function checkLastNodeLineIndent(node2, lastLineIndent) {
        const lastToken = sourceCode2.getLastToken(node2);
        const endIndent = getNodeIndent(lastToken, true);
        if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node2, true)) {
          report(
            node2,
            lastLineIndent,
            endIndent.space,
            endIndent.tab,
            {
              line: lastToken.loc.start.line,
              column: lastToken.loc.start.column
            },
            true
          );
        }
      }
      function checkLastReturnStatementLineIndent(node2, firstLineIndent) {
        const lastToken = sourceCode2.getLastToken(
          node2,
          astUtils2.isClosingParenToken
        );
        const textBeforeClosingParenthesis = sourceCode2.getText(lastToken, lastToken.loc.start.column).slice(0, -1);
        if (textBeforeClosingParenthesis.trim()) {
          return;
        }
        const endIndent = getNodeIndent(lastToken, true);
        if (endIndent.goodChar !== firstLineIndent) {
          report(
            node2,
            firstLineIndent,
            endIndent.space,
            endIndent.tab,
            {
              line: lastToken.loc.start.line,
              column: lastToken.loc.start.column
            },
            true
          );
        }
      }
      function checkFirstNodeLineIndent(node2, firstLineIndent) {
        const startIndent = getNodeIndent(node2, false);
        if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node2)) {
          report(
            node2,
            firstLineIndent,
            startIndent.space,
            startIndent.tab,
            {
              line: node2.loc.start.line,
              column: node2.loc.start.column
            }
          );
        }
      }
      function getParentNodeByType(node2, type2, stopAtList) {
        let parent = node2.parent;
        const stopAtSet = new Set(stopAtList || ["Program"]);
        while (parent.type !== type2 && !stopAtSet.has(parent.type) && parent.type !== "Program") {
          parent = parent.parent;
        }
        return parent.type === type2 ? parent : null;
      }
      function getVariableDeclaratorNode(node2) {
        return getParentNodeByType(node2, "VariableDeclarator");
      }
      function isNodeInVarOnTop(node2, varNode) {
        return varNode && varNode.parent.loc.start.line === node2.loc.start.line && varNode.parent.declarations.length > 1;
      }
      function isArgBeforeCalleeNodeMultiline(node2) {
        const parent = node2.parent;
        if (parent.arguments.length >= 2 && parent.arguments[1] === node2) {
          return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
        }
        return false;
      }
      function isOuterIIFE(node2) {
        const parent = node2.parent;
        let stmt = parent.parent;
        if (parent.type !== "CallExpression" || parent.callee !== node2) {
          return false;
        }
        while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {
          stmt = stmt.parent;
        }
        return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
      }
      function checkIndentInFunctionBlock(node2) {
        const calleeNode = node2.parent;
        let indent2;
        if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
          indent2 = getNodeIndent(calleeNode, false).goodChar;
        } else {
          indent2 = getNodeIndent(calleeNode).goodChar;
        }
        if (calleeNode.parent.type === "CallExpression") {
          const calleeParent = calleeNode.parent;
          if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
            if (calleeParent && calleeParent.loc.start.line < node2.loc.start.line) {
              indent2 = getNodeIndent(calleeParent).goodChar;
            }
          } else {
            if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
              indent2 = getNodeIndent(calleeParent).goodChar;
            }
          }
        }
        let functionOffset = indentSize;
        if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
          functionOffset = options.outerIIFEBody * indentSize;
        } else if (calleeNode.type === "FunctionExpression") {
          functionOffset = options.FunctionExpression.body * indentSize;
        } else if (calleeNode.type === "FunctionDeclaration") {
          functionOffset = options.FunctionDeclaration.body * indentSize;
        }
        indent2 += functionOffset;
        const parentVarNode = getVariableDeclaratorNode(node2);
        if (parentVarNode && isNodeInVarOnTop(node2, parentVarNode)) {
          indent2 += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }
        if (node2.body.length > 0) {
          checkNodesIndent(node2.body, indent2);
        }
        checkLastNodeLineIndent(node2, indent2 - functionOffset);
      }
      function isSingleLineNode(node2) {
        const lastToken = sourceCode2.getLastToken(node2), startLine = node2.loc.start.line, endLine = lastToken.loc.end.line;
        return startLine === endLine;
      }
      function checkIndentInArrayOrObjectBlock(node2) {
        if (isSingleLineNode(node2)) {
          return;
        }
        let elements = node2.type === "ArrayExpression" ? node2.elements : node2.properties;
        elements = elements.filter((elem) => elem !== null);
        let nodeIndent;
        let elementsIndent;
        const parentVarNode = getVariableDeclaratorNode(node2);
        if (isNodeFirstInLine(node2)) {
          const parent = node2.parent;
          nodeIndent = getNodeIndent(parent).goodChar;
          if (!parentVarNode || parentVarNode.loc.start.line !== node2.loc.start.line) {
            if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
              if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
                nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
              } else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
                const parentElements = node2.parent.type === "ObjectExpression" ? node2.parent.properties : node2.parent.elements;
                if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) ;
                else if (typeof options[parent.type] === "number") {
                  nodeIndent += options[parent.type] * indentSize;
                } else {
                  nodeIndent = parentElements[0].loc.start.column;
                }
              } else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
                if (typeof options.CallExpression.arguments === "number") {
                  nodeIndent += options.CallExpression.arguments * indentSize;
                } else if (options.CallExpression.arguments === "first") {
                  if (parent.arguments.includes(node2)) {
                    nodeIndent = parent.arguments[0].loc.start.column;
                  }
                } else {
                  nodeIndent += indentSize;
                }
              } else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
                nodeIndent += indentSize;
              }
            }
          }
          checkFirstNodeLineIndent(node2, nodeIndent);
        } else {
          nodeIndent = getNodeIndent(node2).goodChar;
        }
        if (options[node2.type] === "first") {
          elementsIndent = elements.length ? elements[0].loc.start.column : 0;
        } else {
          elementsIndent = nodeIndent + indentSize * options[node2.type];
        }
        if (isNodeInVarOnTop(node2, parentVarNode)) {
          elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }
        checkNodesIndent(elements, elementsIndent);
        if (elements.length > 0) {
          if (elements.at(-1).loc.end.line === node2.loc.end.line) {
            return;
          }
        }
        checkLastNodeLineIndent(
          node2,
          nodeIndent + (isNodeInVarOnTop(node2, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0)
        );
      }
      function isNodeBodyBlock(node2) {
        return node2.type === "BlockStatement" || node2.type === "ClassBody" || node2.body && node2.body.type === "BlockStatement" || node2.consequent && node2.consequent.type === "BlockStatement";
      }
      function blockIndentationCheck(node2) {
        if (isSingleLineNode(node2)) {
          return;
        }
        if (node2.parent && (node2.parent.type === "FunctionExpression" || node2.parent.type === "FunctionDeclaration" || node2.parent.type === "ArrowFunctionExpression")) {
          checkIndentInFunctionBlock(node2);
          return;
        }
        let indent2;
        let nodesToCheck;
        const statementsWithProperties = [
          "IfStatement",
          "WhileStatement",
          "ForStatement",
          "ForInStatement",
          "ForOfStatement",
          "DoWhileStatement",
          "ClassDeclaration",
          "TryStatement"
        ];
        if (node2.parent && statementsWithProperties.includes(node2.parent.type) && isNodeBodyBlock(node2)) {
          indent2 = getNodeIndent(node2.parent).goodChar;
        } else if (node2.parent && node2.parent.type === "CatchClause") {
          indent2 = getNodeIndent(node2.parent.parent).goodChar;
        } else {
          indent2 = getNodeIndent(node2).goodChar;
        }
        if (node2.type === "IfStatement" && node2.consequent.type !== "BlockStatement") {
          nodesToCheck = [node2.consequent];
        } else if (Array.isArray(node2.body)) {
          nodesToCheck = node2.body;
        } else {
          nodesToCheck = [node2.body];
        }
        if (nodesToCheck.length > 0) {
          checkNodesIndent(nodesToCheck, indent2 + indentSize);
        }
        if (node2.type === "BlockStatement") {
          checkLastNodeLineIndent(node2, indent2);
        }
      }
      function filterOutSameLineVars(node2) {
        return node2.declarations.reduce((finalCollection, elem) => {
          const lastElem = finalCollection.at(-1);
          if (elem.loc.start.line !== node2.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
            finalCollection.push(elem);
          }
          return finalCollection;
        }, []);
      }
      function checkIndentInVariableDeclarations(node2) {
        const elements = filterOutSameLineVars(node2);
        const nodeIndent = getNodeIndent(node2).goodChar;
        const lastElement = elements.at(-1);
        const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node2.kind];
        checkNodesIndent(elements, elementsIndent);
        if (sourceCode2.getLastToken(node2).loc.end.line <= lastElement.loc.end.line) {
          return;
        }
        const tokenBeforeLastElement = sourceCode2.getTokenBefore(lastElement);
        if (tokenBeforeLastElement.value === ",") {
          checkLastNodeLineIndent(
            node2,
            getNodeIndent(tokenBeforeLastElement).goodChar
          );
        } else {
          checkLastNodeLineIndent(node2, elementsIndent - indentSize);
        }
      }
      function blockLessNodes(node2) {
        if (node2.body.type !== "BlockStatement") {
          blockIndentationCheck(node2);
        }
      }
      function expectedCaseIndent(node2, providedSwitchIndent) {
        const switchNode = node2.type === "SwitchStatement" ? node2 : node2.parent;
        const switchIndent = typeof providedSwitchIndent === "undefined" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;
        let caseIndent;
        if (caseIndentStore[switchNode.loc.start.line]) {
          return caseIndentStore[switchNode.loc.start.line];
        }
        if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
          caseIndent = switchIndent;
        } else {
          caseIndent = switchIndent + indentSize * options.SwitchCase;
        }
        caseIndentStore[switchNode.loc.start.line] = caseIndent;
        return caseIndent;
      }
      function isWrappedInParenthesis(node2) {
        const regex = /^return\s*\(\s*\)/u;
        const statementWithoutArgument = sourceCode2.getText(node2).replace(sourceCode2.getText(node2.argument), "");
        return regex.test(statementWithoutArgument);
      }
      return {
        Program(node2) {
          if (node2.body.length > 0) {
            checkNodesIndent(node2.body, getNodeIndent(node2).goodChar);
          }
        },
        ClassBody: blockIndentationCheck,
        BlockStatement: blockIndentationCheck,
        WhileStatement: blockLessNodes,
        ForStatement: blockLessNodes,
        ForInStatement: blockLessNodes,
        ForOfStatement: blockLessNodes,
        DoWhileStatement: blockLessNodes,
        IfStatement(node2) {
          if (node2.consequent.type !== "BlockStatement" && node2.consequent.loc.start.line > node2.loc.start.line) {
            blockIndentationCheck(node2);
          }
        },
        VariableDeclaration(node2) {
          if (node2.declarations.at(-1).loc.start.line > node2.declarations[0].loc.start.line) {
            checkIndentInVariableDeclarations(node2);
          }
        },
        ObjectExpression(node2) {
          checkIndentInArrayOrObjectBlock(node2);
        },
        ArrayExpression(node2) {
          checkIndentInArrayOrObjectBlock(node2);
        },
        MemberExpression(node2) {
          if (typeof options.MemberExpression === "undefined") {
            return;
          }
          if (isSingleLineNode(node2)) {
            return;
          }
          if (getParentNodeByType(node2, "VariableDeclarator", [
            "FunctionExpression",
            "ArrowFunctionExpression"
          ])) {
            return;
          }
          if (getParentNodeByType(node2, "AssignmentExpression", [
            "FunctionExpression"
          ])) {
            return;
          }
          const propertyIndent = getNodeIndent(node2).goodChar + indentSize * options.MemberExpression;
          const checkNodes = [node2.property];
          const dot2 = sourceCode2.getTokenBefore(node2.property);
          if (dot2.type === "Punctuator" && dot2.value === ".") {
            checkNodes.push(dot2);
          }
          checkNodesIndent(checkNodes, propertyIndent);
        },
        SwitchStatement(node2) {
          const switchIndent = getNodeIndent(node2).goodChar;
          const caseIndent = expectedCaseIndent(node2, switchIndent);
          checkNodesIndent(node2.cases, caseIndent);
          checkLastNodeLineIndent(node2, switchIndent);
        },
        SwitchCase(node2) {
          if (isSingleLineNode(node2)) {
            return;
          }
          const caseIndent = expectedCaseIndent(node2);
          checkNodesIndent(node2.consequent, caseIndent + indentSize);
        },
        FunctionDeclaration(node2) {
          if (isSingleLineNode(node2)) {
            return;
          }
          if (options.FunctionDeclaration.parameters === "first" && node2.params.length) {
            checkNodesIndent(
              node2.params.slice(1),
              node2.params[0].loc.start.column
            );
          } else if (options.FunctionDeclaration.parameters !== null) {
            checkNodesIndent(
              node2.params,
              getNodeIndent(node2).goodChar + indentSize * options.FunctionDeclaration.parameters
            );
          }
        },
        FunctionExpression(node2) {
          if (isSingleLineNode(node2)) {
            return;
          }
          if (options.FunctionExpression.parameters === "first" && node2.params.length) {
            checkNodesIndent(
              node2.params.slice(1),
              node2.params[0].loc.start.column
            );
          } else if (options.FunctionExpression.parameters !== null) {
            checkNodesIndent(
              node2.params,
              getNodeIndent(node2).goodChar + indentSize * options.FunctionExpression.parameters
            );
          }
        },
        ReturnStatement(node2) {
          if (isSingleLineNode(node2)) {
            return;
          }
          const firstLineIndent = getNodeIndent(node2).goodChar;
          if (isWrappedInParenthesis(node2)) {
            checkLastReturnStatementLineIndent(node2, firstLineIndent);
          } else {
            checkNodeIndent(node2, firstLineIndent);
          }
        },
        CallExpression(node2) {
          if (isSingleLineNode(node2)) {
            return;
          }
          if (options.CallExpression.arguments === "first" && node2.arguments.length) {
            checkNodesIndent(
              node2.arguments.slice(1),
              node2.arguments[0].loc.start.column
            );
          } else if (options.CallExpression.arguments !== null) {
            checkNodesIndent(
              node2.arguments,
              getNodeIndent(node2).goodChar + indentSize * options.CallExpression.arguments
            );
          }
        }
      };
    }
  };
  return indentLegacy;
}
var initDeclarations;
var hasRequiredInitDeclarations;
function requireInitDeclarations() {
  if (hasRequiredInitDeclarations) return initDeclarations;
  hasRequiredInitDeclarations = 1;
  const CONSTANT_BINDINGS = /* @__PURE__ */ new Set(["const", "using", "await using"]);
  function isForLoop(block) {
    return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
  }
  function isInitialized(node2) {
    const declaration = node2.parent;
    const block = declaration.parent;
    if (isForLoop(block)) {
      if (block.type === "ForStatement") {
        return block.init === declaration;
      }
      return block.left === declaration;
    }
    return Boolean(node2.init);
  }
  initDeclarations = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Require or disallow initialization in variable declarations",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/init-declarations"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              },
              {
                type: "object",
                properties: {
                  ignoreForLoopInit: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        initialized: "Variable '{{idName}}' should be initialized on declaration.",
        notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
      }
    },
    create(context) {
      const MODE_ALWAYS = "always", MODE_NEVER = "never";
      const mode = context.options[0] || MODE_ALWAYS;
      const params = context.options[1] || {};
      let insideDeclaredNamespace = false;
      return {
        TSModuleDeclaration(node2) {
          if (node2.declare) {
            insideDeclaredNamespace = true;
          }
        },
        "TSModuleDeclaration:exit"(node2) {
          if (node2.declare) {
            insideDeclaredNamespace = false;
          }
        },
        "VariableDeclaration:exit"(node2) {
          const kind = node2.kind, declarations = node2.declarations;
          if (node2.declare || insideDeclaredNamespace) {
            return;
          }
          for (let i2 = 0; i2 < declarations.length; ++i2) {
            const declaration = declarations[i2], id2 = declaration.id, initialized = isInitialized(declaration), isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node2.parent);
            let messageId = "";
            if (mode === MODE_ALWAYS && !initialized) {
              messageId = "initialized";
            } else if (mode === MODE_NEVER && !CONSTANT_BINDINGS.has(kind) && initialized && !isIgnoredForLoop) {
              messageId = "notInitialized";
            }
            if (id2.type === "Identifier" && messageId) {
              context.report({
                node: declaration,
                messageId,
                data: {
                  idName: id2.name
                }
              });
            }
          }
        }
      };
    }
  };
  return initDeclarations;
}
var jsxQuotes;
var hasRequiredJsxQuotes;
function requireJsxQuotes() {
  if (hasRequiredJsxQuotes) return jsxQuotes;
  hasRequiredJsxQuotes = 1;
  const astUtils2 = requireAstUtils();
  const QUOTE_SETTINGS = {
    "prefer-double": {
      quote: '"',
      description: "singlequote",
      convert(str) {
        return str.replace(/'/gu, '"');
      }
    },
    "prefer-single": {
      quote: "'",
      description: "doublequote",
      convert(str) {
        return str.replace(/"/gu, "'");
      }
    }
  };
  jsxQuotes = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "jsx-quotes",
              url: "https://eslint.style/rules/jsx-quotes"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce the consistent use of either double or single quotes in JSX attributes",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/jsx-quotes"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["prefer-single", "prefer-double"]
        }
      ],
      messages: {
        unexpected: "Unexpected usage of {{description}}."
      }
    },
    create(context) {
      const quoteOption = context.options[0] || "prefer-double", setting = QUOTE_SETTINGS[quoteOption];
      function usesExpectedQuotes(node2) {
        return node2.value.includes(setting.quote) || astUtils2.isSurroundedBy(node2.raw, setting.quote);
      }
      return {
        JSXAttribute(node2) {
          const attributeValue = node2.value;
          if (attributeValue && astUtils2.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
            context.report({
              node: attributeValue,
              messageId: "unexpected",
              data: {
                description: setting.description
              },
              fix(fixer) {
                return fixer.replaceText(
                  attributeValue,
                  setting.convert(attributeValue.raw)
                );
              }
            });
          }
        }
      };
    }
  };
  return jsxQuotes;
}
var keySpacing;
var hasRequiredKeySpacing;
function requireKeySpacing() {
  if (hasRequiredKeySpacing) return keySpacing;
  hasRequiredKeySpacing = 1;
  const astUtils2 = requireAstUtils();
  const { getGraphemeCount } = requireStringUtils();
  function containsLineTerminator(str) {
    return astUtils2.LINEBREAK_MATCHER.test(str);
  }
  function last(arr) {
    return arr.at(-1);
  }
  function isSingleLine(node2) {
    return node2.loc.end.line === node2.loc.start.line;
  }
  function isSingleLineProperties(properties2) {
    const [firstProp] = properties2, lastProp = last(properties2);
    return firstProp.loc.start.line === lastProp.loc.end.line;
  }
  function initOptionProperty(toOptions, fromOptions) {
    toOptions.mode = fromOptions.mode || "strict";
    if (typeof fromOptions.beforeColon !== "undefined") {
      toOptions.beforeColon = +fromOptions.beforeColon;
    } else {
      toOptions.beforeColon = 0;
    }
    if (typeof fromOptions.afterColon !== "undefined") {
      toOptions.afterColon = +fromOptions.afterColon;
    } else {
      toOptions.afterColon = 1;
    }
    if (typeof fromOptions.align !== "undefined") {
      if (typeof fromOptions.align === "object") {
        toOptions.align = fromOptions.align;
      } else {
        toOptions.align = {
          on: fromOptions.align,
          mode: toOptions.mode,
          beforeColon: toOptions.beforeColon,
          afterColon: toOptions.afterColon
        };
      }
    }
    return toOptions;
  }
  function initOptions(toOptions, fromOptions) {
    if (typeof fromOptions.align === "object") {
      toOptions.align = initOptionProperty({}, fromOptions.align);
      toOptions.align.on = fromOptions.align.on || "colon";
      toOptions.align.mode = fromOptions.align.mode || "strict";
      toOptions.multiLine = initOptionProperty(
        {},
        fromOptions.multiLine || fromOptions
      );
      toOptions.singleLine = initOptionProperty(
        {},
        fromOptions.singleLine || fromOptions
      );
    } else {
      toOptions.multiLine = initOptionProperty(
        {},
        fromOptions.multiLine || fromOptions
      );
      toOptions.singleLine = initOptionProperty(
        {},
        fromOptions.singleLine || fromOptions
      );
      if (toOptions.multiLine.align) {
        toOptions.align = {
          on: toOptions.multiLine.align.on,
          mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
          beforeColon: toOptions.multiLine.align.beforeColon,
          afterColon: toOptions.multiLine.align.afterColon
        };
      }
    }
    return toOptions;
  }
  keySpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "key-spacing",
              url: "https://eslint.style/rules/key-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing between keys and values in object literal properties",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/key-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          anyOf: [
            {
              type: "object",
              properties: {
                align: {
                  anyOf: [
                    {
                      enum: ["colon", "value"]
                    },
                    {
                      type: "object",
                      properties: {
                        mode: {
                          enum: ["strict", "minimum"]
                        },
                        on: {
                          enum: ["colon", "value"]
                        },
                        beforeColon: {
                          type: "boolean"
                        },
                        afterColon: {
                          type: "boolean"
                        }
                      },
                      additionalProperties: false
                    }
                  ]
                },
                mode: {
                  enum: ["strict", "minimum"]
                },
                beforeColon: {
                  type: "boolean"
                },
                afterColon: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                singleLine: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                multiLine: {
                  type: "object",
                  properties: {
                    align: {
                      anyOf: [
                        {
                          enum: ["colon", "value"]
                        },
                        {
                          type: "object",
                          properties: {
                            mode: {
                              enum: [
                                "strict",
                                "minimum"
                              ]
                            },
                            on: {
                              enum: [
                                "colon",
                                "value"
                              ]
                            },
                            beforeColon: {
                              type: "boolean"
                            },
                            afterColon: {
                              type: "boolean"
                            }
                          },
                          additionalProperties: false
                        }
                      ]
                    },
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                singleLine: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                multiLine: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                align: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    on: {
                      enum: ["colon", "value"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        extraKey: "Extra space after {{computed}}key '{{key}}'.",
        extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
        missingKey: "Missing space after {{computed}}key '{{key}}'.",
        missingValue: "Missing space before value for {{computed}}key '{{key}}'."
      }
    },
    create(context) {
      const options = context.options[0] || {}, ruleOptions = initOptions({}, options), multiLineOptions = ruleOptions.multiLine, singleLineOptions = ruleOptions.singleLine, alignmentOptions = ruleOptions.align || null;
      const sourceCode2 = context.sourceCode;
      function isKeyValueProperty(property) {
        return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property");
      }
      function getNextColon(node2) {
        return sourceCode2.getTokenAfter(node2, astUtils2.isColonToken);
      }
      function getLastTokenBeforeColon(node2) {
        const colonToken = getNextColon(node2);
        return sourceCode2.getTokenBefore(colonToken);
      }
      function getFirstTokenAfterColon(node2) {
        const colonToken = getNextColon(node2);
        return sourceCode2.getTokenAfter(colonToken);
      }
      function continuesPropertyGroup(lastMember, candidate) {
        const groupEndLine = lastMember.loc.start.line, candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;
        if (candidateValueStartLine - groupEndLine <= 1) {
          return true;
        }
        const leadingComments = sourceCode2.getCommentsBefore(candidate);
        if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateValueStartLine - last(leadingComments).loc.end.line <= 1) {
          for (let i2 = 1; i2 < leadingComments.length; i2++) {
            if (leadingComments[i2].loc.start.line - leadingComments[i2 - 1].loc.end.line > 1) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function getKey(property) {
        const key = property.key;
        if (property.computed) {
          return sourceCode2.getText().slice(key.range[0], key.range[1]);
        }
        return astUtils2.getStaticPropertyName(property);
      }
      function report(property, side, whitespace, expected, mode) {
        const diff = whitespace.length - expected;
        if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
          const nextColon = getNextColon(property.key), tokenBeforeColon = sourceCode2.getTokenBefore(nextColon, {
            includeComments: true
          }), tokenAfterColon = sourceCode2.getTokenAfter(nextColon, {
            includeComments: true
          }), isKeySide = side === "key", isExtra = diff > 0, diffAbs = Math.abs(diff), spaces2 = Array(diffAbs + 1).join(" ");
          const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
          const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
          const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
          const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;
          let fix;
          if (isExtra) {
            let range;
            if (isKeySide) {
              range = [
                tokenBeforeColon.range[1],
                tokenBeforeColon.range[1] + diffAbs
              ];
            } else {
              range = [
                tokenAfterColon.range[0] - diffAbs,
                tokenAfterColon.range[0]
              ];
            }
            fix = function(fixer) {
              return fixer.removeRange(range);
            };
          } else {
            if (isKeySide) {
              fix = function(fixer) {
                return fixer.insertTextAfter(
                  tokenBeforeColon,
                  spaces2
                );
              };
            } else {
              fix = function(fixer) {
                return fixer.insertTextBefore(
                  tokenAfterColon,
                  spaces2
                );
              };
            }
          }
          let messageId;
          if (isExtra) {
            messageId = side === "key" ? "extraKey" : "extraValue";
          } else {
            messageId = side === "key" ? "missingKey" : "missingValue";
          }
          context.report({
            node: property[side],
            loc,
            messageId,
            data: {
              computed: property.computed ? "computed " : "",
              key: getKey(property)
            },
            fix
          });
        }
      }
      function getKeyWidth(property) {
        const startToken = sourceCode2.getFirstToken(property);
        const endToken = getLastTokenBeforeColon(property.key);
        return getGraphemeCount(
          sourceCode2.getText().slice(startToken.range[0], endToken.range[1])
        );
      }
      function getPropertyWhitespace(property) {
        const whitespace = /(\s*):(\s*)/u.exec(
          sourceCode2.getText().slice(property.key.range[1], property.value.range[0])
        );
        if (whitespace) {
          return {
            beforeColon: whitespace[1],
            afterColon: whitespace[2]
          };
        }
        return null;
      }
      function createGroups(node2) {
        if (node2.properties.length === 1) {
          return [node2.properties];
        }
        return node2.properties.reduce(
          (groups, property) => {
            const currentGroup = last(groups), prev = last(currentGroup);
            if (!prev || continuesPropertyGroup(prev, property)) {
              currentGroup.push(property);
            } else {
              groups.push([property]);
            }
            return groups;
          },
          [[]]
        );
      }
      function verifyGroupAlignment(properties2) {
        const length = properties2.length, widths = properties2.map(getKeyWidth), align = alignmentOptions.on;
        let targetWidth = Math.max(...widths), beforeColon, afterColon, mode;
        if (alignmentOptions && length > 1) {
          beforeColon = alignmentOptions.beforeColon;
          afterColon = alignmentOptions.afterColon;
          mode = alignmentOptions.mode;
        } else {
          beforeColon = multiLineOptions.beforeColon;
          afterColon = multiLineOptions.afterColon;
          mode = alignmentOptions.mode;
        }
        targetWidth += align === "colon" ? beforeColon : afterColon;
        for (let i2 = 0; i2 < length; i2++) {
          const property = properties2[i2];
          const whitespace = getPropertyWhitespace(property);
          if (whitespace) {
            const width = widths[i2];
            if (align === "value") {
              report(
                property,
                "key",
                whitespace.beforeColon,
                beforeColon,
                mode
              );
              report(
                property,
                "value",
                whitespace.afterColon,
                targetWidth - width,
                mode
              );
            } else {
              report(
                property,
                "key",
                whitespace.beforeColon,
                targetWidth - width,
                mode
              );
              report(
                property,
                "value",
                whitespace.afterColon,
                afterColon,
                mode
              );
            }
          }
        }
      }
      function verifySpacing(node2, lineOptions) {
        const actual = getPropertyWhitespace(node2);
        if (actual) {
          report(
            node2,
            "key",
            actual.beforeColon,
            lineOptions.beforeColon,
            lineOptions.mode
          );
          report(
            node2,
            "value",
            actual.afterColon,
            lineOptions.afterColon,
            lineOptions.mode
          );
        }
      }
      function verifyListSpacing(properties2, lineOptions) {
        const length = properties2.length;
        for (let i2 = 0; i2 < length; i2++) {
          verifySpacing(properties2[i2], lineOptions);
        }
      }
      function verifyAlignment(node2) {
        createGroups(node2).forEach((group) => {
          const properties2 = group.filter(isKeyValueProperty);
          if (properties2.length > 0 && isSingleLineProperties(properties2)) {
            verifyListSpacing(properties2, multiLineOptions);
          } else {
            verifyGroupAlignment(properties2);
          }
        });
      }
      if (alignmentOptions) {
        return {
          ObjectExpression(node2) {
            if (isSingleLine(node2)) {
              verifyListSpacing(
                node2.properties.filter(isKeyValueProperty),
                singleLineOptions
              );
            } else {
              verifyAlignment(node2);
            }
          }
        };
      }
      return {
        Property(node2) {
          verifySpacing(
            node2,
            isSingleLine(node2.parent) ? singleLineOptions : multiLineOptions
          );
        }
      };
    }
  };
  return keySpacing;
}
var keywordSpacing;
var hasRequiredKeywordSpacing;
function requireKeywordSpacing() {
  if (hasRequiredKeywordSpacing) return keywordSpacing;
  hasRequiredKeywordSpacing = 1;
  const astUtils2 = requireAstUtils(), keywords2 = requireKeywords();
  const PREV_TOKEN = /^[)\]}>]$/u;
  const NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/u;
  const PREV_TOKEN_M = /^[)\]}>*]$/u;
  const NEXT_TOKEN_M = /^[{*]$/u;
  const TEMPLATE_OPEN_PAREN = /\$\{$/u;
  const TEMPLATE_CLOSE_PAREN = /^\}/u;
  const CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;
  const KEYS = keywords2.concat([
    "as",
    "async",
    "await",
    "from",
    "get",
    "let",
    "of",
    "set",
    "yield"
  ]);
  (function() {
    KEYS.sort();
    for (let i2 = 1; i2 < KEYS.length; ++i2) {
      if (KEYS[i2] === KEYS[i2 - 1]) {
        throw new Error(
          `Duplication was found in the keyword list: ${KEYS[i2]}`
        );
      }
    }
  })();
  function isOpenParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
  }
  function isCloseParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
  }
  keywordSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "keyword-spacing",
              url: "https://eslint.style/rules/keyword-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after keywords",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/keyword-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: { type: "boolean", default: true },
            after: { type: "boolean", default: true },
            overrides: {
              type: "object",
              properties: KEYS.reduce((retv, key) => {
                retv[key] = {
                  type: "object",
                  properties: {
                    before: { type: "boolean" },
                    after: { type: "boolean" }
                  },
                  additionalProperties: false
                };
                return retv;
              }, {}),
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedBefore: 'Expected space(s) before "{{value}}".',
        expectedAfter: 'Expected space(s) after "{{value}}".',
        unexpectedBefore: 'Unexpected space(s) before "{{value}}".',
        unexpectedAfter: 'Unexpected space(s) after "{{value}}".'
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const tokensToIgnore = /* @__PURE__ */ new WeakSet();
      function expectSpaceBefore(token, pattern2) {
        const prevToken = sourceCode2.getTokenBefore(token);
        if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern2.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils2.isTokenOnSameLine(prevToken, token) && !sourceCode2.isSpaceBetweenTokens(prevToken, token)) {
          context.report({
            loc: token.loc,
            messageId: "expectedBefore",
            data: token,
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
      }
      function unexpectSpaceBefore(token, pattern2) {
        const prevToken = sourceCode2.getTokenBefore(token);
        if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern2.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils2.isTokenOnSameLine(prevToken, token) && sourceCode2.isSpaceBetweenTokens(prevToken, token)) {
          context.report({
            loc: { start: prevToken.loc.end, end: token.loc.start },
            messageId: "unexpectedBefore",
            data: token,
            fix(fixer) {
              return fixer.removeRange([
                prevToken.range[1],
                token.range[0]
              ]);
            }
          });
        }
      }
      function expectSpaceAfter(token, pattern2) {
        const nextToken = sourceCode2.getTokenAfter(token);
        if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern2.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils2.isTokenOnSameLine(token, nextToken) && !sourceCode2.isSpaceBetweenTokens(token, nextToken)) {
          context.report({
            loc: token.loc,
            messageId: "expectedAfter",
            data: token,
            fix(fixer) {
              return fixer.insertTextAfter(token, " ");
            }
          });
        }
      }
      function unexpectSpaceAfter(token, pattern2) {
        const nextToken = sourceCode2.getTokenAfter(token);
        if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern2.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils2.isTokenOnSameLine(token, nextToken) && sourceCode2.isSpaceBetweenTokens(token, nextToken)) {
          context.report({
            loc: { start: token.loc.end, end: nextToken.loc.start },
            messageId: "unexpectedAfter",
            data: token,
            fix(fixer) {
              return fixer.removeRange([
                token.range[1],
                nextToken.range[0]
              ]);
            }
          });
        }
      }
      function parseOptions(options = {}) {
        const before = options.before !== false;
        const after = options.after !== false;
        const defaultValue = {
          before: before ? expectSpaceBefore : unexpectSpaceBefore,
          after: after ? expectSpaceAfter : unexpectSpaceAfter
        };
        const overrides2 = options && options.overrides || {};
        const retv = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < KEYS.length; ++i2) {
          const key = KEYS[i2];
          const override = overrides2[key];
          if (override) {
            const thisBefore = "before" in override ? override.before : before;
            const thisAfter = "after" in override ? override.after : after;
            retv[key] = {
              before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
              after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
            };
          } else {
            retv[key] = defaultValue;
          }
        }
        return retv;
      }
      const checkMethodMap = parseOptions(context.options[0]);
      function checkSpacingBefore(token, pattern2) {
        checkMethodMap[token.value].before(token, pattern2 || PREV_TOKEN);
      }
      function checkSpacingAfter(token, pattern2) {
        checkMethodMap[token.value].after(token, pattern2 || NEXT_TOKEN);
      }
      function checkSpacingAround(token) {
        checkSpacingBefore(token);
        checkSpacingAfter(token);
      }
      function checkSpacingAroundFirstToken(node2) {
        const firstToken = node2 && sourceCode2.getFirstToken(node2);
        if (firstToken && firstToken.type === "Keyword") {
          checkSpacingAround(firstToken);
        }
      }
      function checkSpacingBeforeFirstToken(node2) {
        const firstToken = node2 && sourceCode2.getFirstToken(node2);
        if (firstToken && firstToken.type === "Keyword") {
          checkSpacingBefore(firstToken);
        }
      }
      function checkSpacingAroundTokenBefore(node2) {
        if (node2) {
          const token = sourceCode2.getTokenBefore(
            node2,
            astUtils2.isKeywordToken
          );
          checkSpacingAround(token);
        }
      }
      function checkSpacingForFunction(node2) {
        const firstToken = node2 && sourceCode2.getFirstToken(node2);
        if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
          checkSpacingBefore(firstToken);
        }
      }
      function checkSpacingForClass(node2) {
        checkSpacingAroundFirstToken(node2);
        checkSpacingAroundTokenBefore(node2.superClass);
      }
      function checkSpacingForIfStatement(node2) {
        checkSpacingAroundFirstToken(node2);
        checkSpacingAroundTokenBefore(node2.alternate);
      }
      function checkSpacingForTryStatement(node2) {
        checkSpacingAroundFirstToken(node2);
        checkSpacingAroundFirstToken(node2.handler);
        checkSpacingAroundTokenBefore(node2.finalizer);
      }
      function checkSpacingForDoWhileStatement(node2) {
        checkSpacingAroundFirstToken(node2);
        checkSpacingAroundTokenBefore(node2.test);
      }
      function checkSpacingForForInStatement(node2) {
        checkSpacingAroundFirstToken(node2);
        const inToken = sourceCode2.getTokenBefore(
          node2.right,
          astUtils2.isNotOpeningParenToken
        );
        const previousToken = sourceCode2.getTokenBefore(inToken);
        if (previousToken.type !== "PrivateIdentifier") {
          checkSpacingBefore(inToken);
        }
        checkSpacingAfter(inToken);
      }
      function checkSpacingForForOfStatement(node2) {
        if (node2.await) {
          checkSpacingBefore(sourceCode2.getFirstToken(node2, 0));
          checkSpacingAfter(sourceCode2.getFirstToken(node2, 1));
        } else {
          checkSpacingAroundFirstToken(node2);
        }
        const ofToken = sourceCode2.getTokenBefore(
          node2.right,
          astUtils2.isNotOpeningParenToken
        );
        const previousToken = sourceCode2.getTokenBefore(ofToken);
        if (previousToken.type !== "PrivateIdentifier") {
          checkSpacingBefore(ofToken);
        }
        checkSpacingAfter(ofToken);
      }
      function checkSpacingForModuleDeclaration(node2) {
        const firstToken = sourceCode2.getFirstToken(node2);
        checkSpacingBefore(firstToken, PREV_TOKEN_M);
        checkSpacingAfter(firstToken, NEXT_TOKEN_M);
        if (node2.type === "ExportDefaultDeclaration") {
          checkSpacingAround(sourceCode2.getTokenAfter(firstToken));
        }
        if (node2.type === "ExportAllDeclaration" && node2.exported) {
          const asToken = sourceCode2.getTokenBefore(node2.exported);
          checkSpacingBefore(asToken, PREV_TOKEN_M);
          checkSpacingAfter(asToken, NEXT_TOKEN_M);
        }
        if (node2.source) {
          const fromToken = sourceCode2.getTokenBefore(node2.source);
          checkSpacingBefore(fromToken, PREV_TOKEN_M);
          checkSpacingAfter(fromToken, NEXT_TOKEN_M);
        }
      }
      function checkSpacingForImportSpecifier(node2) {
        if (node2.imported.range[0] !== node2.local.range[0]) {
          const asToken = sourceCode2.getTokenBefore(node2.local);
          checkSpacingBefore(asToken, PREV_TOKEN_M);
        }
      }
      function checkSpacingForExportSpecifier(node2) {
        if (node2.local.range[0] !== node2.exported.range[0]) {
          const asToken = sourceCode2.getTokenBefore(node2.exported);
          checkSpacingBefore(asToken, PREV_TOKEN_M);
          checkSpacingAfter(asToken, NEXT_TOKEN_M);
        }
      }
      function checkSpacingForImportNamespaceSpecifier(node2) {
        const asToken = sourceCode2.getFirstToken(node2, 1);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
      }
      function checkSpacingForProperty(node2) {
        if (node2.static) {
          checkSpacingAroundFirstToken(node2);
        }
        if (node2.kind === "get" || node2.kind === "set" || (node2.method || node2.type === "MethodDefinition") && node2.value.async) {
          const token = sourceCode2.getTokenBefore(node2.key, (tok) => {
            switch (tok.value) {
              case "get":
              case "set":
              case "async":
                return true;
              default:
                return false;
            }
          });
          if (!token) {
            throw new Error(
              "Failed to find token get, set, or async beside method name"
            );
          }
          checkSpacingAround(token);
        }
      }
      function checkSpacingForAwaitExpression(node2) {
        checkSpacingBefore(sourceCode2.getFirstToken(node2));
      }
      return {
        // Statements
        DebuggerStatement: checkSpacingAroundFirstToken,
        WithStatement: checkSpacingAroundFirstToken,
        // Statements - Control flow
        BreakStatement: checkSpacingAroundFirstToken,
        ContinueStatement: checkSpacingAroundFirstToken,
        ReturnStatement: checkSpacingAroundFirstToken,
        ThrowStatement: checkSpacingAroundFirstToken,
        TryStatement: checkSpacingForTryStatement,
        // Statements - Choice
        IfStatement: checkSpacingForIfStatement,
        SwitchStatement: checkSpacingAroundFirstToken,
        SwitchCase: checkSpacingAroundFirstToken,
        // Statements - Loops
        DoWhileStatement: checkSpacingForDoWhileStatement,
        ForInStatement: checkSpacingForForInStatement,
        ForOfStatement: checkSpacingForForOfStatement,
        ForStatement: checkSpacingAroundFirstToken,
        WhileStatement: checkSpacingAroundFirstToken,
        // Statements - Declarations
        ClassDeclaration: checkSpacingForClass,
        ExportNamedDeclaration: checkSpacingForModuleDeclaration,
        ExportDefaultDeclaration: checkSpacingForModuleDeclaration,
        ExportAllDeclaration: checkSpacingForModuleDeclaration,
        FunctionDeclaration: checkSpacingForFunction,
        ImportDeclaration: checkSpacingForModuleDeclaration,
        VariableDeclaration: checkSpacingAroundFirstToken,
        // Expressions
        ArrowFunctionExpression: checkSpacingForFunction,
        AwaitExpression: checkSpacingForAwaitExpression,
        ClassExpression: checkSpacingForClass,
        FunctionExpression: checkSpacingForFunction,
        NewExpression: checkSpacingBeforeFirstToken,
        Super: checkSpacingBeforeFirstToken,
        ThisExpression: checkSpacingBeforeFirstToken,
        UnaryExpression: checkSpacingBeforeFirstToken,
        YieldExpression: checkSpacingBeforeFirstToken,
        // Others
        ImportSpecifier: checkSpacingForImportSpecifier,
        ExportSpecifier: checkSpacingForExportSpecifier,
        ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
        MethodDefinition: checkSpacingForProperty,
        PropertyDefinition: checkSpacingForProperty,
        StaticBlock: checkSpacingAroundFirstToken,
        Property: checkSpacingForProperty,
        // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`
        "BinaryExpression[operator='>']"(node2) {
          const operatorToken2 = sourceCode2.getTokenBefore(
            node2.right,
            astUtils2.isNotOpeningParenToken
          );
          tokensToIgnore.add(operatorToken2);
        }
      };
    }
  };
  return keywordSpacing;
}
var lineCommentPosition;
var hasRequiredLineCommentPosition;
function requireLineCommentPosition() {
  if (hasRequiredLineCommentPosition) return lineCommentPosition;
  hasRequiredLineCommentPosition = 1;
  const astUtils2 = requireAstUtils();
  lineCommentPosition = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "9.3.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "line-comment-position",
              url: "https://eslint.style/rules/line-comment-position"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce position of line comments",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/line-comment-position"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["above", "beside"]
            },
            {
              type: "object",
              properties: {
                position: {
                  enum: ["above", "beside"]
                },
                ignorePattern: {
                  type: "string"
                },
                applyDefaultPatterns: {
                  type: "boolean"
                },
                applyDefaultIgnorePatterns: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        above: "Expected comment to be above code.",
        beside: "Expected comment to be beside code."
      }
    },
    create(context) {
      const options = context.options[0];
      let above, ignorePattern, applyDefaultIgnorePatterns = true;
      if (!options || typeof options === "string") {
        above = !options || options === "above";
      } else {
        above = !options.position || options.position === "above";
        ignorePattern = options.ignorePattern;
        if (Object.hasOwn(options, "applyDefaultIgnorePatterns")) {
          applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;
        } else {
          applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
        }
      }
      const defaultIgnoreRegExp = astUtils2.COMMENTS_IGNORE_PATTERN;
      const fallThroughRegExp = /^\s*falls?\s?through/u;
      const customIgnoreRegExp = new RegExp(ignorePattern, "u");
      const sourceCode2 = context.sourceCode;
      return {
        Program() {
          const comments = sourceCode2.getAllComments();
          comments.filter((token) => token.type === "Line").forEach((node2) => {
            if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node2.value) || fallThroughRegExp.test(node2.value))) {
              return;
            }
            if (ignorePattern && customIgnoreRegExp.test(node2.value)) {
              return;
            }
            const previous = sourceCode2.getTokenBefore(node2, {
              includeComments: true
            });
            const isOnSameLine = previous && previous.loc.end.line === node2.loc.start.line;
            if (above) {
              if (isOnSameLine) {
                context.report({
                  node: node2,
                  messageId: "above"
                });
              }
            } else {
              if (!isOnSameLine) {
                context.report({
                  node: node2,
                  messageId: "beside"
                });
              }
            }
          });
        }
      };
    }
  };
  return lineCommentPosition;
}
var linebreakStyle;
var hasRequiredLinebreakStyle;
function requireLinebreakStyle() {
  if (hasRequiredLinebreakStyle) return linebreakStyle;
  hasRequiredLinebreakStyle = 1;
  const astUtils2 = requireAstUtils();
  linebreakStyle = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "linebreak-style",
              url: "https://eslint.style/rules/linebreak-style"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent linebreak style",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/linebreak-style"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["unix", "windows"]
        }
      ],
      messages: {
        expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
        expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function createFix(range, text) {
        return function(fixer) {
          return fixer.replaceTextRange(range, text);
        };
      }
      return {
        Program: function checkForLinebreakStyle(node2) {
          const linebreakStyle2 = context.options[0] || "unix", expectedLF = linebreakStyle2 === "unix", expectedLFChars = expectedLF ? "\n" : "\r\n", source = sourceCode2.getText(), pattern2 = astUtils2.createGlobalLinebreakMatcher();
          let match;
          let i2 = 0;
          while ((match = pattern2.exec(source)) !== null) {
            i2++;
            if (match[0] === expectedLFChars) {
              continue;
            }
            const index = match.index;
            const range = [index, index + match[0].length];
            context.report({
              node: node2,
              loc: {
                start: {
                  line: i2,
                  column: sourceCode2.lines[i2 - 1].length
                },
                end: {
                  line: i2 + 1,
                  column: 0
                }
              },
              messageId: expectedLF ? "expectedLF" : "expectedCRLF",
              fix: createFix(range, expectedLFChars)
            });
          }
        }
      };
    }
  };
  return linebreakStyle;
}
var linesAroundComment;
var hasRequiredLinesAroundComment;
function requireLinesAroundComment() {
  if (hasRequiredLinesAroundComment) return linesAroundComment;
  hasRequiredLinesAroundComment = 1;
  const astUtils2 = requireAstUtils();
  function getEmptyLineNums(lines) {
    const emptyLines = lines.map((line, i2) => ({
      code: line.trim(),
      num: i2 + 1
    })).filter((line) => !line.code).map((line) => line.num);
    return emptyLines;
  }
  function getCommentLineNums(comments) {
    const lines = [];
    comments.forEach((token) => {
      const start = token.loc.start.line;
      const end = token.loc.end.line;
      lines.push(start, end);
    });
    return lines;
  }
  linesAroundComment = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "lines-around-comment",
              url: "https://eslint.style/rules/lines-around-comment"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require empty lines around comments",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/lines-around-comment"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            beforeBlockComment: {
              type: "boolean",
              default: true
            },
            afterBlockComment: {
              type: "boolean",
              default: false
            },
            beforeLineComment: {
              type: "boolean",
              default: false
            },
            afterLineComment: {
              type: "boolean",
              default: false
            },
            allowBlockStart: {
              type: "boolean",
              default: false
            },
            allowBlockEnd: {
              type: "boolean",
              default: false
            },
            allowClassStart: {
              type: "boolean"
            },
            allowClassEnd: {
              type: "boolean"
            },
            allowObjectStart: {
              type: "boolean"
            },
            allowObjectEnd: {
              type: "boolean"
            },
            allowArrayStart: {
              type: "boolean"
            },
            allowArrayEnd: {
              type: "boolean"
            },
            ignorePattern: {
              type: "string"
            },
            applyDefaultIgnorePatterns: {
              type: "boolean"
            },
            afterHashbangComment: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        after: "Expected line after comment.",
        before: "Expected line before comment."
      }
    },
    create(context) {
      const options = Object.assign({}, context.options[0]);
      const ignorePattern = options.ignorePattern;
      const defaultIgnoreRegExp = astUtils2.COMMENTS_IGNORE_PATTERN;
      const customIgnoreRegExp = new RegExp(ignorePattern, "u");
      const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
      options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
      const sourceCode2 = context.sourceCode;
      const lines = sourceCode2.lines, numLines = lines.length + 1, comments = sourceCode2.getAllComments(), commentLines = getCommentLineNums(comments), emptyLines = getEmptyLineNums(lines), commentAndEmptyLines = new Set(commentLines.concat(emptyLines));
      function codeAroundComment(token) {
        let currentToken = token;
        do {
          currentToken = sourceCode2.getTokenBefore(currentToken, {
            includeComments: true
          });
        } while (currentToken && astUtils2.isCommentToken(currentToken));
        if (currentToken && astUtils2.isTokenOnSameLine(currentToken, token)) {
          return true;
        }
        currentToken = token;
        do {
          currentToken = sourceCode2.getTokenAfter(currentToken, {
            includeComments: true
          });
        } while (currentToken && astUtils2.isCommentToken(currentToken));
        if (currentToken && astUtils2.isTokenOnSameLine(token, currentToken)) {
          return true;
        }
        return false;
      }
      function isParentNodeType(parent, nodeType) {
        return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
      }
      function getParentNodeOfToken(token) {
        const node2 = sourceCode2.getNodeByRangeIndex(token.range[0]);
        if (node2 && node2.type === "StaticBlock") {
          const openingBrace = sourceCode2.getFirstToken(node2, {
            skip: 1
          });
          return token.range[0] >= openingBrace.range[0] ? node2 : null;
        }
        return node2;
      }
      function isCommentAtParentStart(token, nodeType) {
        const parent = getParentNodeOfToken(token);
        if (parent && isParentNodeType(parent, nodeType)) {
          let parentStartNodeOrToken = parent;
          if (parent.type === "StaticBlock") {
            parentStartNodeOrToken = sourceCode2.getFirstToken(parent, {
              skip: 1
            });
          } else if (parent.type === "SwitchStatement") {
            parentStartNodeOrToken = sourceCode2.getTokenAfter(
              parent.discriminant,
              {
                filter: astUtils2.isOpeningBraceToken
              }
            );
          }
          return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;
        }
        return false;
      }
      function isCommentAtParentEnd(token, nodeType) {
        const parent = getParentNodeOfToken(token);
        return !!parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
      }
      function isCommentAtBlockStart(token) {
        return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "StaticBlock") || isCommentAtParentStart(token, "SwitchCase") || isCommentAtParentStart(token, "SwitchStatement");
      }
      function isCommentAtBlockEnd(token) {
        return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "StaticBlock") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
      }
      function isCommentAtClassStart(token) {
        return isCommentAtParentStart(token, "ClassBody");
      }
      function isCommentAtClassEnd(token) {
        return isCommentAtParentEnd(token, "ClassBody");
      }
      function isCommentAtObjectStart(token) {
        return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
      }
      function isCommentAtObjectEnd(token) {
        return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
      }
      function isCommentAtArrayStart(token) {
        return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
      }
      function isCommentAtArrayEnd(token) {
        return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
      }
      function checkForEmptyLine(token, opts) {
        if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
          return;
        }
        if (ignorePattern && customIgnoreRegExp.test(token.value)) {
          return;
        }
        let after = opts.after, before = opts.before;
        const prevLineNum = token.loc.start.line - 1, nextLineNum = token.loc.end.line + 1, commentIsNotAlone = codeAroundComment(token);
        const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)), blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)), classStartAllowed = options.allowClassStart && isCommentAtClassStart(token), classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token), objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token), objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token), arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token), arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);
        const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
        const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
        if (prevLineNum < 1) {
          before = false;
        }
        if (nextLineNum >= numLines) {
          after = false;
        }
        if (commentIsNotAlone) {
          return;
        }
        const previousTokenOrComment = sourceCode2.getTokenBefore(token, {
          includeComments: true
        });
        const nextTokenOrComment = sourceCode2.getTokenAfter(token, {
          includeComments: true
        });
        if (!exceptionStartAllowed && before && !commentAndEmptyLines.has(prevLineNum) && !(astUtils2.isCommentToken(previousTokenOrComment) && astUtils2.isTokenOnSameLine(previousTokenOrComment, token))) {
          const lineStart = token.range[0] - token.loc.start.column;
          const range = [lineStart, lineStart];
          context.report({
            node: token,
            messageId: "before",
            fix(fixer) {
              return fixer.insertTextBeforeRange(range, "\n");
            }
          });
        }
        if (!exceptionEndAllowed && after && !commentAndEmptyLines.has(nextLineNum) && !(astUtils2.isCommentToken(nextTokenOrComment) && astUtils2.isTokenOnSameLine(token, nextTokenOrComment))) {
          context.report({
            node: token,
            messageId: "after",
            fix(fixer) {
              return fixer.insertTextAfter(token, "\n");
            }
          });
        }
      }
      return {
        Program() {
          comments.forEach((token) => {
            if (token.type === "Line") {
              if (options.beforeLineComment || options.afterLineComment) {
                checkForEmptyLine(token, {
                  after: options.afterLineComment,
                  before: options.beforeLineComment
                });
              }
            } else if (token.type === "Block") {
              if (options.beforeBlockComment || options.afterBlockComment) {
                checkForEmptyLine(token, {
                  after: options.afterBlockComment,
                  before: options.beforeBlockComment
                });
              }
            } else if (token.type === "Shebang") {
              if (options.afterHashbangComment) {
                checkForEmptyLine(token, {
                  after: options.afterHashbangComment,
                  before: false
                });
              }
            }
          });
        }
      };
    }
  };
  return linesAroundComment;
}
var linesAroundDirective;
var hasRequiredLinesAroundDirective;
function requireLinesAroundDirective() {
  if (hasRequiredLinesAroundDirective) return linesAroundDirective;
  hasRequiredLinesAroundDirective = 1;
  const astUtils2 = requireAstUtils();
  linesAroundDirective = {
    meta: {
      type: "layout",
      docs: {
        description: "Require or disallow newlines around directives",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/lines-around-directive"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                before: {
                  enum: ["always", "never"]
                },
                after: {
                  enum: ["always", "never"]
                }
              },
              additionalProperties: false,
              minProperties: 2
            }
          ]
        }
      ],
      fixable: "whitespace",
      messages: {
        expected: 'Expected newline {{location}} "{{value}}" directive.',
        unexpected: 'Unexpected newline {{location}} "{{value}}" directive.'
      },
      deprecated: {
        message: "The rule was replaced with a more general rule.",
        url: "https://eslint.org/blog/2017/06/eslint-v4.0.0-released/",
        deprecatedSince: "4.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "The new rule moved to a plugin.",
            url: "https://eslint.org/docs/latest/rules/padding-line-between-statements#examples",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "padding-line-between-statements",
              url: "https://eslint.style/rules/padding-line-between-statements"
            }
          }
        ]
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const config2 = context.options[0] || "always";
      const expectLineBefore = typeof config2 === "string" ? config2 : config2.before;
      const expectLineAfter = typeof config2 === "string" ? config2 : config2.after;
      function hasNewlineBefore(node2) {
        const tokenBefore = sourceCode2.getTokenBefore(node2, {
          includeComments: true
        });
        const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
        return node2.loc.start.line - tokenLineBefore >= 2;
      }
      function getLastTokenOnLine(node2) {
        const lastToken = sourceCode2.getLastToken(node2);
        const secondToLastToken = sourceCode2.getTokenBefore(lastToken);
        return astUtils2.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
      }
      function hasNewlineAfter(node2) {
        const lastToken = getLastTokenOnLine(node2);
        const tokenAfter = sourceCode2.getTokenAfter(lastToken, {
          includeComments: true
        });
        return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
      }
      function reportError(node2, location, expected) {
        context.report({
          node: node2,
          messageId: expected ? "expected" : "unexpected",
          data: {
            value: node2.expression.value,
            location
          },
          fix(fixer) {
            const lastToken = getLastTokenOnLine(node2);
            if (expected) {
              return location === "before" ? fixer.insertTextBefore(node2, "\n") : fixer.insertTextAfter(lastToken, "\n");
            }
            return fixer.removeRange(
              location === "before" ? [node2.range[0] - 1, node2.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]
            );
          }
        });
      }
      function checkDirectives(node2) {
        const directives2 = astUtils2.getDirectivePrologue(node2);
        if (!directives2.length) {
          return;
        }
        const firstDirective = directives2[0];
        const leadingComments = sourceCode2.getCommentsBefore(firstDirective);
        if (leadingComments.length) {
          if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
            reportError(firstDirective, "before", true);
          }
          if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
            reportError(firstDirective, "before", false);
          }
        } else if (node2.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
          reportError(firstDirective, "before", false);
        }
        const lastDirective = directives2.at(-1);
        const statements = node2.type === "Program" ? node2.body : node2.body.body;
        if (lastDirective === statements.at(-1) && !lastDirective.trailingComments) {
          return;
        }
        if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
          reportError(lastDirective, "after", true);
        }
        if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
          reportError(lastDirective, "after", false);
        }
      }
      return {
        Program: checkDirectives,
        FunctionDeclaration: checkDirectives,
        FunctionExpression: checkDirectives,
        ArrowFunctionExpression: checkDirectives
      };
    }
  };
  return linesAroundDirective;
}
var linesBetweenClassMembers;
var hasRequiredLinesBetweenClassMembers;
function requireLinesBetweenClassMembers() {
  if (hasRequiredLinesBetweenClassMembers) return linesBetweenClassMembers;
  hasRequiredLinesBetweenClassMembers = 1;
  const astUtils2 = requireAstUtils();
  const ClassMemberTypes = {
    "*": { test: () => true },
    field: { test: (node2) => node2.type === "PropertyDefinition" },
    method: { test: (node2) => node2.type === "MethodDefinition" }
  };
  linesBetweenClassMembers = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "lines-between-class-members",
              url: "https://eslint.style/rules/lines-between-class-members"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow an empty line between class members",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/lines-between-class-members"
      },
      fixable: "whitespace",
      schema: [
        {
          anyOf: [
            {
              type: "object",
              properties: {
                enforce: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      blankLine: {
                        enum: ["always", "never"]
                      },
                      prev: {
                        enum: ["method", "field", "*"]
                      },
                      next: {
                        enum: ["method", "field", "*"]
                      }
                    },
                    additionalProperties: false,
                    required: ["blankLine", "prev", "next"]
                  },
                  minItems: 1
                }
              },
              additionalProperties: false,
              required: ["enforce"]
            },
            {
              enum: ["always", "never"]
            }
          ]
        },
        {
          type: "object",
          properties: {
            exceptAfterSingleLine: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        never: "Unexpected blank line between class members.",
        always: "Expected blank line between class members."
      }
    },
    create(context) {
      const options = [];
      options[0] = context.options[0] || "always";
      options[1] = context.options[1] || { exceptAfterSingleLine: false };
      const configureList = typeof options[0] === "object" ? options[0].enforce : [{ blankLine: options[0], prev: "*", next: "*" }];
      const sourceCode2 = context.sourceCode;
      function getBoundaryTokens(curNode, nextNode) {
        const lastToken = sourceCode2.getLastToken(curNode);
        const prevToken = sourceCode2.getTokenBefore(lastToken);
        const nextToken = sourceCode2.getFirstToken(nextNode);
        const isSemicolonLessStyle = astUtils2.isSemicolonToken(lastToken) && !astUtils2.isTokenOnSameLine(prevToken, lastToken) && astUtils2.isTokenOnSameLine(lastToken, nextToken);
        return isSemicolonLessStyle ? { curLast: prevToken, nextFirst: lastToken } : { curLast: lastToken, nextFirst: nextToken };
      }
      function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {
        const after = sourceCode2.getTokenAfter(prevLastToken, {
          includeComments: true
        });
        if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {
          return findLastConsecutiveTokenAfter(
            after,
            nextFirstToken,
            maxLine
          );
        }
        return prevLastToken;
      }
      function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {
        const before = sourceCode2.getTokenBefore(nextFirstToken, {
          includeComments: true
        });
        if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {
          return findFirstConsecutiveTokenBefore(
            before,
            prevLastToken,
            maxLine
          );
        }
        return nextFirstToken;
      }
      function hasTokenOrCommentBetween(before, after) {
        return sourceCode2.getTokensBetween(before, after, {
          includeComments: true
        }).length !== 0;
      }
      function match(node2, type2) {
        return ClassMemberTypes[type2].test(node2);
      }
      function getPaddingType(prevNode, nextNode) {
        for (let i2 = configureList.length - 1; i2 >= 0; --i2) {
          const configure = configureList[i2];
          const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);
          if (matched) {
            return configure.blankLine;
          }
        }
        return null;
      }
      return {
        ClassBody(node2) {
          const body = node2.body;
          for (let i2 = 0; i2 < body.length - 1; i2++) {
            const curFirst = sourceCode2.getFirstToken(body[i2]);
            const { curLast, nextFirst } = getBoundaryTokens(
              body[i2],
              body[i2 + 1]
            );
            const isMulti = !astUtils2.isTokenOnSameLine(
              curFirst,
              curLast
            );
            const skip = !isMulti && options[1].exceptAfterSingleLine;
            const beforePadding = findLastConsecutiveTokenAfter(
              curLast,
              nextFirst,
              1
            );
            const afterPadding = findFirstConsecutiveTokenBefore(
              nextFirst,
              curLast,
              1
            );
            const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
            const hasTokenInPadding = hasTokenOrCommentBetween(
              beforePadding,
              afterPadding
            );
            const curLineLastToken = findLastConsecutiveTokenAfter(
              curLast,
              nextFirst,
              0
            );
            const paddingType = getPaddingType(body[i2], body[i2 + 1]);
            if (paddingType === "never" && isPadded) {
              context.report({
                node: body[i2 + 1],
                messageId: "never",
                fix(fixer) {
                  if (hasTokenInPadding) {
                    return null;
                  }
                  return fixer.replaceTextRange(
                    [
                      beforePadding.range[1],
                      afterPadding.range[0]
                    ],
                    "\n"
                  );
                }
              });
            } else if (paddingType === "always" && !skip && !isPadded) {
              context.report({
                node: body[i2 + 1],
                messageId: "always",
                fix(fixer) {
                  if (hasTokenInPadding) {
                    return null;
                  }
                  return fixer.insertTextAfter(
                    curLineLastToken,
                    "\n"
                  );
                }
              });
            }
          }
        }
      };
    }
  };
  return linesBetweenClassMembers;
}
var logicalAssignmentOperators;
var hasRequiredLogicalAssignmentOperators;
function requireLogicalAssignmentOperators() {
  if (hasRequiredLogicalAssignmentOperators) return logicalAssignmentOperators;
  hasRequiredLogicalAssignmentOperators = 1;
  const astUtils2 = requireAstUtils();
  const baseTypes = /* @__PURE__ */ new Set(["Identifier", "Super", "ThisExpression"]);
  function isUndefined(expression, scope) {
    if (expression.type === "Identifier" && expression.name === "undefined") {
      return astUtils2.isReferenceToGlobalVariable(scope, expression);
    }
    return expression.type === "UnaryExpression" && expression.operator === "void" && expression.argument.type === "Literal" && expression.argument.value === 0;
  }
  function isReference(expression) {
    return expression.type === "Identifier" && expression.name !== "undefined" || expression.type === "MemberExpression";
  }
  function isImplicitNullishComparison(expression, scope) {
    if (expression.type !== "BinaryExpression" || expression.operator !== "==") {
      return false;
    }
    const reference = isReference(expression.left) ? "left" : "right";
    const nullish = reference === "left" ? "right" : "left";
    return isReference(expression[reference]) && (astUtils2.isNullLiteral(expression[nullish]) || isUndefined(expression[nullish], scope));
  }
  function isDoubleComparison(expression) {
    return expression.type === "LogicalExpression" && expression.operator === "||" && expression.left.type === "BinaryExpression" && expression.left.operator === "===" && expression.right.type === "BinaryExpression" && expression.right.operator === "===";
  }
  function isExplicitNullishComparison(expression, scope) {
    if (!isDoubleComparison(expression)) {
      return false;
    }
    const leftReference = isReference(expression.left.left) ? "left" : "right";
    const leftNullish = leftReference === "left" ? "right" : "left";
    const rightReference = isReference(expression.right.left) ? "left" : "right";
    const rightNullish = rightReference === "left" ? "right" : "left";
    return astUtils2.isSameReference(
      expression.left[leftReference],
      expression.right[rightReference]
    ) && (astUtils2.isNullLiteral(expression.left[leftNullish]) && isUndefined(expression.right[rightNullish], scope) || isUndefined(expression.left[leftNullish], scope) && astUtils2.isNullLiteral(expression.right[rightNullish]));
  }
  function isBooleanCast(expression, scope) {
    return expression.type === "CallExpression" && expression.callee.name === "Boolean" && expression.arguments.length === 1 && astUtils2.isReferenceToGlobalVariable(scope, expression.callee);
  }
  function getExistence(expression, scope) {
    const isNegated = expression.type === "UnaryExpression" && expression.operator === "!";
    const base2 = isNegated ? expression.argument : expression;
    switch (true) {
      case isReference(base2):
        return { reference: base2, operator: isNegated ? "||" : "&&" };
      case (base2.type === "UnaryExpression" && base2.operator === "!" && isReference(base2.argument)):
        return { reference: base2.argument, operator: "&&" };
      case (isBooleanCast(base2, scope) && isReference(base2.arguments[0])):
        return {
          reference: base2.arguments[0],
          operator: isNegated ? "||" : "&&"
        };
      case isImplicitNullishComparison(expression, scope):
        return {
          reference: isReference(expression.left) ? expression.left : expression.right,
          operator: "??"
        };
      case isExplicitNullishComparison(expression, scope):
        return {
          reference: isReference(expression.left.left) ? expression.left.left : expression.left.right,
          operator: "??"
        };
      default:
        return null;
    }
  }
  function isInsideWithBlock(node2) {
    if (node2.type === "Program") {
      return false;
    }
    return node2.parent.type === "WithStatement" && node2.parent.body === node2 ? true : isInsideWithBlock(node2.parent);
  }
  function getLeftmostOperand(sourceCode2, node2) {
    let left = node2.left;
    while (left.type === "LogicalExpression" && left.operator === node2.operator) {
      if (astUtils2.isParenthesised(sourceCode2, left)) {
        return left;
      }
      left = left.left;
    }
    return left;
  }
  logicalAssignmentOperators = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow logical assignment operator shorthand",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/logical-assignment-operators"
      },
      schema: {
        type: "array",
        oneOf: [
          {
            items: [
              { const: "always" },
              {
                type: "object",
                properties: {
                  enforceForIfStatements: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            // 0 for allowing passing no options
            maxItems: 2
          },
          {
            items: [{ const: "never" }],
            minItems: 1,
            maxItems: 1
          }
        ]
      },
      fixable: "code",
      hasSuggestions: true,
      messages: {
        assignment: "Assignment (=) can be replaced with operator assignment ({{operator}}).",
        useLogicalOperator: "Convert this assignment to use the operator {{ operator }}.",
        logical: "Logical expression can be replaced with an assignment ({{ operator }}).",
        convertLogical: "Replace this logical expression with an assignment with the operator {{ operator }}.",
        if: "'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.",
        convertIf: "Replace this 'if' statement with a logical assignment with operator {{ operator }}.",
        unexpected: "Unexpected logical operator assignment ({{operator}}) shorthand.",
        separate: "Separate the logical assignment into an assignment with a logical operator."
      }
    },
    create(context) {
      const mode = context.options[0] === "never" ? "never" : "always";
      const checkIf = mode === "always" && context.options.length > 1 && context.options[1].enforceForIfStatements;
      const sourceCode2 = context.sourceCode;
      const isStrict = sourceCode2.getScope(sourceCode2.ast).isStrict;
      function cannotBeGetter(node2) {
        return node2.type === "Identifier" && (isStrict || !isInsideWithBlock(node2));
      }
      function accessesSingleProperty(node2) {
        if (!isStrict && isInsideWithBlock(node2)) {
          return node2.type === "Identifier";
        }
        return node2.type === "MemberExpression" && baseTypes.has(node2.object.type) && (!node2.computed || node2.property.type !== "MemberExpression" && node2.property.type !== "ChainExpression");
      }
      function createConditionalFixer(descriptor, suggestion, shouldBeFixed) {
        if (shouldBeFixed) {
          return {
            ...descriptor,
            fix: suggestion.fix
          };
        }
        return {
          ...descriptor,
          suggest: [suggestion]
        };
      }
      function getOperatorToken(node2) {
        return sourceCode2.getFirstTokenBetween(
          node2.left,
          node2.right,
          (token) => token.value === node2.operator
        );
      }
      if (mode === "never") {
        return {
          // foo ||= bar
          AssignmentExpression(assignment) {
            if (!astUtils2.isLogicalAssignmentOperator(
              assignment.operator
            )) {
              return;
            }
            const descriptor = {
              messageId: "unexpected",
              node: assignment,
              data: { operator: assignment.operator }
            };
            const suggestion = {
              messageId: "separate",
              *fix(ruleFixer2) {
                if (sourceCode2.getCommentsInside(assignment).length > 0) {
                  return;
                }
                const operatorToken2 = getOperatorToken(assignment);
                yield ruleFixer2.replaceText(operatorToken2, "=");
                const assignmentText = sourceCode2.getText(
                  assignment.left
                );
                const operator2 = assignment.operator.slice(0, -1);
                yield ruleFixer2.insertTextAfter(
                  operatorToken2,
                  ` ${assignmentText} ${operator2}`
                );
                const precedence = astUtils2.getPrecedence(assignment.right) <= astUtils2.getPrecedence({
                  type: "LogicalExpression",
                  operator: operator2
                });
                const mixed = assignment.operator === "??=" && astUtils2.isLogicalExpression(assignment.right);
                if (!astUtils2.isParenthesised(
                  sourceCode2,
                  assignment.right
                ) && (precedence || mixed)) {
                  yield ruleFixer2.insertTextBefore(
                    assignment.right,
                    "("
                  );
                  yield ruleFixer2.insertTextAfter(
                    assignment.right,
                    ")"
                  );
                }
              }
            };
            context.report(
              createConditionalFixer(
                descriptor,
                suggestion,
                cannotBeGetter(assignment.left)
              )
            );
          }
        };
      }
      return {
        // foo = foo || bar
        "AssignmentExpression[operator='='][right.type='LogicalExpression']"(assignment) {
          const leftOperand = getLeftmostOperand(
            sourceCode2,
            assignment.right
          );
          if (!astUtils2.isSameReference(assignment.left, leftOperand)) {
            return;
          }
          const descriptor = {
            messageId: "assignment",
            node: assignment,
            data: { operator: `${assignment.right.operator}=` }
          };
          const suggestion = {
            messageId: "useLogicalOperator",
            data: { operator: `${assignment.right.operator}=` },
            *fix(ruleFixer2) {
              if (sourceCode2.getCommentsInside(assignment).length > 0) {
                return;
              }
              const assignmentOperatorToken = getOperatorToken(assignment);
              yield ruleFixer2.insertTextBefore(
                assignmentOperatorToken,
                assignment.right.operator
              );
              const logicalOperatorToken = getOperatorToken(
                leftOperand.parent
              );
              const firstRightOperandToken = sourceCode2.getTokenAfter(logicalOperatorToken);
              yield ruleFixer2.removeRange([
                leftOperand.parent.range[0],
                firstRightOperandToken.range[0]
              ]);
            }
          };
          context.report(
            createConditionalFixer(
              descriptor,
              suggestion,
              cannotBeGetter(assignment.left)
            )
          );
        },
        // foo || (foo = bar)
        'LogicalExpression[right.type="AssignmentExpression"][right.operator="="]'(logical) {
          if (isReference(logical.left) && astUtils2.isSameReference(logical.left, logical.right.left)) {
            const descriptor = {
              messageId: "logical",
              node: logical,
              data: { operator: `${logical.operator}=` }
            };
            const suggestion = {
              messageId: "convertLogical",
              data: { operator: `${logical.operator}=` },
              *fix(ruleFixer2) {
                if (sourceCode2.getCommentsInside(logical).length > 0) {
                  return;
                }
                const parentPrecedence = astUtils2.getPrecedence(
                  logical.parent
                );
                const requiresOuterParenthesis = logical.parent.type !== "ExpressionStatement" && (parentPrecedence === -1 || astUtils2.getPrecedence({
                  type: "AssignmentExpression"
                }) < parentPrecedence);
                if (!astUtils2.isParenthesised(
                  sourceCode2,
                  logical
                ) && requiresOuterParenthesis) {
                  yield ruleFixer2.insertTextBefore(logical, "(");
                  yield ruleFixer2.insertTextAfter(logical, ")");
                }
                yield ruleFixer2.removeRange([
                  logical.range[0],
                  logical.right.range[0]
                ]);
                yield ruleFixer2.removeRange([
                  logical.right.range[1],
                  logical.range[1]
                ]);
                const operatorToken2 = getOperatorToken(
                  logical.right
                );
                yield ruleFixer2.insertTextBefore(
                  operatorToken2,
                  logical.operator
                );
              }
            };
            const fix = cannotBeGetter(logical.left) || accessesSingleProperty(logical.left);
            context.report(
              createConditionalFixer(descriptor, suggestion, fix)
            );
          }
        },
        // if (foo) foo = bar
        "IfStatement[alternate=null]"(ifNode) {
          if (!checkIf) {
            return;
          }
          const hasBody = ifNode.consequent.type === "BlockStatement";
          if (hasBody && ifNode.consequent.body.length !== 1) {
            return;
          }
          const body = hasBody ? ifNode.consequent.body[0] : ifNode.consequent;
          const scope = sourceCode2.getScope(ifNode);
          const existence = getExistence(ifNode.test, scope);
          if (body.type === "ExpressionStatement" && body.expression.type === "AssignmentExpression" && body.expression.operator === "=" && existence !== null && astUtils2.isSameReference(
            existence.reference,
            body.expression.left
          )) {
            const descriptor = {
              messageId: "if",
              node: ifNode,
              data: { operator: `${existence.operator}=` }
            };
            const suggestion = {
              messageId: "convertIf",
              data: { operator: `${existence.operator}=` },
              *fix(ruleFixer2) {
                if (sourceCode2.getCommentsInside(ifNode).length > 0) {
                  return;
                }
                const firstBodyToken = sourceCode2.getFirstToken(body);
                const prevToken = sourceCode2.getTokenBefore(ifNode);
                if (prevToken !== null && prevToken.value !== ";" && prevToken.value !== "{" && firstBodyToken.type !== "Identifier" && firstBodyToken.type !== "Keyword") {
                  return;
                }
                const operatorToken2 = getOperatorToken(
                  body.expression
                );
                yield ruleFixer2.insertTextBefore(
                  operatorToken2,
                  existence.operator
                );
                yield ruleFixer2.removeRange([
                  ifNode.range[0],
                  body.range[0]
                ]);
                yield ruleFixer2.removeRange([
                  body.range[1],
                  ifNode.range[1]
                ]);
                const nextToken = sourceCode2.getTokenAfter(
                  body.expression
                );
                if (hasBody && nextToken !== null && nextToken.value !== ";") {
                  yield ruleFixer2.insertTextAfter(ifNode, ";");
                }
              }
            };
            const shouldBeFixed = cannotBeGetter(existence.reference) || ifNode.test.type !== "LogicalExpression" && accessesSingleProperty(existence.reference);
            context.report(
              createConditionalFixer(
                descriptor,
                suggestion,
                shouldBeFixed
              )
            );
          }
        }
      };
    }
  };
  return logicalAssignmentOperators;
}
var maxClassesPerFile;
var hasRequiredMaxClassesPerFile;
function requireMaxClassesPerFile() {
  if (hasRequiredMaxClassesPerFile) return maxClassesPerFile;
  hasRequiredMaxClassesPerFile = 1;
  maxClassesPerFile = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of classes per file",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-classes-per-file"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 1
            },
            {
              type: "object",
              properties: {
                ignoreExpressions: {
                  type: "boolean"
                },
                max: {
                  type: "integer",
                  minimum: 1
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."
      }
    },
    create(context) {
      const [option = {}] = context.options;
      const [ignoreExpressions, max] = typeof option === "number" ? [false, option || 1] : [option.ignoreExpressions, option.max || 1];
      let classCount = 0;
      return {
        Program() {
          classCount = 0;
        },
        "Program:exit"(node2) {
          if (classCount > max) {
            context.report({
              node: node2,
              messageId: "maximumExceeded",
              data: {
                classCount,
                max
              }
            });
          }
        },
        ClassDeclaration() {
          classCount++;
        },
        ClassExpression() {
          if (!ignoreExpressions) {
            classCount++;
          }
        }
      };
    }
  };
  return maxClassesPerFile;
}
var maxDepth;
var hasRequiredMaxDepth;
function requireMaxDepth() {
  if (hasRequiredMaxDepth) return maxDepth;
  hasRequiredMaxDepth = 1;
  maxDepth = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum depth that blocks can be nested",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-depth"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."
      }
    },
    create(context) {
      const functionStack = [], option = context.options[0];
      let maxDepth2 = 4;
      if (typeof option === "object" && (Object.hasOwn(option, "maximum") || Object.hasOwn(option, "max"))) {
        maxDepth2 = option.maximum || option.max;
      }
      if (typeof option === "number") {
        maxDepth2 = option;
      }
      function startFunction() {
        functionStack.push(0);
      }
      function endFunction() {
        functionStack.pop();
      }
      function pushBlock(node2) {
        const len = ++functionStack[functionStack.length - 1];
        if (len > maxDepth2) {
          context.report({
            node: node2,
            messageId: "tooDeeply",
            data: { depth: len, maxDepth: maxDepth2 }
          });
        }
      }
      function popBlock() {
        functionStack[functionStack.length - 1]--;
      }
      return {
        Program: startFunction,
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        StaticBlock: startFunction,
        IfStatement(node2) {
          if (node2.parent.type !== "IfStatement") {
            pushBlock(node2);
          }
        },
        SwitchStatement: pushBlock,
        TryStatement: pushBlock,
        DoWhileStatement: pushBlock,
        WhileStatement: pushBlock,
        WithStatement: pushBlock,
        ForStatement: pushBlock,
        ForInStatement: pushBlock,
        ForOfStatement: pushBlock,
        "IfStatement:exit": popBlock,
        "SwitchStatement:exit": popBlock,
        "TryStatement:exit": popBlock,
        "DoWhileStatement:exit": popBlock,
        "WhileStatement:exit": popBlock,
        "WithStatement:exit": popBlock,
        "ForStatement:exit": popBlock,
        "ForInStatement:exit": popBlock,
        "ForOfStatement:exit": popBlock,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "StaticBlock:exit": endFunction,
        "Program:exit": endFunction
      };
    }
  };
  return maxDepth;
}
var maxLen;
var hasRequiredMaxLen;
function requireMaxLen() {
  if (hasRequiredMaxLen) return maxLen;
  hasRequiredMaxLen = 1;
  const OPTIONS_SCHEMA = {
    type: "object",
    properties: {
      code: {
        type: "integer",
        minimum: 0
      },
      comments: {
        type: "integer",
        minimum: 0
      },
      tabWidth: {
        type: "integer",
        minimum: 0
      },
      ignorePattern: {
        type: "string"
      },
      ignoreComments: {
        type: "boolean"
      },
      ignoreStrings: {
        type: "boolean"
      },
      ignoreUrls: {
        type: "boolean"
      },
      ignoreTemplateLiterals: {
        type: "boolean"
      },
      ignoreRegExpLiterals: {
        type: "boolean"
      },
      ignoreTrailingComments: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  const OPTIONS_OR_INTEGER_SCHEMA = {
    anyOf: [
      OPTIONS_SCHEMA,
      {
        type: "integer",
        minimum: 0
      }
    ]
  };
  maxLen = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "max-len",
              url: "https://eslint.style/rules/max-len"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce a maximum line length",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-len"
      },
      schema: [
        OPTIONS_OR_INTEGER_SCHEMA,
        OPTIONS_OR_INTEGER_SCHEMA,
        OPTIONS_SCHEMA
      ],
      messages: {
        max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
        maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
      }
    },
    create(context) {
      const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;
      const sourceCode2 = context.sourceCode;
      function computeLineLength(line, tabWidth2) {
        let extraCharacterCount = 0;
        line.replace(/\t/gu, (match, offset) => {
          const totalOffset = offset + extraCharacterCount, previousTabStopOffset = tabWidth2 ? totalOffset % tabWidth2 : 0, spaceCount = tabWidth2 - previousTabStopOffset;
          extraCharacterCount += spaceCount - 1;
        });
        return Array.from(line).length + extraCharacterCount;
      }
      const options = Object.assign({}, context.options.at(-1));
      if (typeof context.options[0] === "number") {
        options.code = context.options[0];
      }
      if (typeof context.options[1] === "number") {
        options.tabWidth = context.options[1];
      }
      const maxLength = typeof options.code === "number" ? options.code : 80, tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 4, ignoreComments = !!options.ignoreComments, ignoreStrings = !!options.ignoreStrings, ignoreTemplateLiterals = !!options.ignoreTemplateLiterals, ignoreRegExpLiterals = !!options.ignoreRegExpLiterals, ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments, ignoreUrls = !!options.ignoreUrls, maxCommentLength = options.comments;
      let ignorePattern = options.ignorePattern || null;
      if (ignorePattern) {
        ignorePattern = new RegExp(ignorePattern, "u");
      }
      function isTrailingComment(line, lineNumber, comment2) {
        return comment2 && comment2.loc.start.line === lineNumber && lineNumber <= comment2.loc.end.line && (comment2.loc.end.line > lineNumber || comment2.loc.end.column === line.length);
      }
      function isFullLineComment(line, lineNumber, comment2) {
        const start = comment2.loc.start, end = comment2.loc.end, isFirstTokenOnLine = !line.slice(0, comment2.loc.start.column).trim();
        return comment2 && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
      }
      function isJSXEmptyExpressionInSingleLineContainer(node2) {
        if (!node2 || !node2.parent || node2.type !== "JSXEmptyExpression" || node2.parent.type !== "JSXExpressionContainer") {
          return false;
        }
        const parent = node2.parent;
        return parent.loc.start.line === parent.loc.end.line;
      }
      function stripTrailingComment(line, comment2) {
        return line.slice(0, comment2.loc.start.column).replace(/\s+$/u, "");
      }
      function ensureArrayAndPush(object, key, value) {
        if (!Array.isArray(object[key])) {
          object[key] = [];
        }
        object[key].push(value);
      }
      function getAllStrings() {
        return sourceCode2.ast.tokens.filter(
          (token) => token.type === "String" || token.type === "JSXText" && sourceCode2.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute"
        );
      }
      function getAllTemplateLiterals() {
        return sourceCode2.ast.tokens.filter(
          (token) => token.type === "Template"
        );
      }
      function getAllRegExpLiterals() {
        return sourceCode2.ast.tokens.filter(
          (token) => token.type === "RegularExpression"
        );
      }
      function groupArrayByLineNumber(arr) {
        const obj = {};
        for (let i2 = 0; i2 < arr.length; i2++) {
          const node2 = arr[i2];
          for (let j = node2.loc.start.line; j <= node2.loc.end.line; ++j) {
            ensureArrayAndPush(obj, j, node2);
          }
        }
        return obj;
      }
      function getAllComments() {
        const comments = [];
        sourceCode2.getAllComments().forEach((commentNode) => {
          const containingNode = sourceCode2.getNodeByRangeIndex(
            commentNode.range[0]
          );
          if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
            if (comments.at(-1) !== containingNode.parent) {
              comments.push(containingNode.parent);
            }
          } else {
            comments.push(commentNode);
          }
        });
        return comments;
      }
      function checkProgramForMaxLength(node2) {
        const lines = sourceCode2.lines, comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];
        let commentsIndex = 0;
        const strings = getAllStrings();
        const stringsByLine = groupArrayByLineNumber(strings);
        const templateLiterals = getAllTemplateLiterals();
        const templateLiteralsByLine = groupArrayByLineNumber(templateLiterals);
        const regExpLiterals = getAllRegExpLiterals();
        const regExpLiteralsByLine = groupArrayByLineNumber(regExpLiterals);
        lines.forEach((line, i2) => {
          const lineNumber = i2 + 1;
          let lineIsComment = false;
          let textToMeasure;
          if (commentsIndex < comments.length) {
            let comment2;
            do {
              comment2 = comments[++commentsIndex];
            } while (comment2 && comment2.loc.start.line <= lineNumber);
            comment2 = comments[--commentsIndex];
            if (isFullLineComment(line, lineNumber, comment2)) {
              lineIsComment = true;
              textToMeasure = line;
            } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment2)) {
              textToMeasure = stripTrailingComment(line, comment2);
              let lastIndex = commentsIndex;
              while (isTrailingComment(
                textToMeasure,
                lineNumber,
                comments[--lastIndex]
              )) {
                textToMeasure = stripTrailingComment(
                  textToMeasure,
                  comments[lastIndex]
                );
              }
            } else {
              textToMeasure = line;
            }
          } else {
            textToMeasure = line;
          }
          if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
            return;
          }
          const lineLength = computeLineLength(textToMeasure, tabWidth);
          const commentLengthApplies = lineIsComment && maxCommentLength;
          if (lineIsComment && ignoreComments) {
            return;
          }
          const loc = {
            start: {
              line: lineNumber,
              column: 0
            },
            end: {
              line: lineNumber,
              column: textToMeasure.length
            }
          };
          if (commentLengthApplies) {
            if (lineLength > maxCommentLength) {
              context.report({
                node: node2,
                loc,
                messageId: "maxComment",
                data: {
                  lineLength,
                  maxCommentLength
                }
              });
            }
          } else if (lineLength > maxLength) {
            context.report({
              node: node2,
              loc,
              messageId: "max",
              data: {
                lineLength,
                maxLength
              }
            });
          }
        });
      }
      return {
        Program: checkProgramForMaxLength
      };
    }
  };
  return maxLen;
}
var maxLines;
var hasRequiredMaxLines;
function requireMaxLines() {
  if (hasRequiredMaxLines) return maxLines;
  hasRequiredMaxLines = 1;
  const astUtils2 = requireAstUtils();
  function range(start, end) {
    return [...Array(end - start).keys()].map((x2) => x2 + start);
  }
  maxLines = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of lines per file",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-lines"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                max: {
                  type: "integer",
                  minimum: 0
                },
                skipComments: {
                  type: "boolean"
                },
                skipBlankLines: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}."
      }
    },
    create(context) {
      const option = context.options[0];
      let max = 300;
      if (typeof option === "object" && Object.hasOwn(option, "max")) {
        max = option.max;
      } else if (typeof option === "number") {
        max = option;
      }
      const skipComments = option && option.skipComments;
      const skipBlankLines = option && option.skipBlankLines;
      const sourceCode2 = context.sourceCode;
      function isCommentNodeType(token) {
        return token && (token.type === "Block" || token.type === "Line");
      }
      function getLinesWithoutCode(comment2) {
        let start = comment2.loc.start.line;
        let end = comment2.loc.end.line;
        let token;
        token = comment2;
        do {
          token = sourceCode2.getTokenBefore(token, {
            includeComments: true
          });
        } while (isCommentNodeType(token));
        if (token && astUtils2.isTokenOnSameLine(token, comment2)) {
          start += 1;
        }
        token = comment2;
        do {
          token = sourceCode2.getTokenAfter(token, {
            includeComments: true
          });
        } while (isCommentNodeType(token));
        if (token && astUtils2.isTokenOnSameLine(comment2, token)) {
          end -= 1;
        }
        if (start <= end) {
          return range(start, end + 1);
        }
        return [];
      }
      return {
        "Program:exit"() {
          let lines = sourceCode2.lines.map((text, i2) => ({
            lineNumber: i2 + 1,
            text
          }));
          if (lines.length > 1 && lines.at(-1).text === "") {
            lines.pop();
          }
          if (skipBlankLines) {
            lines = lines.filter((l2) => l2.text.trim() !== "");
          }
          if (skipComments) {
            const comments = sourceCode2.getAllComments();
            const commentLines = new Set(
              comments.flatMap(getLinesWithoutCode)
            );
            lines = lines.filter((l2) => !commentLines.has(l2.lineNumber));
          }
          if (lines.length > max) {
            const loc = {
              start: {
                line: lines[max].lineNumber,
                column: 0
              },
              end: {
                line: sourceCode2.lines.length,
                column: sourceCode2.lines.at(-1).length
              }
            };
            context.report({
              loc,
              messageId: "exceed",
              data: {
                max,
                actual: lines.length
              }
            });
          }
        }
      };
    }
  };
  return maxLines;
}
var maxLinesPerFunction;
var hasRequiredMaxLinesPerFunction;
function requireMaxLinesPerFunction() {
  if (hasRequiredMaxLinesPerFunction) return maxLinesPerFunction;
  hasRequiredMaxLinesPerFunction = 1;
  const astUtils2 = requireAstUtils();
  const { upperCaseFirst } = requireStringUtils();
  const OPTIONS_SCHEMA = {
    type: "object",
    properties: {
      max: {
        type: "integer",
        minimum: 0
      },
      skipComments: {
        type: "boolean"
      },
      skipBlankLines: {
        type: "boolean"
      },
      IIFEs: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  const OPTIONS_OR_INTEGER_SCHEMA = {
    oneOf: [
      OPTIONS_SCHEMA,
      {
        type: "integer",
        minimum: 1
      }
    ]
  };
  function getCommentLineNumbers(comments) {
    const map = /* @__PURE__ */ new Map();
    comments.forEach((comment2) => {
      for (let i2 = comment2.loc.start.line; i2 <= comment2.loc.end.line; i2++) {
        map.set(i2, comment2);
      }
    });
    return map;
  }
  maxLinesPerFunction = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of lines of code in a function",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-lines-per-function"
      },
      schema: [OPTIONS_OR_INTEGER_SCHEMA],
      messages: {
        exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const lines = sourceCode2.lines;
      const option = context.options[0];
      let maxLines2 = 50;
      let skipComments = false;
      let skipBlankLines = false;
      let IIFEs = false;
      if (typeof option === "object") {
        maxLines2 = typeof option.max === "number" ? option.max : 50;
        skipComments = !!option.skipComments;
        skipBlankLines = !!option.skipBlankLines;
        IIFEs = !!option.IIFEs;
      } else if (typeof option === "number") {
        maxLines2 = option;
      }
      const commentLineNumbers = getCommentLineNumbers(
        sourceCode2.getAllComments()
      );
      function isFullLineComment(line, lineNumber, comment2) {
        const start = comment2.loc.start, end = comment2.loc.end, isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(), isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
        return comment2 && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
      }
      function isIIFE(node2) {
        return (node2.type === "FunctionExpression" || node2.type === "ArrowFunctionExpression") && node2.parent && node2.parent.type === "CallExpression" && node2.parent.callee === node2;
      }
      function isEmbedded(node2) {
        if (!node2.parent) {
          return false;
        }
        if (node2 !== node2.parent.value) {
          return false;
        }
        if (node2.parent.type === "MethodDefinition") {
          return true;
        }
        if (node2.parent.type === "Property") {
          return node2.parent.method === true || node2.parent.kind === "get" || node2.parent.kind === "set";
        }
        return false;
      }
      function processFunction(funcNode) {
        const node2 = isEmbedded(funcNode) ? funcNode.parent : funcNode;
        if (!IIFEs && isIIFE(node2)) {
          return;
        }
        let lineCount = 0;
        for (let i2 = node2.loc.start.line - 1; i2 < node2.loc.end.line; ++i2) {
          const line = lines[i2];
          if (skipComments) {
            if (commentLineNumbers.has(i2 + 1) && isFullLineComment(
              line,
              i2 + 1,
              commentLineNumbers.get(i2 + 1)
            )) {
              continue;
            }
          }
          if (skipBlankLines) {
            if (line.match(/^\s*$/u)) {
              continue;
            }
          }
          lineCount++;
        }
        if (lineCount > maxLines2) {
          const name2 = upperCaseFirst(
            astUtils2.getFunctionNameWithKind(funcNode)
          );
          context.report({
            node: node2,
            messageId: "exceed",
            data: { name: name2, lineCount, maxLines: maxLines2 }
          });
        }
      }
      return {
        FunctionDeclaration: processFunction,
        FunctionExpression: processFunction,
        ArrowFunctionExpression: processFunction
      };
    }
  };
  return maxLinesPerFunction;
}
var maxNestedCallbacks;
var hasRequiredMaxNestedCallbacks;
function requireMaxNestedCallbacks() {
  if (hasRequiredMaxNestedCallbacks) return maxNestedCallbacks;
  hasRequiredMaxNestedCallbacks = 1;
  maxNestedCallbacks = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum depth that callbacks can be nested",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-nested-callbacks"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
      }
    },
    create(context) {
      const option = context.options[0];
      let THRESHOLD = 10;
      if (typeof option === "object" && (Object.hasOwn(option, "maximum") || Object.hasOwn(option, "max"))) {
        THRESHOLD = option.maximum || option.max;
      } else if (typeof option === "number") {
        THRESHOLD = option;
      }
      const callbackStack = [];
      function checkFunction(node2) {
        const parent = node2.parent;
        if (parent.type === "CallExpression") {
          callbackStack.push(node2);
        }
        if (callbackStack.length > THRESHOLD) {
          const opts = { num: callbackStack.length, max: THRESHOLD };
          context.report({ node: node2, messageId: "exceed", data: opts });
        }
      }
      function popStack() {
        callbackStack.pop();
      }
      return {
        ArrowFunctionExpression: checkFunction,
        "ArrowFunctionExpression:exit": popStack,
        FunctionExpression: checkFunction,
        "FunctionExpression:exit": popStack
      };
    }
  };
  return maxNestedCallbacks;
}
var maxParams;
var hasRequiredMaxParams;
function requireMaxParams() {
  if (hasRequiredMaxParams) return maxParams;
  hasRequiredMaxParams = 1;
  const astUtils2 = requireAstUtils();
  const { upperCaseFirst } = requireStringUtils();
  maxParams = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Enforce a maximum number of parameters in function definitions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-params"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                },
                countVoidThis: {
                  type: "boolean",
                  description: "Whether to count a `this` declaration when the type is `void`."
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const option = context.options[0];
      let numParams = 3;
      let countVoidThis = false;
      if (typeof option === "object") {
        if (Object.hasOwn(option, "maximum") || Object.hasOwn(option, "max")) {
          numParams = option.maximum || option.max;
        }
        countVoidThis = option.countVoidThis;
      }
      if (typeof option === "number") {
        numParams = option;
      }
      function checkFunction(node2) {
        var _a2;
        const hasVoidThisParam = node2.params.length > 0 && node2.params[0].type === "Identifier" && node2.params[0].name === "this" && ((_a2 = node2.params[0].typeAnnotation) == null ? void 0 : _a2.typeAnnotation.type) === "TSVoidKeyword";
        const effectiveParamCount = hasVoidThisParam && !countVoidThis ? node2.params.length - 1 : node2.params.length;
        if (effectiveParamCount > numParams) {
          context.report({
            loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
            node: node2,
            messageId: "exceed",
            data: {
              name: upperCaseFirst(
                astUtils2.getFunctionNameWithKind(node2)
              ),
              count: effectiveParamCount,
              max: numParams
            }
          });
        }
      }
      return {
        FunctionDeclaration: checkFunction,
        ArrowFunctionExpression: checkFunction,
        FunctionExpression: checkFunction,
        TSDeclareFunction: checkFunction,
        TSFunctionType: checkFunction
      };
    }
  };
  return maxParams;
}
var maxStatements;
var hasRequiredMaxStatements;
function requireMaxStatements() {
  if (hasRequiredMaxStatements) return maxStatements;
  hasRequiredMaxStatements = 1;
  const astUtils2 = requireAstUtils();
  const { upperCaseFirst } = requireStringUtils();
  maxStatements = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce a maximum number of statements allowed in function blocks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-statements"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        },
        {
          type: "object",
          properties: {
            ignoreTopLevelFunctions: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
      }
    },
    create(context) {
      const functionStack = [], option = context.options[0], ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false, topLevelFunctions = [];
      let maxStatements2 = 10;
      if (typeof option === "object" && (Object.hasOwn(option, "maximum") || Object.hasOwn(option, "max"))) {
        maxStatements2 = option.maximum || option.max;
      } else if (typeof option === "number") {
        maxStatements2 = option;
      }
      function reportIfTooManyStatements(node2, count, max) {
        if (count > max) {
          const name2 = upperCaseFirst(
            astUtils2.getFunctionNameWithKind(node2)
          );
          context.report({
            node: node2,
            messageId: "exceed",
            data: { name: name2, count, max }
          });
        }
      }
      function startFunction() {
        functionStack.push(0);
      }
      function endFunction(node2) {
        const count = functionStack.pop();
        if (node2.type === "StaticBlock") {
          return;
        }
        if (ignoreTopLevelFunctions && functionStack.length === 0) {
          topLevelFunctions.push({ node: node2, count });
        } else {
          reportIfTooManyStatements(node2, count, maxStatements2);
        }
      }
      function countStatements(node2) {
        functionStack[functionStack.length - 1] += node2.body.length;
      }
      return {
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        StaticBlock: startFunction,
        BlockStatement: countStatements,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "StaticBlock:exit": endFunction,
        "Program:exit"() {
          if (topLevelFunctions.length === 1) {
            return;
          }
          topLevelFunctions.forEach((element) => {
            const count = element.count;
            const node2 = element.node;
            reportIfTooManyStatements(node2, count, maxStatements2);
          });
        }
      };
    }
  };
  return maxStatements;
}
var maxStatementsPerLine;
var hasRequiredMaxStatementsPerLine;
function requireMaxStatementsPerLine() {
  if (hasRequiredMaxStatementsPerLine) return maxStatementsPerLine;
  hasRequiredMaxStatementsPerLine = 1;
  const astUtils2 = requireAstUtils();
  maxStatementsPerLine = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "max-statements-per-line",
              url: "https://eslint.style/rules/max-statements-per-line"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce a maximum number of statements allowed per line",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/max-statements-per-line"
      },
      schema: [
        {
          type: "object",
          properties: {
            max: {
              type: "integer",
              minimum: 1,
              default: 1
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode, options = context.options[0] || {}, maxStatementsPerLine2 = typeof options.max !== "undefined" ? options.max : 1;
      let lastStatementLine = 0, numberOfStatementsOnThisLine = 0, firstExtraStatement;
      const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;
      function reportFirstExtraStatementAndClear() {
        if (firstExtraStatement) {
          context.report({
            node: firstExtraStatement,
            messageId: "exceed",
            data: {
              numberOfStatementsOnThisLine,
              maxStatementsPerLine: maxStatementsPerLine2,
              statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
            }
          });
        }
        firstExtraStatement = null;
      }
      function getActualLastToken(node2) {
        return sourceCode2.getLastToken(node2, astUtils2.isNotSemicolonToken);
      }
      function enterStatement(node2) {
        const line = node2.loc.start.line;
        if (SINGLE_CHILD_ALLOWED.test(node2.parent.type) && node2.parent.alternate !== node2) {
          return;
        }
        if (line === lastStatementLine) {
          numberOfStatementsOnThisLine += 1;
        } else {
          reportFirstExtraStatementAndClear();
          numberOfStatementsOnThisLine = 1;
          lastStatementLine = line;
        }
        if (numberOfStatementsOnThisLine === maxStatementsPerLine2 + 1) {
          firstExtraStatement = firstExtraStatement || node2;
        }
      }
      function leaveStatement(node2) {
        const line = getActualLastToken(node2).loc.end.line;
        if (line !== lastStatementLine) {
          reportFirstExtraStatementAndClear();
          numberOfStatementsOnThisLine = 1;
          lastStatementLine = line;
        }
      }
      return {
        BreakStatement: enterStatement,
        ClassDeclaration: enterStatement,
        ContinueStatement: enterStatement,
        DebuggerStatement: enterStatement,
        DoWhileStatement: enterStatement,
        ExpressionStatement: enterStatement,
        ForInStatement: enterStatement,
        ForOfStatement: enterStatement,
        ForStatement: enterStatement,
        FunctionDeclaration: enterStatement,
        IfStatement: enterStatement,
        ImportDeclaration: enterStatement,
        LabeledStatement: enterStatement,
        ReturnStatement: enterStatement,
        SwitchStatement: enterStatement,
        ThrowStatement: enterStatement,
        TryStatement: enterStatement,
        VariableDeclaration: enterStatement,
        WhileStatement: enterStatement,
        WithStatement: enterStatement,
        ExportNamedDeclaration: enterStatement,
        ExportDefaultDeclaration: enterStatement,
        ExportAllDeclaration: enterStatement,
        "BreakStatement:exit": leaveStatement,
        "ClassDeclaration:exit": leaveStatement,
        "ContinueStatement:exit": leaveStatement,
        "DebuggerStatement:exit": leaveStatement,
        "DoWhileStatement:exit": leaveStatement,
        "ExpressionStatement:exit": leaveStatement,
        "ForInStatement:exit": leaveStatement,
        "ForOfStatement:exit": leaveStatement,
        "ForStatement:exit": leaveStatement,
        "FunctionDeclaration:exit": leaveStatement,
        "IfStatement:exit": leaveStatement,
        "ImportDeclaration:exit": leaveStatement,
        "LabeledStatement:exit": leaveStatement,
        "ReturnStatement:exit": leaveStatement,
        "SwitchStatement:exit": leaveStatement,
        "ThrowStatement:exit": leaveStatement,
        "TryStatement:exit": leaveStatement,
        "VariableDeclaration:exit": leaveStatement,
        "WhileStatement:exit": leaveStatement,
        "WithStatement:exit": leaveStatement,
        "ExportNamedDeclaration:exit": leaveStatement,
        "ExportDefaultDeclaration:exit": leaveStatement,
        "ExportAllDeclaration:exit": leaveStatement,
        "Program:exit": reportFirstExtraStatementAndClear
      };
    }
  };
  return maxStatementsPerLine;
}
var multilineCommentStyle;
var hasRequiredMultilineCommentStyle;
function requireMultilineCommentStyle() {
  if (hasRequiredMultilineCommentStyle) return multilineCommentStyle;
  hasRequiredMultilineCommentStyle = 1;
  const astUtils2 = requireAstUtils();
  multilineCommentStyle = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "9.3.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "multiline-comment-style",
              url: "https://eslint.style/rules/multiline-comment-style"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Enforce a particular style for multiline comments",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/multiline-comment-style"
      },
      fixable: "whitespace",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["starred-block", "bare-block"]
              }
            ],
            additionalItems: false
          },
          {
            type: "array",
            items: [
              {
                enum: ["separate-lines"]
              },
              {
                type: "object",
                properties: {
                  checkJSDoc: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            additionalItems: false
          }
        ]
      },
      messages: {
        expectedBlock: "Expected a block comment instead of consecutive line comments.",
        expectedBareBlock: "Expected a block comment without padding stars.",
        startNewline: "Expected a linebreak after '/*'.",
        endNewline: "Expected a linebreak before '*/'.",
        missingStar: "Expected a '*' at the start of this line.",
        alignment: "Expected this line to be aligned with the start of the comment.",
        expectedLines: "Expected multiple line comments instead of a block comment."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const option = context.options[0] || "starred-block";
      const params = context.options[1] || {};
      const checkJSDoc = !!params.checkJSDoc;
      function isStarredCommentLine(line) {
        return /^\s*\*/u.test(line);
      }
      function isStarredBlockComment([firstComment]) {
        if (firstComment.type !== "Block") {
          return false;
        }
        const lines = firstComment.value.split(astUtils2.LINEBREAK_MATCHER);
        return lines.length > 0 && lines.every(
          (line, i2) => (i2 === 0 || i2 === lines.length - 1 ? /^\s*$/u : /^\s*\*/u).test(line)
        );
      }
      function isJSDocComment([firstComment]) {
        if (firstComment.type !== "Block") {
          return false;
        }
        const lines = firstComment.value.split(astUtils2.LINEBREAK_MATCHER);
        return /^\*\s*$/u.test(lines[0]) && lines.slice(1, -1).every((line) => /^\s* /u.test(line)) && /^\s*$/u.test(lines.at(-1));
      }
      function processSeparateLineComments(commentGroup) {
        const allLinesHaveLeadingSpace = commentGroup.map(({ value }) => value).filter((line) => line.trim().length).every((line) => line.startsWith(" "));
        return commentGroup.map(
          ({ value }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, "") : value
        );
      }
      function processStarredBlockComment(comment2) {
        const lines = comment2.value.split(astUtils2.LINEBREAK_MATCHER).filter(
          (line, i2, linesArr) => !(i2 === 0 || i2 === linesArr.length - 1)
        ).map((line) => line.replace(/^\s*$/u, ""));
        const allLinesHaveLeadingSpace = lines.map((line) => line.replace(/\s*\*/u, "")).filter((line) => line.trim().length).every((line) => line.startsWith(" "));
        return lines.map(
          (line) => line.replace(
            allLinesHaveLeadingSpace ? /\s*\* ?/u : /\s*\*/u,
            ""
          )
        );
      }
      function processBareBlockComment(comment2) {
        const lines = comment2.value.split(astUtils2.LINEBREAK_MATCHER).map((line) => line.replace(/^\s*$/u, ""));
        const leadingWhitespace = `${sourceCode2.text.slice(comment2.range[0] - comment2.loc.start.column, comment2.range[0])}   `;
        let offset = "";
        for (const [i2, line] of lines.entries()) {
          if (!line.trim().length || i2 === 0) {
            continue;
          }
          const [, lineOffset] = line.match(/^(\s*\*?\s*)/u);
          if (lineOffset.length < leadingWhitespace.length) {
            const newOffset = leadingWhitespace.slice(
              lineOffset.length - leadingWhitespace.length
            );
            if (newOffset.length > offset.length) {
              offset = newOffset;
            }
          }
        }
        return lines.map((line) => {
          const match = line.match(/^(\s*\*?\s*)(.*)/u);
          const [, lineOffset, lineContents] = match;
          if (lineOffset.length > leadingWhitespace.length) {
            return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;
          }
          if (lineOffset.length < leadingWhitespace.length) {
            return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;
          }
          return lineContents;
        });
      }
      function getCommentLines(commentGroup) {
        const [firstComment] = commentGroup;
        if (firstComment.type === "Line") {
          return processSeparateLineComments(commentGroup);
        }
        if (isStarredBlockComment(commentGroup)) {
          return processStarredBlockComment(firstComment);
        }
        return processBareBlockComment(firstComment);
      }
      function getInitialOffset(comment2) {
        return sourceCode2.text.slice(
          comment2.range[0] - comment2.loc.start.column,
          comment2.range[0]
        );
      }
      function convertToStarredBlock(firstComment, commentLinesList) {
        const initialOffset = getInitialOffset(firstComment);
        return `/*
${commentLinesList.map((line) => `${initialOffset} * ${line}`).join("\n")}
${initialOffset} */`;
      }
      function convertToSeparateLines(firstComment, commentLinesList) {
        return commentLinesList.map((line) => `// ${line}`).join(`
${getInitialOffset(firstComment)}`);
      }
      function convertToBlock(firstComment, commentLinesList) {
        return `/* ${commentLinesList.join(`
${getInitialOffset(firstComment)}   `)} */`;
      }
      const commentGroupCheckers = {
        "starred-block"(commentGroup) {
          const [firstComment] = commentGroup;
          const commentLines = getCommentLines(commentGroup);
          if (commentLines.some((value) => value.includes("*/"))) {
            return;
          }
          if (commentGroup.length > 1) {
            context.report({
              loc: {
                start: firstComment.loc.start,
                end: commentGroup.at(-1).loc.end
              },
              messageId: "expectedBlock",
              fix(fixer) {
                const range = [
                  firstComment.range[0],
                  commentGroup.at(-1).range[1]
                ];
                return commentLines.some(
                  (value) => value.startsWith("/")
                ) ? null : fixer.replaceTextRange(
                  range,
                  convertToStarredBlock(
                    firstComment,
                    commentLines
                  )
                );
              }
            });
          } else {
            const lines = firstComment.value.split(
              astUtils2.LINEBREAK_MATCHER
            );
            const expectedLeadingWhitespace = getInitialOffset(firstComment);
            const expectedLinePrefix = `${expectedLeadingWhitespace} *`;
            if (!/^\*?\s*$/u.test(lines[0])) {
              const start = firstComment.value.startsWith("*") ? firstComment.range[0] + 1 : firstComment.range[0];
              context.report({
                loc: {
                  start: firstComment.loc.start,
                  end: {
                    line: firstComment.loc.start.line,
                    column: firstComment.loc.start.column + 2
                  }
                },
                messageId: "startNewline",
                fix: (fixer) => fixer.insertTextAfterRange(
                  [start, start + 2],
                  `
${expectedLinePrefix}`
                )
              });
            }
            if (!/^\s*$/u.test(lines.at(-1))) {
              context.report({
                loc: {
                  start: {
                    line: firstComment.loc.end.line,
                    column: firstComment.loc.end.column - 2
                  },
                  end: firstComment.loc.end
                },
                messageId: "endNewline",
                fix: (fixer) => fixer.replaceTextRange(
                  [
                    firstComment.range[1] - 2,
                    firstComment.range[1]
                  ],
                  `
${expectedLinePrefix}/`
                )
              });
            }
            for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {
              const lineText = sourceCode2.lines[lineNumber - 1];
              const errorType = isStarredCommentLine(lineText) ? "alignment" : "missingStar";
              if (!lineText.startsWith(expectedLinePrefix)) {
                context.report({
                  loc: {
                    start: { line: lineNumber, column: 0 },
                    end: {
                      line: lineNumber,
                      column: lineText.length
                    }
                  },
                  messageId: errorType,
                  fix(fixer) {
                    const lineStartIndex = sourceCode2.getIndexFromLoc({
                      line: lineNumber,
                      column: 0
                    });
                    if (errorType === "alignment") {
                      const [, commentTextPrefix2 = ""] = lineText.match(/^(\s*\*)/u) || [];
                      const commentTextStartIndex2 = lineStartIndex + commentTextPrefix2.length;
                      return fixer.replaceTextRange(
                        [
                          lineStartIndex,
                          commentTextStartIndex2
                        ],
                        expectedLinePrefix
                      );
                    }
                    const [, commentTextPrefix = ""] = lineText.match(/^(\s*)/u) || [];
                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                    let offset;
                    for (const [idx, line] of lines.entries()) {
                      if (!/\S+/u.test(line)) {
                        continue;
                      }
                      const lineTextToAlignWith = sourceCode2.lines[firstComment.loc.start.line - 1 + idx];
                      const [
                        ,
                        prefix = "",
                        initialOffset = ""
                      ] = lineTextToAlignWith.match(
                        /^(\s*(?:\/?\*)?(\s*))/u
                      ) || [];
                      offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;
                      if (/^\s*\//u.test(lineText) && offset.length === 0) {
                        offset += " ";
                      }
                      break;
                    }
                    return fixer.replaceTextRange(
                      [lineStartIndex, commentTextStartIndex],
                      `${expectedLinePrefix}${offset}`
                    );
                  }
                });
              }
            }
          }
        },
        "separate-lines"(commentGroup) {
          const [firstComment] = commentGroup;
          const isJSDoc = isJSDocComment(commentGroup);
          if (firstComment.type !== "Block" || !checkJSDoc && isJSDoc) {
            return;
          }
          let commentLines = getCommentLines(commentGroup);
          if (isJSDoc) {
            commentLines = commentLines.slice(
              1,
              commentLines.length - 1
            );
          }
          const tokenAfter = sourceCode2.getTokenAfter(firstComment, {
            includeComments: true
          });
          if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {
            return;
          }
          context.report({
            loc: {
              start: firstComment.loc.start,
              end: {
                line: firstComment.loc.start.line,
                column: firstComment.loc.start.column + 2
              }
            },
            messageId: "expectedLines",
            fix(fixer) {
              return fixer.replaceText(
                firstComment,
                convertToSeparateLines(firstComment, commentLines)
              );
            }
          });
        },
        "bare-block"(commentGroup) {
          if (isJSDocComment(commentGroup)) {
            return;
          }
          const [firstComment] = commentGroup;
          const commentLines = getCommentLines(commentGroup);
          if (firstComment.type === "Line" && commentLines.length > 1 && !commentLines.some((value) => value.includes("*/"))) {
            context.report({
              loc: {
                start: firstComment.loc.start,
                end: commentGroup.at(-1).loc.end
              },
              messageId: "expectedBlock",
              fix(fixer) {
                return fixer.replaceTextRange(
                  [
                    firstComment.range[0],
                    commentGroup.at(-1).range[1]
                  ],
                  convertToBlock(firstComment, commentLines)
                );
              }
            });
          }
          if (isStarredBlockComment(commentGroup)) {
            context.report({
              loc: {
                start: firstComment.loc.start,
                end: {
                  line: firstComment.loc.start.line,
                  column: firstComment.loc.start.column + 2
                }
              },
              messageId: "expectedBareBlock",
              fix(fixer) {
                return fixer.replaceText(
                  firstComment,
                  convertToBlock(firstComment, commentLines)
                );
              }
            });
          }
        }
      };
      return {
        Program() {
          return sourceCode2.getAllComments().filter((comment2) => comment2.type !== "Shebang").filter(
            (comment2) => !astUtils2.COMMENTS_IGNORE_PATTERN.test(
              comment2.value
            )
          ).filter((comment2) => {
            const tokenBefore = sourceCode2.getTokenBefore(comment2, {
              includeComments: true
            });
            return !tokenBefore || tokenBefore.loc.end.line < comment2.loc.start.line;
          }).reduce((commentGroups, comment2, index, commentList) => {
            const tokenBefore = sourceCode2.getTokenBefore(comment2, {
              includeComments: true
            });
            if (comment2.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment2.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
              commentGroups.at(-1).push(comment2);
            } else {
              commentGroups.push([comment2]);
            }
            return commentGroups;
          }, []).filter(
            (commentGroup) => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)
          ).forEach(commentGroupCheckers[option]);
        }
      };
    }
  };
  return multilineCommentStyle;
}
var multilineTernary;
var hasRequiredMultilineTernary;
function requireMultilineTernary() {
  if (hasRequiredMultilineTernary) return multilineTernary;
  hasRequiredMultilineTernary = 1;
  const astUtils2 = requireAstUtils();
  multilineTernary = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "multiline-ternary",
              url: "https://eslint.style/rules/multiline-ternary"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce newlines between operands of ternary expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/multiline-ternary"
      },
      schema: [
        {
          enum: ["always", "always-multiline", "never"]
        }
      ],
      messages: {
        expectedTestCons: "Expected newline between test and consequent of ternary expression.",
        expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
        unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
        unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
      },
      fixable: "whitespace"
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const option = context.options[0];
      const multiline = option !== "never";
      const allowSingleLine = option === "always-multiline";
      return {
        ConditionalExpression(node2) {
          const questionToken = sourceCode2.getTokenAfter(
            node2.test,
            astUtils2.isNotClosingParenToken
          );
          const colonToken = sourceCode2.getTokenAfter(
            node2.consequent,
            astUtils2.isNotClosingParenToken
          );
          const firstTokenOfTest = sourceCode2.getFirstToken(node2);
          const lastTokenOfTest = sourceCode2.getTokenBefore(questionToken);
          const firstTokenOfConsequent = sourceCode2.getTokenAfter(questionToken);
          const lastTokenOfConsequent = sourceCode2.getTokenBefore(colonToken);
          const firstTokenOfAlternate = sourceCode2.getTokenAfter(colonToken);
          const areTestAndConsequentOnSameLine = astUtils2.isTokenOnSameLine(
            lastTokenOfTest,
            firstTokenOfConsequent
          );
          const areConsequentAndAlternateOnSameLine = astUtils2.isTokenOnSameLine(
            lastTokenOfConsequent,
            firstTokenOfAlternate
          );
          const hasComments = !!sourceCode2.getCommentsInside(node2).length;
          if (!multiline) {
            if (!areTestAndConsequentOnSameLine) {
              context.report({
                node: node2.test,
                loc: {
                  start: firstTokenOfTest.loc.start,
                  end: lastTokenOfTest.loc.end
                },
                messageId: "unexpectedTestCons",
                fix(fixer) {
                  if (hasComments) {
                    return null;
                  }
                  const fixers = [];
                  const areTestAndQuestionOnSameLine = astUtils2.isTokenOnSameLine(
                    lastTokenOfTest,
                    questionToken
                  );
                  const areQuestionAndConsOnSameLine = astUtils2.isTokenOnSameLine(
                    questionToken,
                    firstTokenOfConsequent
                  );
                  if (!areTestAndQuestionOnSameLine) {
                    fixers.push(
                      fixer.removeRange([
                        lastTokenOfTest.range[1],
                        questionToken.range[0]
                      ])
                    );
                  }
                  if (!areQuestionAndConsOnSameLine) {
                    fixers.push(
                      fixer.removeRange([
                        questionToken.range[1],
                        firstTokenOfConsequent.range[0]
                      ])
                    );
                  }
                  return fixers;
                }
              });
            }
            if (!areConsequentAndAlternateOnSameLine) {
              context.report({
                node: node2.consequent,
                loc: {
                  start: firstTokenOfConsequent.loc.start,
                  end: lastTokenOfConsequent.loc.end
                },
                messageId: "unexpectedConsAlt",
                fix(fixer) {
                  if (hasComments) {
                    return null;
                  }
                  const fixers = [];
                  const areConsAndColonOnSameLine = astUtils2.isTokenOnSameLine(
                    lastTokenOfConsequent,
                    colonToken
                  );
                  const areColonAndAltOnSameLine = astUtils2.isTokenOnSameLine(
                    colonToken,
                    firstTokenOfAlternate
                  );
                  if (!areConsAndColonOnSameLine) {
                    fixers.push(
                      fixer.removeRange([
                        lastTokenOfConsequent.range[1],
                        colonToken.range[0]
                      ])
                    );
                  }
                  if (!areColonAndAltOnSameLine) {
                    fixers.push(
                      fixer.removeRange([
                        colonToken.range[1],
                        firstTokenOfAlternate.range[0]
                      ])
                    );
                  }
                  return fixers;
                }
              });
            }
          } else {
            if (allowSingleLine && node2.loc.start.line === node2.loc.end.line) {
              return;
            }
            if (areTestAndConsequentOnSameLine) {
              context.report({
                node: node2.test,
                loc: {
                  start: firstTokenOfTest.loc.start,
                  end: lastTokenOfTest.loc.end
                },
                messageId: "expectedTestCons",
                fix: (fixer) => hasComments ? null : fixer.replaceTextRange(
                  [
                    lastTokenOfTest.range[1],
                    questionToken.range[0]
                  ],
                  "\n"
                )
              });
            }
            if (areConsequentAndAlternateOnSameLine) {
              context.report({
                node: node2.consequent,
                loc: {
                  start: firstTokenOfConsequent.loc.start,
                  end: lastTokenOfConsequent.loc.end
                },
                messageId: "expectedConsAlt",
                fix: (fixer) => hasComments ? null : fixer.replaceTextRange(
                  [
                    lastTokenOfConsequent.range[1],
                    colonToken.range[0]
                  ],
                  "\n"
                )
              });
            }
          }
        }
      };
    }
  };
  return multilineTernary;
}
var newCap;
var hasRequiredNewCap;
function requireNewCap() {
  if (hasRequiredNewCap) return newCap;
  hasRequiredNewCap = 1;
  const astUtils2 = requireAstUtils();
  const CAPS_ALLOWED = [
    "Array",
    "Boolean",
    "Date",
    "Error",
    "Function",
    "Number",
    "Object",
    "RegExp",
    "String",
    "Symbol",
    "BigInt"
  ];
  function invert(map, key) {
    map[key] = true;
    return map;
  }
  function calculateCapIsNewExceptions(config2) {
    const capIsNewExceptions = Array.from(
      /* @__PURE__ */ new Set([...config2.capIsNewExceptions, ...CAPS_ALLOWED])
    );
    return capIsNewExceptions.reduce(invert, {});
  }
  newCap = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require constructor names to begin with a capital letter",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/new-cap"
      },
      schema: [
        {
          type: "object",
          properties: {
            newIsCap: {
              type: "boolean"
            },
            capIsNew: {
              type: "boolean"
            },
            newIsCapExceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            newIsCapExceptionPattern: {
              type: "string"
            },
            capIsNewExceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            capIsNewExceptionPattern: {
              type: "string"
            },
            properties: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      defaultOptions: [
        {
          capIsNew: true,
          capIsNewExceptions: CAPS_ALLOWED,
          newIsCap: true,
          newIsCapExceptions: [],
          properties: true
        }
      ],
      messages: {
        upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
        lower: "A constructor name should not start with a lowercase letter."
      }
    },
    create(context) {
      const [config2] = context.options;
      const skipProperties = !config2.properties;
      const newIsCapExceptions = config2.newIsCapExceptions.reduce(invert, {});
      const newIsCapExceptionPattern = config2.newIsCapExceptionPattern ? new RegExp(config2.newIsCapExceptionPattern, "u") : null;
      const capIsNewExceptions = calculateCapIsNewExceptions(config2);
      const capIsNewExceptionPattern = config2.capIsNewExceptionPattern ? new RegExp(config2.capIsNewExceptionPattern, "u") : null;
      const listeners = {};
      const sourceCode2 = context.sourceCode;
      function extractNameFromExpression(node2) {
        return node2.callee.type === "Identifier" ? node2.callee.name : astUtils2.getStaticPropertyName(node2.callee) || "";
      }
      function getCap(str) {
        const firstChar = str.charAt(0);
        const firstCharLower = firstChar.toLowerCase();
        const firstCharUpper = firstChar.toUpperCase();
        if (firstCharLower === firstCharUpper) {
          return "non-alpha";
        }
        if (firstChar === firstCharLower) {
          return "lower";
        }
        return "upper";
      }
      function isCapAllowed(allowedMap, node2, calleeName, pattern2) {
        const sourceText = sourceCode2.getText(node2.callee);
        if (allowedMap[calleeName] || allowedMap[sourceText]) {
          return true;
        }
        if (pattern2 && pattern2.test(sourceText)) {
          return true;
        }
        const callee = astUtils2.skipChainExpression(node2.callee);
        if (calleeName === "UTC" && callee.type === "MemberExpression") {
          return callee.object.type === "Identifier" && callee.object.name === "Date";
        }
        return skipProperties && callee.type === "MemberExpression";
      }
      function report(node2, messageId) {
        let callee = astUtils2.skipChainExpression(node2.callee);
        if (callee.type === "MemberExpression") {
          callee = callee.property;
        }
        context.report({ node: node2, loc: callee.loc, messageId });
      }
      if (config2.newIsCap) {
        listeners.NewExpression = function(node2) {
          const constructorName = extractNameFromExpression(node2);
          if (constructorName) {
            const capitalization = getCap(constructorName);
            const isAllowed = capitalization !== "lower" || isCapAllowed(
              newIsCapExceptions,
              node2,
              constructorName,
              newIsCapExceptionPattern
            );
            if (!isAllowed) {
              report(node2, "lower");
            }
          }
        };
      }
      if (config2.capIsNew) {
        listeners.CallExpression = function(node2) {
          const calleeName = extractNameFromExpression(node2);
          if (calleeName) {
            const capitalization = getCap(calleeName);
            const isAllowed = capitalization !== "upper" || isCapAllowed(
              capIsNewExceptions,
              node2,
              calleeName,
              capIsNewExceptionPattern
            );
            if (!isAllowed) {
              report(node2, "upper");
            }
          }
        };
      }
      return listeners;
    }
  };
  return newCap;
}
var newParens;
var hasRequiredNewParens;
function requireNewParens() {
  if (hasRequiredNewParens) return newParens;
  hasRequiredNewParens = 1;
  const astUtils2 = requireAstUtils();
  newParens = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "new-parens",
              url: "https://eslint.style/rules/new-parens"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce or disallow parentheses when invoking a constructor with no arguments",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/new-parens"
      },
      fixable: "code",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        missing: "Missing '()' invoking a constructor.",
        unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
      }
    },
    create(context) {
      const options = context.options;
      const always = options[0] !== "never";
      const sourceCode2 = context.sourceCode;
      return {
        NewExpression(node2) {
          if (node2.arguments.length !== 0) {
            return;
          }
          const lastToken = sourceCode2.getLastToken(node2);
          const hasLastParen = lastToken && astUtils2.isClosingParenToken(lastToken);
          const hasParens = hasLastParen && astUtils2.isOpeningParenToken(
            sourceCode2.getTokenBefore(lastToken)
          ) && node2.callee.range[1] < node2.range[1];
          if (always) {
            if (!hasParens) {
              context.report({
                node: node2,
                messageId: "missing",
                fix: (fixer) => fixer.insertTextAfter(node2, "()")
              });
            }
          } else {
            if (hasParens) {
              context.report({
                node: node2,
                messageId: "unnecessary",
                fix: (fixer) => [
                  fixer.remove(
                    sourceCode2.getTokenBefore(lastToken)
                  ),
                  fixer.remove(lastToken),
                  fixer.insertTextBefore(node2, "("),
                  fixer.insertTextAfter(node2, ")")
                ]
              });
            }
          }
        }
      };
    }
  };
  return newParens;
}
var newlineAfterVar;
var hasRequiredNewlineAfterVar;
function requireNewlineAfterVar() {
  if (hasRequiredNewlineAfterVar) return newlineAfterVar;
  hasRequiredNewlineAfterVar = 1;
  const astUtils2 = requireAstUtils();
  newlineAfterVar = {
    meta: {
      type: "layout",
      docs: {
        description: "Require or disallow an empty line after variable declarations",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/newline-after-var"
      },
      schema: [
        {
          enum: ["never", "always"]
        }
      ],
      fixable: "whitespace",
      messages: {
        expected: "Expected blank line after variable declarations.",
        unexpected: "Unexpected blank line after variable declarations."
      },
      deprecated: {
        message: "The rule was replaced with a more general rule.",
        url: "https://eslint.org/blog/2017/06/eslint-v4.0.0-released/",
        deprecatedSince: "4.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "The new rule moved to a plugin.",
            url: "https://eslint.org/docs/latest/rules/padding-line-between-statements#examples",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "padding-line-between-statements",
              url: "https://eslint.style/rules/padding-line-between-statements"
            }
          }
        ]
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const mode = context.options[0] === "never" ? "never" : "always";
      const commentEndLine = sourceCode2.getAllComments().reduce((result, token) => {
        result[token.loc.start.line] = token.loc.end.line;
        return result;
      }, {});
      function getLastToken(node2) {
        const lastToken = sourceCode2.getLastToken(node2);
        if (lastToken.type === "Punctuator" && lastToken.value === ";") {
          const prevToken = sourceCode2.getTokenBefore(lastToken);
          if (prevToken.loc.end.line !== lastToken.loc.start.line) {
            return prevToken;
          }
        }
        return lastToken;
      }
      function isVar(keyword2) {
        return keyword2 === "var" || keyword2 === "let" || keyword2 === "const";
      }
      function isForTypeSpecifier(keyword2) {
        return keyword2 === "ForStatement" || keyword2 === "ForInStatement" || keyword2 === "ForOfStatement";
      }
      function isExportSpecifier(nodeType) {
        return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
      }
      function isLastNode(node2) {
        const token = sourceCode2.getTokenAfter(node2);
        return !token || token.type === "Punctuator" && token.value === "}";
      }
      function getLastCommentLineOfBlock(commentStartLine) {
        const currentCommentEnd = commentEndLine[commentStartLine];
        return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
      }
      function hasBlankLineAfterComment(token, commentStartLine) {
        return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
      }
      function checkForBlankLine(node2) {
        const lastToken = getLastToken(node2), nextToken = lastToken === sourceCode2.getLastToken(node2) ? sourceCode2.getTokenAfter(node2) : sourceCode2.getLastToken(node2), nextLineNum = lastToken.loc.end.line + 1;
        if (!nextToken) {
          return;
        }
        if (isForTypeSpecifier(node2.parent.type)) {
          return;
        }
        if (isExportSpecifier(node2.parent.type)) {
          return;
        }
        if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
          return;
        }
        if (isLastNode(node2)) {
          return;
        }
        const noNextLineToken = nextToken.loc.start.line > nextLineNum;
        const hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";
        if (mode === "never" && noNextLineToken && !hasNextLineComment) {
          context.report({
            node: node2,
            messageId: "unexpected",
            fix(fixer) {
              const linesBetween = sourceCode2.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils2.LINEBREAK_MATCHER);
              return fixer.replaceTextRange(
                [lastToken.range[1], nextToken.range[0]],
                `${linesBetween.slice(0, -1).join("")}
${linesBetween.at(-1)}`
              );
            }
          });
        }
        if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
          context.report({
            node: node2,
            messageId: "expected",
            fix(fixer) {
              if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
                return fixer.insertTextBefore(nextToken, "\n\n");
              }
              return fixer.insertTextBeforeRange(
                [
                  nextToken.range[0] - nextToken.loc.start.column,
                  nextToken.range[1]
                ],
                "\n"
              );
            }
          });
        }
      }
      return {
        VariableDeclaration: checkForBlankLine
      };
    }
  };
  return newlineAfterVar;
}
var newlineBeforeReturn;
var hasRequiredNewlineBeforeReturn;
function requireNewlineBeforeReturn() {
  if (hasRequiredNewlineBeforeReturn) return newlineBeforeReturn;
  hasRequiredNewlineBeforeReturn = 1;
  newlineBeforeReturn = {
    meta: {
      type: "layout",
      docs: {
        description: "Require an empty line before `return` statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/newline-before-return"
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        expected: "Expected newline before return statement."
      },
      deprecated: {
        message: "The rule was replaced with a more general rule.",
        url: "https://eslint.org/blog/2017/06/eslint-v4.0.0-released/",
        deprecatedSince: "4.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "The new rule moved to a plugin.",
            url: "https://eslint.org/docs/latest/rules/padding-line-between-statements#examples",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "padding-line-between-statements",
              url: "https://eslint.style/rules/padding-line-between-statements"
            }
          }
        ]
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function isPrecededByTokens(node2, testTokens) {
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        return testTokens.includes(tokenBefore.value);
      }
      function isFirstNode(node2) {
        const parentType = node2.parent.type;
        if (node2.parent.body) {
          return Array.isArray(node2.parent.body) ? node2.parent.body[0] === node2 : node2.parent.body === node2;
        }
        if (parentType === "IfStatement") {
          return isPrecededByTokens(node2, ["else", ")"]);
        }
        if (parentType === "DoWhileStatement") {
          return isPrecededByTokens(node2, ["do"]);
        }
        if (parentType === "SwitchCase") {
          return isPrecededByTokens(node2, [":"]);
        }
        return isPrecededByTokens(node2, [")"]);
      }
      function calcCommentLines(node2, lineNumTokenBefore) {
        const comments = sourceCode2.getCommentsBefore(node2);
        let numLinesComments = 0;
        if (!comments.length) {
          return numLinesComments;
        }
        comments.forEach((comment2) => {
          numLinesComments++;
          if (comment2.type === "Block") {
            numLinesComments += comment2.loc.end.line - comment2.loc.start.line;
          }
          if (comment2.loc.start.line === lineNumTokenBefore) {
            numLinesComments--;
          }
          if (comment2.loc.end.line === node2.loc.start.line) {
            numLinesComments--;
          }
        });
        return numLinesComments;
      }
      function getLineNumberOfTokenBefore(node2) {
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        let lineNumTokenBefore;
        if (tokenBefore) {
          lineNumTokenBefore = tokenBefore.loc.end.line;
        } else {
          lineNumTokenBefore = 0;
        }
        return lineNumTokenBefore;
      }
      function hasNewlineBefore(node2) {
        const lineNumNode = node2.loc.start.line;
        const lineNumTokenBefore = getLineNumberOfTokenBefore(node2);
        const commentLines = calcCommentLines(node2, lineNumTokenBefore);
        return lineNumNode - lineNumTokenBefore - commentLines > 1;
      }
      function canFix(node2) {
        const leadingComments = sourceCode2.getCommentsBefore(node2);
        const lastLeadingComment = leadingComments.at(-1);
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        if (leadingComments.length === 0) {
          return true;
        }
        if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node2.loc.start.line) {
          return true;
        }
        return false;
      }
      return {
        ReturnStatement(node2) {
          if (!isFirstNode(node2) && !hasNewlineBefore(node2)) {
            context.report({
              node: node2,
              messageId: "expected",
              fix(fixer) {
                if (canFix(node2)) {
                  const tokenBefore = sourceCode2.getTokenBefore(node2);
                  const newlines = node2.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
                  return fixer.insertTextBefore(node2, newlines);
                }
                return null;
              }
            });
          }
        }
      };
    }
  };
  return newlineBeforeReturn;
}
var newlinePerChainedCall;
var hasRequiredNewlinePerChainedCall;
function requireNewlinePerChainedCall() {
  if (hasRequiredNewlinePerChainedCall) return newlinePerChainedCall;
  hasRequiredNewlinePerChainedCall = 1;
  const astUtils2 = requireAstUtils();
  newlinePerChainedCall = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "newline-per-chained-call",
              url: "https://eslint.style/rules/newline-per-chained-call"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require a newline after each call in a method chain",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/newline-per-chained-call"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            ignoreChainWithDepth: {
              type: "integer",
              minimum: 1,
              maximum: 10,
              default: 2
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expected: "Expected line break before `{{callee}}`."
      }
    },
    create(context) {
      const options = context.options[0] || {}, ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
      const sourceCode2 = context.sourceCode;
      function getPrefix(node2) {
        if (node2.computed) {
          if (node2.optional) {
            return "?.[";
          }
          return "[";
        }
        if (node2.optional) {
          return "?.";
        }
        return ".";
      }
      function getPropertyText(node2) {
        const prefix = getPrefix(node2);
        const lines = sourceCode2.getText(node2.property).split(astUtils2.LINEBREAK_MATCHER);
        const suffix = node2.computed && lines.length === 1 ? "]" : "";
        return prefix + lines[0] + suffix;
      }
      return {
        "CallExpression:exit"(node2) {
          const callee = astUtils2.skipChainExpression(node2.callee);
          if (callee.type !== "MemberExpression") {
            return;
          }
          let parent = astUtils2.skipChainExpression(callee.object);
          let depth2 = 1;
          while (parent && parent.callee) {
            depth2 += 1;
            parent = astUtils2.skipChainExpression(
              astUtils2.skipChainExpression(parent.callee).object
            );
          }
          if (depth2 > ignoreChainWithDepth && astUtils2.isTokenOnSameLine(callee.object, callee.property)) {
            const firstTokenAfterObject = sourceCode2.getTokenAfter(
              callee.object,
              astUtils2.isNotClosingParenToken
            );
            context.report({
              node: callee.property,
              loc: {
                start: firstTokenAfterObject.loc.start,
                end: callee.loc.end
              },
              messageId: "expected",
              data: {
                callee: getPropertyText(callee)
              },
              fix(fixer) {
                return fixer.insertTextBefore(
                  firstTokenAfterObject,
                  "\n"
                );
              }
            });
          }
        }
      };
    }
  };
  return newlinePerChainedCall;
}
var noAlert;
var hasRequiredNoAlert;
function requireNoAlert() {
  if (hasRequiredNoAlert) return noAlert;
  hasRequiredNoAlert = 1;
  const {
    getStaticPropertyName: getPropertyName,
    getVariableByName,
    skipChainExpression
  } = requireAstUtils();
  function isProhibitedIdentifier(name2) {
    return /^(?:alert|confirm|prompt)$/u.test(name2);
  }
  function findReference(scope, node2) {
    const references = scope.references.filter(
      (reference) => reference.identifier.range[0] === node2.range[0] && reference.identifier.range[1] === node2.range[1]
    );
    if (references.length === 1) {
      return references[0];
    }
    return null;
  }
  function isShadowed(scope, node2) {
    const reference = findReference(scope, node2);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
  }
  function isGlobalThisReferenceOrGlobalWindow(scope, node2) {
    if (scope.type === "global" && node2.type === "ThisExpression") {
      return true;
    }
    if (node2.type === "Identifier" && (node2.name === "window" || node2.name === "globalThis" && getVariableByName(scope, "globalThis"))) {
      return !isShadowed(scope, node2);
    }
    return false;
  }
  noAlert = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `alert`, `confirm`, and `prompt`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-alert"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected {{name}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        CallExpression(node2) {
          const callee = skipChainExpression(node2.callee), currentScope = sourceCode2.getScope(node2);
          if (callee.type === "Identifier") {
            const name2 = callee.name;
            if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
              context.report({
                node: node2,
                messageId: "unexpected",
                data: { name: name2 }
              });
            }
          } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(
            currentScope,
            callee.object
          )) {
            const name2 = getPropertyName(callee);
            if (isProhibitedIdentifier(name2)) {
              context.report({
                node: node2,
                messageId: "unexpected",
                data: { name: name2 }
              });
            }
          }
        }
      };
    }
  };
  return noAlert;
}
var noArrayConstructor;
var hasRequiredNoArrayConstructor;
function requireNoArrayConstructor() {
  if (hasRequiredNoArrayConstructor) return noArrayConstructor;
  hasRequiredNoArrayConstructor = 1;
  const {
    getVariableByName,
    isClosingParenToken,
    isOpeningParenToken,
    isStartOfExpressionStatement,
    needsPrecedingSemicolon
  } = requireAstUtils();
  noArrayConstructor = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      docs: {
        description: "Disallow `Array` constructors",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-array-constructor"
      },
      fixable: "code",
      hasSuggestions: true,
      schema: [],
      messages: {
        preferLiteral: "The array literal notation [] is preferable.",
        useLiteral: "Replace with an array literal.",
        useLiteralAfterSemicolon: "Replace with an array literal, add preceding semicolon."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function hasCommentsInArrayConstructor(node2) {
        const firstToken = sourceCode2.getFirstToken(node2);
        const lastToken = sourceCode2.getLastToken(node2);
        let lastRelevantToken = sourceCode2.getLastToken(node2.callee);
        while (lastRelevantToken !== lastToken && !isOpeningParenToken(lastRelevantToken)) {
          lastRelevantToken = sourceCode2.getTokenAfter(lastRelevantToken);
        }
        return sourceCode2.commentsExistBetween(
          firstToken,
          lastRelevantToken
        );
      }
      function getArgumentsText(node2) {
        const lastToken = sourceCode2.getLastToken(node2);
        if (!isClosingParenToken(lastToken)) {
          return "";
        }
        let firstToken = node2.callee;
        do {
          firstToken = sourceCode2.getTokenAfter(firstToken);
          if (!firstToken || firstToken === lastToken) {
            return "";
          }
        } while (!isOpeningParenToken(firstToken));
        return sourceCode2.text.slice(
          firstToken.range[1],
          lastToken.range[0]
        );
      }
      function check2(node2) {
        if (node2.callee.type !== "Identifier" || node2.callee.name !== "Array" || node2.typeArguments || node2.arguments.length === 1 && node2.arguments[0].type !== "SpreadElement") {
          return;
        }
        const variable = getVariableByName(
          sourceCode2.getScope(node2),
          "Array"
        );
        if (variable && variable.identifiers.length === 0) {
          const argsText = getArgumentsText(node2);
          let fixText;
          let messageId;
          const nonSpreadCount = node2.arguments.reduce(
            (count, arg) => arg.type !== "SpreadElement" ? count + 1 : count,
            0
          );
          const shouldSuggest = node2.optional || node2.arguments.length > 0 && nonSpreadCount < 2 || hasCommentsInArrayConstructor(node2);
          if (isStartOfExpressionStatement(node2) && needsPrecedingSemicolon(sourceCode2, node2)) {
            fixText = `;[${argsText}]`;
            messageId = "useLiteralAfterSemicolon";
          } else {
            fixText = `[${argsText}]`;
            messageId = "useLiteral";
          }
          context.report({
            node: node2,
            messageId: "preferLiteral",
            fix(fixer) {
              if (shouldSuggest) {
                return null;
              }
              return fixer.replaceText(node2, fixText);
            },
            suggest: [
              {
                messageId,
                fix(fixer) {
                  if (shouldSuggest) {
                    return fixer.replaceText(node2, fixText);
                  }
                  return null;
                }
              }
            ]
          });
        }
      }
      return {
        CallExpression: check2,
        NewExpression: check2
      };
    }
  };
  return noArrayConstructor;
}
var noAsyncPromiseExecutor;
var hasRequiredNoAsyncPromiseExecutor;
function requireNoAsyncPromiseExecutor() {
  if (hasRequiredNoAsyncPromiseExecutor) return noAsyncPromiseExecutor;
  hasRequiredNoAsyncPromiseExecutor = 1;
  noAsyncPromiseExecutor = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow using an async function as a Promise executor",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-async-promise-executor"
      },
      fixable: null,
      schema: [],
      messages: {
        async: "Promise executor functions should not be async."
      }
    },
    create(context) {
      return {
        "NewExpression[callee.name='Promise'][arguments.0.async=true]"(node2) {
          context.report({
            node: context.sourceCode.getFirstToken(
              node2.arguments[0],
              (token) => token.value === "async"
            ),
            messageId: "async"
          });
        }
      };
    }
  };
  return noAsyncPromiseExecutor;
}
var noAwaitInLoop;
var hasRequiredNoAwaitInLoop;
function requireNoAwaitInLoop() {
  if (hasRequiredNoAwaitInLoop) return noAwaitInLoop;
  hasRequiredNoAwaitInLoop = 1;
  function isBoundary(node2) {
    const t2 = node2.type;
    return t2 === "FunctionDeclaration" || t2 === "FunctionExpression" || t2 === "ArrowFunctionExpression" || /*
     * Don't report the await expressions on for-await-of loop since it's
     * asynchronous iteration intentionally.
     */
    t2 === "ForOfStatement" && node2.await === true;
  }
  function isLooped(node2, parent) {
    switch (parent.type) {
      case "ForStatement":
        return node2 === parent.test || node2 === parent.update || node2 === parent.body;
      case "ForOfStatement":
      case "ForInStatement":
        return node2 === parent.body || node2 === parent.left && node2.kind === "await using";
      case "WhileStatement":
      case "DoWhileStatement":
        return node2 === parent.test || node2 === parent.body;
      default:
        return false;
    }
  }
  noAwaitInLoop = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `await` inside of loops",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-await-in-loop"
      },
      schema: [],
      messages: {
        unexpectedAwait: "Unexpected `await` inside a loop."
      }
    },
    create(context) {
      function validate2(awaitNode) {
        if (awaitNode.type === "VariableDeclaration" && awaitNode.kind !== "await using") {
          return;
        }
        if (awaitNode.type === "ForOfStatement" && !awaitNode.await) {
          return;
        }
        let node2 = awaitNode;
        let parent = node2.parent;
        while (parent && !isBoundary(parent)) {
          if (isLooped(node2, parent)) {
            context.report({
              node: awaitNode,
              messageId: "unexpectedAwait"
            });
            return;
          }
          node2 = parent;
          parent = parent.parent;
        }
      }
      return {
        AwaitExpression: validate2,
        ForOfStatement: validate2,
        VariableDeclaration: validate2
      };
    }
  };
  return noAwaitInLoop;
}
var noBitwise;
var hasRequiredNoBitwise;
function requireNoBitwise() {
  if (hasRequiredNoBitwise) return noBitwise;
  hasRequiredNoBitwise = 1;
  const BITWISE_OPERATORS = [
    "^",
    "|",
    "&",
    "<<",
    ">>",
    ">>>",
    "^=",
    "|=",
    "&=",
    "<<=",
    ">>=",
    ">>>=",
    "~"
  ];
  noBitwise = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allow: [],
          int32Hint: false
        }
      ],
      docs: {
        description: "Disallow bitwise operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-bitwise"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                enum: BITWISE_OPERATORS
              },
              uniqueItems: true
            },
            int32Hint: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected use of '{{operator}}'."
      }
    },
    create(context) {
      const [{ allow: allowed, int32Hint }] = context.options;
      function report(node2) {
        context.report({
          node: node2,
          messageId: "unexpected",
          data: { operator: node2.operator }
        });
      }
      function hasBitwiseOperator(node2) {
        return BITWISE_OPERATORS.includes(node2.operator);
      }
      function allowedOperator(node2) {
        return allowed.includes(node2.operator);
      }
      function isInt32Hint(node2) {
        return int32Hint && node2.operator === "|" && node2.right && node2.right.type === "Literal" && node2.right.value === 0;
      }
      function checkNodeForBitwiseOperator(node2) {
        if (hasBitwiseOperator(node2) && !allowedOperator(node2) && !isInt32Hint(node2)) {
          report(node2);
        }
      }
      return {
        AssignmentExpression: checkNodeForBitwiseOperator,
        BinaryExpression: checkNodeForBitwiseOperator,
        UnaryExpression: checkNodeForBitwiseOperator
      };
    }
  };
  return noBitwise;
}
var noBufferConstructor;
var hasRequiredNoBufferConstructor;
function requireNoBufferConstructor() {
  if (hasRequiredNoBufferConstructor) return noBufferConstructor;
  hasRequiredNoBufferConstructor = 1;
  noBufferConstructor = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-deprecated-api",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-deprecated-api.md"
            }
          }
        ]
      },
      type: "problem",
      docs: {
        description: "Disallow use of the `Buffer()` constructor",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-buffer-constructor"
      },
      schema: [],
      messages: {
        deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
      }
    },
    create(context) {
      return {
        "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node2) {
          context.report({
            node: node2,
            messageId: "deprecated",
            data: {
              expr: node2.type === "CallExpression" ? "Buffer()" : "new Buffer()"
            }
          });
        }
      };
    }
  };
  return noBufferConstructor;
}
var noCaller;
var hasRequiredNoCaller;
function requireNoCaller() {
  if (hasRequiredNoCaller) return noCaller;
  hasRequiredNoCaller = 1;
  noCaller = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `arguments.caller` or `arguments.callee`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-caller"
      },
      schema: [],
      messages: {
        unexpected: "Avoid arguments.{{prop}}."
      }
    },
    create(context) {
      return {
        MemberExpression(node2) {
          const objectName = node2.object.name, propertyName2 = node2.property.name;
          if (objectName === "arguments" && !node2.computed && propertyName2 && propertyName2.match(/^calle[er]$/u)) {
            context.report({
              node: node2,
              messageId: "unexpected",
              data: { prop: propertyName2 }
            });
          }
        }
      };
    }
  };
  return noCaller;
}
var noCaseDeclarations;
var hasRequiredNoCaseDeclarations;
function requireNoCaseDeclarations() {
  if (hasRequiredNoCaseDeclarations) return noCaseDeclarations;
  hasRequiredNoCaseDeclarations = 1;
  noCaseDeclarations = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow lexical declarations in case clauses",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-case-declarations"
      },
      hasSuggestions: true,
      schema: [],
      messages: {
        addBrackets: "Add {} brackets around the case block.",
        unexpected: "Unexpected lexical declaration in case block."
      }
    },
    create(context) {
      function isLexicalDeclaration(node2) {
        switch (node2.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            return true;
          case "VariableDeclaration":
            return node2.kind !== "var";
          default:
            return false;
        }
      }
      return {
        SwitchCase(node2) {
          for (let i2 = 0; i2 < node2.consequent.length; i2++) {
            const statement = node2.consequent[i2];
            if (isLexicalDeclaration(statement)) {
              context.report({
                node: statement,
                messageId: "unexpected",
                suggest: [
                  {
                    messageId: "addBrackets",
                    fix: (fixer) => [
                      fixer.insertTextBefore(
                        node2.consequent[0],
                        "{ "
                      ),
                      fixer.insertTextAfter(
                        node2.consequent.at(-1),
                        " }"
                      )
                    ]
                  }
                ]
              });
            }
          }
        }
      };
    }
  };
  return noCaseDeclarations;
}
var noCatchShadow;
var hasRequiredNoCatchShadow;
function requireNoCatchShadow() {
  if (hasRequiredNoCatchShadow) return noCatchShadow;
  hasRequiredNoCatchShadow = 1;
  const astUtils2 = requireAstUtils();
  noCatchShadow = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `catch` clause parameters from shadowing variables in the outer scope",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-catch-shadow"
      },
      deprecated: {
        message: "This rule was renamed.",
        url: "https://eslint.org/blog/2018/07/eslint-v5.1.0-released/",
        deprecatedSince: "5.1.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            rule: {
              name: "no-shadow",
              url: "https://eslint.org/docs/rules/no-shadow"
            }
          }
        ]
      },
      schema: [],
      messages: {
        mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function paramIsShadowing(scope, name2) {
        return astUtils2.getVariableByName(scope, name2) !== null;
      }
      return {
        "CatchClause[param!=null]"(node2) {
          let scope = sourceCode2.getScope(node2);
          if (scope.block === node2) {
            scope = scope.upper;
          }
          if (paramIsShadowing(scope, node2.param.name)) {
            context.report({
              node: node2,
              messageId: "mutable",
              data: { name: node2.param.name }
            });
          }
        }
      };
    }
  };
  return noCatchShadow;
}
var noClassAssign;
var hasRequiredNoClassAssign;
function requireNoClassAssign() {
  if (hasRequiredNoClassAssign) return noClassAssign;
  hasRequiredNoClassAssign = 1;
  const astUtils2 = requireAstUtils();
  noClassAssign = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning class members",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-class-assign"
      },
      schema: [],
      messages: {
        class: "'{{name}}' is a class."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkVariable(variable) {
        astUtils2.getModifyingReferences(variable.references).forEach((reference) => {
          context.report({
            node: reference.identifier,
            messageId: "class",
            data: { name: reference.identifier.name }
          });
        });
      }
      function checkForClass(node2) {
        sourceCode2.getDeclaredVariables(node2).forEach(checkVariable);
      }
      return {
        ClassDeclaration: checkForClass,
        ClassExpression: checkForClass
      };
    }
  };
  return noClassAssign;
}
var noCompareNegZero;
var hasRequiredNoCompareNegZero;
function requireNoCompareNegZero() {
  if (hasRequiredNoCompareNegZero) return noCompareNegZero;
  hasRequiredNoCompareNegZero = 1;
  noCompareNegZero = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow comparing against `-0`",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-compare-neg-zero"
      },
      fixable: null,
      schema: [],
      messages: {
        unexpected: "Do not use the '{{operator}}' operator to compare against -0."
      }
    },
    create(context) {
      function isNegZero(node2) {
        return node2.type === "UnaryExpression" && node2.operator === "-" && node2.argument.type === "Literal" && node2.argument.value === 0;
      }
      const OPERATORS_TO_CHECK = /* @__PURE__ */ new Set([
        ">",
        ">=",
        "<",
        "<=",
        "==",
        "===",
        "!=",
        "!=="
      ]);
      return {
        BinaryExpression(node2) {
          if (OPERATORS_TO_CHECK.has(node2.operator)) {
            if (isNegZero(node2.left) || isNegZero(node2.right)) {
              context.report({
                node: node2,
                messageId: "unexpected",
                data: { operator: node2.operator }
              });
            }
          }
        }
      };
    }
  };
  return noCompareNegZero;
}
var noCondAssign;
var hasRequiredNoCondAssign;
function requireNoCondAssign() {
  if (hasRequiredNoCondAssign) return noCondAssign;
  hasRequiredNoCondAssign = 1;
  const astUtils2 = requireAstUtils();
  const TEST_CONDITION_PARENT_TYPES = /* @__PURE__ */ new Set([
    "IfStatement",
    "WhileStatement",
    "DoWhileStatement",
    "ForStatement",
    "ConditionalExpression"
  ]);
  const NODE_DESCRIPTIONS = {
    DoWhileStatement: "a 'do...while' statement",
    ForStatement: "a 'for' statement",
    IfStatement: "an 'if' statement",
    WhileStatement: "a 'while' statement"
  };
  noCondAssign = {
    meta: {
      type: "problem",
      defaultOptions: ["except-parens"],
      docs: {
        description: "Disallow assignment operators in conditional expressions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-cond-assign"
      },
      schema: [
        {
          enum: ["except-parens", "always"]
        }
      ],
      messages: {
        unexpected: "Unexpected assignment within {{type}}.",
        // must match JSHint's error message
        missing: "Expected a conditional expression and instead saw an assignment."
      }
    },
    create(context) {
      const [prohibitAssign] = context.options;
      const sourceCode2 = context.sourceCode;
      function isConditionalTestExpression(node2) {
        return node2.parent && TEST_CONDITION_PARENT_TYPES.has(node2.parent.type) && node2 === node2.parent.test;
      }
      function findConditionalAncestor(node2) {
        let currentAncestor = node2;
        do {
          if (isConditionalTestExpression(currentAncestor)) {
            return currentAncestor.parent;
          }
        } while ((currentAncestor = currentAncestor.parent) && !astUtils2.isFunction(currentAncestor));
        return null;
      }
      function isParenthesisedTwice(node2) {
        const previousToken = sourceCode2.getTokenBefore(node2, 1), nextToken = sourceCode2.getTokenAfter(node2, 1);
        return astUtils2.isParenthesised(sourceCode2, node2) && previousToken && astUtils2.isOpeningParenToken(previousToken) && previousToken.range[1] <= node2.range[0] && astUtils2.isClosingParenToken(nextToken) && nextToken.range[0] >= node2.range[1];
      }
      function testForAssign(node2) {
        if (node2.test && node2.test.type === "AssignmentExpression" && (node2.type === "ForStatement" ? !astUtils2.isParenthesised(sourceCode2, node2.test) : !isParenthesisedTwice(node2.test))) {
          context.report({
            node: node2.test,
            messageId: "missing"
          });
        }
      }
      function testForConditionalAncestor(node2) {
        const ancestor = findConditionalAncestor(node2);
        if (ancestor) {
          context.report({
            node: node2,
            messageId: "unexpected",
            data: {
              type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
            }
          });
        }
      }
      if (prohibitAssign === "always") {
        return {
          AssignmentExpression: testForConditionalAncestor
        };
      }
      return {
        DoWhileStatement: testForAssign,
        ForStatement: testForAssign,
        IfStatement: testForAssign,
        WhileStatement: testForAssign,
        ConditionalExpression: testForAssign
      };
    }
  };
  return noCondAssign;
}
var noConfusingArrow;
var hasRequiredNoConfusingArrow;
function requireNoConfusingArrow() {
  if (hasRequiredNoConfusingArrow) return noConfusingArrow;
  hasRequiredNoConfusingArrow = 1;
  const astUtils2 = requireAstUtils();
  function isConditional(node2) {
    return node2 && node2.type === "ConditionalExpression";
  }
  noConfusingArrow = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-confusing-arrow",
              url: "https://eslint.style/rules/no-confusing-arrow"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow arrow functions where they could be confused with comparisons",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-confusing-arrow"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            allowParens: { type: "boolean", default: true },
            onlyOneSimpleParam: { type: "boolean", default: false }
          },
          additionalProperties: false
        }
      ],
      messages: {
        confusing: "Arrow function used ambiguously with a conditional expression."
      }
    },
    create(context) {
      const config2 = context.options[0] || {};
      const allowParens = config2.allowParens || config2.allowParens === void 0;
      const onlyOneSimpleParam = config2.onlyOneSimpleParam;
      const sourceCode2 = context.sourceCode;
      function checkArrowFunc(node2) {
        const body = node2.body;
        if (isConditional(body) && !(allowParens && astUtils2.isParenthesised(sourceCode2, body)) && !(onlyOneSimpleParam && !(node2.params.length === 1 && node2.params[0].type === "Identifier"))) {
          context.report({
            node: node2,
            messageId: "confusing",
            fix(fixer) {
              return allowParens && fixer.replaceText(
                node2.body,
                `(${sourceCode2.getText(node2.body)})`
              );
            }
          });
        }
      }
      return {
        ArrowFunctionExpression: checkArrowFunc
      };
    }
  };
  return noConfusingArrow;
}
var noConsole;
var hasRequiredNoConsole;
function requireNoConsole() {
  if (hasRequiredNoConsole) return noConsole;
  hasRequiredNoConsole = 1;
  const astUtils2 = requireAstUtils();
  noConsole = {
    meta: {
      type: "suggestion",
      defaultOptions: [{}],
      docs: {
        description: "Disallow the use of `console`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-console"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      hasSuggestions: true,
      messages: {
        unexpected: "Unexpected console statement.",
        limited: "Unexpected console statement. Only these console methods are allowed: {{ allowed }}.",
        removeConsole: "Remove the console.{{ propertyName }}().",
        removeMethodCall: "Remove the console method call."
      }
    },
    create(context) {
      const [{ allow: allowed = [] }] = context.options;
      const sourceCode2 = context.sourceCode;
      function isConsole(reference) {
        const id2 = reference.identifier;
        return id2 && id2.name === "console";
      }
      function isAllowed(node2) {
        const propertyName2 = astUtils2.getStaticPropertyName(node2);
        return propertyName2 && allowed.includes(propertyName2);
      }
      function isMemberAccessExceptAllowed(reference) {
        const node2 = reference.identifier;
        const parent = node2.parent;
        return parent.type === "MemberExpression" && parent.object === node2 && !isAllowed(parent);
      }
      function maybeAsiHazard(node2) {
        const SAFE_TOKENS_BEFORE = /^[:;{]$/u;
        const UNSAFE_CHARS_AFTER = /^[-[(/+`]/u;
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        const tokenAfter = sourceCode2.getTokenAfter(node2);
        return Boolean(tokenAfter) && UNSAFE_CHARS_AFTER.test(tokenAfter.value) && tokenAfter.value !== "++" && tokenAfter.value !== "--" && Boolean(tokenBefore) && !SAFE_TOKENS_BEFORE.test(tokenBefore.value);
      }
      function canProvideSuggestions(node2) {
        return node2.parent.type === "CallExpression" && node2.parent.callee === node2 && node2.parent.parent.type === "ExpressionStatement" && astUtils2.STATEMENT_LIST_PARENTS.has(
          node2.parent.parent.parent.type
        ) && !maybeAsiHazard(node2.parent.parent);
      }
      function report(reference) {
        const node2 = reference.identifier.parent;
        const suggest = [];
        if (canProvideSuggestions(node2)) {
          const suggestion = {
            fix(fixer) {
              return fixer.remove(node2.parent.parent);
            }
          };
          if (node2.computed) {
            suggestion.messageId = "removeMethodCall";
          } else {
            suggestion.messageId = "removeConsole";
            suggestion.data = { propertyName: node2.property.name };
          }
          suggest.push(suggestion);
        }
        context.report({
          node: node2,
          loc: node2.loc,
          messageId: allowed.length ? "limited" : "unexpected",
          data: { allowed: allowed.join(", ") },
          suggest
        });
      }
      return {
        "Program:exit"(node2) {
          const scope = sourceCode2.getScope(node2);
          const consoleVar = astUtils2.getVariableByName(scope, "console");
          const shadowed = consoleVar && consoleVar.defs.length > 0;
          const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);
          if (!shadowed) {
            references.filter(isMemberAccessExceptAllowed).forEach(report);
          }
        }
      };
    }
  };
  return noConsole;
}
var noConstAssign;
var hasRequiredNoConstAssign;
function requireNoConstAssign() {
  if (hasRequiredNoConstAssign) return noConstAssign;
  hasRequiredNoConstAssign = 1;
  const astUtils2 = requireAstUtils();
  const CONSTANT_BINDINGS = /* @__PURE__ */ new Set(["const", "using", "await using"]);
  noConstAssign = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning `const`, `using`, and `await using` variables",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-const-assign"
      },
      schema: [],
      messages: {
        const: "'{{name}}' is constant."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkVariable(variable) {
        astUtils2.getModifyingReferences(variable.references).forEach((reference) => {
          context.report({
            node: reference.identifier,
            messageId: "const",
            data: { name: reference.identifier.name }
          });
        });
      }
      return {
        VariableDeclaration(node2) {
          if (CONSTANT_BINDINGS.has(node2.kind)) {
            sourceCode2.getDeclaredVariables(node2).forEach(checkVariable);
          }
        }
      };
    }
  };
  return noConstAssign;
}
var noConstantBinaryExpression;
var hasRequiredNoConstantBinaryExpression;
function requireNoConstantBinaryExpression() {
  if (hasRequiredNoConstantBinaryExpression) return noConstantBinaryExpression;
  hasRequiredNoConstantBinaryExpression = 1;
  const {
    isNullLiteral,
    isConstant,
    isReferenceToGlobalVariable,
    isLogicalAssignmentOperator,
    ECMASCRIPT_GLOBALS
  } = requireAstUtils();
  const NUMERIC_OR_STRING_BINARY_OPERATORS = /* @__PURE__ */ new Set([
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "^",
    "&",
    "**",
    "<<",
    ">>",
    ">>>"
  ]);
  function isNullOrUndefined(scope, node2) {
    return isNullLiteral(node2) || node2.type === "Identifier" && node2.name === "undefined" && isReferenceToGlobalVariable(scope, node2) || node2.type === "UnaryExpression" && node2.operator === "void";
  }
  function hasConstantNullishness(scope, node2, nonNullish) {
    if (nonNullish && isNullOrUndefined(scope, node2)) {
      return false;
    }
    switch (node2.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ClassExpression":
      case "NewExpression":
      case "Literal":
      case "TemplateLiteral":
      case "UpdateExpression":
      case "BinaryExpression":
        return true;
      case "CallExpression": {
        if (node2.callee.type !== "Identifier") {
          return false;
        }
        const functionName = node2.callee.name;
        return (functionName === "Boolean" || functionName === "String" || functionName === "Number") && isReferenceToGlobalVariable(scope, node2.callee);
      }
      case "LogicalExpression": {
        return node2.operator === "??" && hasConstantNullishness(scope, node2.right, true);
      }
      case "AssignmentExpression":
        if (node2.operator === "=") {
          return hasConstantNullishness(scope, node2.right, nonNullish);
        }
        if (isLogicalAssignmentOperator(node2.operator)) {
          return false;
        }
        return true;
      case "UnaryExpression":
        return true;
      case "SequenceExpression": {
        const last = node2.expressions.at(-1);
        return hasConstantNullishness(scope, last, nonNullish);
      }
      case "Identifier":
        return node2.name === "undefined" && isReferenceToGlobalVariable(scope, node2);
      case "JSXElement":
      case "JSXFragment":
        return false;
      default:
        return false;
    }
  }
  function isStaticBoolean(scope, node2) {
    switch (node2.type) {
      case "Literal":
        return typeof node2.value === "boolean";
      case "CallExpression":
        return node2.callee.type === "Identifier" && node2.callee.name === "Boolean" && isReferenceToGlobalVariable(scope, node2.callee) && (node2.arguments.length === 0 || isConstant(scope, node2.arguments[0], true));
      case "UnaryExpression":
        return node2.operator === "!" && isConstant(scope, node2.argument, true);
      default:
        return false;
    }
  }
  function hasConstantLooseBooleanComparison(scope, node2) {
    switch (node2.type) {
      case "ObjectExpression":
      case "ClassExpression":
        return true;
      case "ArrayExpression": {
        const nonSpreadElements = node2.elements.filter(
          (e2) => (
            // Elements can be `null` in sparse arrays: `[,,]`;
            e2 !== null && e2.type !== "SpreadElement"
          )
        );
        return node2.elements.length === 0 || nonSpreadElements.length > 1;
      }
      case "ArrowFunctionExpression":
      case "FunctionExpression":
        return true;
      case "UnaryExpression":
        if (node2.operator === "void" || // Always returns `undefined`
        node2.operator === "typeof") {
          return true;
        }
        if (node2.operator === "!") {
          return isConstant(scope, node2.argument, true);
        }
        return false;
      case "NewExpression":
        return false;
      case "CallExpression": {
        if (node2.callee.type === "Identifier" && node2.callee.name === "Boolean" && isReferenceToGlobalVariable(scope, node2.callee)) {
          return node2.arguments.length === 0 || isConstant(scope, node2.arguments[0], true);
        }
        return false;
      }
      case "Literal":
        return true;
      case "Identifier":
        return node2.name === "undefined" && isReferenceToGlobalVariable(scope, node2);
      case "TemplateLiteral":
        return node2.expressions.length === 0;
      case "AssignmentExpression":
        if (node2.operator === "=") {
          return hasConstantLooseBooleanComparison(scope, node2.right);
        }
        return false;
      case "SequenceExpression": {
        const last = node2.expressions.at(-1);
        return hasConstantLooseBooleanComparison(scope, last);
      }
      case "JSXElement":
      case "JSXFragment":
        return false;
      default:
        return false;
    }
  }
  function hasConstantStrictBooleanComparison(scope, node2) {
    switch (node2.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ClassExpression":
      case "NewExpression":
      case "TemplateLiteral":
      case "Literal":
      case "UpdateExpression":
        return true;
      case "BinaryExpression":
        return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node2.operator);
      case "UnaryExpression": {
        if (node2.operator === "delete") {
          return false;
        }
        if (node2.operator === "!") {
          return isConstant(scope, node2.argument, true);
        }
        return true;
      }
      case "SequenceExpression": {
        const last = node2.expressions.at(-1);
        return hasConstantStrictBooleanComparison(scope, last);
      }
      case "Identifier":
        return node2.name === "undefined" && isReferenceToGlobalVariable(scope, node2);
      case "AssignmentExpression":
        if (node2.operator === "=") {
          return hasConstantStrictBooleanComparison(scope, node2.right);
        }
        if (isLogicalAssignmentOperator(node2.operator)) {
          return false;
        }
        return true;
      case "CallExpression": {
        if (node2.callee.type !== "Identifier") {
          return false;
        }
        const functionName = node2.callee.name;
        if ((functionName === "String" || functionName === "Number") && isReferenceToGlobalVariable(scope, node2.callee)) {
          return true;
        }
        if (functionName === "Boolean" && isReferenceToGlobalVariable(scope, node2.callee)) {
          return node2.arguments.length === 0 || isConstant(scope, node2.arguments[0], true);
        }
        return false;
      }
      case "JSXElement":
      case "JSXFragment":
        return false;
      default:
        return false;
    }
  }
  function isAlwaysNew(scope, node2) {
    switch (node2.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ClassExpression":
        return true;
      case "NewExpression": {
        if (node2.callee.type !== "Identifier") {
          return false;
        }
        return Object.hasOwn(ECMASCRIPT_GLOBALS, node2.callee.name) && isReferenceToGlobalVariable(scope, node2.callee);
      }
      case "Literal":
        return typeof node2.regex === "object";
      case "SequenceExpression": {
        const last = node2.expressions.at(-1);
        return isAlwaysNew(scope, last);
      }
      case "AssignmentExpression":
        if (node2.operator === "=") {
          return isAlwaysNew(scope, node2.right);
        }
        return false;
      case "ConditionalExpression":
        return isAlwaysNew(scope, node2.consequent) && isAlwaysNew(scope, node2.alternate);
      case "JSXElement":
      case "JSXFragment":
        return false;
      default:
        return false;
    }
  }
  function findBinaryExpressionConstantOperand(scope, a2, b, operator2) {
    if (operator2 === "==" || operator2 === "!=") {
      if (isNullOrUndefined(scope, a2) && hasConstantNullishness(scope, b, false) || isStaticBoolean(scope, a2) && hasConstantLooseBooleanComparison(scope, b)) {
        return b;
      }
    } else if (operator2 === "===" || operator2 === "!==") {
      if (isNullOrUndefined(scope, a2) && hasConstantNullishness(scope, b, false) || isStaticBoolean(scope, a2) && hasConstantStrictBooleanComparison(scope, b)) {
        return b;
      }
    }
    return null;
  }
  noConstantBinaryExpression = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow expressions where the operation doesn't affect the value",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-constant-binary-expression"
      },
      schema: [],
      messages: {
        constantBinaryOperand: "Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.",
        constantShortCircuit: "Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.",
        alwaysNew: "Unexpected comparison to newly constructed object. These two values can never be equal.",
        bothAlwaysNew: "Unexpected comparison of two newly constructed objects. These two values can never be equal."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        LogicalExpression(node2) {
          const { operator: operator2, left } = node2;
          const scope = sourceCode2.getScope(node2);
          if ((operator2 === "&&" || operator2 === "||") && isConstant(scope, left, true)) {
            context.report({
              node: left,
              messageId: "constantShortCircuit",
              data: { property: "truthiness", operator: operator2 }
            });
          } else if (operator2 === "??" && hasConstantNullishness(scope, left, false)) {
            context.report({
              node: left,
              messageId: "constantShortCircuit",
              data: { property: "nullishness", operator: operator2 }
            });
          }
        },
        BinaryExpression(node2) {
          const scope = sourceCode2.getScope(node2);
          const { right, left, operator: operator2 } = node2;
          const rightConstantOperand = findBinaryExpressionConstantOperand(
            scope,
            left,
            right,
            operator2
          );
          const leftConstantOperand = findBinaryExpressionConstantOperand(
            scope,
            right,
            left,
            operator2
          );
          if (rightConstantOperand) {
            context.report({
              node: rightConstantOperand,
              messageId: "constantBinaryOperand",
              data: { operator: operator2, otherSide: "left" }
            });
          } else if (leftConstantOperand) {
            context.report({
              node: leftConstantOperand,
              messageId: "constantBinaryOperand",
              data: { operator: operator2, otherSide: "right" }
            });
          } else if (operator2 === "===" || operator2 === "!==") {
            if (isAlwaysNew(scope, left)) {
              context.report({ node: left, messageId: "alwaysNew" });
            } else if (isAlwaysNew(scope, right)) {
              context.report({ node: right, messageId: "alwaysNew" });
            }
          } else if (operator2 === "==" || operator2 === "!=") {
            if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {
              context.report({
                node: left,
                messageId: "bothAlwaysNew"
              });
            }
          }
        }
        /*
         * In theory we could handle short-circuiting assignment operators,
         * for some constant values, but that would require walking the
         * scope to find the value of the variable being assigned. This is
         * dependent on https://github.com/eslint/eslint/issues/13776
         *
         * AssignmentExpression() {},
         */
      };
    }
  };
  return noConstantBinaryExpression;
}
var noConstantCondition;
var hasRequiredNoConstantCondition;
function requireNoConstantCondition() {
  if (hasRequiredNoConstantCondition) return noConstantCondition;
  hasRequiredNoConstantCondition = 1;
  const { isConstant } = requireAstUtils();
  noConstantCondition = {
    meta: {
      type: "problem",
      defaultOptions: [{ checkLoops: "allExceptWhileTrue" }],
      docs: {
        description: "Disallow constant expressions in conditions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-constant-condition"
      },
      schema: [
        {
          type: "object",
          properties: {
            checkLoops: {
              enum: [
                "all",
                "allExceptWhileTrue",
                "none",
                true,
                false
              ]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected constant condition."
      }
    },
    create(context) {
      const loopSetStack = [];
      const sourceCode2 = context.sourceCode;
      let [{ checkLoops }] = context.options;
      if (checkLoops === true) {
        checkLoops = "all";
      } else if (checkLoops === false) {
        checkLoops = "none";
      }
      let loopsInCurrentScope = /* @__PURE__ */ new Set();
      function trackConstantConditionLoop(node2) {
        if (node2.test && isConstant(sourceCode2.getScope(node2), node2.test, true)) {
          loopsInCurrentScope.add(node2);
        }
      }
      function checkConstantConditionLoopInSet(node2) {
        if (loopsInCurrentScope.has(node2)) {
          loopsInCurrentScope.delete(node2);
          context.report({ node: node2.test, messageId: "unexpected" });
        }
      }
      function reportIfConstant(node2) {
        if (node2.test && isConstant(sourceCode2.getScope(node2), node2.test, true)) {
          context.report({ node: node2.test, messageId: "unexpected" });
        }
      }
      function enterFunction() {
        loopSetStack.push(loopsInCurrentScope);
        loopsInCurrentScope = /* @__PURE__ */ new Set();
      }
      function exitFunction() {
        loopsInCurrentScope = loopSetStack.pop();
      }
      function checkLoop(node2) {
        if (checkLoops === "all" || checkLoops === "allExceptWhileTrue") {
          trackConstantConditionLoop(node2);
        }
      }
      return {
        ConditionalExpression: reportIfConstant,
        IfStatement: reportIfConstant,
        WhileStatement(node2) {
          if (node2.test.type === "Literal" && node2.test.value === true && checkLoops === "allExceptWhileTrue") {
            return;
          }
          checkLoop(node2);
        },
        "WhileStatement:exit": checkConstantConditionLoopInSet,
        DoWhileStatement: checkLoop,
        "DoWhileStatement:exit": checkConstantConditionLoopInSet,
        ForStatement: checkLoop,
        "ForStatement > .test": (node2) => checkLoop(node2.parent),
        "ForStatement:exit": checkConstantConditionLoopInSet,
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        YieldExpression: () => loopsInCurrentScope.clear()
      };
    }
  };
  return noConstantCondition;
}
var noConstructorReturn;
var hasRequiredNoConstructorReturn;
function requireNoConstructorReturn() {
  if (hasRequiredNoConstructorReturn) return noConstructorReturn;
  hasRequiredNoConstructorReturn = 1;
  noConstructorReturn = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow returning value from constructor",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-constructor-return"
      },
      schema: [],
      fixable: null,
      messages: {
        unexpected: "Unexpected return statement in constructor."
      }
    },
    create(context) {
      const stack = [];
      return {
        onCodePathStart(_, node2) {
          stack.push(node2);
        },
        onCodePathEnd() {
          stack.pop();
        },
        ReturnStatement(node2) {
          const last = stack.at(-1);
          if (!last.parent) {
            return;
          }
          if (last.parent.type === "MethodDefinition" && last.parent.kind === "constructor" && node2.argument) {
            context.report({
              node: node2,
              messageId: "unexpected"
            });
          }
        }
      };
    }
  };
  return noConstructorReturn;
}
var noContinue;
var hasRequiredNoContinue;
function requireNoContinue() {
  if (hasRequiredNoContinue) return noContinue;
  hasRequiredNoContinue = 1;
  noContinue = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `continue` statements",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-continue"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected use of continue statement."
      }
    },
    create(context) {
      return {
        ContinueStatement(node2) {
          context.report({ node: node2, messageId: "unexpected" });
        }
      };
    }
  };
  return noContinue;
}
var regexpp = {};
var hasRequiredRegexpp;
function requireRegexpp() {
  if (hasRequiredRegexpp) return regexpp;
  hasRequiredRegexpp = 1;
  Object.defineProperty(regexpp, "__esModule", { value: true });
  var ast2 = /* @__PURE__ */ Object.freeze({
    __proto__: null
  });
  const latestEcmaVersion = 2025;
  let largeIdStartRanges = void 0;
  let largeIdContinueRanges = void 0;
  function isIdStart(cp) {
    if (cp < 65)
      return false;
    if (cp < 91)
      return true;
    if (cp < 97)
      return false;
    if (cp < 123)
      return true;
    return isLargeIdStart(cp);
  }
  function isIdContinue(cp) {
    if (cp < 48)
      return false;
    if (cp < 58)
      return true;
    if (cp < 65)
      return false;
    if (cp < 91)
      return true;
    if (cp === 95)
      return true;
    if (cp < 97)
      return false;
    if (cp < 123)
      return true;
    return isLargeIdStart(cp) || isLargeIdContinue(cp);
  }
  function isLargeIdStart(cp) {
    return isInRange(cp, largeIdStartRanges !== null && largeIdStartRanges !== void 0 ? largeIdStartRanges : largeIdStartRanges = initLargeIdStartRanges());
  }
  function isLargeIdContinue(cp) {
    return isInRange(cp, largeIdContinueRanges !== null && largeIdContinueRanges !== void 0 ? largeIdContinueRanges : largeIdContinueRanges = initLargeIdContinueRanges());
  }
  function initLargeIdStartRanges() {
    return restoreRanges("4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 6 n 2 5 i 15 1n 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 3 0 3 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 w 1 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 h e i f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 7 1j t e 1 b 17 r z 16 2 b z 3 a 6 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 6c 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t h3g 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1u 3 1 2 0 2 7 m f 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f d a 2 e 2 6 2 1 2 a 2 e 2 6 2 1 4 1f d 8m a l b 7 p 5 2 15 2 8 1y 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 13 r a m 6z 15 7 1 h 2 1o s b 0 9 l 17 h 1b k s m d 1g 1m 1 3 0 e 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o k 1 1s 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 v 9 2 0 3 0 2 11 2 0 q 0 2 0 19 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 12 6 56 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 j 20 5k w w 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i g 0 2 c 2 x 3h 0 28 pl 2v 32 i 5f 219 2o g tr i 5 q 32y 6 g6 5a2 t 1cz fs 8 u i 26 i t j 1b h 3 w k 6 i c1 18 5w 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 16 9 6w8 3 2 6 2 1 2 82 g 0 u 2 3 0 f 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1f9 u 7 5 7a 1p 43 18 b 6 h 0 8y t j 17 dh r 6d t 3 0 ds 6 2 3 2 1 2 e 2 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyn x 37d 7 65 3 4g1 f 5rk g h9 1wj f1 15v 3t6 6 38f");
  }
  function initLargeIdContinueRanges() {
    return restoreRanges("53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 1o 8 17 n 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1k 0 2 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 4 0 d 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 6 2 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 3 t 2 u 1 v 1 1t v a 0 3 9 y 2 2 a 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 f 1e 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1r el 1 1e 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 2p 0 n51 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 12 0 ig 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 7 9 w 4 8u 1 28 3 1z a 1e 3 3f 2 1i e w a 3 1 b 3 1a a 8 0 1a 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 3 0 4e b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 1w 8 2 0 3 0 2 3 2 4 2 0 f 1 2b h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 7 j 1m e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f 9j 9 1i 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 a 1 2 0 1d 6 4 4 e a 44m 0 7 e 8uh r 1t3 9 2f 9 13 4 1o 6 q 9 ev 9 d2 0 2 1i 8 3 2a 0 c 1 f58 1 382 9 ef 19 3 m f3 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 2t 0 4h 6 a 9 9x 0 1q d dv d 6t 1 2 9 k6 6 32 6 6 9 3o7 9 gvt3 6n");
  }
  function isInRange(cp, ranges) {
    let l2 = 0, r2 = ranges.length / 2 | 0, i2 = 0, min = 0, max = 0;
    while (l2 < r2) {
      i2 = (l2 + r2) / 2 | 0;
      min = ranges[2 * i2];
      max = ranges[2 * i2 + 1];
      if (cp < min) {
        r2 = i2;
      } else if (cp > max) {
        l2 = i2 + 1;
      } else {
        return true;
      }
    }
    return false;
  }
  function restoreRanges(data2) {
    let last = 0;
    return data2.split(" ").map((s2) => last += parseInt(s2, 36) | 0);
  }
  class DataSet {
    constructor(raw2018, raw2019, raw2020, raw2021, raw2022, raw2023, raw2024, raw2025) {
      this._raw2018 = raw2018;
      this._raw2019 = raw2019;
      this._raw2020 = raw2020;
      this._raw2021 = raw2021;
      this._raw2022 = raw2022;
      this._raw2023 = raw2023;
      this._raw2024 = raw2024;
      this._raw2025 = raw2025;
    }
    get es2018() {
      var _a2;
      return (_a2 = this._set2018) !== null && _a2 !== void 0 ? _a2 : this._set2018 = new Set(this._raw2018.split(" "));
    }
    get es2019() {
      var _a2;
      return (_a2 = this._set2019) !== null && _a2 !== void 0 ? _a2 : this._set2019 = new Set(this._raw2019.split(" "));
    }
    get es2020() {
      var _a2;
      return (_a2 = this._set2020) !== null && _a2 !== void 0 ? _a2 : this._set2020 = new Set(this._raw2020.split(" "));
    }
    get es2021() {
      var _a2;
      return (_a2 = this._set2021) !== null && _a2 !== void 0 ? _a2 : this._set2021 = new Set(this._raw2021.split(" "));
    }
    get es2022() {
      var _a2;
      return (_a2 = this._set2022) !== null && _a2 !== void 0 ? _a2 : this._set2022 = new Set(this._raw2022.split(" "));
    }
    get es2023() {
      var _a2;
      return (_a2 = this._set2023) !== null && _a2 !== void 0 ? _a2 : this._set2023 = new Set(this._raw2023.split(" "));
    }
    get es2024() {
      var _a2;
      return (_a2 = this._set2024) !== null && _a2 !== void 0 ? _a2 : this._set2024 = new Set(this._raw2024.split(" "));
    }
    get es2025() {
      var _a2;
      return (_a2 = this._set2025) !== null && _a2 !== void 0 ? _a2 : this._set2025 = new Set(this._raw2025.split(" "));
    }
  }
  const gcNameSet = /* @__PURE__ */ new Set(["General_Category", "gc"]);
  const scNameSet = /* @__PURE__ */ new Set(["Script", "Script_Extensions", "sc", "scx"]);
  const gcValueSets = new DataSet("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "", "", "", "", "", "");
  const scValueSets = new DataSet("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho", "Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", "Cpmn Cypro_Minoan Old_Uyghur Ougr Tangsa Tnsa Toto Vith Vithkuqi", "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", "", "");
  const binPropertySets = new DataSet("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "", "EBase EComp EMod EPres ExtPict", "", "", "", "");
  const binPropertyOfStringsSets = new DataSet("", "", "", "", "", "", "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji RGI_Emoji_Flag_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence", "");
  function isValidUnicodeProperty(version2, name2, value) {
    if (gcNameSet.has(name2)) {
      return version2 >= 2018 && gcValueSets.es2018.has(value);
    }
    if (scNameSet.has(name2)) {
      return version2 >= 2018 && scValueSets.es2018.has(value) || version2 >= 2019 && scValueSets.es2019.has(value) || version2 >= 2020 && scValueSets.es2020.has(value) || version2 >= 2021 && scValueSets.es2021.has(value) || version2 >= 2022 && scValueSets.es2022.has(value) || version2 >= 2023 && scValueSets.es2023.has(value);
    }
    return false;
  }
  function isValidLoneUnicodeProperty(version2, value) {
    return version2 >= 2018 && binPropertySets.es2018.has(value) || version2 >= 2019 && binPropertySets.es2019.has(value) || version2 >= 2021 && binPropertySets.es2021.has(value);
  }
  function isValidLoneUnicodePropertyOfString(version2, value) {
    return version2 >= 2024 && binPropertyOfStringsSets.es2024.has(value);
  }
  const BACKSPACE = 8;
  const CHARACTER_TABULATION = 9;
  const LINE_FEED = 10;
  const LINE_TABULATION = 11;
  const FORM_FEED = 12;
  const CARRIAGE_RETURN = 13;
  const EXCLAMATION_MARK = 33;
  const NUMBER_SIGN = 35;
  const DOLLAR_SIGN = 36;
  const PERCENT_SIGN = 37;
  const AMPERSAND = 38;
  const LEFT_PARENTHESIS = 40;
  const RIGHT_PARENTHESIS = 41;
  const ASTERISK = 42;
  const PLUS_SIGN = 43;
  const COMMA = 44;
  const HYPHEN_MINUS = 45;
  const FULL_STOP = 46;
  const SOLIDUS = 47;
  const DIGIT_ZERO = 48;
  const DIGIT_ONE = 49;
  const DIGIT_SEVEN = 55;
  const DIGIT_NINE = 57;
  const COLON = 58;
  const SEMICOLON = 59;
  const LESS_THAN_SIGN = 60;
  const EQUALS_SIGN = 61;
  const GREATER_THAN_SIGN = 62;
  const QUESTION_MARK = 63;
  const COMMERCIAL_AT = 64;
  const LATIN_CAPITAL_LETTER_A = 65;
  const LATIN_CAPITAL_LETTER_B = 66;
  const LATIN_CAPITAL_LETTER_D = 68;
  const LATIN_CAPITAL_LETTER_F = 70;
  const LATIN_CAPITAL_LETTER_P = 80;
  const LATIN_CAPITAL_LETTER_S = 83;
  const LATIN_CAPITAL_LETTER_W = 87;
  const LATIN_CAPITAL_LETTER_Z = 90;
  const LOW_LINE = 95;
  const LATIN_SMALL_LETTER_A = 97;
  const LATIN_SMALL_LETTER_B = 98;
  const LATIN_SMALL_LETTER_C = 99;
  const LATIN_SMALL_LETTER_D = 100;
  const LATIN_SMALL_LETTER_F = 102;
  const LATIN_SMALL_LETTER_G = 103;
  const LATIN_SMALL_LETTER_I = 105;
  const LATIN_SMALL_LETTER_K = 107;
  const LATIN_SMALL_LETTER_M = 109;
  const LATIN_SMALL_LETTER_N = 110;
  const LATIN_SMALL_LETTER_P = 112;
  const LATIN_SMALL_LETTER_Q = 113;
  const LATIN_SMALL_LETTER_R = 114;
  const LATIN_SMALL_LETTER_S = 115;
  const LATIN_SMALL_LETTER_T = 116;
  const LATIN_SMALL_LETTER_U = 117;
  const LATIN_SMALL_LETTER_V = 118;
  const LATIN_SMALL_LETTER_W = 119;
  const LATIN_SMALL_LETTER_X = 120;
  const LATIN_SMALL_LETTER_Y = 121;
  const LATIN_SMALL_LETTER_Z = 122;
  const LEFT_SQUARE_BRACKET = 91;
  const REVERSE_SOLIDUS = 92;
  const RIGHT_SQUARE_BRACKET = 93;
  const CIRCUMFLEX_ACCENT = 94;
  const GRAVE_ACCENT = 96;
  const LEFT_CURLY_BRACKET = 123;
  const VERTICAL_LINE = 124;
  const RIGHT_CURLY_BRACKET = 125;
  const TILDE = 126;
  const ZERO_WIDTH_NON_JOINER = 8204;
  const ZERO_WIDTH_JOINER = 8205;
  const LINE_SEPARATOR = 8232;
  const PARAGRAPH_SEPARATOR = 8233;
  const MIN_CODE_POINT = 0;
  const MAX_CODE_POINT = 1114111;
  function isLatinLetter(code2) {
    return code2 >= LATIN_CAPITAL_LETTER_A && code2 <= LATIN_CAPITAL_LETTER_Z || code2 >= LATIN_SMALL_LETTER_A && code2 <= LATIN_SMALL_LETTER_Z;
  }
  function isDecimalDigit(code2) {
    return code2 >= DIGIT_ZERO && code2 <= DIGIT_NINE;
  }
  function isOctalDigit(code2) {
    return code2 >= DIGIT_ZERO && code2 <= DIGIT_SEVEN;
  }
  function isHexDigit(code2) {
    return code2 >= DIGIT_ZERO && code2 <= DIGIT_NINE || code2 >= LATIN_CAPITAL_LETTER_A && code2 <= LATIN_CAPITAL_LETTER_F || code2 >= LATIN_SMALL_LETTER_A && code2 <= LATIN_SMALL_LETTER_F;
  }
  function isLineTerminator(code2) {
    return code2 === LINE_FEED || code2 === CARRIAGE_RETURN || code2 === LINE_SEPARATOR || code2 === PARAGRAPH_SEPARATOR;
  }
  function isValidUnicode(code2) {
    return code2 >= MIN_CODE_POINT && code2 <= MAX_CODE_POINT;
  }
  function digitToInt(code2) {
    if (code2 >= LATIN_SMALL_LETTER_A && code2 <= LATIN_SMALL_LETTER_F) {
      return code2 - LATIN_SMALL_LETTER_A + 10;
    }
    if (code2 >= LATIN_CAPITAL_LETTER_A && code2 <= LATIN_CAPITAL_LETTER_F) {
      return code2 - LATIN_CAPITAL_LETTER_A + 10;
    }
    return code2 - DIGIT_ZERO;
  }
  function isLeadSurrogate(code2) {
    return code2 >= 55296 && code2 <= 56319;
  }
  function isTrailSurrogate(code2) {
    return code2 >= 56320 && code2 <= 57343;
  }
  function combineSurrogatePair(lead, trail) {
    return (lead - 55296) * 1024 + (trail - 56320) + 65536;
  }
  class GroupSpecifiersAsES2018 {
    constructor() {
      this.groupName = /* @__PURE__ */ new Set();
    }
    clear() {
      this.groupName.clear();
    }
    isEmpty() {
      return !this.groupName.size;
    }
    hasInPattern(name2) {
      return this.groupName.has(name2);
    }
    hasInScope(name2) {
      return this.hasInPattern(name2);
    }
    addToScope(name2) {
      this.groupName.add(name2);
    }
    enterDisjunction() {
    }
    enterAlternative() {
    }
    leaveDisjunction() {
    }
  }
  class BranchID {
    constructor(parent, base2) {
      this.parent = parent;
      this.base = base2 !== null && base2 !== void 0 ? base2 : this;
    }
    separatedFrom(other) {
      var _a2, _b;
      if (this.base === other.base && this !== other) {
        return true;
      }
      if (other.parent && this.separatedFrom(other.parent)) {
        return true;
      }
      return (_b = (_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.separatedFrom(other)) !== null && _b !== void 0 ? _b : false;
    }
    child() {
      return new BranchID(this, null);
    }
    sibling() {
      return new BranchID(this.parent, this.base);
    }
  }
  class GroupSpecifiersAsES2025 {
    constructor() {
      this.branchID = new BranchID(null, null);
      this.groupNames = /* @__PURE__ */ new Map();
    }
    clear() {
      this.branchID = new BranchID(null, null);
      this.groupNames.clear();
    }
    isEmpty() {
      return !this.groupNames.size;
    }
    enterDisjunction() {
      this.branchID = this.branchID.child();
    }
    enterAlternative(index) {
      if (index === 0) {
        return;
      }
      this.branchID = this.branchID.sibling();
    }
    leaveDisjunction() {
      this.branchID = this.branchID.parent;
    }
    hasInPattern(name2) {
      return this.groupNames.has(name2);
    }
    hasInScope(name2) {
      const branches = this.groupNames.get(name2);
      if (!branches) {
        return false;
      }
      for (const branch of branches) {
        if (!branch.separatedFrom(this.branchID)) {
          return true;
        }
      }
      return false;
    }
    addToScope(name2) {
      const branches = this.groupNames.get(name2);
      if (branches) {
        branches.push(this.branchID);
        return;
      }
      this.groupNames.set(name2, [this.branchID]);
    }
  }
  const legacyImpl = {
    at(s2, end, i2) {
      return i2 < end ? s2.charCodeAt(i2) : -1;
    },
    width(c2) {
      return 1;
    }
  };
  const unicodeImpl = {
    at(s2, end, i2) {
      return i2 < end ? s2.codePointAt(i2) : -1;
    },
    width(c2) {
      return c2 > 65535 ? 2 : 1;
    }
  };
  class Reader {
    constructor() {
      this._impl = legacyImpl;
      this._s = "";
      this._i = 0;
      this._end = 0;
      this._cp1 = -1;
      this._w1 = 1;
      this._cp2 = -1;
      this._w2 = 1;
      this._cp3 = -1;
      this._w3 = 1;
      this._cp4 = -1;
    }
    get source() {
      return this._s;
    }
    get index() {
      return this._i;
    }
    get currentCodePoint() {
      return this._cp1;
    }
    get nextCodePoint() {
      return this._cp2;
    }
    get nextCodePoint2() {
      return this._cp3;
    }
    get nextCodePoint3() {
      return this._cp4;
    }
    reset(source, start, end, uFlag) {
      this._impl = uFlag ? unicodeImpl : legacyImpl;
      this._s = source;
      this._end = end;
      this.rewind(start);
    }
    rewind(index) {
      const impl = this._impl;
      this._i = index;
      this._cp1 = impl.at(this._s, this._end, index);
      this._w1 = impl.width(this._cp1);
      this._cp2 = impl.at(this._s, this._end, index + this._w1);
      this._w2 = impl.width(this._cp2);
      this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);
      this._w3 = impl.width(this._cp3);
      this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);
    }
    advance() {
      if (this._cp1 !== -1) {
        const impl = this._impl;
        this._i += this._w1;
        this._cp1 = this._cp2;
        this._w1 = this._w2;
        this._cp2 = this._cp3;
        this._w2 = impl.width(this._cp2);
        this._cp3 = this._cp4;
        this._w3 = impl.width(this._cp3);
        this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
      }
    }
    eat(cp) {
      if (this._cp1 === cp) {
        this.advance();
        return true;
      }
      return false;
    }
    eat2(cp1, cp2) {
      if (this._cp1 === cp1 && this._cp2 === cp2) {
        this.advance();
        this.advance();
        return true;
      }
      return false;
    }
    eat3(cp1, cp2, cp3) {
      if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {
        this.advance();
        this.advance();
        this.advance();
        return true;
      }
      return false;
    }
  }
  class RegExpSyntaxError extends SyntaxError {
    constructor(message, index) {
      super(message);
      this.index = index;
    }
  }
  function newRegExpSyntaxError(srcCtx, flags2, index, message) {
    let source = "";
    if (srcCtx.kind === "literal") {
      const literal2 = srcCtx.source.slice(srcCtx.start, srcCtx.end);
      if (literal2) {
        source = `: ${literal2}`;
      }
    } else if (srcCtx.kind === "pattern") {
      const pattern2 = srcCtx.source.slice(srcCtx.start, srcCtx.end);
      const flagsText = `${flags2.unicode ? "u" : ""}${flags2.unicodeSets ? "v" : ""}`;
      source = `: /${pattern2}/${flagsText}`;
    }
    return new RegExpSyntaxError(`Invalid regular expression${source}: ${message}`, index);
  }
  const SYNTAX_CHARACTER = /* @__PURE__ */ new Set([
    CIRCUMFLEX_ACCENT,
    DOLLAR_SIGN,
    REVERSE_SOLIDUS,
    FULL_STOP,
    ASTERISK,
    PLUS_SIGN,
    QUESTION_MARK,
    LEFT_PARENTHESIS,
    RIGHT_PARENTHESIS,
    LEFT_SQUARE_BRACKET,
    RIGHT_SQUARE_BRACKET,
    LEFT_CURLY_BRACKET,
    RIGHT_CURLY_BRACKET,
    VERTICAL_LINE
  ]);
  const CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR_CHARACTER = /* @__PURE__ */ new Set([
    AMPERSAND,
    EXCLAMATION_MARK,
    NUMBER_SIGN,
    DOLLAR_SIGN,
    PERCENT_SIGN,
    ASTERISK,
    PLUS_SIGN,
    COMMA,
    FULL_STOP,
    COLON,
    SEMICOLON,
    LESS_THAN_SIGN,
    EQUALS_SIGN,
    GREATER_THAN_SIGN,
    QUESTION_MARK,
    COMMERCIAL_AT,
    CIRCUMFLEX_ACCENT,
    GRAVE_ACCENT,
    TILDE
  ]);
  const CLASS_SET_SYNTAX_CHARACTER = /* @__PURE__ */ new Set([
    LEFT_PARENTHESIS,
    RIGHT_PARENTHESIS,
    LEFT_SQUARE_BRACKET,
    RIGHT_SQUARE_BRACKET,
    LEFT_CURLY_BRACKET,
    RIGHT_CURLY_BRACKET,
    SOLIDUS,
    HYPHEN_MINUS,
    REVERSE_SOLIDUS,
    VERTICAL_LINE
  ]);
  const CLASS_SET_RESERVED_PUNCTUATOR = /* @__PURE__ */ new Set([
    AMPERSAND,
    HYPHEN_MINUS,
    EXCLAMATION_MARK,
    NUMBER_SIGN,
    PERCENT_SIGN,
    COMMA,
    COLON,
    SEMICOLON,
    LESS_THAN_SIGN,
    EQUALS_SIGN,
    GREATER_THAN_SIGN,
    COMMERCIAL_AT,
    GRAVE_ACCENT,
    TILDE
  ]);
  const FLAG_PROP_TO_CODEPOINT = {
    global: LATIN_SMALL_LETTER_G,
    ignoreCase: LATIN_SMALL_LETTER_I,
    multiline: LATIN_SMALL_LETTER_M,
    unicode: LATIN_SMALL_LETTER_U,
    sticky: LATIN_SMALL_LETTER_Y,
    dotAll: LATIN_SMALL_LETTER_S,
    hasIndices: LATIN_SMALL_LETTER_D,
    unicodeSets: LATIN_SMALL_LETTER_V
  };
  const FLAG_CODEPOINT_TO_PROP = Object.fromEntries(Object.entries(FLAG_PROP_TO_CODEPOINT).map(([k, v2]) => [v2, k]));
  function isSyntaxCharacter(cp) {
    return SYNTAX_CHARACTER.has(cp);
  }
  function isClassSetReservedDoublePunctuatorCharacter(cp) {
    return CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR_CHARACTER.has(cp);
  }
  function isClassSetSyntaxCharacter(cp) {
    return CLASS_SET_SYNTAX_CHARACTER.has(cp);
  }
  function isClassSetReservedPunctuator(cp) {
    return CLASS_SET_RESERVED_PUNCTUATOR.has(cp);
  }
  function isIdentifierStartChar(cp) {
    return isIdStart(cp) || cp === DOLLAR_SIGN || cp === LOW_LINE;
  }
  function isIdentifierPartChar(cp) {
    return isIdContinue(cp) || cp === DOLLAR_SIGN || cp === ZERO_WIDTH_NON_JOINER || cp === ZERO_WIDTH_JOINER;
  }
  function isUnicodePropertyNameCharacter(cp) {
    return isLatinLetter(cp) || cp === LOW_LINE;
  }
  function isUnicodePropertyValueCharacter(cp) {
    return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);
  }
  function isRegularExpressionModifier(ch) {
    return ch === LATIN_SMALL_LETTER_I || ch === LATIN_SMALL_LETTER_M || ch === LATIN_SMALL_LETTER_S;
  }
  class RegExpValidator {
    constructor(options) {
      this._reader = new Reader();
      this._unicodeMode = false;
      this._unicodeSetsMode = false;
      this._nFlag = false;
      this._lastIntValue = 0;
      this._lastRange = {
        min: 0,
        max: Number.POSITIVE_INFINITY
      };
      this._lastStrValue = "";
      this._lastAssertionIsQuantifiable = false;
      this._numCapturingParens = 0;
      this._backreferenceNames = /* @__PURE__ */ new Set();
      this._srcCtx = null;
      this._options = options !== null && options !== void 0 ? options : {};
      this._groupSpecifiers = this.ecmaVersion >= 2025 ? new GroupSpecifiersAsES2025() : new GroupSpecifiersAsES2018();
    }
    validateLiteral(source, start = 0, end = source.length) {
      this._srcCtx = { source, start, end, kind: "literal" };
      this._unicodeSetsMode = this._unicodeMode = this._nFlag = false;
      this.reset(source, start, end);
      this.onLiteralEnter(start);
      if (this.eat(SOLIDUS) && this.eatRegExpBody() && this.eat(SOLIDUS)) {
        const flagStart = this.index;
        const unicode2 = source.includes("u", flagStart);
        const unicodeSets = source.includes("v", flagStart);
        this.validateFlagsInternal(source, flagStart, end);
        this.validatePatternInternal(source, start + 1, flagStart - 1, {
          unicode: unicode2,
          unicodeSets
        });
      } else if (start >= end) {
        this.raise("Empty");
      } else {
        const c2 = String.fromCodePoint(this.currentCodePoint);
        this.raise(`Unexpected character '${c2}'`);
      }
      this.onLiteralLeave(start, end);
    }
    validateFlags(source, start = 0, end = source.length) {
      this._srcCtx = { source, start, end, kind: "flags" };
      this.validateFlagsInternal(source, start, end);
    }
    validatePattern(source, start = 0, end = source.length, uFlagOrFlags = void 0) {
      this._srcCtx = { source, start, end, kind: "pattern" };
      this.validatePatternInternal(source, start, end, uFlagOrFlags);
    }
    validatePatternInternal(source, start = 0, end = source.length, uFlagOrFlags = void 0) {
      const mode = this._parseFlagsOptionToMode(uFlagOrFlags, end);
      this._unicodeMode = mode.unicodeMode;
      this._nFlag = mode.nFlag;
      this._unicodeSetsMode = mode.unicodeSetsMode;
      this.reset(source, start, end);
      this.consumePattern();
      if (!this._nFlag && this.ecmaVersion >= 2018 && !this._groupSpecifiers.isEmpty()) {
        this._nFlag = true;
        this.rewind(start);
        this.consumePattern();
      }
    }
    validateFlagsInternal(source, start, end) {
      const flags2 = this.parseFlags(source, start, end);
      this.onRegExpFlags(start, end, flags2);
    }
    _parseFlagsOptionToMode(uFlagOrFlags, sourceEnd) {
      let unicode2 = false;
      let unicodeSets = false;
      if (uFlagOrFlags && this.ecmaVersion >= 2015) {
        if (typeof uFlagOrFlags === "object") {
          unicode2 = Boolean(uFlagOrFlags.unicode);
          if (this.ecmaVersion >= 2024) {
            unicodeSets = Boolean(uFlagOrFlags.unicodeSets);
          }
        } else {
          unicode2 = uFlagOrFlags;
        }
      }
      if (unicode2 && unicodeSets) {
        this.raise("Invalid regular expression flags", {
          index: sourceEnd + 1,
          unicode: unicode2,
          unicodeSets
        });
      }
      const unicodeMode = unicode2 || unicodeSets;
      const nFlag = unicode2 && this.ecmaVersion >= 2018 || unicodeSets || Boolean(this._options.strict && this.ecmaVersion >= 2023);
      const unicodeSetsMode = unicodeSets;
      return { unicodeMode, nFlag, unicodeSetsMode };
    }
    get strict() {
      return Boolean(this._options.strict) || this._unicodeMode;
    }
    get ecmaVersion() {
      var _a2;
      return (_a2 = this._options.ecmaVersion) !== null && _a2 !== void 0 ? _a2 : latestEcmaVersion;
    }
    onLiteralEnter(start) {
      if (this._options.onLiteralEnter) {
        this._options.onLiteralEnter(start);
      }
    }
    onLiteralLeave(start, end) {
      if (this._options.onLiteralLeave) {
        this._options.onLiteralLeave(start, end);
      }
    }
    onRegExpFlags(start, end, flags2) {
      if (this._options.onRegExpFlags) {
        this._options.onRegExpFlags(start, end, flags2);
      }
      if (this._options.onFlags) {
        this._options.onFlags(start, end, flags2.global, flags2.ignoreCase, flags2.multiline, flags2.unicode, flags2.sticky, flags2.dotAll, flags2.hasIndices);
      }
    }
    onPatternEnter(start) {
      if (this._options.onPatternEnter) {
        this._options.onPatternEnter(start);
      }
    }
    onPatternLeave(start, end) {
      if (this._options.onPatternLeave) {
        this._options.onPatternLeave(start, end);
      }
    }
    onDisjunctionEnter(start) {
      if (this._options.onDisjunctionEnter) {
        this._options.onDisjunctionEnter(start);
      }
    }
    onDisjunctionLeave(start, end) {
      if (this._options.onDisjunctionLeave) {
        this._options.onDisjunctionLeave(start, end);
      }
    }
    onAlternativeEnter(start, index) {
      if (this._options.onAlternativeEnter) {
        this._options.onAlternativeEnter(start, index);
      }
    }
    onAlternativeLeave(start, end, index) {
      if (this._options.onAlternativeLeave) {
        this._options.onAlternativeLeave(start, end, index);
      }
    }
    onGroupEnter(start) {
      if (this._options.onGroupEnter) {
        this._options.onGroupEnter(start);
      }
    }
    onGroupLeave(start, end) {
      if (this._options.onGroupLeave) {
        this._options.onGroupLeave(start, end);
      }
    }
    onModifiersEnter(start) {
      if (this._options.onModifiersEnter) {
        this._options.onModifiersEnter(start);
      }
    }
    onModifiersLeave(start, end) {
      if (this._options.onModifiersLeave) {
        this._options.onModifiersLeave(start, end);
      }
    }
    onAddModifiers(start, end, flags2) {
      if (this._options.onAddModifiers) {
        this._options.onAddModifiers(start, end, flags2);
      }
    }
    onRemoveModifiers(start, end, flags2) {
      if (this._options.onRemoveModifiers) {
        this._options.onRemoveModifiers(start, end, flags2);
      }
    }
    onCapturingGroupEnter(start, name2) {
      if (this._options.onCapturingGroupEnter) {
        this._options.onCapturingGroupEnter(start, name2);
      }
    }
    onCapturingGroupLeave(start, end, name2) {
      if (this._options.onCapturingGroupLeave) {
        this._options.onCapturingGroupLeave(start, end, name2);
      }
    }
    onQuantifier(start, end, min, max, greedy) {
      if (this._options.onQuantifier) {
        this._options.onQuantifier(start, end, min, max, greedy);
      }
    }
    onLookaroundAssertionEnter(start, kind, negate) {
      if (this._options.onLookaroundAssertionEnter) {
        this._options.onLookaroundAssertionEnter(start, kind, negate);
      }
    }
    onLookaroundAssertionLeave(start, end, kind, negate) {
      if (this._options.onLookaroundAssertionLeave) {
        this._options.onLookaroundAssertionLeave(start, end, kind, negate);
      }
    }
    onEdgeAssertion(start, end, kind) {
      if (this._options.onEdgeAssertion) {
        this._options.onEdgeAssertion(start, end, kind);
      }
    }
    onWordBoundaryAssertion(start, end, kind, negate) {
      if (this._options.onWordBoundaryAssertion) {
        this._options.onWordBoundaryAssertion(start, end, kind, negate);
      }
    }
    onAnyCharacterSet(start, end, kind) {
      if (this._options.onAnyCharacterSet) {
        this._options.onAnyCharacterSet(start, end, kind);
      }
    }
    onEscapeCharacterSet(start, end, kind, negate) {
      if (this._options.onEscapeCharacterSet) {
        this._options.onEscapeCharacterSet(start, end, kind, negate);
      }
    }
    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings) {
      if (this._options.onUnicodePropertyCharacterSet) {
        this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings);
      }
    }
    onCharacter(start, end, value) {
      if (this._options.onCharacter) {
        this._options.onCharacter(start, end, value);
      }
    }
    onBackreference(start, end, ref2) {
      if (this._options.onBackreference) {
        this._options.onBackreference(start, end, ref2);
      }
    }
    onCharacterClassEnter(start, negate, unicodeSets) {
      if (this._options.onCharacterClassEnter) {
        this._options.onCharacterClassEnter(start, negate, unicodeSets);
      }
    }
    onCharacterClassLeave(start, end, negate) {
      if (this._options.onCharacterClassLeave) {
        this._options.onCharacterClassLeave(start, end, negate);
      }
    }
    onCharacterClassRange(start, end, min, max) {
      if (this._options.onCharacterClassRange) {
        this._options.onCharacterClassRange(start, end, min, max);
      }
    }
    onClassIntersection(start, end) {
      if (this._options.onClassIntersection) {
        this._options.onClassIntersection(start, end);
      }
    }
    onClassSubtraction(start, end) {
      if (this._options.onClassSubtraction) {
        this._options.onClassSubtraction(start, end);
      }
    }
    onClassStringDisjunctionEnter(start) {
      if (this._options.onClassStringDisjunctionEnter) {
        this._options.onClassStringDisjunctionEnter(start);
      }
    }
    onClassStringDisjunctionLeave(start, end) {
      if (this._options.onClassStringDisjunctionLeave) {
        this._options.onClassStringDisjunctionLeave(start, end);
      }
    }
    onStringAlternativeEnter(start, index) {
      if (this._options.onStringAlternativeEnter) {
        this._options.onStringAlternativeEnter(start, index);
      }
    }
    onStringAlternativeLeave(start, end, index) {
      if (this._options.onStringAlternativeLeave) {
        this._options.onStringAlternativeLeave(start, end, index);
      }
    }
    get index() {
      return this._reader.index;
    }
    get currentCodePoint() {
      return this._reader.currentCodePoint;
    }
    get nextCodePoint() {
      return this._reader.nextCodePoint;
    }
    get nextCodePoint2() {
      return this._reader.nextCodePoint2;
    }
    get nextCodePoint3() {
      return this._reader.nextCodePoint3;
    }
    reset(source, start, end) {
      this._reader.reset(source, start, end, this._unicodeMode);
    }
    rewind(index) {
      this._reader.rewind(index);
    }
    advance() {
      this._reader.advance();
    }
    eat(cp) {
      return this._reader.eat(cp);
    }
    eat2(cp1, cp2) {
      return this._reader.eat2(cp1, cp2);
    }
    eat3(cp1, cp2, cp3) {
      return this._reader.eat3(cp1, cp2, cp3);
    }
    raise(message, context) {
      var _a2, _b, _c;
      throw newRegExpSyntaxError(this._srcCtx, {
        unicode: (_a2 = context === null || context === void 0 ? void 0 : context.unicode) !== null && _a2 !== void 0 ? _a2 : this._unicodeMode && !this._unicodeSetsMode,
        unicodeSets: (_b = context === null || context === void 0 ? void 0 : context.unicodeSets) !== null && _b !== void 0 ? _b : this._unicodeSetsMode
      }, (_c = context === null || context === void 0 ? void 0 : context.index) !== null && _c !== void 0 ? _c : this.index, message);
    }
    eatRegExpBody() {
      const start = this.index;
      let inClass = false;
      let escaped = false;
      for (; ; ) {
        const cp = this.currentCodePoint;
        if (cp === -1 || isLineTerminator(cp)) {
          const kind = inClass ? "character class" : "regular expression";
          this.raise(`Unterminated ${kind}`);
        }
        if (escaped) {
          escaped = false;
        } else if (cp === REVERSE_SOLIDUS) {
          escaped = true;
        } else if (cp === LEFT_SQUARE_BRACKET) {
          inClass = true;
        } else if (cp === RIGHT_SQUARE_BRACKET) {
          inClass = false;
        } else if (cp === SOLIDUS && !inClass || cp === ASTERISK && this.index === start) {
          break;
        }
        this.advance();
      }
      return this.index !== start;
    }
    consumePattern() {
      const start = this.index;
      this._numCapturingParens = this.countCapturingParens();
      this._groupSpecifiers.clear();
      this._backreferenceNames.clear();
      this.onPatternEnter(start);
      this.consumeDisjunction();
      const cp = this.currentCodePoint;
      if (this.currentCodePoint !== -1) {
        if (cp === RIGHT_PARENTHESIS) {
          this.raise("Unmatched ')'");
        }
        if (cp === REVERSE_SOLIDUS) {
          this.raise("\\ at end of pattern");
        }
        if (cp === RIGHT_SQUARE_BRACKET || cp === RIGHT_CURLY_BRACKET) {
          this.raise("Lone quantifier brackets");
        }
        const c2 = String.fromCodePoint(cp);
        this.raise(`Unexpected character '${c2}'`);
      }
      for (const name2 of this._backreferenceNames) {
        if (!this._groupSpecifiers.hasInPattern(name2)) {
          this.raise("Invalid named capture referenced");
        }
      }
      this.onPatternLeave(start, this.index);
    }
    countCapturingParens() {
      const start = this.index;
      let inClass = false;
      let escaped = false;
      let count = 0;
      let cp = 0;
      while ((cp = this.currentCodePoint) !== -1) {
        if (escaped) {
          escaped = false;
        } else if (cp === REVERSE_SOLIDUS) {
          escaped = true;
        } else if (cp === LEFT_SQUARE_BRACKET) {
          inClass = true;
        } else if (cp === RIGHT_SQUARE_BRACKET) {
          inClass = false;
        } else if (cp === LEFT_PARENTHESIS && !inClass && (this.nextCodePoint !== QUESTION_MARK || this.nextCodePoint2 === LESS_THAN_SIGN && this.nextCodePoint3 !== EQUALS_SIGN && this.nextCodePoint3 !== EXCLAMATION_MARK)) {
          count += 1;
        }
        this.advance();
      }
      this.rewind(start);
      return count;
    }
    consumeDisjunction() {
      const start = this.index;
      let i2 = 0;
      this._groupSpecifiers.enterDisjunction();
      this.onDisjunctionEnter(start);
      do {
        this.consumeAlternative(i2++);
      } while (this.eat(VERTICAL_LINE));
      if (this.consumeQuantifier(true)) {
        this.raise("Nothing to repeat");
      }
      if (this.eat(LEFT_CURLY_BRACKET)) {
        this.raise("Lone quantifier brackets");
      }
      this.onDisjunctionLeave(start, this.index);
      this._groupSpecifiers.leaveDisjunction();
    }
    consumeAlternative(i2) {
      const start = this.index;
      this._groupSpecifiers.enterAlternative(i2);
      this.onAlternativeEnter(start, i2);
      while (this.currentCodePoint !== -1 && this.consumeTerm()) {
      }
      this.onAlternativeLeave(start, this.index, i2);
    }
    consumeTerm() {
      if (this._unicodeMode || this.strict) {
        return this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier();
      }
      return this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
    }
    consumeOptionalQuantifier() {
      this.consumeQuantifier();
      return true;
    }
    consumeAssertion() {
      const start = this.index;
      this._lastAssertionIsQuantifiable = false;
      if (this.eat(CIRCUMFLEX_ACCENT)) {
        this.onEdgeAssertion(start, this.index, "start");
        return true;
      }
      if (this.eat(DOLLAR_SIGN)) {
        this.onEdgeAssertion(start, this.index, "end");
        return true;
      }
      if (this.eat2(REVERSE_SOLIDUS, LATIN_CAPITAL_LETTER_B)) {
        this.onWordBoundaryAssertion(start, this.index, "word", true);
        return true;
      }
      if (this.eat2(REVERSE_SOLIDUS, LATIN_SMALL_LETTER_B)) {
        this.onWordBoundaryAssertion(start, this.index, "word", false);
        return true;
      }
      if (this.eat2(LEFT_PARENTHESIS, QUESTION_MARK)) {
        const lookbehind = this.ecmaVersion >= 2018 && this.eat(LESS_THAN_SIGN);
        let negate = false;
        if (this.eat(EQUALS_SIGN) || (negate = this.eat(EXCLAMATION_MARK))) {
          const kind = lookbehind ? "lookbehind" : "lookahead";
          this.onLookaroundAssertionEnter(start, kind, negate);
          this.consumeDisjunction();
          if (!this.eat(RIGHT_PARENTHESIS)) {
            this.raise("Unterminated group");
          }
          this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;
          this.onLookaroundAssertionLeave(start, this.index, kind, negate);
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    consumeQuantifier(noConsume = false) {
      const start = this.index;
      let min = 0;
      let max = 0;
      let greedy = false;
      if (this.eat(ASTERISK)) {
        min = 0;
        max = Number.POSITIVE_INFINITY;
      } else if (this.eat(PLUS_SIGN)) {
        min = 1;
        max = Number.POSITIVE_INFINITY;
      } else if (this.eat(QUESTION_MARK)) {
        min = 0;
        max = 1;
      } else if (this.eatBracedQuantifier(noConsume)) {
        ({ min, max } = this._lastRange);
      } else {
        return false;
      }
      greedy = !this.eat(QUESTION_MARK);
      if (!noConsume) {
        this.onQuantifier(start, this.index, min, max, greedy);
      }
      return true;
    }
    eatBracedQuantifier(noError) {
      const start = this.index;
      if (this.eat(LEFT_CURLY_BRACKET)) {
        if (this.eatDecimalDigits()) {
          const min = this._lastIntValue;
          let max = min;
          if (this.eat(COMMA)) {
            max = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY;
          }
          if (this.eat(RIGHT_CURLY_BRACKET)) {
            if (!noError && max < min) {
              this.raise("numbers out of order in {} quantifier");
            }
            this._lastRange = { min, max };
            return true;
          }
        }
        if (!noError && (this._unicodeMode || this.strict)) {
          this.raise("Incomplete quantifier");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeAtom() {
      return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || Boolean(this.consumeCharacterClass()) || this.consumeCapturingGroup() || this.consumeUncapturingGroup();
    }
    consumeDot() {
      if (this.eat(FULL_STOP)) {
        this.onAnyCharacterSet(this.index - 1, this.index, "any");
        return true;
      }
      return false;
    }
    consumeReverseSolidusAtomEscape() {
      const start = this.index;
      if (this.eat(REVERSE_SOLIDUS)) {
        if (this.consumeAtomEscape()) {
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    consumeUncapturingGroup() {
      const start = this.index;
      if (this.eat2(LEFT_PARENTHESIS, QUESTION_MARK)) {
        this.onGroupEnter(start);
        if (this.ecmaVersion >= 2025) {
          this.consumeModifiers();
        }
        if (!this.eat(COLON)) {
          this.rewind(start + 1);
          this.raise("Invalid group");
        }
        this.consumeDisjunction();
        if (!this.eat(RIGHT_PARENTHESIS)) {
          this.raise("Unterminated group");
        }
        this.onGroupLeave(start, this.index);
        return true;
      }
      return false;
    }
    consumeModifiers() {
      const start = this.index;
      const hasAddModifiers = this.eatModifiers();
      const addModifiersEnd = this.index;
      const hasHyphen = this.eat(HYPHEN_MINUS);
      if (!hasAddModifiers && !hasHyphen) {
        return false;
      }
      this.onModifiersEnter(start);
      const addModifiers = this.parseModifiers(start, addModifiersEnd);
      this.onAddModifiers(start, addModifiersEnd, addModifiers);
      if (hasHyphen) {
        const modifiersStart = this.index;
        if (!this.eatModifiers() && !hasAddModifiers && this.currentCodePoint === COLON) {
          this.raise("Invalid empty flags");
        }
        const modifiers2 = this.parseModifiers(modifiersStart, this.index);
        for (const [flagName] of Object.entries(modifiers2).filter(([, enable]) => enable)) {
          if (addModifiers[flagName]) {
            this.raise(`Duplicated flag '${String.fromCodePoint(FLAG_PROP_TO_CODEPOINT[flagName])}'`);
          }
        }
        this.onRemoveModifiers(modifiersStart, this.index, modifiers2);
      }
      this.onModifiersLeave(start, this.index);
      return true;
    }
    consumeCapturingGroup() {
      const start = this.index;
      if (this.eat(LEFT_PARENTHESIS)) {
        let name2 = null;
        if (this.ecmaVersion >= 2018) {
          if (this.consumeGroupSpecifier()) {
            name2 = this._lastStrValue;
          } else if (this.currentCodePoint === QUESTION_MARK) {
            this.rewind(start);
            return false;
          }
        } else if (this.currentCodePoint === QUESTION_MARK) {
          this.rewind(start);
          return false;
        }
        this.onCapturingGroupEnter(start, name2);
        this.consumeDisjunction();
        if (!this.eat(RIGHT_PARENTHESIS)) {
          this.raise("Unterminated group");
        }
        this.onCapturingGroupLeave(start, this.index, name2);
        return true;
      }
      return false;
    }
    consumeExtendedAtom() {
      return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || Boolean(this.consumeCharacterClass()) || this.consumeCapturingGroup() || this.consumeUncapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
    }
    consumeReverseSolidusFollowedByC() {
      const start = this.index;
      if (this.currentCodePoint === REVERSE_SOLIDUS && this.nextCodePoint === LATIN_SMALL_LETTER_C) {
        this._lastIntValue = this.currentCodePoint;
        this.advance();
        this.onCharacter(start, this.index, REVERSE_SOLIDUS);
        return true;
      }
      return false;
    }
    consumeInvalidBracedQuantifier() {
      if (this.eatBracedQuantifier(true)) {
        this.raise("Nothing to repeat");
      }
      return false;
    }
    consumePatternCharacter() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== -1 && !isSyntaxCharacter(cp)) {
        this.advance();
        this.onCharacter(start, this.index, cp);
        return true;
      }
      return false;
    }
    consumeExtendedPatternCharacter() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== -1 && cp !== CIRCUMFLEX_ACCENT && cp !== DOLLAR_SIGN && cp !== REVERSE_SOLIDUS && cp !== FULL_STOP && cp !== ASTERISK && cp !== PLUS_SIGN && cp !== QUESTION_MARK && cp !== LEFT_PARENTHESIS && cp !== RIGHT_PARENTHESIS && cp !== LEFT_SQUARE_BRACKET && cp !== VERTICAL_LINE) {
        this.advance();
        this.onCharacter(start, this.index, cp);
        return true;
      }
      return false;
    }
    consumeGroupSpecifier() {
      const start = this.index;
      if (this.eat(QUESTION_MARK)) {
        if (this.eatGroupName()) {
          if (!this._groupSpecifiers.hasInScope(this._lastStrValue)) {
            this._groupSpecifiers.addToScope(this._lastStrValue);
            return true;
          }
          this.raise("Duplicate capture group name");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeAtomEscape() {
      if (this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName()) {
        return true;
      }
      if (this.strict || this._unicodeMode) {
        this.raise("Invalid escape");
      }
      return false;
    }
    consumeBackreference() {
      const start = this.index;
      if (this.eatDecimalEscape()) {
        const n2 = this._lastIntValue;
        if (n2 <= this._numCapturingParens) {
          this.onBackreference(start - 1, this.index, n2);
          return true;
        }
        if (this.strict || this._unicodeMode) {
          this.raise("Invalid escape");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeCharacterClassEscape() {
      var _a2;
      const start = this.index;
      if (this.eat(LATIN_SMALL_LETTER_D)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "digit", false);
        return {};
      }
      if (this.eat(LATIN_CAPITAL_LETTER_D)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "digit", true);
        return {};
      }
      if (this.eat(LATIN_SMALL_LETTER_S)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "space", false);
        return {};
      }
      if (this.eat(LATIN_CAPITAL_LETTER_S)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "space", true);
        return {};
      }
      if (this.eat(LATIN_SMALL_LETTER_W)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "word", false);
        return {};
      }
      if (this.eat(LATIN_CAPITAL_LETTER_W)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "word", true);
        return {};
      }
      let negate = false;
      if (this._unicodeMode && this.ecmaVersion >= 2018 && (this.eat(LATIN_SMALL_LETTER_P) || (negate = this.eat(LATIN_CAPITAL_LETTER_P)))) {
        this._lastIntValue = -1;
        let result = null;
        if (this.eat(LEFT_CURLY_BRACKET) && (result = this.eatUnicodePropertyValueExpression()) && this.eat(RIGHT_CURLY_BRACKET)) {
          if (negate && result.strings) {
            this.raise("Invalid property name");
          }
          this.onUnicodePropertyCharacterSet(start - 1, this.index, "property", result.key, result.value, negate, (_a2 = result.strings) !== null && _a2 !== void 0 ? _a2 : false);
          return { mayContainStrings: result.strings };
        }
        this.raise("Invalid property name");
      }
      return null;
    }
    consumeCharacterEscape() {
      const start = this.index;
      if (this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._unicodeMode && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape()) {
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      return false;
    }
    consumeKGroupName() {
      const start = this.index;
      if (this.eat(LATIN_SMALL_LETTER_K)) {
        if (this.eatGroupName()) {
          const groupName = this._lastStrValue;
          this._backreferenceNames.add(groupName);
          this.onBackreference(start - 1, this.index, groupName);
          return true;
        }
        this.raise("Invalid named reference");
      }
      return false;
    }
    consumeCharacterClass() {
      const start = this.index;
      if (this.eat(LEFT_SQUARE_BRACKET)) {
        const negate = this.eat(CIRCUMFLEX_ACCENT);
        this.onCharacterClassEnter(start, negate, this._unicodeSetsMode);
        const result = this.consumeClassContents();
        if (!this.eat(RIGHT_SQUARE_BRACKET)) {
          if (this.currentCodePoint === -1) {
            this.raise("Unterminated character class");
          }
          this.raise("Invalid character in character class");
        }
        if (negate && result.mayContainStrings) {
          this.raise("Negated character class may contain strings");
        }
        this.onCharacterClassLeave(start, this.index, negate);
        return result;
      }
      return null;
    }
    consumeClassContents() {
      if (this._unicodeSetsMode) {
        if (this.currentCodePoint === RIGHT_SQUARE_BRACKET) {
          return {};
        }
        const result = this.consumeClassSetExpression();
        return result;
      }
      const strict2 = this.strict || this._unicodeMode;
      for (; ; ) {
        const rangeStart = this.index;
        if (!this.consumeClassAtom()) {
          break;
        }
        const min = this._lastIntValue;
        if (!this.eat(HYPHEN_MINUS)) {
          continue;
        }
        this.onCharacter(this.index - 1, this.index, HYPHEN_MINUS);
        if (!this.consumeClassAtom()) {
          break;
        }
        const max = this._lastIntValue;
        if (min === -1 || max === -1) {
          if (strict2) {
            this.raise("Invalid character class");
          }
          continue;
        }
        if (min > max) {
          this.raise("Range out of order in character class");
        }
        this.onCharacterClassRange(rangeStart, this.index, min, max);
      }
      return {};
    }
    consumeClassAtom() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== -1 && cp !== REVERSE_SOLIDUS && cp !== RIGHT_SQUARE_BRACKET) {
        this.advance();
        this._lastIntValue = cp;
        this.onCharacter(start, this.index, this._lastIntValue);
        return true;
      }
      if (this.eat(REVERSE_SOLIDUS)) {
        if (this.consumeClassEscape()) {
          return true;
        }
        if (!this.strict && this.currentCodePoint === LATIN_SMALL_LETTER_C) {
          this._lastIntValue = REVERSE_SOLIDUS;
          this.onCharacter(start, this.index, this._lastIntValue);
          return true;
        }
        if (this.strict || this._unicodeMode) {
          this.raise("Invalid escape");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeClassEscape() {
      const start = this.index;
      if (this.eat(LATIN_SMALL_LETTER_B)) {
        this._lastIntValue = BACKSPACE;
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      if (this._unicodeMode && this.eat(HYPHEN_MINUS)) {
        this._lastIntValue = HYPHEN_MINUS;
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      let cp = 0;
      if (!this.strict && !this._unicodeMode && this.currentCodePoint === LATIN_SMALL_LETTER_C && (isDecimalDigit(cp = this.nextCodePoint) || cp === LOW_LINE)) {
        this.advance();
        this.advance();
        this._lastIntValue = cp % 32;
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      return Boolean(this.consumeCharacterClassEscape()) || this.consumeCharacterEscape();
    }
    consumeClassSetExpression() {
      const start = this.index;
      let mayContainStrings = false;
      let result = null;
      if (this.consumeClassSetCharacter()) {
        if (this.consumeClassSetRangeFromOperator(start)) {
          this.consumeClassUnionRight({});
          return {};
        }
        mayContainStrings = false;
      } else if (result = this.consumeClassSetOperand()) {
        mayContainStrings = result.mayContainStrings;
      } else {
        const cp = this.currentCodePoint;
        if (cp === REVERSE_SOLIDUS) {
          this.advance();
          this.raise("Invalid escape");
        }
        if (cp === this.nextCodePoint && isClassSetReservedDoublePunctuatorCharacter(cp)) {
          this.raise("Invalid set operation in character class");
        }
        this.raise("Invalid character in character class");
      }
      if (this.eat2(AMPERSAND, AMPERSAND)) {
        while (this.currentCodePoint !== AMPERSAND && (result = this.consumeClassSetOperand())) {
          this.onClassIntersection(start, this.index);
          if (!result.mayContainStrings) {
            mayContainStrings = false;
          }
          if (this.eat2(AMPERSAND, AMPERSAND)) {
            continue;
          }
          return { mayContainStrings };
        }
        this.raise("Invalid character in character class");
      }
      if (this.eat2(HYPHEN_MINUS, HYPHEN_MINUS)) {
        while (this.consumeClassSetOperand()) {
          this.onClassSubtraction(start, this.index);
          if (this.eat2(HYPHEN_MINUS, HYPHEN_MINUS)) {
            continue;
          }
          return { mayContainStrings };
        }
        this.raise("Invalid character in character class");
      }
      return this.consumeClassUnionRight({ mayContainStrings });
    }
    consumeClassUnionRight(leftResult) {
      let mayContainStrings = leftResult.mayContainStrings;
      for (; ; ) {
        const start = this.index;
        if (this.consumeClassSetCharacter()) {
          this.consumeClassSetRangeFromOperator(start);
          continue;
        }
        const result = this.consumeClassSetOperand();
        if (result) {
          if (result.mayContainStrings) {
            mayContainStrings = true;
          }
          continue;
        }
        break;
      }
      return { mayContainStrings };
    }
    consumeClassSetRangeFromOperator(start) {
      const currentStart = this.index;
      const min = this._lastIntValue;
      if (this.eat(HYPHEN_MINUS)) {
        if (this.consumeClassSetCharacter()) {
          const max = this._lastIntValue;
          if (min === -1 || max === -1) {
            this.raise("Invalid character class");
          }
          if (min > max) {
            this.raise("Range out of order in character class");
          }
          this.onCharacterClassRange(start, this.index, min, max);
          return true;
        }
        this.rewind(currentStart);
      }
      return false;
    }
    consumeClassSetOperand() {
      let result = null;
      if (result = this.consumeNestedClass()) {
        return result;
      }
      if (result = this.consumeClassStringDisjunction()) {
        return result;
      }
      if (this.consumeClassSetCharacter()) {
        return {};
      }
      return null;
    }
    consumeNestedClass() {
      const start = this.index;
      if (this.eat(LEFT_SQUARE_BRACKET)) {
        const negate = this.eat(CIRCUMFLEX_ACCENT);
        this.onCharacterClassEnter(start, negate, true);
        const result = this.consumeClassContents();
        if (!this.eat(RIGHT_SQUARE_BRACKET)) {
          this.raise("Unterminated character class");
        }
        if (negate && result.mayContainStrings) {
          this.raise("Negated character class may contain strings");
        }
        this.onCharacterClassLeave(start, this.index, negate);
        return result;
      }
      if (this.eat(REVERSE_SOLIDUS)) {
        const result = this.consumeCharacterClassEscape();
        if (result) {
          return result;
        }
        this.rewind(start);
      }
      return null;
    }
    consumeClassStringDisjunction() {
      const start = this.index;
      if (this.eat3(REVERSE_SOLIDUS, LATIN_SMALL_LETTER_Q, LEFT_CURLY_BRACKET)) {
        this.onClassStringDisjunctionEnter(start);
        let i2 = 0;
        let mayContainStrings = false;
        do {
          if (this.consumeClassString(i2++).mayContainStrings) {
            mayContainStrings = true;
          }
        } while (this.eat(VERTICAL_LINE));
        if (this.eat(RIGHT_CURLY_BRACKET)) {
          this.onClassStringDisjunctionLeave(start, this.index);
          return { mayContainStrings };
        }
        this.raise("Unterminated class string disjunction");
      }
      return null;
    }
    consumeClassString(i2) {
      const start = this.index;
      let count = 0;
      this.onStringAlternativeEnter(start, i2);
      while (this.currentCodePoint !== -1 && this.consumeClassSetCharacter()) {
        count++;
      }
      this.onStringAlternativeLeave(start, this.index, i2);
      return { mayContainStrings: count !== 1 };
    }
    consumeClassSetCharacter() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== this.nextCodePoint || !isClassSetReservedDoublePunctuatorCharacter(cp)) {
        if (cp !== -1 && !isClassSetSyntaxCharacter(cp)) {
          this._lastIntValue = cp;
          this.advance();
          this.onCharacter(start, this.index, this._lastIntValue);
          return true;
        }
      }
      if (this.eat(REVERSE_SOLIDUS)) {
        if (this.consumeCharacterEscape()) {
          return true;
        }
        if (isClassSetReservedPunctuator(this.currentCodePoint)) {
          this._lastIntValue = this.currentCodePoint;
          this.advance();
          this.onCharacter(start, this.index, this._lastIntValue);
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_B)) {
          this._lastIntValue = BACKSPACE;
          this.onCharacter(start, this.index, this._lastIntValue);
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    eatGroupName() {
      if (this.eat(LESS_THAN_SIGN)) {
        if (this.eatRegExpIdentifierName() && this.eat(GREATER_THAN_SIGN)) {
          return true;
        }
        this.raise("Invalid capture group name");
      }
      return false;
    }
    eatRegExpIdentifierName() {
      if (this.eatRegExpIdentifierStart()) {
        this._lastStrValue = String.fromCodePoint(this._lastIntValue);
        while (this.eatRegExpIdentifierPart()) {
          this._lastStrValue += String.fromCodePoint(this._lastIntValue);
        }
        return true;
      }
      return false;
    }
    eatRegExpIdentifierStart() {
      const start = this.index;
      const forceUFlag = !this._unicodeMode && this.ecmaVersion >= 2020;
      let cp = this.currentCodePoint;
      this.advance();
      if (cp === REVERSE_SOLIDUS && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
        cp = this._lastIntValue;
      } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
        cp = combineSurrogatePair(cp, this.currentCodePoint);
        this.advance();
      }
      if (isIdentifierStartChar(cp)) {
        this._lastIntValue = cp;
        return true;
      }
      if (this.index !== start) {
        this.rewind(start);
      }
      return false;
    }
    eatRegExpIdentifierPart() {
      const start = this.index;
      const forceUFlag = !this._unicodeMode && this.ecmaVersion >= 2020;
      let cp = this.currentCodePoint;
      this.advance();
      if (cp === REVERSE_SOLIDUS && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
        cp = this._lastIntValue;
      } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
        cp = combineSurrogatePair(cp, this.currentCodePoint);
        this.advance();
      }
      if (isIdentifierPartChar(cp)) {
        this._lastIntValue = cp;
        return true;
      }
      if (this.index !== start) {
        this.rewind(start);
      }
      return false;
    }
    eatCControlLetter() {
      const start = this.index;
      if (this.eat(LATIN_SMALL_LETTER_C)) {
        if (this.eatControlLetter()) {
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    eatZero() {
      if (this.currentCodePoint === DIGIT_ZERO && !isDecimalDigit(this.nextCodePoint)) {
        this._lastIntValue = 0;
        this.advance();
        return true;
      }
      return false;
    }
    eatControlEscape() {
      if (this.eat(LATIN_SMALL_LETTER_F)) {
        this._lastIntValue = FORM_FEED;
        return true;
      }
      if (this.eat(LATIN_SMALL_LETTER_N)) {
        this._lastIntValue = LINE_FEED;
        return true;
      }
      if (this.eat(LATIN_SMALL_LETTER_R)) {
        this._lastIntValue = CARRIAGE_RETURN;
        return true;
      }
      if (this.eat(LATIN_SMALL_LETTER_T)) {
        this._lastIntValue = CHARACTER_TABULATION;
        return true;
      }
      if (this.eat(LATIN_SMALL_LETTER_V)) {
        this._lastIntValue = LINE_TABULATION;
        return true;
      }
      return false;
    }
    eatControlLetter() {
      const cp = this.currentCodePoint;
      if (isLatinLetter(cp)) {
        this.advance();
        this._lastIntValue = cp % 32;
        return true;
      }
      return false;
    }
    eatRegExpUnicodeEscapeSequence(forceUFlag = false) {
      const start = this.index;
      const uFlag = forceUFlag || this._unicodeMode;
      if (this.eat(LATIN_SMALL_LETTER_U)) {
        if (uFlag && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || uFlag && this.eatRegExpUnicodeCodePointEscape()) {
          return true;
        }
        if (this.strict || uFlag) {
          this.raise("Invalid unicode escape");
        }
        this.rewind(start);
      }
      return false;
    }
    eatRegExpUnicodeSurrogatePairEscape() {
      const start = this.index;
      if (this.eatFixedHexDigits(4)) {
        const lead = this._lastIntValue;
        if (isLeadSurrogate(lead) && this.eat(REVERSE_SOLIDUS) && this.eat(LATIN_SMALL_LETTER_U) && this.eatFixedHexDigits(4)) {
          const trail = this._lastIntValue;
          if (isTrailSurrogate(trail)) {
            this._lastIntValue = combineSurrogatePair(lead, trail);
            return true;
          }
        }
        this.rewind(start);
      }
      return false;
    }
    eatRegExpUnicodeCodePointEscape() {
      const start = this.index;
      if (this.eat(LEFT_CURLY_BRACKET) && this.eatHexDigits() && this.eat(RIGHT_CURLY_BRACKET) && isValidUnicode(this._lastIntValue)) {
        return true;
      }
      this.rewind(start);
      return false;
    }
    eatIdentityEscape() {
      const cp = this.currentCodePoint;
      if (this.isValidIdentityEscape(cp)) {
        this._lastIntValue = cp;
        this.advance();
        return true;
      }
      return false;
    }
    isValidIdentityEscape(cp) {
      if (cp === -1) {
        return false;
      }
      if (this._unicodeMode) {
        return isSyntaxCharacter(cp) || cp === SOLIDUS;
      }
      if (this.strict) {
        return !isIdContinue(cp);
      }
      if (this._nFlag) {
        return !(cp === LATIN_SMALL_LETTER_C || cp === LATIN_SMALL_LETTER_K);
      }
      return cp !== LATIN_SMALL_LETTER_C;
    }
    eatDecimalEscape() {
      this._lastIntValue = 0;
      let cp = this.currentCodePoint;
      if (cp >= DIGIT_ONE && cp <= DIGIT_NINE) {
        do {
          this._lastIntValue = 10 * this._lastIntValue + (cp - DIGIT_ZERO);
          this.advance();
        } while ((cp = this.currentCodePoint) >= DIGIT_ZERO && cp <= DIGIT_NINE);
        return true;
      }
      return false;
    }
    eatUnicodePropertyValueExpression() {
      const start = this.index;
      if (this.eatUnicodePropertyName() && this.eat(EQUALS_SIGN)) {
        const key = this._lastStrValue;
        if (this.eatUnicodePropertyValue()) {
          const value = this._lastStrValue;
          if (isValidUnicodeProperty(this.ecmaVersion, key, value)) {
            return {
              key,
              value: value || null
            };
          }
          this.raise("Invalid property name");
        }
      }
      this.rewind(start);
      if (this.eatLoneUnicodePropertyNameOrValue()) {
        const nameOrValue = this._lastStrValue;
        if (isValidUnicodeProperty(this.ecmaVersion, "General_Category", nameOrValue)) {
          return {
            key: "General_Category",
            value: nameOrValue || null
          };
        }
        if (isValidLoneUnicodeProperty(this.ecmaVersion, nameOrValue)) {
          return {
            key: nameOrValue,
            value: null
          };
        }
        if (this._unicodeSetsMode && isValidLoneUnicodePropertyOfString(this.ecmaVersion, nameOrValue)) {
          return {
            key: nameOrValue,
            value: null,
            strings: true
          };
        }
        this.raise("Invalid property name");
      }
      return null;
    }
    eatUnicodePropertyName() {
      this._lastStrValue = "";
      while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
        this.advance();
      }
      return this._lastStrValue !== "";
    }
    eatUnicodePropertyValue() {
      this._lastStrValue = "";
      while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
        this.advance();
      }
      return this._lastStrValue !== "";
    }
    eatLoneUnicodePropertyNameOrValue() {
      return this.eatUnicodePropertyValue();
    }
    eatHexEscapeSequence() {
      const start = this.index;
      if (this.eat(LATIN_SMALL_LETTER_X)) {
        if (this.eatFixedHexDigits(2)) {
          return true;
        }
        if (this._unicodeMode || this.strict) {
          this.raise("Invalid escape");
        }
        this.rewind(start);
      }
      return false;
    }
    eatDecimalDigits() {
      const start = this.index;
      this._lastIntValue = 0;
      while (isDecimalDigit(this.currentCodePoint)) {
        this._lastIntValue = 10 * this._lastIntValue + digitToInt(this.currentCodePoint);
        this.advance();
      }
      return this.index !== start;
    }
    eatHexDigits() {
      const start = this.index;
      this._lastIntValue = 0;
      while (isHexDigit(this.currentCodePoint)) {
        this._lastIntValue = 16 * this._lastIntValue + digitToInt(this.currentCodePoint);
        this.advance();
      }
      return this.index !== start;
    }
    eatLegacyOctalEscapeSequence() {
      if (this.eatOctalDigit()) {
        const n1 = this._lastIntValue;
        if (this.eatOctalDigit()) {
          const n2 = this._lastIntValue;
          if (n1 <= 3 && this.eatOctalDigit()) {
            this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;
          } else {
            this._lastIntValue = n1 * 8 + n2;
          }
        } else {
          this._lastIntValue = n1;
        }
        return true;
      }
      return false;
    }
    eatOctalDigit() {
      const cp = this.currentCodePoint;
      if (isOctalDigit(cp)) {
        this.advance();
        this._lastIntValue = cp - DIGIT_ZERO;
        return true;
      }
      this._lastIntValue = 0;
      return false;
    }
    eatFixedHexDigits(length) {
      const start = this.index;
      this._lastIntValue = 0;
      for (let i2 = 0; i2 < length; ++i2) {
        const cp = this.currentCodePoint;
        if (!isHexDigit(cp)) {
          this.rewind(start);
          return false;
        }
        this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);
        this.advance();
      }
      return true;
    }
    eatModifiers() {
      let ate = false;
      while (isRegularExpressionModifier(this.currentCodePoint)) {
        this.advance();
        ate = true;
      }
      return ate;
    }
    parseModifiers(start, end) {
      const { ignoreCase, multiline, dotAll } = this.parseFlags(this._reader.source, start, end);
      return { ignoreCase, multiline, dotAll };
    }
    parseFlags(source, start, end) {
      const flags2 = {
        global: false,
        ignoreCase: false,
        multiline: false,
        unicode: false,
        sticky: false,
        dotAll: false,
        hasIndices: false,
        unicodeSets: false
      };
      const validFlags = /* @__PURE__ */ new Set();
      validFlags.add(LATIN_SMALL_LETTER_G);
      validFlags.add(LATIN_SMALL_LETTER_I);
      validFlags.add(LATIN_SMALL_LETTER_M);
      if (this.ecmaVersion >= 2015) {
        validFlags.add(LATIN_SMALL_LETTER_U);
        validFlags.add(LATIN_SMALL_LETTER_Y);
        if (this.ecmaVersion >= 2018) {
          validFlags.add(LATIN_SMALL_LETTER_S);
          if (this.ecmaVersion >= 2022) {
            validFlags.add(LATIN_SMALL_LETTER_D);
            if (this.ecmaVersion >= 2024) {
              validFlags.add(LATIN_SMALL_LETTER_V);
            }
          }
        }
      }
      for (let i2 = start; i2 < end; ++i2) {
        const flag = source.charCodeAt(i2);
        if (validFlags.has(flag)) {
          const prop = FLAG_CODEPOINT_TO_PROP[flag];
          if (flags2[prop]) {
            this.raise(`Duplicated flag '${source[i2]}'`, {
              index: start
            });
          }
          flags2[prop] = true;
        } else {
          this.raise(`Invalid flag '${source[i2]}'`, { index: start });
        }
      }
      return flags2;
    }
  }
  const DUMMY_PATTERN = {};
  const DUMMY_FLAGS = {};
  const DUMMY_CAPTURING_GROUP = {};
  function isClassSetOperand(node2) {
    return node2.type === "Character" || node2.type === "CharacterSet" || node2.type === "CharacterClass" || node2.type === "ExpressionCharacterClass" || node2.type === "ClassStringDisjunction";
  }
  class RegExpParserState {
    constructor(options) {
      var _a2;
      this._node = DUMMY_PATTERN;
      this._expressionBufferMap = /* @__PURE__ */ new Map();
      this._flags = DUMMY_FLAGS;
      this._backreferences = [];
      this._capturingGroups = [];
      this.source = "";
      this.strict = Boolean(options === null || options === void 0 ? void 0 : options.strict);
      this.ecmaVersion = (_a2 = options === null || options === void 0 ? void 0 : options.ecmaVersion) !== null && _a2 !== void 0 ? _a2 : latestEcmaVersion;
    }
    get pattern() {
      if (this._node.type !== "Pattern") {
        throw new Error("UnknownError");
      }
      return this._node;
    }
    get flags() {
      if (this._flags.type !== "Flags") {
        throw new Error("UnknownError");
      }
      return this._flags;
    }
    onRegExpFlags(start, end, { global, ignoreCase, multiline, unicode: unicode2, sticky, dotAll, hasIndices, unicodeSets }) {
      this._flags = {
        type: "Flags",
        parent: null,
        start,
        end,
        raw: this.source.slice(start, end),
        global,
        ignoreCase,
        multiline,
        unicode: unicode2,
        sticky,
        dotAll,
        hasIndices,
        unicodeSets
      };
    }
    onPatternEnter(start) {
      this._node = {
        type: "Pattern",
        parent: null,
        start,
        end: start,
        raw: "",
        alternatives: []
      };
      this._backreferences.length = 0;
      this._capturingGroups.length = 0;
    }
    onPatternLeave(start, end) {
      this._node.end = end;
      this._node.raw = this.source.slice(start, end);
      for (const reference of this._backreferences) {
        const ref2 = reference.ref;
        const groups = typeof ref2 === "number" ? [this._capturingGroups[ref2 - 1]] : this._capturingGroups.filter((g2) => g2.name === ref2);
        if (groups.length === 1) {
          const group = groups[0];
          reference.ambiguous = false;
          reference.resolved = group;
        } else {
          reference.ambiguous = true;
          reference.resolved = groups;
        }
        for (const group of groups) {
          group.references.push(reference);
        }
      }
    }
    onAlternativeEnter(start) {
      const parent = this._node;
      if (parent.type !== "Assertion" && parent.type !== "CapturingGroup" && parent.type !== "Group" && parent.type !== "Pattern") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "Alternative",
        parent,
        start,
        end: start,
        raw: "",
        elements: []
      };
      parent.alternatives.push(this._node);
    }
    onAlternativeLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
    onGroupEnter(start) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const group = {
        type: "Group",
        parent,
        start,
        end: start,
        raw: "",
        modifiers: null,
        alternatives: []
      };
      this._node = group;
      parent.elements.push(this._node);
    }
    onGroupLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "Group" || node2.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
    onModifiersEnter(start) {
      const parent = this._node;
      if (parent.type !== "Group") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "Modifiers",
        parent,
        start,
        end: start,
        raw: "",
        add: null,
        remove: null
      };
      parent.modifiers = this._node;
    }
    onModifiersLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "Modifiers" || node2.parent.type !== "Group") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
    onAddModifiers(start, end, { ignoreCase, multiline, dotAll }) {
      const parent = this._node;
      if (parent.type !== "Modifiers") {
        throw new Error("UnknownError");
      }
      parent.add = {
        type: "ModifierFlags",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        ignoreCase,
        multiline,
        dotAll
      };
    }
    onRemoveModifiers(start, end, { ignoreCase, multiline, dotAll }) {
      const parent = this._node;
      if (parent.type !== "Modifiers") {
        throw new Error("UnknownError");
      }
      parent.remove = {
        type: "ModifierFlags",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        ignoreCase,
        multiline,
        dotAll
      };
    }
    onCapturingGroupEnter(start, name2) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "CapturingGroup",
        parent,
        start,
        end: start,
        raw: "",
        name: name2,
        alternatives: [],
        references: []
      };
      parent.elements.push(this._node);
      this._capturingGroups.push(this._node);
    }
    onCapturingGroupLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "CapturingGroup" || node2.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
    onQuantifier(start, end, min, max, greedy) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const element = parent.elements.pop();
      if (element == null || element.type === "Quantifier" || element.type === "Assertion" && element.kind !== "lookahead") {
        throw new Error("UnknownError");
      }
      const node2 = {
        type: "Quantifier",
        parent,
        start: element.start,
        end,
        raw: this.source.slice(element.start, end),
        min,
        max,
        greedy,
        element
      };
      parent.elements.push(node2);
      element.parent = node2;
    }
    onLookaroundAssertionEnter(start, kind, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const node2 = this._node = {
        type: "Assertion",
        parent,
        start,
        end: start,
        raw: "",
        kind,
        negate,
        alternatives: []
      };
      parent.elements.push(node2);
    }
    onLookaroundAssertionLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "Assertion" || node2.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
    onEdgeAssertion(start, end, kind) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "Assertion",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind
      });
    }
    onWordBoundaryAssertion(start, end, kind, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "Assertion",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind,
        negate
      });
    }
    onAnyCharacterSet(start, end, kind) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "CharacterSet",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind
      });
    }
    onEscapeCharacterSet(start, end, kind, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "CharacterSet",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind,
        negate
      });
    }
    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate, strings) {
      const parent = this._node;
      if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      const base2 = {
        type: "CharacterSet",
        parent: null,
        start,
        end,
        raw: this.source.slice(start, end),
        kind,
        strings: null,
        key
      };
      if (strings) {
        if (parent.type === "CharacterClass" && !parent.unicodeSets || negate || value !== null) {
          throw new Error("UnknownError");
        }
        parent.elements.push(Object.assign(Object.assign({}, base2), { parent, strings, value, negate }));
      } else {
        parent.elements.push(Object.assign(Object.assign({}, base2), { parent, strings, value, negate }));
      }
    }
    onCharacter(start, end, value) {
      const parent = this._node;
      if (parent.type !== "Alternative" && parent.type !== "CharacterClass" && parent.type !== "StringAlternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "Character",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        value
      });
    }
    onBackreference(start, end, ref2) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const node2 = {
        type: "Backreference",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        ref: ref2,
        ambiguous: false,
        resolved: DUMMY_CAPTURING_GROUP
      };
      parent.elements.push(node2);
      this._backreferences.push(node2);
    }
    onCharacterClassEnter(start, negate, unicodeSets) {
      const parent = this._node;
      const base2 = {
        type: "CharacterClass",
        parent,
        start,
        end: start,
        raw: "",
        unicodeSets,
        negate,
        elements: []
      };
      if (parent.type === "Alternative") {
        const node2 = Object.assign(Object.assign({}, base2), { parent });
        this._node = node2;
        parent.elements.push(node2);
      } else if (parent.type === "CharacterClass" && parent.unicodeSets && unicodeSets) {
        const node2 = Object.assign(Object.assign({}, base2), {
          parent,
          unicodeSets
        });
        this._node = node2;
        parent.elements.push(node2);
      } else {
        throw new Error("UnknownError");
      }
    }
    onCharacterClassLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "CharacterClass" || node2.parent.type !== "Alternative" && node2.parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      const parent = node2.parent;
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = parent;
      const expression = this._expressionBufferMap.get(node2);
      if (!expression) {
        return;
      }
      if (node2.elements.length > 0) {
        throw new Error("UnknownError");
      }
      this._expressionBufferMap.delete(node2);
      const newNode = {
        type: "ExpressionCharacterClass",
        parent,
        start: node2.start,
        end: node2.end,
        raw: node2.raw,
        negate: node2.negate,
        expression
      };
      expression.parent = newNode;
      if (node2 !== parent.elements.pop()) {
        throw new Error("UnknownError");
      }
      parent.elements.push(newNode);
    }
    onCharacterClassRange(start, end) {
      const parent = this._node;
      if (parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      const elements = parent.elements;
      const max = elements.pop();
      if (!max || max.type !== "Character") {
        throw new Error("UnknownError");
      }
      if (!parent.unicodeSets) {
        const hyphen = elements.pop();
        if (!hyphen || hyphen.type !== "Character" || hyphen.value !== HYPHEN_MINUS) {
          throw new Error("UnknownError");
        }
      }
      const min = elements.pop();
      if (!min || min.type !== "Character") {
        throw new Error("UnknownError");
      }
      const node2 = {
        type: "CharacterClassRange",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        min,
        max
      };
      min.parent = node2;
      max.parent = node2;
      elements.push(node2);
    }
    onClassIntersection(start, end) {
      var _a2;
      const parent = this._node;
      if (parent.type !== "CharacterClass" || !parent.unicodeSets) {
        throw new Error("UnknownError");
      }
      const right = parent.elements.pop();
      const left = (_a2 = this._expressionBufferMap.get(parent)) !== null && _a2 !== void 0 ? _a2 : parent.elements.pop();
      if (!left || !right || left.type === "ClassSubtraction" || left.type !== "ClassIntersection" && !isClassSetOperand(left) || !isClassSetOperand(right)) {
        throw new Error("UnknownError");
      }
      const node2 = {
        type: "ClassIntersection",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        left,
        right
      };
      left.parent = node2;
      right.parent = node2;
      this._expressionBufferMap.set(parent, node2);
    }
    onClassSubtraction(start, end) {
      var _a2;
      const parent = this._node;
      if (parent.type !== "CharacterClass" || !parent.unicodeSets) {
        throw new Error("UnknownError");
      }
      const right = parent.elements.pop();
      const left = (_a2 = this._expressionBufferMap.get(parent)) !== null && _a2 !== void 0 ? _a2 : parent.elements.pop();
      if (!left || !right || left.type === "ClassIntersection" || left.type !== "ClassSubtraction" && !isClassSetOperand(left) || !isClassSetOperand(right)) {
        throw new Error("UnknownError");
      }
      const node2 = {
        type: "ClassSubtraction",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        left,
        right
      };
      left.parent = node2;
      right.parent = node2;
      this._expressionBufferMap.set(parent, node2);
    }
    onClassStringDisjunctionEnter(start) {
      const parent = this._node;
      if (parent.type !== "CharacterClass" || !parent.unicodeSets) {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "ClassStringDisjunction",
        parent,
        start,
        end: start,
        raw: "",
        alternatives: []
      };
      parent.elements.push(this._node);
    }
    onClassStringDisjunctionLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "ClassStringDisjunction" || node2.parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
    onStringAlternativeEnter(start) {
      const parent = this._node;
      if (parent.type !== "ClassStringDisjunction") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "StringAlternative",
        parent,
        start,
        end: start,
        raw: "",
        elements: []
      };
      parent.alternatives.push(this._node);
    }
    onStringAlternativeLeave(start, end) {
      const node2 = this._node;
      if (node2.type !== "StringAlternative") {
        throw new Error("UnknownError");
      }
      node2.end = end;
      node2.raw = this.source.slice(start, end);
      this._node = node2.parent;
    }
  }
  class RegExpParser {
    constructor(options) {
      this._state = new RegExpParserState(options);
      this._validator = new RegExpValidator(this._state);
    }
    parseLiteral(source, start = 0, end = source.length) {
      this._state.source = source;
      this._validator.validateLiteral(source, start, end);
      const pattern2 = this._state.pattern;
      const flags2 = this._state.flags;
      const literal2 = {
        type: "RegExpLiteral",
        parent: null,
        start,
        end,
        raw: source,
        pattern: pattern2,
        flags: flags2
      };
      pattern2.parent = literal2;
      flags2.parent = literal2;
      return literal2;
    }
    parseFlags(source, start = 0, end = source.length) {
      this._state.source = source;
      this._validator.validateFlags(source, start, end);
      return this._state.flags;
    }
    parsePattern(source, start = 0, end = source.length, uFlagOrFlags = void 0) {
      this._state.source = source;
      this._validator.validatePattern(source, start, end, uFlagOrFlags);
      return this._state.pattern;
    }
  }
  class RegExpVisitor {
    constructor(handlers2) {
      this._handlers = handlers2;
    }
    visit(node2) {
      switch (node2.type) {
        case "Alternative":
          this.visitAlternative(node2);
          break;
        case "Assertion":
          this.visitAssertion(node2);
          break;
        case "Backreference":
          this.visitBackreference(node2);
          break;
        case "CapturingGroup":
          this.visitCapturingGroup(node2);
          break;
        case "Character":
          this.visitCharacter(node2);
          break;
        case "CharacterClass":
          this.visitCharacterClass(node2);
          break;
        case "CharacterClassRange":
          this.visitCharacterClassRange(node2);
          break;
        case "CharacterSet":
          this.visitCharacterSet(node2);
          break;
        case "ClassIntersection":
          this.visitClassIntersection(node2);
          break;
        case "ClassStringDisjunction":
          this.visitClassStringDisjunction(node2);
          break;
        case "ClassSubtraction":
          this.visitClassSubtraction(node2);
          break;
        case "ExpressionCharacterClass":
          this.visitExpressionCharacterClass(node2);
          break;
        case "Flags":
          this.visitFlags(node2);
          break;
        case "Group":
          this.visitGroup(node2);
          break;
        case "Modifiers":
          this.visitModifiers(node2);
          break;
        case "ModifierFlags":
          this.visitModifierFlags(node2);
          break;
        case "Pattern":
          this.visitPattern(node2);
          break;
        case "Quantifier":
          this.visitQuantifier(node2);
          break;
        case "RegExpLiteral":
          this.visitRegExpLiteral(node2);
          break;
        case "StringAlternative":
          this.visitStringAlternative(node2);
          break;
        default:
          throw new Error(`Unknown type: ${node2.type}`);
      }
    }
    visitAlternative(node2) {
      if (this._handlers.onAlternativeEnter) {
        this._handlers.onAlternativeEnter(node2);
      }
      node2.elements.forEach(this.visit, this);
      if (this._handlers.onAlternativeLeave) {
        this._handlers.onAlternativeLeave(node2);
      }
    }
    visitAssertion(node2) {
      if (this._handlers.onAssertionEnter) {
        this._handlers.onAssertionEnter(node2);
      }
      if (node2.kind === "lookahead" || node2.kind === "lookbehind") {
        node2.alternatives.forEach(this.visit, this);
      }
      if (this._handlers.onAssertionLeave) {
        this._handlers.onAssertionLeave(node2);
      }
    }
    visitBackreference(node2) {
      if (this._handlers.onBackreferenceEnter) {
        this._handlers.onBackreferenceEnter(node2);
      }
      if (this._handlers.onBackreferenceLeave) {
        this._handlers.onBackreferenceLeave(node2);
      }
    }
    visitCapturingGroup(node2) {
      if (this._handlers.onCapturingGroupEnter) {
        this._handlers.onCapturingGroupEnter(node2);
      }
      node2.alternatives.forEach(this.visit, this);
      if (this._handlers.onCapturingGroupLeave) {
        this._handlers.onCapturingGroupLeave(node2);
      }
    }
    visitCharacter(node2) {
      if (this._handlers.onCharacterEnter) {
        this._handlers.onCharacterEnter(node2);
      }
      if (this._handlers.onCharacterLeave) {
        this._handlers.onCharacterLeave(node2);
      }
    }
    visitCharacterClass(node2) {
      if (this._handlers.onCharacterClassEnter) {
        this._handlers.onCharacterClassEnter(node2);
      }
      node2.elements.forEach(this.visit, this);
      if (this._handlers.onCharacterClassLeave) {
        this._handlers.onCharacterClassLeave(node2);
      }
    }
    visitCharacterClassRange(node2) {
      if (this._handlers.onCharacterClassRangeEnter) {
        this._handlers.onCharacterClassRangeEnter(node2);
      }
      this.visitCharacter(node2.min);
      this.visitCharacter(node2.max);
      if (this._handlers.onCharacterClassRangeLeave) {
        this._handlers.onCharacterClassRangeLeave(node2);
      }
    }
    visitCharacterSet(node2) {
      if (this._handlers.onCharacterSetEnter) {
        this._handlers.onCharacterSetEnter(node2);
      }
      if (this._handlers.onCharacterSetLeave) {
        this._handlers.onCharacterSetLeave(node2);
      }
    }
    visitClassIntersection(node2) {
      if (this._handlers.onClassIntersectionEnter) {
        this._handlers.onClassIntersectionEnter(node2);
      }
      this.visit(node2.left);
      this.visit(node2.right);
      if (this._handlers.onClassIntersectionLeave) {
        this._handlers.onClassIntersectionLeave(node2);
      }
    }
    visitClassStringDisjunction(node2) {
      if (this._handlers.onClassStringDisjunctionEnter) {
        this._handlers.onClassStringDisjunctionEnter(node2);
      }
      node2.alternatives.forEach(this.visit, this);
      if (this._handlers.onClassStringDisjunctionLeave) {
        this._handlers.onClassStringDisjunctionLeave(node2);
      }
    }
    visitClassSubtraction(node2) {
      if (this._handlers.onClassSubtractionEnter) {
        this._handlers.onClassSubtractionEnter(node2);
      }
      this.visit(node2.left);
      this.visit(node2.right);
      if (this._handlers.onClassSubtractionLeave) {
        this._handlers.onClassSubtractionLeave(node2);
      }
    }
    visitExpressionCharacterClass(node2) {
      if (this._handlers.onExpressionCharacterClassEnter) {
        this._handlers.onExpressionCharacterClassEnter(node2);
      }
      this.visit(node2.expression);
      if (this._handlers.onExpressionCharacterClassLeave) {
        this._handlers.onExpressionCharacterClassLeave(node2);
      }
    }
    visitFlags(node2) {
      if (this._handlers.onFlagsEnter) {
        this._handlers.onFlagsEnter(node2);
      }
      if (this._handlers.onFlagsLeave) {
        this._handlers.onFlagsLeave(node2);
      }
    }
    visitGroup(node2) {
      if (this._handlers.onGroupEnter) {
        this._handlers.onGroupEnter(node2);
      }
      if (node2.modifiers) {
        this.visit(node2.modifiers);
      }
      node2.alternatives.forEach(this.visit, this);
      if (this._handlers.onGroupLeave) {
        this._handlers.onGroupLeave(node2);
      }
    }
    visitModifiers(node2) {
      if (this._handlers.onModifiersEnter) {
        this._handlers.onModifiersEnter(node2);
      }
      if (node2.add) {
        this.visit(node2.add);
      }
      if (node2.remove) {
        this.visit(node2.remove);
      }
      if (this._handlers.onModifiersLeave) {
        this._handlers.onModifiersLeave(node2);
      }
    }
    visitModifierFlags(node2) {
      if (this._handlers.onModifierFlagsEnter) {
        this._handlers.onModifierFlagsEnter(node2);
      }
      if (this._handlers.onModifierFlagsLeave) {
        this._handlers.onModifierFlagsLeave(node2);
      }
    }
    visitPattern(node2) {
      if (this._handlers.onPatternEnter) {
        this._handlers.onPatternEnter(node2);
      }
      node2.alternatives.forEach(this.visit, this);
      if (this._handlers.onPatternLeave) {
        this._handlers.onPatternLeave(node2);
      }
    }
    visitQuantifier(node2) {
      if (this._handlers.onQuantifierEnter) {
        this._handlers.onQuantifierEnter(node2);
      }
      this.visit(node2.element);
      if (this._handlers.onQuantifierLeave) {
        this._handlers.onQuantifierLeave(node2);
      }
    }
    visitRegExpLiteral(node2) {
      if (this._handlers.onRegExpLiteralEnter) {
        this._handlers.onRegExpLiteralEnter(node2);
      }
      this.visitPattern(node2.pattern);
      this.visitFlags(node2.flags);
      if (this._handlers.onRegExpLiteralLeave) {
        this._handlers.onRegExpLiteralLeave(node2);
      }
    }
    visitStringAlternative(node2) {
      if (this._handlers.onStringAlternativeEnter) {
        this._handlers.onStringAlternativeEnter(node2);
      }
      node2.elements.forEach(this.visit, this);
      if (this._handlers.onStringAlternativeLeave) {
        this._handlers.onStringAlternativeLeave(node2);
      }
    }
  }
  function parseRegExpLiteral(source, options) {
    return new RegExpParser(options).parseLiteral(String(source));
  }
  function validateRegExpLiteral(source, options) {
    new RegExpValidator(options).validateLiteral(source);
  }
  function visitRegExpAST(node2, handlers2) {
    new RegExpVisitor(handlers2).visit(node2);
  }
  regexpp.AST = ast2;
  regexpp.RegExpParser = RegExpParser;
  regexpp.RegExpSyntaxError = RegExpSyntaxError;
  regexpp.RegExpValidator = RegExpValidator;
  regexpp.parseRegExpLiteral = parseRegExpLiteral;
  regexpp.validateRegExpLiteral = validateRegExpLiteral;
  regexpp.visitRegExpAST = visitRegExpAST;
  return regexpp;
}
var noControlRegex;
var hasRequiredNoControlRegex;
function requireNoControlRegex() {
  if (hasRequiredNoControlRegex) return noControlRegex;
  hasRequiredNoControlRegex = 1;
  const RegExpValidator = requireRegexpp().RegExpValidator;
  const collector = new class {
    constructor() {
      this._source = "";
      this._controlChars = [];
      this._validator = new RegExpValidator(this);
    }
    onPatternEnter() {
      this._controlChars = [];
    }
    onCharacter(start, end, cp) {
      if (cp >= 0 && cp <= 31 && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith("\\x") || this._source.slice(start, end).startsWith("\\u"))) {
        this._controlChars.push(`\\x${`0${cp.toString(16)}`.slice(-2)}`);
      }
    }
    collectControlChars(regexpStr, flags2) {
      const uFlag = typeof flags2 === "string" && flags2.includes("u");
      const vFlag = typeof flags2 === "string" && flags2.includes("v");
      this._controlChars = [];
      this._source = regexpStr;
      try {
        this._validator.validatePattern(regexpStr, void 0, void 0, {
          unicode: uFlag,
          unicodeSets: vFlag
        });
      } catch {
      }
      return this._controlChars;
    }
  }();
  noControlRegex = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow control characters in regular expressions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-control-regex"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
      }
    },
    create(context) {
      function getRegExp(node2) {
        if (node2.regex) {
          return node2.regex;
        }
        if (typeof node2.value === "string" && (node2.parent.type === "NewExpression" || node2.parent.type === "CallExpression") && node2.parent.callee.type === "Identifier" && node2.parent.callee.name === "RegExp" && node2.parent.arguments[0] === node2) {
          const pattern2 = node2.value;
          const flags2 = node2.parent.arguments.length > 1 && node2.parent.arguments[1].type === "Literal" && typeof node2.parent.arguments[1].value === "string" ? node2.parent.arguments[1].value : null;
          return { pattern: pattern2, flags: flags2 };
        }
        return null;
      }
      return {
        Literal(node2) {
          const regExp = getRegExp(node2);
          if (regExp) {
            const { pattern: pattern2, flags: flags2 } = regExp;
            const controlCharacters = collector.collectControlChars(
              pattern2,
              flags2
            );
            if (controlCharacters.length > 0) {
              context.report({
                node: node2,
                messageId: "unexpected",
                data: {
                  controlChars: controlCharacters.join(", ")
                }
              });
            }
          }
        }
      };
    }
  };
  return noControlRegex;
}
var noDebugger;
var hasRequiredNoDebugger;
function requireNoDebugger() {
  if (hasRequiredNoDebugger) return noDebugger;
  hasRequiredNoDebugger = 1;
  noDebugger = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow the use of `debugger`",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-debugger"
      },
      fixable: null,
      schema: [],
      messages: {
        unexpected: "Unexpected 'debugger' statement."
      }
    },
    create(context) {
      return {
        DebuggerStatement(node2) {
          context.report({
            node: node2,
            messageId: "unexpected"
          });
        }
      };
    }
  };
  return noDebugger;
}
var noDeleteVar;
var hasRequiredNoDeleteVar;
function requireNoDeleteVar() {
  if (hasRequiredNoDeleteVar) return noDeleteVar;
  hasRequiredNoDeleteVar = 1;
  noDeleteVar = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow deleting variables",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-delete-var"
      },
      schema: [],
      messages: {
        unexpected: "Variables should not be deleted."
      }
    },
    create(context) {
      return {
        UnaryExpression(node2) {
          if (node2.operator === "delete" && node2.argument.type === "Identifier") {
            context.report({ node: node2, messageId: "unexpected" });
          }
        }
      };
    }
  };
  return noDeleteVar;
}
var noDivRegex;
var hasRequiredNoDivRegex;
function requireNoDivRegex() {
  if (hasRequiredNoDivRegex) return noDivRegex;
  hasRequiredNoDivRegex = 1;
  noDivRegex = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow equal signs explicitly at the beginning of regular expressions",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-div-regex"
      },
      fixable: "code",
      schema: [],
      messages: {
        unexpected: "A regular expression literal can be confused with '/='."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        Literal(node2) {
          const token = sourceCode2.getFirstToken(node2);
          if (token.type === "RegularExpression" && token.value[1] === "=") {
            context.report({
              node: node2,
              messageId: "unexpected",
              fix(fixer) {
                return fixer.replaceTextRange(
                  [token.range[0] + 1, token.range[0] + 2],
                  "[=]"
                );
              }
            });
          }
        }
      };
    }
  };
  return noDivRegex;
}
var noDupeArgs;
var hasRequiredNoDupeArgs;
function requireNoDupeArgs() {
  if (hasRequiredNoDupeArgs) return noDupeArgs;
  hasRequiredNoDupeArgs = 1;
  const astUtils2 = requireAstUtils();
  noDupeArgs = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate arguments in `function` definitions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-dupe-args"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate param '{{name}}'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function isParameter(def) {
        return def.type === "Parameter";
      }
      function checkParams(node2) {
        const variables = sourceCode2.getDeclaredVariables(node2);
        for (let i2 = 0; i2 < variables.length; ++i2) {
          const variable = variables[i2];
          const defs = variable.defs.filter(isParameter);
          const loc = {
            start: astUtils2.getOpeningParenOfParams(node2, sourceCode2).loc.start,
            end: sourceCode2.getTokenBefore(node2.body).loc.end
          };
          if (defs.length >= 2) {
            context.report({
              loc,
              messageId: "unexpected",
              data: { name: variable.name }
            });
          }
        }
      }
      return {
        FunctionDeclaration: checkParams,
        FunctionExpression: checkParams
      };
    }
  };
  return noDupeArgs;
}
var noDupeClassMembers;
var hasRequiredNoDupeClassMembers;
function requireNoDupeClassMembers() {
  if (hasRequiredNoDupeClassMembers) return noDupeClassMembers;
  hasRequiredNoDupeClassMembers = 1;
  const astUtils2 = requireAstUtils();
  noDupeClassMembers = {
    meta: {
      type: "problem",
      dialects: ["javascript", "typescript"],
      language: "javascript",
      docs: {
        description: "Disallow duplicate class members",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-dupe-class-members"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate name '{{name}}'."
      }
    },
    create(context) {
      let stack = [];
      function getState(name2, isStatic) {
        const stateMap = stack.at(-1);
        const key = `$${name2}`;
        if (!stateMap[key]) {
          stateMap[key] = {
            nonStatic: { init: false, get: false, set: false },
            static: { init: false, get: false, set: false }
          };
        }
        return stateMap[key][isStatic ? "static" : "nonStatic"];
      }
      return {
        // Initializes the stack of state of member declarations.
        Program() {
          stack = [];
        },
        // Initializes state of member declarations for the class.
        ClassBody() {
          stack.push(/* @__PURE__ */ Object.create(null));
        },
        // Disposes the state for the class.
        "ClassBody:exit"() {
          stack.pop();
        },
        // Reports the node if its name has been declared already.
        "MethodDefinition, PropertyDefinition"(node2) {
          if (node2.value && node2.value.type === "TSEmptyBodyFunctionExpression") {
            return;
          }
          const name2 = astUtils2.getStaticPropertyName(node2);
          const kind = node2.type === "MethodDefinition" ? node2.kind : "field";
          if (name2 === null || kind === "constructor") {
            return;
          }
          const state = getState(name2, node2.static);
          let isDuplicate;
          if (kind === "get") {
            isDuplicate = state.init || state.get;
            state.get = true;
          } else if (kind === "set") {
            isDuplicate = state.init || state.set;
            state.set = true;
          } else {
            isDuplicate = state.init || state.get || state.set;
            state.init = true;
          }
          if (isDuplicate) {
            context.report({
              loc: node2.key.loc,
              messageId: "unexpected",
              data: { name: name2 }
            });
          }
        }
      };
    }
  };
  return noDupeClassMembers;
}
var noDupeElseIf;
var hasRequiredNoDupeElseIf;
function requireNoDupeElseIf() {
  if (hasRequiredNoDupeElseIf) return noDupeElseIf;
  hasRequiredNoDupeElseIf = 1;
  const astUtils2 = requireAstUtils();
  function isSubsetByComparator(comparator, arrA, arrB) {
    return arrA.every((a2) => arrB.some((b) => comparator(a2, b)));
  }
  function splitByLogicalOperator(operator2, node2) {
    if (node2.type === "LogicalExpression" && node2.operator === operator2) {
      return [
        ...splitByLogicalOperator(operator2, node2.left),
        ...splitByLogicalOperator(operator2, node2.right)
      ];
    }
    return [node2];
  }
  const splitByOr = splitByLogicalOperator.bind(null, "||");
  const splitByAnd = splitByLogicalOperator.bind(null, "&&");
  noDupeElseIf = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate conditions in if-else-if chains",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-dupe-else-if"
      },
      schema: [],
      messages: {
        unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function equal(a2, b) {
        if (a2.type !== b.type) {
          return false;
        }
        if (a2.type === "LogicalExpression" && (a2.operator === "||" || a2.operator === "&&") && a2.operator === b.operator) {
          return equal(a2.left, b.left) && equal(a2.right, b.right) || equal(a2.left, b.right) && equal(a2.right, b.left);
        }
        return astUtils2.equalTokens(a2, b, sourceCode2);
      }
      const isSubset = isSubsetByComparator.bind(null, equal);
      return {
        IfStatement(node2) {
          const test = node2.test, conditionsToCheck = test.type === "LogicalExpression" && test.operator === "&&" ? [test, ...splitByAnd(test)] : [test];
          let current = node2, listToCheck = conditionsToCheck.map(
            (c2) => splitByOr(c2).map(splitByAnd)
          );
          while (current.parent && current.parent.type === "IfStatement" && current.parent.alternate === current) {
            current = current.parent;
            const currentOrOperands = splitByOr(current.test).map(
              splitByAnd
            );
            listToCheck = listToCheck.map(
              (orOperands) => orOperands.filter(
                (orOperand) => !currentOrOperands.some(
                  (currentOrOperand) => isSubset(currentOrOperand, orOperand)
                )
              )
            );
            if (listToCheck.some((orOperands) => orOperands.length === 0)) {
              context.report({ node: test, messageId: "unexpected" });
              break;
            }
          }
        }
      };
    }
  };
  return noDupeElseIf;
}
var noDupeKeys;
var hasRequiredNoDupeKeys;
function requireNoDupeKeys() {
  if (hasRequiredNoDupeKeys) return noDupeKeys;
  hasRequiredNoDupeKeys = 1;
  const astUtils2 = requireAstUtils();
  const GET_KIND = /^(?:init|get)$/u;
  const SET_KIND = /^(?:init|set)$/u;
  class ObjectInfo {
    /**
     * @param {ObjectInfo|null} upper The information of the outer object.
     * @param {ASTNode} node The ObjectExpression node of this information.
     */
    constructor(upper, node2) {
      this.upper = upper;
      this.node = node2;
      this.properties = /* @__PURE__ */ new Map();
    }
    /**
     * Gets the information of the given Property node.
     * @param {ASTNode} node The Property node to get.
     * @returns {{get: boolean, set: boolean}} The information of the property.
     */
    getPropertyInfo(node2) {
      const name2 = astUtils2.getStaticPropertyName(node2);
      if (!this.properties.has(name2)) {
        this.properties.set(name2, { get: false, set: false });
      }
      return this.properties.get(name2);
    }
    /**
     * Checks whether the given property has been defined already or not.
     * @param {ASTNode} node The Property node to check.
     * @returns {boolean} `true` if the property has been defined.
     */
    isPropertyDefined(node2) {
      const entry = this.getPropertyInfo(node2);
      return GET_KIND.test(node2.kind) && entry.get || SET_KIND.test(node2.kind) && entry.set;
    }
    /**
     * Defines the given property.
     * @param {ASTNode} node The Property node to define.
     * @returns {void}
     */
    defineProperty(node2) {
      const entry = this.getPropertyInfo(node2);
      if (GET_KIND.test(node2.kind)) {
        entry.get = true;
      }
      if (SET_KIND.test(node2.kind)) {
        entry.set = true;
      }
    }
  }
  noDupeKeys = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate keys in object literals",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-dupe-keys"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate key '{{name}}'."
      }
    },
    create(context) {
      let info = null;
      return {
        ObjectExpression(node2) {
          info = new ObjectInfo(info, node2);
        },
        "ObjectExpression:exit"() {
          info = info.upper;
        },
        Property(node2) {
          const name2 = astUtils2.getStaticPropertyName(node2);
          if (node2.parent.type !== "ObjectExpression") {
            return;
          }
          if (name2 === null) {
            return;
          }
          if (name2 === "__proto__" && node2.kind === "init" && !node2.computed && !node2.shorthand && !node2.method) {
            return;
          }
          if (info.isPropertyDefined(node2)) {
            context.report({
              node: info.node,
              loc: node2.key.loc,
              messageId: "unexpected",
              data: { name: name2 }
            });
          }
          info.defineProperty(node2);
        }
      };
    }
  };
  return noDupeKeys;
}
var noDuplicateCase;
var hasRequiredNoDuplicateCase;
function requireNoDuplicateCase() {
  if (hasRequiredNoDuplicateCase) return noDuplicateCase;
  hasRequiredNoDuplicateCase = 1;
  const astUtils2 = requireAstUtils();
  noDuplicateCase = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow duplicate case labels",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-duplicate-case"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate case label."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function equal(a2, b) {
        if (a2.type !== b.type) {
          return false;
        }
        return astUtils2.equalTokens(a2, b, sourceCode2);
      }
      return {
        SwitchStatement(node2) {
          const previousTests = [];
          for (const switchCase of node2.cases) {
            if (switchCase.test) {
              const test = switchCase.test;
              if (previousTests.some(
                (previousTest) => equal(previousTest, test)
              )) {
                context.report({
                  node: switchCase,
                  messageId: "unexpected"
                });
              } else {
                previousTests.push(test);
              }
            }
          }
        }
      };
    }
  };
  return noDuplicateCase;
}
var noDuplicateImports;
var hasRequiredNoDuplicateImports;
function requireNoDuplicateImports() {
  if (hasRequiredNoDuplicateImports) return noDuplicateImports;
  hasRequiredNoDuplicateImports = 1;
  const NAMED_TYPES = ["ImportSpecifier", "ExportSpecifier"];
  const NAMESPACE_TYPES = [
    "ImportNamespaceSpecifier",
    "ExportNamespaceSpecifier"
  ];
  function isImportExportSpecifier(importExportType, type2) {
    const arrayToCheck = type2 === "named" ? NAMED_TYPES : NAMESPACE_TYPES;
    return arrayToCheck.includes(importExportType);
  }
  function getImportExportType(node2) {
    if (node2.specifiers && node2.specifiers.length > 0) {
      const nodeSpecifiers = node2.specifiers;
      const index = nodeSpecifiers.findIndex(
        ({ type: type2 }) => isImportExportSpecifier(type2, "named") || isImportExportSpecifier(type2, "namespace")
      );
      const i2 = index > -1 ? index : 0;
      return nodeSpecifiers[i2].type;
    }
    if (node2.type === "ExportAllDeclaration") {
      if (node2.exported) {
        return "ExportNamespaceSpecifier";
      }
      return "ExportAll";
    }
    return "SideEffectImport";
  }
  function isImportExportCanBeMerged(node1, node2) {
    const importExportType1 = getImportExportType(node1);
    const importExportType2 = getImportExportType(node2);
    if ((node1.importKind === "type" || node1.exportKind === "type") && (node2.importKind === "type" || node2.exportKind === "type")) {
      const isDefault1 = importExportType1 === "ImportDefaultSpecifier";
      const isDefault2 = importExportType2 === "ImportDefaultSpecifier";
      const isNamed1 = isImportExportSpecifier(importExportType1, "named");
      const isNamed2 = isImportExportSpecifier(importExportType2, "named");
      if (isDefault1 && isNamed2 || isDefault2 && isNamed1) {
        return false;
      }
    }
    if (importExportType1 === "ExportAll" && importExportType2 !== "ExportAll" && importExportType2 !== "SideEffectImport" || importExportType1 !== "ExportAll" && importExportType1 !== "SideEffectImport" && importExportType2 === "ExportAll") {
      return false;
    }
    if (isImportExportSpecifier(importExportType1, "namespace") && isImportExportSpecifier(importExportType2, "named") || isImportExportSpecifier(importExportType2, "namespace") && isImportExportSpecifier(importExportType1, "named")) {
      return false;
    }
    return true;
  }
  function shouldReportImportExport(node2, previousNodes, allowSeparateTypeImports) {
    let i2 = 0;
    while (i2 < previousNodes.length) {
      const previousNode = previousNodes[i2];
      if (allowSeparateTypeImports) {
        const isTypeNode = node2.importKind === "type" || node2.exportKind === "type";
        const isTypePrevious = previousNode.importKind === "type" || previousNode.exportKind === "type";
        if (isTypeNode !== isTypePrevious) {
          i2++;
          continue;
        }
      }
      if (isImportExportCanBeMerged(node2, previousNode)) {
        return true;
      }
      i2++;
    }
    return false;
  }
  function getNodesByDeclarationType(nodes, type2) {
    return nodes.filter(({ declarationType }) => declarationType === type2).map(({ node: node2 }) => node2);
  }
  function getModule(node2) {
    if (node2 && node2.source && node2.source.value) {
      return node2.source.value.trim();
    }
    return "";
  }
  function checkAndReport(context, node2, modules, declarationType, includeExports, allowSeparateTypeImports) {
    const module = getModule(node2);
    if (modules.has(module)) {
      const previousNodes = modules.get(module);
      const messagesIds = [];
      const importNodes = getNodesByDeclarationType(previousNodes, "import");
      let exportNodes;
      if (includeExports) {
        exportNodes = getNodesByDeclarationType(previousNodes, "export");
      }
      if (declarationType === "import") {
        if (shouldReportImportExport(
          node2,
          importNodes,
          allowSeparateTypeImports
        )) {
          messagesIds.push("import");
        }
        if (includeExports) {
          if (shouldReportImportExport(
            node2,
            exportNodes,
            allowSeparateTypeImports
          )) {
            messagesIds.push("importAs");
          }
        }
      } else if (declarationType === "export") {
        if (shouldReportImportExport(
          node2,
          exportNodes,
          allowSeparateTypeImports
        )) {
          messagesIds.push("export");
        }
        if (shouldReportImportExport(
          node2,
          importNodes,
          allowSeparateTypeImports
        )) {
          messagesIds.push("exportAs");
        }
      }
      messagesIds.forEach(
        (messageId) => context.report({
          node: node2,
          messageId,
          data: {
            module
          }
        })
      );
    }
  }
  function handleImportsExports(context, modules, declarationType, includeExports, allowSeparateTypeImports) {
    return function(node2) {
      const module = getModule(node2);
      if (module) {
        checkAndReport(
          context,
          node2,
          modules,
          declarationType,
          includeExports,
          allowSeparateTypeImports
        );
        const currentNode = { node: node2, declarationType };
        let nodes = [currentNode];
        if (modules.has(module)) {
          const previousNodes = modules.get(module);
          nodes = [...previousNodes, currentNode];
        }
        modules.set(module, nodes);
      }
    };
  }
  noDuplicateImports = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "problem",
      defaultOptions: [
        {
          includeExports: false,
          allowSeparateTypeImports: false
        }
      ],
      docs: {
        description: "Disallow duplicate module imports",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-duplicate-imports"
      },
      schema: [
        {
          type: "object",
          properties: {
            includeExports: {
              type: "boolean"
            },
            allowSeparateTypeImports: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        import: "'{{module}}' import is duplicated.",
        importAs: "'{{module}}' import is duplicated as export.",
        export: "'{{module}}' export is duplicated.",
        exportAs: "'{{module}}' export is duplicated as import."
      }
    },
    create(context) {
      const [{ includeExports, allowSeparateTypeImports }] = context.options;
      const modules = /* @__PURE__ */ new Map();
      const handlers2 = {
        ImportDeclaration: handleImportsExports(
          context,
          modules,
          "import",
          includeExports,
          allowSeparateTypeImports
        )
      };
      if (includeExports) {
        handlers2.ExportNamedDeclaration = handleImportsExports(
          context,
          modules,
          "export",
          includeExports,
          allowSeparateTypeImports
        );
        handlers2.ExportAllDeclaration = handleImportsExports(
          context,
          modules,
          "export",
          includeExports,
          allowSeparateTypeImports
        );
      }
      return handlers2;
    }
  };
  return noDuplicateImports;
}
var fixTracker;
var hasRequiredFixTracker;
function requireFixTracker() {
  if (hasRequiredFixTracker) return fixTracker;
  hasRequiredFixTracker = 1;
  const astUtils2 = requireAstUtils();
  class FixTracker {
    /**
     * Create a new FixTracker.
     * @param {ruleFixer} fixer A ruleFixer instance.
     * @param {SourceCode} sourceCode A SourceCode object for the current code.
     */
    constructor(fixer, sourceCode2) {
      this.fixer = fixer;
      this.sourceCode = sourceCode2;
      this.retainedRange = null;
    }
    /**
     * Mark the given range as "retained", meaning that other fixes may not
     * may not modify this region in the same pass.
     * @param {SourceRange} range The range to retain.
     * @returns {FixTracker} The same RuleFixer, for chained calls.
     */
    retainRange(range) {
      this.retainedRange = range;
      return this;
    }
    /**
     * Given a node, find the function containing it (or the entire program) and
     * mark it as retained, meaning that other fixes may not modify it in this
     * pass. This is useful for avoiding conflicts in fixes that modify control
     * flow.
     * @param {ASTNode} node The node to use as a starting point.
     * @returns {FixTracker} The same RuleFixer, for chained calls.
     */
    retainEnclosingFunction(node2) {
      const functionNode = astUtils2.getUpperFunction(node2);
      return this.retainRange(
        functionNode ? functionNode.range : this.sourceCode.ast.range
      );
    }
    /**
     * Given a node or token, find the token before and afterward, and mark that
     * range as retained, meaning that other fixes may not modify it in this
     * pass. This is useful for avoiding conflicts in fixes that make a small
     * change to the code where the AST should not be changed.
     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting
     *      point. The token to the left and right are use in the range.
     * @returns {FixTracker} The same RuleFixer, for chained calls.
     */
    retainSurroundingTokens(nodeOrToken) {
      const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
      const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
      return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
    }
    /**
     * Create a fix command that replaces the given range with the given text,
     * accounting for any retained ranges.
     * @param {SourceRange} range The range to remove in the fix.
     * @param {string} text The text to insert in place of the range.
     * @returns {Object} The fix command.
     */
    replaceTextRange(range, text) {
      let actualRange;
      if (this.retainedRange) {
        actualRange = [
          Math.min(this.retainedRange[0], range[0]),
          Math.max(this.retainedRange[1], range[1])
        ];
      } else {
        actualRange = range;
      }
      return this.fixer.replaceTextRange(
        actualRange,
        this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1])
      );
    }
    /**
     * Create a fix command that removes the given node or token, accounting for
     * any retained ranges.
     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
     * @returns {Object} The fix command.
     */
    remove(nodeOrToken) {
      return this.replaceTextRange(nodeOrToken.range, "");
    }
  }
  fixTracker = FixTracker;
  return fixTracker;
}
var noElseReturn;
var hasRequiredNoElseReturn;
function requireNoElseReturn() {
  if (hasRequiredNoElseReturn) return noElseReturn;
  hasRequiredNoElseReturn = 1;
  const astUtils2 = requireAstUtils();
  const FixTracker = requireFixTracker();
  noElseReturn = {
    meta: {
      type: "suggestion",
      defaultOptions: [{ allowElseIf: true }],
      docs: {
        description: "Disallow `else` blocks after `return` statements in `if` statements",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-else-return"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowElseIf: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        unexpected: "Unnecessary 'else' after 'return'."
      }
    },
    create(context) {
      const [{ allowElseIf }] = context.options;
      const sourceCode2 = context.sourceCode;
      function isSafeToDeclare(names, scope) {
        if (names.length === 0) {
          return true;
        }
        const functionScope = scope.variableScope;
        const declaredVariables = scope.variables.filter(
          ({ defs }) => defs.length > 0
        );
        if (declaredVariables.some(({ name: name2 }) => names.includes(name2))) {
          return false;
        }
        if (scope !== functionScope && scope.upper.type === "catch") {
          if (scope.upper.variables.some(
            ({ name: name2 }) => names.includes(name2)
          )) {
            return false;
          }
        }
        const usedImplicitVariables = scope.variables.filter(
          ({ defs, references }) => defs.length === 0 && references.length > 0
        );
        if (usedImplicitVariables.some(({ name: name2 }) => names.includes(name2))) {
          return false;
        }
        if (scope.through.some((t2) => names.includes(t2.identifier.name))) {
          return false;
        }
        if (scope !== functionScope) {
          const scopeNodeRange = scope.block.range;
          const variablesToCheck = functionScope.variables.filter(
            ({ name: name2 }) => names.includes(name2)
          );
          if (variablesToCheck.some(
            (v2) => v2.defs.some(
              ({ node: { range } }) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]
            )
          )) {
            return false;
          }
        }
        return true;
      }
      function isSafeFromNameCollisions(node2, scope) {
        if (node2.type === "FunctionDeclaration") {
          return false;
        }
        if (node2.type !== "BlockStatement") {
          return true;
        }
        const elseBlockScope = scope.childScopes.find(
          ({ block }) => block === node2
        );
        if (!elseBlockScope) {
          return true;
        }
        const namesToCheck = elseBlockScope.variables.map(
          ({ name: name2 }) => name2
        );
        return isSafeToDeclare(namesToCheck, scope);
      }
      function displayReport(elseNode) {
        const currentScope = sourceCode2.getScope(elseNode.parent);
        context.report({
          node: elseNode,
          messageId: "unexpected",
          fix(fixer) {
            if (!isSafeFromNameCollisions(elseNode, currentScope)) {
              return null;
            }
            const startToken = sourceCode2.getFirstToken(elseNode);
            const elseToken = sourceCode2.getTokenBefore(startToken);
            const source = sourceCode2.getText(elseNode);
            const lastIfToken = sourceCode2.getTokenBefore(elseToken);
            let fixedSource, firstTokenOfElseBlock;
            if (startToken.type === "Punctuator" && startToken.value === "{") {
              firstTokenOfElseBlock = sourceCode2.getTokenAfter(startToken);
            } else {
              firstTokenOfElseBlock = startToken;
            }
            const ifBlockMaybeUnsafe = elseNode.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
            const elseBlockUnsafe = /^[([/+`-]/u.test(
              firstTokenOfElseBlock.value
            );
            if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
              return null;
            }
            const endToken = sourceCode2.getLastToken(elseNode);
            const lastTokenOfElseBlock = sourceCode2.getTokenBefore(endToken);
            if (lastTokenOfElseBlock.value !== ";") {
              const nextToken = sourceCode2.getTokenAfter(endToken);
              const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);
              const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;
              if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
                return null;
              }
            }
            if (startToken.type === "Punctuator" && startToken.value === "{") {
              fixedSource = source.slice(1, -1);
            } else {
              fixedSource = source;
            }
            return new FixTracker(fixer, sourceCode2).retainEnclosingFunction(elseNode).replaceTextRange(
              [elseToken.range[0], elseNode.range[1]],
              fixedSource
            );
          }
        });
      }
      function checkForReturn(node2) {
        return node2.type === "ReturnStatement";
      }
      function naiveHasReturn(node2) {
        if (node2.type === "BlockStatement") {
          const body = node2.body, lastChildNode = body.at(-1);
          return lastChildNode && checkForReturn(lastChildNode);
        }
        return checkForReturn(node2);
      }
      function hasElse(node2) {
        return node2.alternate && node2.consequent;
      }
      function checkForIf(node2) {
        return node2.type === "IfStatement" && hasElse(node2) && naiveHasReturn(node2.alternate) && naiveHasReturn(node2.consequent);
      }
      function checkForReturnOrIf(node2) {
        return checkForReturn(node2) || checkForIf(node2);
      }
      function alwaysReturns(node2) {
        if (node2.type === "BlockStatement") {
          return node2.body.some(checkForReturnOrIf);
        }
        return checkForReturnOrIf(node2);
      }
      function checkIfWithoutElse(node2) {
        const parent = node2.parent;
        if (!astUtils2.STATEMENT_LIST_PARENTS.has(parent.type)) {
          return;
        }
        const consequents = [];
        let alternate;
        for (let currentNode = node2; currentNode.type === "IfStatement"; currentNode = currentNode.alternate) {
          if (!currentNode.alternate) {
            return;
          }
          consequents.push(currentNode.consequent);
          alternate = currentNode.alternate;
        }
        if (consequents.every(alwaysReturns)) {
          displayReport(alternate);
        }
      }
      function checkIfWithElse(node2) {
        const parent = node2.parent;
        if (!astUtils2.STATEMENT_LIST_PARENTS.has(parent.type)) {
          return;
        }
        const alternate = node2.alternate;
        if (alternate && alwaysReturns(node2.consequent)) {
          displayReport(alternate);
        }
      }
      return {
        "IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse
      };
    }
  };
  return noElseReturn;
}
var noEmpty;
var hasRequiredNoEmpty;
function requireNoEmpty() {
  if (hasRequiredNoEmpty) return noEmpty;
  hasRequiredNoEmpty = 1;
  const astUtils2 = requireAstUtils();
  noEmpty = {
    meta: {
      hasSuggestions: true,
      type: "suggestion",
      defaultOptions: [
        {
          allowEmptyCatch: false
        }
      ],
      docs: {
        description: "Disallow empty block statements",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-empty"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowEmptyCatch: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Empty {{type}} statement.",
        suggestComment: "Add comment inside empty {{type}} statement."
      }
    },
    create(context) {
      const [{ allowEmptyCatch }] = context.options;
      const sourceCode2 = context.sourceCode;
      return {
        BlockStatement(node2) {
          if (node2.body.length !== 0) {
            return;
          }
          if (astUtils2.isFunction(node2.parent)) {
            return;
          }
          if (allowEmptyCatch && node2.parent.type === "CatchClause") {
            return;
          }
          if (sourceCode2.getCommentsInside(node2).length > 0) {
            return;
          }
          context.report({
            node: node2,
            messageId: "unexpected",
            data: { type: "block" },
            suggest: [
              {
                messageId: "suggestComment",
                data: { type: "block" },
                fix(fixer) {
                  const range = [
                    node2.range[0] + 1,
                    node2.range[1] - 1
                  ];
                  return fixer.replaceTextRange(
                    range,
                    " /* empty */ "
                  );
                }
              }
            ]
          });
        },
        SwitchStatement(node2) {
          if (typeof node2.cases === "undefined" || node2.cases.length === 0) {
            const openingBrace = sourceCode2.getTokenAfter(
              node2.discriminant,
              astUtils2.isOpeningBraceToken
            );
            const closingBrace = sourceCode2.getLastToken(node2);
            if (sourceCode2.commentsExistBetween(
              openingBrace,
              closingBrace
            )) {
              return;
            }
            context.report({
              node: node2,
              loc: {
                start: openingBrace.loc.start,
                end: closingBrace.loc.end
              },
              messageId: "unexpected",
              data: { type: "switch" },
              suggest: [
                {
                  messageId: "suggestComment",
                  data: { type: "switch" },
                  fix(fixer) {
                    const range = [
                      openingBrace.range[1],
                      closingBrace.range[0]
                    ];
                    return fixer.replaceTextRange(
                      range,
                      " /* empty */ "
                    );
                  }
                }
              ]
            });
          }
        }
      };
    }
  };
  return noEmpty;
}
var noEmptyCharacterClass;
var hasRequiredNoEmptyCharacterClass;
function requireNoEmptyCharacterClass() {
  if (hasRequiredNoEmptyCharacterClass) return noEmptyCharacterClass;
  hasRequiredNoEmptyCharacterClass = 1;
  const { RegExpParser, visitRegExpAST } = requireRegexpp();
  const parser2 = new RegExpParser();
  const QUICK_TEST_REGEX = /\[\]/u;
  noEmptyCharacterClass = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow empty character classes in regular expressions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-empty-character-class"
      },
      schema: [],
      messages: {
        unexpected: "Empty class."
      }
    },
    create(context) {
      return {
        "Literal[regex]"(node2) {
          const { pattern: pattern2, flags: flags2 } = node2.regex;
          if (!QUICK_TEST_REGEX.test(pattern2)) {
            return;
          }
          let regExpAST;
          try {
            regExpAST = parser2.parsePattern(
              pattern2,
              0,
              pattern2.length,
              {
                unicode: flags2.includes("u"),
                unicodeSets: flags2.includes("v")
              }
            );
          } catch {
            return;
          }
          visitRegExpAST(regExpAST, {
            onCharacterClassEnter(characterClass) {
              if (!characterClass.negate && characterClass.elements.length === 0) {
                context.report({ node: node2, messageId: "unexpected" });
              }
            }
          });
        }
      };
    }
  };
  return noEmptyCharacterClass;
}
var noEmptyFunction;
var hasRequiredNoEmptyFunction;
function requireNoEmptyFunction() {
  if (hasRequiredNoEmptyFunction) return noEmptyFunction;
  hasRequiredNoEmptyFunction = 1;
  const astUtils2 = requireAstUtils();
  const ALLOW_OPTIONS = Object.freeze([
    "functions",
    "arrowFunctions",
    "generatorFunctions",
    "methods",
    "generatorMethods",
    "getters",
    "setters",
    "constructors",
    "asyncFunctions",
    "asyncMethods",
    "privateConstructors",
    "protectedConstructors",
    "decoratedFunctions",
    "overrideMethods"
  ]);
  function getKind(node2) {
    const parent = node2.parent;
    let kind;
    if (node2.type === "ArrowFunctionExpression") {
      return "arrowFunctions";
    }
    if (parent.type === "Property") {
      if (parent.kind === "get") {
        return "getters";
      }
      if (parent.kind === "set") {
        return "setters";
      }
      kind = parent.method ? "methods" : "functions";
    } else if (parent.type === "MethodDefinition") {
      if (parent.kind === "get") {
        return "getters";
      }
      if (parent.kind === "set") {
        return "setters";
      }
      if (parent.kind === "constructor") {
        return "constructors";
      }
      kind = "methods";
    } else {
      kind = "functions";
    }
    let prefix;
    if (node2.generator) {
      prefix = "generator";
    } else if (node2.async) {
      prefix = "async";
    } else {
      return kind;
    }
    return prefix + kind[0].toUpperCase() + kind.slice(1);
  }
  function isParameterPropertiesConstructor(node2) {
    return node2.params.some((param) => param.type === "TSParameterProperty");
  }
  noEmptyFunction = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      hasSuggestions: true,
      type: "suggestion",
      defaultOptions: [{ allow: [] }],
      docs: {
        description: "Disallow empty functions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-empty-function"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: { enum: ALLOW_OPTIONS },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected empty {{name}}.",
        suggestComment: "Add comment inside empty {{name}}."
      }
    },
    create(context) {
      const [{ allow }] = context.options;
      const sourceCode2 = context.sourceCode;
      function isAllowedEmptyFunction(node2) {
        var _a2;
        const kind = getKind(node2);
        if (allow.includes(kind)) {
          return true;
        }
        if (kind === "constructors") {
          if (node2.parent.accessibility === "private" && allow.includes("privateConstructors") || node2.parent.accessibility === "protected" && allow.includes("protectedConstructors") || isParameterPropertiesConstructor(node2)) {
            return true;
          }
        }
        if (/(?:g|s)etters|methods$/iu.test(kind)) {
          if (((_a2 = node2.parent.decorators) == null ? void 0 : _a2.length) && allow.includes("decoratedFunctions") || node2.parent.override && allow.includes("overrideMethods")) {
            return true;
          }
        }
        return false;
      }
      function reportIfEmpty(node2) {
        const name2 = astUtils2.getFunctionNameWithKind(node2);
        const innerComments = sourceCode2.getTokens(node2.body, {
          includeComments: true,
          filter: astUtils2.isCommentToken
        });
        if (!isAllowedEmptyFunction(node2) && node2.body.type === "BlockStatement" && node2.body.body.length === 0 && innerComments.length === 0) {
          context.report({
            node: node2,
            loc: node2.body.loc,
            messageId: "unexpected",
            data: { name: name2 },
            suggest: [
              {
                messageId: "suggestComment",
                data: { name: name2 },
                fix(fixer) {
                  const range = [
                    node2.body.range[0] + 1,
                    node2.body.range[1] - 1
                  ];
                  return fixer.replaceTextRange(
                    range,
                    " /* empty */ "
                  );
                }
              }
            ]
          });
        }
      }
      return {
        ArrowFunctionExpression: reportIfEmpty,
        FunctionDeclaration: reportIfEmpty,
        FunctionExpression: reportIfEmpty
      };
    }
  };
  return noEmptyFunction;
}
var noEmptyPattern;
var hasRequiredNoEmptyPattern;
function requireNoEmptyPattern() {
  if (hasRequiredNoEmptyPattern) return noEmptyPattern;
  hasRequiredNoEmptyPattern = 1;
  const astUtils2 = requireAstUtils();
  noEmptyPattern = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowObjectPatternsAsParameters: false
        }
      ],
      docs: {
        description: "Disallow empty destructuring patterns",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-empty-pattern"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowObjectPatternsAsParameters: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected empty {{type}} pattern."
      }
    },
    create(context) {
      const [{ allowObjectPatternsAsParameters }] = context.options;
      return {
        ObjectPattern(node2) {
          if (node2.properties.length > 0) {
            return;
          }
          if (allowObjectPatternsAsParameters && (astUtils2.isFunction(node2.parent) || node2.parent.type === "AssignmentPattern" && astUtils2.isFunction(node2.parent.parent) && node2.parent.right.type === "ObjectExpression" && node2.parent.right.properties.length === 0)) {
            return;
          }
          context.report({
            node: node2,
            messageId: "unexpected",
            data: { type: "object" }
          });
        },
        ArrayPattern(node2) {
          if (node2.elements.length === 0) {
            context.report({
              node: node2,
              messageId: "unexpected",
              data: { type: "array" }
            });
          }
        }
      };
    }
  };
  return noEmptyPattern;
}
var noEmptyStaticBlock;
var hasRequiredNoEmptyStaticBlock;
function requireNoEmptyStaticBlock() {
  if (hasRequiredNoEmptyStaticBlock) return noEmptyStaticBlock;
  hasRequiredNoEmptyStaticBlock = 1;
  noEmptyStaticBlock = {
    meta: {
      hasSuggestions: true,
      type: "suggestion",
      docs: {
        description: "Disallow empty static blocks",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-empty-static-block"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected empty static block.",
        suggestComment: "Add comment inside empty static block."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        StaticBlock(node2) {
          if (node2.body.length === 0) {
            const openingBrace = sourceCode2.getFirstToken(node2, {
              skip: 1
            });
            const closingBrace = sourceCode2.getLastToken(node2);
            if (sourceCode2.getCommentsBefore(closingBrace).length === 0) {
              context.report({
                loc: {
                  start: openingBrace.loc.start,
                  end: closingBrace.loc.end
                },
                messageId: "unexpected",
                suggest: [
                  {
                    messageId: "suggestComment",
                    fix(fixer) {
                      const range = [
                        openingBrace.range[1],
                        closingBrace.range[0]
                      ];
                      return fixer.replaceTextRange(
                        range,
                        " /* empty */ "
                      );
                    }
                  }
                ]
              });
            }
          }
        }
      };
    }
  };
  return noEmptyStaticBlock;
}
var noEqNull;
var hasRequiredNoEqNull;
function requireNoEqNull() {
  if (hasRequiredNoEqNull) return noEqNull;
  hasRequiredNoEqNull = 1;
  noEqNull = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `null` comparisons without type-checking operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-eq-null"
      },
      schema: [],
      messages: {
        unexpected: "Use '===' to compare with null."
      }
    },
    create(context) {
      return {
        BinaryExpression(node2) {
          const badOperator = node2.operator === "==" || node2.operator === "!=";
          if (node2.right.type === "Literal" && node2.right.raw === "null" && badOperator || node2.left.type === "Literal" && node2.left.raw === "null" && badOperator) {
            context.report({ node: node2, messageId: "unexpected" });
          }
        }
      };
    }
  };
  return noEqNull;
}
var noEval;
var hasRequiredNoEval;
function requireNoEval() {
  if (hasRequiredNoEval) return noEval;
  hasRequiredNoEval = 1;
  const astUtils2 = requireAstUtils();
  const candidatesOfGlobalObject = Object.freeze([
    "global",
    "window",
    "globalThis"
  ]);
  function isMember(node2, name2) {
    return astUtils2.isSpecificMemberAccess(node2, null, name2);
  }
  noEval = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowIndirect: false
        }
      ],
      docs: {
        description: "Disallow the use of `eval()`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-eval"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowIndirect: { type: "boolean" }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "eval can be harmful."
      }
    },
    create(context) {
      const [{ allowIndirect }] = context.options;
      const sourceCode2 = context.sourceCode;
      let funcInfo = null;
      function enterThisScope(node2) {
        const strict2 = sourceCode2.getScope(node2).isStrict;
        funcInfo = {
          upper: funcInfo,
          node: node2,
          strict: strict2,
          isTopLevelOfScript: false,
          defaultThis: false,
          initialized: strict2
        };
      }
      function exitThisScope() {
        funcInfo = funcInfo.upper;
      }
      function report(node2) {
        const parent = node2.parent;
        const locationNode = node2.type === "MemberExpression" ? node2.property : node2;
        const reportNode = parent.type === "CallExpression" && parent.callee === node2 ? parent : node2;
        context.report({
          node: reportNode,
          loc: locationNode.loc,
          messageId: "unexpected"
        });
      }
      function reportAccessingEvalViaGlobalObject(globalScope) {
        for (let i2 = 0; i2 < candidatesOfGlobalObject.length; ++i2) {
          const name2 = candidatesOfGlobalObject[i2];
          const variable = astUtils2.getVariableByName(globalScope, name2);
          if (!variable) {
            continue;
          }
          const references = variable.references;
          for (let j = 0; j < references.length; ++j) {
            const identifier = references[j].identifier;
            let node2 = identifier.parent;
            while (isMember(node2, name2)) {
              node2 = node2.parent;
            }
            if (isMember(node2, "eval")) {
              report(node2);
            }
          }
        }
      }
      function reportAccessingEval(globalScope) {
        const variable = astUtils2.getVariableByName(globalScope, "eval");
        if (!variable) {
          return;
        }
        const references = variable.references;
        for (let i2 = 0; i2 < references.length; ++i2) {
          const reference = references[i2];
          const id2 = reference.identifier;
          if (id2.name === "eval" && !astUtils2.isCallee(id2)) {
            report(id2);
          }
        }
      }
      if (allowIndirect) {
        return {
          "CallExpression:exit"(node2) {
            const callee = node2.callee;
            if (!node2.optional && astUtils2.isSpecificId(callee, "eval")) {
              report(callee);
            }
          }
        };
      }
      return {
        "CallExpression:exit"(node2) {
          const callee = node2.callee;
          if (astUtils2.isSpecificId(callee, "eval")) {
            report(callee);
          }
        },
        Program(node2) {
          const scope = sourceCode2.getScope(node2), features = context.languageOptions.parserOptions.ecmaFeatures || {}, strict2 = scope.isStrict || node2.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict, isTopLevelOfScript = node2.sourceType !== "module" && !features.globalReturn;
          funcInfo = {
            upper: null,
            node: node2,
            strict: strict2,
            isTopLevelOfScript,
            defaultThis: true,
            initialized: true
          };
        },
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          exitThisScope();
          reportAccessingEval(globalScope);
          reportAccessingEvalViaGlobalObject(globalScope);
        },
        FunctionDeclaration: enterThisScope,
        "FunctionDeclaration:exit": exitThisScope,
        FunctionExpression: enterThisScope,
        "FunctionExpression:exit": exitThisScope,
        "PropertyDefinition > *.value": enterThisScope,
        "PropertyDefinition > *.value:exit": exitThisScope,
        StaticBlock: enterThisScope,
        "StaticBlock:exit": exitThisScope,
        ThisExpression(node2) {
          if (!isMember(node2.parent, "eval")) {
            return;
          }
          if (!funcInfo.initialized) {
            funcInfo.initialized = true;
            funcInfo.defaultThis = astUtils2.isDefaultThisBinding(
              funcInfo.node,
              sourceCode2
            );
          }
          if (funcInfo.isTopLevelOfScript || !funcInfo.strict && funcInfo.defaultThis) {
            report(node2.parent);
          }
        }
      };
    }
  };
  return noEval;
}
var noExAssign;
var hasRequiredNoExAssign;
function requireNoExAssign() {
  if (hasRequiredNoExAssign) return noExAssign;
  hasRequiredNoExAssign = 1;
  const astUtils2 = requireAstUtils();
  noExAssign = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning exceptions in `catch` clauses",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-ex-assign"
      },
      schema: [],
      messages: {
        unexpected: "Do not assign to the exception parameter."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkVariable(variable) {
        astUtils2.getModifyingReferences(variable.references).forEach((reference) => {
          context.report({
            node: reference.identifier,
            messageId: "unexpected"
          });
        });
      }
      return {
        CatchClause(node2) {
          sourceCode2.getDeclaredVariables(node2).forEach(checkVariable);
        }
      };
    }
  };
  return noExAssign;
}
var noExtendNative;
var hasRequiredNoExtendNative;
function requireNoExtendNative() {
  if (hasRequiredNoExtendNative) return noExtendNative;
  hasRequiredNoExtendNative = 1;
  const astUtils2 = requireAstUtils();
  noExtendNative = {
    meta: {
      type: "suggestion",
      defaultOptions: [{ exceptions: [] }],
      docs: {
        description: "Disallow extending native types",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-extend-native"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "{{builtin}} prototype is read only, properties should not be added."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const exceptions = new Set(context.options[0].exceptions);
      const modifiedBuiltins = new Set(
        Object.keys(astUtils2.ECMASCRIPT_GLOBALS).filter((builtin2) => builtin2[0].toUpperCase() === builtin2[0]).filter((builtin2) => !exceptions.has(builtin2))
      );
      function reportNode(node2, builtin2) {
        context.report({
          node: node2,
          messageId: "unexpected",
          data: {
            builtin: builtin2
          }
        });
      }
      function isPrototypePropertyAccessed(identifierNode) {
        return Boolean(
          identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils2.getStaticPropertyName(identifierNode.parent) === "prototype"
        );
      }
      function isAssigningToPropertyOf(node2) {
        return node2.parent.type === "MemberExpression" && node2.parent.object === node2 && node2.parent.parent.type === "AssignmentExpression" && node2.parent.parent.left === node2.parent;
      }
      function isInDefinePropertyCall(node2) {
        return node2.parent.type === "CallExpression" && node2.parent.arguments[0] === node2 && astUtils2.isSpecificMemberAccess(
          node2.parent.callee,
          "Object",
          /^definePropert(?:y|ies)$/u
        );
      }
      function checkAndReportPrototypeExtension(identifierNode) {
        if (!isPrototypePropertyAccessed(identifierNode)) {
          return;
        }
        const prototypeNode = identifierNode.parent.parent.type === "ChainExpression" ? identifierNode.parent.parent : identifierNode.parent;
        if (isAssigningToPropertyOf(prototypeNode)) {
          reportNode(prototypeNode.parent.parent, identifierNode.name);
        } else if (isInDefinePropertyCall(prototypeNode)) {
          reportNode(prototypeNode.parent, identifierNode.name);
        }
      }
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          modifiedBuiltins.forEach((builtin2) => {
            const builtinVar = globalScope.set.get(builtin2);
            if (builtinVar && builtinVar.references) {
              builtinVar.references.map((ref2) => ref2.identifier).forEach(checkAndReportPrototypeExtension);
            }
          });
        }
      };
    }
  };
  return noExtendNative;
}
var noExtraBind;
var hasRequiredNoExtraBind;
function requireNoExtraBind() {
  if (hasRequiredNoExtraBind) return noExtraBind;
  hasRequiredNoExtraBind = 1;
  const astUtils2 = requireAstUtils();
  const SIDE_EFFECT_FREE_NODE_TYPES = /* @__PURE__ */ new Set([
    "Literal",
    "Identifier",
    "ThisExpression",
    "FunctionExpression"
  ]);
  noExtraBind = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary calls to `.bind()`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-extra-bind"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpected: "The function binding is unnecessary."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let scopeInfo = null;
      function isSideEffectFree(node2) {
        return SIDE_EFFECT_FREE_NODE_TYPES.has(node2.type);
      }
      function report(node2) {
        const memberNode = node2.parent;
        const callNode = memberNode.parent.type === "ChainExpression" ? memberNode.parent.parent : memberNode.parent;
        context.report({
          node: callNode,
          messageId: "unexpected",
          loc: memberNode.property.loc,
          fix(fixer) {
            if (!isSideEffectFree(callNode.arguments[0])) {
              return null;
            }
            const tokenPairs = [
              [
                // `.`, `?.`, or `[` token.
                sourceCode2.getTokenAfter(
                  memberNode.object,
                  astUtils2.isNotClosingParenToken
                ),
                // property name or `]` token.
                sourceCode2.getLastToken(memberNode)
              ],
              [
                // `?.` or `(` token of arguments.
                sourceCode2.getTokenAfter(
                  memberNode,
                  astUtils2.isNotClosingParenToken
                ),
                // `)` token of arguments.
                sourceCode2.getLastToken(callNode)
              ]
            ];
            const firstTokenToRemove = tokenPairs[0][0];
            const lastTokenToRemove = tokenPairs[1][1];
            if (sourceCode2.commentsExistBetween(
              firstTokenToRemove,
              lastTokenToRemove
            )) {
              return null;
            }
            return tokenPairs.map(
              ([start, end]) => fixer.removeRange([start.range[0], end.range[1]])
            );
          }
        });
      }
      function isCalleeOfBindMethod(node2) {
        if (!astUtils2.isSpecificMemberAccess(node2.parent, null, "bind")) {
          return false;
        }
        const bindNode = node2.parent.parent.type === "ChainExpression" ? node2.parent.parent : node2.parent;
        return bindNode.parent.type === "CallExpression" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== "SpreadElement";
      }
      function enterFunction(node2) {
        scopeInfo = {
          isBound: isCalleeOfBindMethod(node2),
          thisFound: false,
          upper: scopeInfo
        };
      }
      function exitFunction(node2) {
        if (scopeInfo.isBound && !scopeInfo.thisFound) {
          report(node2);
        }
        scopeInfo = scopeInfo.upper;
      }
      function exitArrowFunction(node2) {
        if (isCalleeOfBindMethod(node2)) {
          report(node2);
        }
      }
      function markAsThisFound() {
        if (scopeInfo) {
          scopeInfo.thisFound = true;
        }
      }
      return {
        "ArrowFunctionExpression:exit": exitArrowFunction,
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        ThisExpression: markAsThisFound
      };
    }
  };
  return noExtraBind;
}
var noExtraBooleanCast;
var hasRequiredNoExtraBooleanCast;
function requireNoExtraBooleanCast() {
  if (hasRequiredNoExtraBooleanCast) return noExtraBooleanCast;
  hasRequiredNoExtraBooleanCast = 1;
  const astUtils2 = requireAstUtils();
  const eslintUtils2 = /* @__PURE__ */ requireEslintUtils();
  const precedence = astUtils2.getPrecedence;
  noExtraBooleanCast = {
    meta: {
      type: "suggestion",
      defaultOptions: [{}],
      docs: {
        description: "Disallow unnecessary boolean casts",
        recommended: true,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-extra-boolean-cast"
      },
      schema: [
        {
          anyOf: [
            {
              type: "object",
              properties: {
                enforceForInnerExpressions: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            },
            // deprecated
            {
              type: "object",
              properties: {
                enforceForLogicalOperands: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      fixable: "code",
      messages: {
        unexpectedCall: "Redundant Boolean call.",
        unexpectedNegation: "Redundant double negation."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ enforceForLogicalOperands, enforceForInnerExpressions }] = context.options;
      const BOOLEAN_NODE_TYPES = /* @__PURE__ */ new Set([
        "IfStatement",
        "DoWhileStatement",
        "WhileStatement",
        "ConditionalExpression",
        "ForStatement"
      ]);
      function isBooleanFunctionOrConstructorCall(node2) {
        return (node2.type === "CallExpression" || node2.type === "NewExpression") && node2.callee.type === "Identifier" && node2.callee.name === "Boolean";
      }
      function isInBooleanContext(node2) {
        return isBooleanFunctionOrConstructorCall(node2.parent) && node2 === node2.parent.arguments[0] || BOOLEAN_NODE_TYPES.has(node2.parent.type) && node2 === node2.parent.test || // !<bool>
        node2.parent.type === "UnaryExpression" && node2.parent.operator === "!";
      }
      function isInFlaggedContext(node2) {
        if (node2.parent.type === "ChainExpression") {
          return isInFlaggedContext(node2.parent);
        }
        if (enforceForLogicalOperands || enforceForInnerExpressions) {
          if (node2.parent.type === "LogicalExpression") {
            if (node2.parent.operator === "||" || node2.parent.operator === "&&") {
              return isInFlaggedContext(node2.parent);
            }
            if (enforceForInnerExpressions && node2.parent.operator === "??" && node2.parent.right === node2) {
              return isInFlaggedContext(node2.parent);
            }
          }
        }
        if (enforceForInnerExpressions) {
          if (node2.parent.type === "ConditionalExpression" && (node2.parent.consequent === node2 || node2.parent.alternate === node2)) {
            return isInFlaggedContext(node2.parent);
          }
          if (node2.parent.type === "SequenceExpression" && node2.parent.expressions.at(-1) === node2) {
            return isInFlaggedContext(node2.parent);
          }
        }
        return isInBooleanContext(node2);
      }
      function hasCommentsInside(node2) {
        return Boolean(sourceCode2.getCommentsInside(node2).length);
      }
      function isParenthesized(node2) {
        return eslintUtils2.isParenthesized(1, node2, sourceCode2);
      }
      function needsParens(previousNode, node2) {
        if (previousNode.parent.type === "ChainExpression") {
          return needsParens(previousNode.parent, node2);
        }
        if (isParenthesized(previousNode)) {
          return false;
        }
        const parent = previousNode.parent;
        switch (parent.type) {
          case "CallExpression":
          case "NewExpression":
            return node2.type === "SequenceExpression";
          case "IfStatement":
          case "DoWhileStatement":
          case "WhileStatement":
          case "ForStatement":
          case "SequenceExpression":
            return false;
          case "ConditionalExpression":
            if (previousNode === parent.test) {
              return precedence(node2) <= precedence(parent);
            }
            if (previousNode === parent.consequent || previousNode === parent.alternate) {
              return precedence(node2) < precedence({ type: "AssignmentExpression" });
            }
            throw new Error(
              "Ternary child must be test, consequent, or alternate."
            );
          case "UnaryExpression":
            return precedence(node2) < precedence(parent);
          case "LogicalExpression":
            if (astUtils2.isMixedLogicalAndCoalesceExpressions(
              node2,
              parent
            )) {
              return true;
            }
            if (previousNode === parent.left) {
              return precedence(node2) < precedence(parent);
            }
            return precedence(node2) <= precedence(parent);
          default:
            throw new Error(`Unexpected parent type: ${parent.type}`);
        }
      }
      return {
        UnaryExpression(node2) {
          const parent = node2.parent;
          if (node2.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
            return;
          }
          if (isInFlaggedContext(parent)) {
            context.report({
              node: parent,
              messageId: "unexpectedNegation",
              fix(fixer) {
                if (hasCommentsInside(parent)) {
                  return null;
                }
                if (needsParens(parent, node2.argument)) {
                  return fixer.replaceText(
                    parent,
                    `(${sourceCode2.getText(node2.argument)})`
                  );
                }
                let prefix = "";
                const tokenBefore = sourceCode2.getTokenBefore(parent);
                const firstReplacementToken = sourceCode2.getFirstToken(node2.argument);
                if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils2.canTokensBeAdjacent(
                  tokenBefore,
                  firstReplacementToken
                )) {
                  prefix = " ";
                }
                return fixer.replaceText(
                  parent,
                  prefix + sourceCode2.getText(node2.argument)
                );
              }
            });
          }
        },
        CallExpression(node2) {
          if (node2.callee.type !== "Identifier" || node2.callee.name !== "Boolean") {
            return;
          }
          if (isInFlaggedContext(node2)) {
            context.report({
              node: node2,
              messageId: "unexpectedCall",
              fix(fixer) {
                const parent = node2.parent;
                if (node2.arguments.length === 0) {
                  if (parent.type === "UnaryExpression" && parent.operator === "!") {
                    if (hasCommentsInside(parent)) {
                      return null;
                    }
                    const replacement = "true";
                    let prefix = "";
                    const tokenBefore = sourceCode2.getTokenBefore(parent);
                    if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils2.canTokensBeAdjacent(
                      tokenBefore,
                      replacement
                    )) {
                      prefix = " ";
                    }
                    return fixer.replaceText(
                      parent,
                      prefix + replacement
                    );
                  }
                  if (hasCommentsInside(node2)) {
                    return null;
                  }
                  return fixer.replaceText(node2, "false");
                }
                if (node2.arguments.length === 1) {
                  const argument = node2.arguments[0];
                  if (argument.type === "SpreadElement" || hasCommentsInside(node2)) {
                    return null;
                  }
                  if (needsParens(node2, argument)) {
                    return fixer.replaceText(
                      node2,
                      `(${sourceCode2.getText(argument)})`
                    );
                  }
                  return fixer.replaceText(
                    node2,
                    sourceCode2.getText(argument)
                  );
                }
                return null;
              }
            });
          }
        }
      };
    }
  };
  return noExtraBooleanCast;
}
var noExtraLabel;
var hasRequiredNoExtraLabel;
function requireNoExtraLabel() {
  if (hasRequiredNoExtraLabel) return noExtraLabel;
  hasRequiredNoExtraLabel = 1;
  const astUtils2 = requireAstUtils();
  noExtraLabel = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary labels",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-extra-label"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpected: "This label '{{name}}' is unnecessary."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let scopeInfo = null;
      function enterBreakableStatement(node2) {
        scopeInfo = {
          label: node2.parent.type === "LabeledStatement" ? node2.parent.label : null,
          breakable: true,
          upper: scopeInfo
        };
      }
      function exitBreakableStatement() {
        scopeInfo = scopeInfo.upper;
      }
      function enterLabeledStatement(node2) {
        if (!astUtils2.isBreakableStatement(node2.body)) {
          scopeInfo = {
            label: node2.label,
            breakable: false,
            upper: scopeInfo
          };
        }
      }
      function exitLabeledStatement(node2) {
        if (!astUtils2.isBreakableStatement(node2.body)) {
          scopeInfo = scopeInfo.upper;
        }
      }
      function reportIfUnnecessary(node2) {
        if (!node2.label) {
          return;
        }
        const labelNode = node2.label;
        for (let info = scopeInfo; info !== null; info = info.upper) {
          if (info.breakable || info.label && info.label.name === labelNode.name) {
            if (info.breakable && info.label && info.label.name === labelNode.name) {
              context.report({
                node: labelNode,
                messageId: "unexpected",
                data: labelNode,
                fix(fixer) {
                  const breakOrContinueToken = sourceCode2.getFirstToken(node2);
                  if (sourceCode2.commentsExistBetween(
                    breakOrContinueToken,
                    labelNode
                  )) {
                    return null;
                  }
                  return fixer.removeRange([
                    breakOrContinueToken.range[1],
                    labelNode.range[1]
                  ]);
                }
              });
            }
            return;
          }
        }
      }
      return {
        WhileStatement: enterBreakableStatement,
        "WhileStatement:exit": exitBreakableStatement,
        DoWhileStatement: enterBreakableStatement,
        "DoWhileStatement:exit": exitBreakableStatement,
        ForStatement: enterBreakableStatement,
        "ForStatement:exit": exitBreakableStatement,
        ForInStatement: enterBreakableStatement,
        "ForInStatement:exit": exitBreakableStatement,
        ForOfStatement: enterBreakableStatement,
        "ForOfStatement:exit": exitBreakableStatement,
        SwitchStatement: enterBreakableStatement,
        "SwitchStatement:exit": exitBreakableStatement,
        LabeledStatement: enterLabeledStatement,
        "LabeledStatement:exit": exitLabeledStatement,
        BreakStatement: reportIfUnnecessary,
        ContinueStatement: reportIfUnnecessary
      };
    }
  };
  return noExtraLabel;
}
var noExtraParens;
var hasRequiredNoExtraParens;
function requireNoExtraParens() {
  if (hasRequiredNoExtraParens) return noExtraParens;
  hasRequiredNoExtraParens = 1;
  const {
    isParenthesized: isParenthesizedRaw
  } = /* @__PURE__ */ requireEslintUtils();
  const astUtils2 = requireAstUtils();
  noExtraParens = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-extra-parens",
              url: "https://eslint.style/rules/no-extra-parens"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow unnecessary parentheses",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-extra-parens"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["functions"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["all"]
              },
              {
                type: "object",
                properties: {
                  conditionalAssign: { type: "boolean" },
                  ternaryOperandBinaryExpressions: {
                    type: "boolean"
                  },
                  nestedBinaryExpressions: { type: "boolean" },
                  returnAssign: { type: "boolean" },
                  ignoreJSX: {
                    enum: [
                      "none",
                      "all",
                      "single-line",
                      "multi-line"
                    ]
                  },
                  enforceForArrowConditionals: {
                    type: "boolean"
                  },
                  enforceForSequenceExpressions: {
                    type: "boolean"
                  },
                  enforceForNewInMemberExpressions: {
                    type: "boolean"
                  },
                  enforceForFunctionPrototypeMethods: {
                    type: "boolean"
                  },
                  allowParensAfterCommentPattern: {
                    type: "string"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        unexpected: "Unnecessary parentheses around expression."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const tokensToIgnore = /* @__PURE__ */ new WeakSet();
      const precedence = astUtils2.getPrecedence;
      const ALL_NODES = context.options[0] !== "functions";
      const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
      const EXCEPT_COND_TERNARY = ALL_NODES && context.options[1] && context.options[1].ternaryOperandBinaryExpressions === false;
      const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
      const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
      const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
      const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;
      const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;
      const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;
      const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] && context.options[1].enforceForFunctionPrototypeMethods === false;
      const ALLOW_PARENS_AFTER_COMMENT_PATTERN = ALL_NODES && context.options[1] && context.options[1].allowParensAfterCommentPattern;
      const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({
        type: "AssignmentExpression"
      });
      const PRECEDENCE_OF_UPDATE_EXPR = precedence({
        type: "UpdateExpression"
      });
      let reportsBuffer;
      function isImmediateFunctionPrototypeMethodCall(node2) {
        const callNode = astUtils2.skipChainExpression(node2);
        if (callNode.type !== "CallExpression") {
          return false;
        }
        const callee = astUtils2.skipChainExpression(callNode.callee);
        return callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && ["call", "apply"].includes(
          astUtils2.getStaticPropertyName(callee)
        );
      }
      function ruleApplies(node2) {
        if (node2.type === "JSXElement" || node2.type === "JSXFragment") {
          const isSingleLine = node2.loc.start.line === node2.loc.end.line;
          switch (IGNORE_JSX) {
            case "all":
              return false;
            case "multi-line":
              return isSingleLine;
            case "single-line":
              return !isSingleLine;
          }
        }
        if (node2.type === "SequenceExpression" && IGNORE_SEQUENCE_EXPRESSIONS) {
          return false;
        }
        if (isImmediateFunctionPrototypeMethodCall(node2) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {
          return false;
        }
        return ALL_NODES || node2.type === "FunctionExpression" || node2.type === "ArrowFunctionExpression";
      }
      function isParenthesised(node2) {
        return isParenthesizedRaw(1, node2, sourceCode2);
      }
      function isParenthesisedTwice(node2) {
        return isParenthesizedRaw(2, node2, sourceCode2);
      }
      function hasExcessParens(node2) {
        return ruleApplies(node2) && isParenthesised(node2);
      }
      function hasDoubleExcessParens(node2) {
        return ruleApplies(node2) && isParenthesisedTwice(node2);
      }
      function hasExcessParensWithPrecedence(node2, precedenceLowerLimit) {
        if (ruleApplies(node2) && isParenthesised(node2)) {
          if (precedence(node2) >= precedenceLowerLimit || isParenthesisedTwice(node2)) {
            return true;
          }
        }
        return false;
      }
      function isCondAssignException(node2) {
        return EXCEPT_COND_ASSIGN && node2.test.type === "AssignmentExpression";
      }
      function isInReturnStatement(node2) {
        for (let currentNode = node2; currentNode; currentNode = currentNode.parent) {
          if (currentNode.type === "ReturnStatement" || currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement") {
            return true;
          }
        }
        return false;
      }
      function isNewExpressionWithParens(newExpression) {
        const lastToken = sourceCode2.getLastToken(newExpression);
        const penultimateToken = sourceCode2.getTokenBefore(lastToken);
        return newExpression.arguments.length > 0 || // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens
        astUtils2.isOpeningParenToken(penultimateToken) && astUtils2.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];
      }
      function containsAssignment(node2) {
        if (node2.type === "AssignmentExpression") {
          return true;
        }
        if (node2.type === "ConditionalExpression" && (node2.consequent.type === "AssignmentExpression" || node2.alternate.type === "AssignmentExpression")) {
          return true;
        }
        if (node2.left && node2.left.type === "AssignmentExpression" || node2.right && node2.right.type === "AssignmentExpression") {
          return true;
        }
        return false;
      }
      function isReturnAssignException(node2) {
        if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node2)) {
          return false;
        }
        if (node2.type === "ReturnStatement") {
          return node2.argument && containsAssignment(node2.argument);
        }
        if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
          return containsAssignment(node2.body);
        }
        return containsAssignment(node2);
      }
      function hasExcessParensNoLineTerminator(token, node2) {
        if (token.loc.end.line === node2.loc.start.line) {
          return hasExcessParens(node2);
        }
        return hasDoubleExcessParens(node2);
      }
      function requiresLeadingSpace(node2) {
        const leftParenToken = sourceCode2.getTokenBefore(node2);
        const tokenBeforeLeftParen = sourceCode2.getTokenBefore(
          leftParenToken,
          { includeComments: true }
        );
        const tokenAfterLeftParen = sourceCode2.getTokenAfter(
          leftParenToken,
          { includeComments: true }
        );
        return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils2.canTokensBeAdjacent(
          tokenBeforeLeftParen,
          tokenAfterLeftParen
        );
      }
      function requiresTrailingSpace(node2) {
        const nextTwoTokens = sourceCode2.getTokensAfter(node2, { count: 2 });
        const rightParenToken = nextTwoTokens[0];
        const tokenAfterRightParen = nextTwoTokens[1];
        const tokenBeforeRightParen = sourceCode2.getLastToken(node2);
        return rightParenToken && tokenAfterRightParen && !sourceCode2.isSpaceBetweenTokens(
          rightParenToken,
          tokenAfterRightParen
        ) && !astUtils2.canTokensBeAdjacent(
          tokenBeforeRightParen,
          tokenAfterRightParen
        );
      }
      function isIIFE(node2) {
        const maybeCallNode = astUtils2.skipChainExpression(node2);
        return maybeCallNode.type === "CallExpression" && maybeCallNode.callee.type === "FunctionExpression";
      }
      function canBeAssignmentTarget(node2) {
        return node2 && (node2.type === "Identifier" || node2.type === "MemberExpression");
      }
      function isFixable(node2) {
        if (node2.type !== "Literal" || typeof node2.value !== "string") {
          return true;
        }
        if (isParenthesisedTwice(node2)) {
          return true;
        }
        return !astUtils2.isTopLevelExpressionStatement(node2.parent);
      }
      function report(node2) {
        const leftParenToken = sourceCode2.getTokenBefore(node2);
        const rightParenToken = sourceCode2.getTokenAfter(node2);
        if (!isParenthesisedTwice(node2)) {
          if (tokensToIgnore.has(sourceCode2.getFirstToken(node2))) {
            return;
          }
          if (isIIFE(node2) && !isParenthesised(node2.callee)) {
            return;
          }
          if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {
            const commentsBeforeLeftParenToken = sourceCode2.getCommentsBefore(leftParenToken);
            const totalCommentsBeforeLeftParenTokenCount = commentsBeforeLeftParenToken.length;
            const ignorePattern = new RegExp(
              ALLOW_PARENS_AFTER_COMMENT_PATTERN,
              "u"
            );
            if (totalCommentsBeforeLeftParenTokenCount > 0 && ignorePattern.test(
              commentsBeforeLeftParenToken[totalCommentsBeforeLeftParenTokenCount - 1].value
            )) {
              return;
            }
          }
        }
        function finishReport() {
          context.report({
            node: node2,
            loc: leftParenToken.loc,
            messageId: "unexpected",
            fix: isFixable(node2) ? (fixer) => {
              const parenthesizedSource = sourceCode2.text.slice(
                leftParenToken.range[1],
                rightParenToken.range[0]
              );
              return fixer.replaceTextRange(
                [
                  leftParenToken.range[0],
                  rightParenToken.range[1]
                ],
                (requiresLeadingSpace(node2) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node2) ? " " : "")
              );
            } : null
          });
        }
        if (reportsBuffer) {
          reportsBuffer.reports.push({ node: node2, finishReport });
          return;
        }
        finishReport();
      }
      function checkArgumentWithPrecedence(node2) {
        if (hasExcessParensWithPrecedence(node2.argument, precedence(node2))) {
          report(node2.argument);
        }
      }
      function doesMemberExpressionContainCallExpression(node2) {
        let currentNode = node2.object;
        let currentNodeType = node2.object.type;
        while (currentNodeType === "MemberExpression") {
          currentNode = currentNode.object;
          currentNodeType = currentNode.type;
        }
        return currentNodeType === "CallExpression";
      }
      function checkCallNew(node2) {
        const callee = node2.callee;
        if (hasExcessParensWithPrecedence(callee, precedence(node2))) {
          if (hasDoubleExcessParens(callee) || !(isIIFE(node2) || // (new A)(); new (new A)();
          callee.type === "NewExpression" && !isNewExpressionWithParens(callee) && !(node2.type === "NewExpression" && !isNewExpressionWithParens(node2)) || // new (a().b)(); new (a.b().c);
          node2.type === "NewExpression" && callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(
            callee
          ) || // (a?.b)(); (a?.())();
          !node2.optional && callee.type === "ChainExpression")) {
            report(node2.callee);
          }
        }
        node2.arguments.filter(
          (arg) => hasExcessParensWithPrecedence(
            arg,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )
        ).forEach(report);
      }
      function checkBinaryLogical(node2) {
        const prec2 = precedence(node2);
        const leftPrecedence = precedence(node2.left);
        const rightPrecedence = precedence(node2.right);
        const isExponentiation = node2.operator === "**";
        const shouldSkipLeft = NESTED_BINARY && (node2.left.type === "BinaryExpression" || node2.left.type === "LogicalExpression");
        const shouldSkipRight = NESTED_BINARY && (node2.right.type === "BinaryExpression" || node2.right.type === "LogicalExpression");
        if (!shouldSkipLeft && hasExcessParens(node2.left)) {
          if (!(["AwaitExpression", "UnaryExpression"].includes(
            node2.left.type
          ) && isExponentiation) && !astUtils2.isMixedLogicalAndCoalesceExpressions(
            node2.left,
            node2
          ) && (leftPrecedence > prec2 || leftPrecedence === prec2 && !isExponentiation) || isParenthesisedTwice(node2.left)) {
            report(node2.left);
          }
        }
        if (!shouldSkipRight && hasExcessParens(node2.right)) {
          if (!astUtils2.isMixedLogicalAndCoalesceExpressions(
            node2.right,
            node2
          ) && (rightPrecedence > prec2 || rightPrecedence === prec2 && isExponentiation) || isParenthesisedTwice(node2.right)) {
            report(node2.right);
          }
        }
      }
      function checkClass(node2) {
        if (!node2.superClass) {
          return;
        }
        const hasExtraParens = precedence(node2.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node2.superClass) : hasDoubleExcessParens(node2.superClass);
        if (hasExtraParens) {
          report(node2.superClass);
        }
      }
      function checkSpreadOperator(node2) {
        if (hasExcessParensWithPrecedence(
          node2.argument,
          PRECEDENCE_OF_ASSIGNMENT_EXPR
        )) {
          report(node2.argument);
        }
      }
      function checkExpressionOrExportStatement(node2) {
        const firstToken = isParenthesised(node2) ? sourceCode2.getTokenBefore(node2) : sourceCode2.getFirstToken(node2);
        const secondToken = sourceCode2.getTokenAfter(
          firstToken,
          astUtils2.isNotOpeningParenToken
        );
        const thirdToken = secondToken ? sourceCode2.getTokenAfter(secondToken) : null;
        const tokenAfterClosingParens = secondToken ? sourceCode2.getTokenAfter(
          secondToken,
          astUtils2.isNotClosingParenToken
        ) : null;
        if (astUtils2.isOpeningParenToken(firstToken) && (astUtils2.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && tokenAfterClosingParens && (astUtils2.isOpeningBracketToken(
          tokenAfterClosingParens
        ) || tokenAfterClosingParens.type === "Identifier")) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
          tokensToIgnore.add(secondToken);
        }
        const hasExtraParens = node2.parent.type === "ExportDefaultDeclaration" ? hasExcessParensWithPrecedence(
          node2,
          PRECEDENCE_OF_ASSIGNMENT_EXPR
        ) : hasExcessParens(node2);
        if (hasExtraParens) {
          report(node2);
        }
      }
      function pathToAncestor(node2, ancestor) {
        const path = [node2];
        let currentNode = node2;
        while (currentNode !== ancestor) {
          currentNode = currentNode.parent;
          if (currentNode === null) {
            throw new Error(
              "Nodes are not in the ancestor-descendant relationship."
            );
          }
          path.push(currentNode);
        }
        return path;
      }
      function pathToDescendant(node2, descendant) {
        return pathToAncestor(descendant, node2).reverse();
      }
      function isSafelyEnclosingInExpression(node2, child) {
        switch (node2.type) {
          case "ArrayExpression":
          case "ArrayPattern":
          case "BlockStatement":
          case "ObjectExpression":
          case "ObjectPattern":
          case "TemplateLiteral":
            return true;
          case "ArrowFunctionExpression":
          case "FunctionExpression":
            return node2.params.includes(child);
          case "CallExpression":
          case "NewExpression":
            return node2.arguments.includes(child);
          case "MemberExpression":
            return node2.computed && node2.property === child;
          case "ConditionalExpression":
            return node2.consequent === child;
          default:
            return false;
        }
      }
      function startNewReportsBuffering() {
        reportsBuffer = {
          upper: reportsBuffer,
          inExpressionNodes: [],
          reports: []
        };
      }
      function endCurrentReportsBuffering() {
        const { upper, inExpressionNodes, reports } = reportsBuffer;
        if (upper) {
          upper.inExpressionNodes.push(...inExpressionNodes);
          upper.reports.push(...reports);
        } else {
          reports.forEach(({ finishReport }) => finishReport());
        }
        reportsBuffer = upper;
      }
      function isInCurrentReportsBuffer(node2) {
        return reportsBuffer.reports.some((r2) => r2.node === node2);
      }
      function removeFromCurrentReportsBuffer(node2) {
        reportsBuffer.reports = reportsBuffer.reports.filter(
          (r2) => r2.node !== node2
        );
      }
      function isMemberExpInNewCallee(node2) {
        if (node2.type === "MemberExpression") {
          return node2.parent.type === "NewExpression" && node2.parent.callee === node2 ? true : node2.parent.object === node2 && isMemberExpInNewCallee(node2.parent);
        }
        return false;
      }
      function isAnonymousFunctionAssignmentException({
        left,
        operator: operator2,
        right
      }) {
        if (left.type === "Identifier" && ["=", "&&=", "||=", "??="].includes(operator2)) {
          const rhsType = right.type;
          if (rhsType === "ArrowFunctionExpression") {
            return true;
          }
          if ((rhsType === "FunctionExpression" || rhsType === "ClassExpression") && !right.id) {
            return true;
          }
        }
        return false;
      }
      return {
        ArrayExpression(node2) {
          node2.elements.filter(
            (e2) => e2 && hasExcessParensWithPrecedence(
              e2,
              PRECEDENCE_OF_ASSIGNMENT_EXPR
            )
          ).forEach(report);
        },
        ArrayPattern(node2) {
          node2.elements.filter((e2) => canBeAssignmentTarget(e2) && hasExcessParens(e2)).forEach(report);
        },
        ArrowFunctionExpression(node2) {
          if (isReturnAssignException(node2)) {
            return;
          }
          if (node2.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS) {
            return;
          }
          if (node2.body.type !== "BlockStatement") {
            const firstBodyToken = sourceCode2.getFirstToken(
              node2.body,
              astUtils2.isNotOpeningParenToken
            );
            const tokenBeforeFirst = sourceCode2.getTokenBefore(firstBodyToken);
            if (astUtils2.isOpeningParenToken(tokenBeforeFirst) && astUtils2.isOpeningBraceToken(firstBodyToken)) {
              tokensToIgnore.add(firstBodyToken);
            }
            if (hasExcessParensWithPrecedence(
              node2.body,
              PRECEDENCE_OF_ASSIGNMENT_EXPR
            )) {
              report(node2.body);
            }
          }
        },
        AssignmentExpression(node2) {
          if (canBeAssignmentTarget(node2.left) && hasExcessParens(node2.left) && (!isAnonymousFunctionAssignmentException(node2) || isParenthesisedTwice(node2.left))) {
            report(node2.left);
          }
          if (!isReturnAssignException(node2) && hasExcessParensWithPrecedence(node2.right, precedence(node2))) {
            report(node2.right);
          }
        },
        BinaryExpression(node2) {
          if (reportsBuffer && node2.operator === "in") {
            reportsBuffer.inExpressionNodes.push(node2);
          }
          checkBinaryLogical(node2);
        },
        CallExpression: checkCallNew,
        ConditionalExpression(node2) {
          if (isReturnAssignException(node2)) {
            return;
          }
          const availableTypes = /* @__PURE__ */ new Set([
            "BinaryExpression",
            "LogicalExpression"
          ]);
          if (!(EXCEPT_COND_TERNARY && availableTypes.has(node2.test.type)) && !isCondAssignException(node2) && hasExcessParensWithPrecedence(
            node2.test,
            precedence({
              type: "LogicalExpression",
              operator: "||"
            })
          )) {
            report(node2.test);
          }
          if (!(EXCEPT_COND_TERNARY && availableTypes.has(node2.consequent.type)) && hasExcessParensWithPrecedence(
            node2.consequent,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(node2.consequent);
          }
          if (!(EXCEPT_COND_TERNARY && availableTypes.has(node2.alternate.type)) && hasExcessParensWithPrecedence(
            node2.alternate,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(node2.alternate);
          }
        },
        DoWhileStatement(node2) {
          if (hasExcessParens(node2.test) && !isCondAssignException(node2)) {
            report(node2.test);
          }
        },
        ExportDefaultDeclaration: (node2) => checkExpressionOrExportStatement(node2.declaration),
        ExpressionStatement: (node2) => checkExpressionOrExportStatement(node2.expression),
        ForInStatement(node2) {
          if (node2.left.type !== "VariableDeclaration") {
            const firstLeftToken = sourceCode2.getFirstToken(
              node2.left,
              astUtils2.isNotOpeningParenToken
            );
            if (firstLeftToken.value === "let" && astUtils2.isOpeningBracketToken(
              sourceCode2.getTokenAfter(
                firstLeftToken,
                astUtils2.isNotClosingParenToken
              )
            )) {
              tokensToIgnore.add(firstLeftToken);
            }
          }
          if (hasExcessParens(node2.left)) {
            report(node2.left);
          }
          if (hasExcessParens(node2.right)) {
            report(node2.right);
          }
        },
        ForOfStatement(node2) {
          if (node2.left.type !== "VariableDeclaration") {
            const firstLeftToken = sourceCode2.getFirstToken(
              node2.left,
              astUtils2.isNotOpeningParenToken
            );
            if (firstLeftToken.value === "let") {
              tokensToIgnore.add(firstLeftToken);
            }
          }
          if (hasExcessParens(node2.left)) {
            report(node2.left);
          }
          if (hasExcessParensWithPrecedence(
            node2.right,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(node2.right);
          }
        },
        ForStatement(node2) {
          if (node2.test && hasExcessParens(node2.test) && !isCondAssignException(node2)) {
            report(node2.test);
          }
          if (node2.update && hasExcessParens(node2.update)) {
            report(node2.update);
          }
          if (node2.init) {
            if (node2.init.type !== "VariableDeclaration") {
              const firstToken = sourceCode2.getFirstToken(
                node2.init,
                astUtils2.isNotOpeningParenToken
              );
              if (firstToken.value === "let" && astUtils2.isOpeningBracketToken(
                sourceCode2.getTokenAfter(
                  firstToken,
                  astUtils2.isNotClosingParenToken
                )
              )) {
                tokensToIgnore.add(firstToken);
              }
            }
            startNewReportsBuffering();
            if (hasExcessParens(node2.init)) {
              report(node2.init);
            }
          }
        },
        "ForStatement > *.init:exit"(node2) {
          if (reportsBuffer.reports.length) {
            reportsBuffer.inExpressionNodes.forEach(
              (inExpressionNode) => {
                const path = pathToDescendant(
                  node2,
                  inExpressionNode
                );
                let nodeToExclude;
                for (let i2 = 0; i2 < path.length; i2++) {
                  const pathNode = path[i2];
                  if (i2 < path.length - 1) {
                    const nextPathNode = path[i2 + 1];
                    if (isSafelyEnclosingInExpression(
                      pathNode,
                      nextPathNode
                    )) {
                      return;
                    }
                  }
                  if (isParenthesised(pathNode)) {
                    if (isInCurrentReportsBuffer(pathNode)) {
                      if (isParenthesisedTwice(pathNode)) {
                        return;
                      }
                      if (!nodeToExclude) {
                        nodeToExclude = pathNode;
                      }
                    } else {
                      return;
                    }
                  }
                }
                removeFromCurrentReportsBuffer(nodeToExclude);
              }
            );
          }
          endCurrentReportsBuffering();
        },
        IfStatement(node2) {
          if (hasExcessParens(node2.test) && !isCondAssignException(node2)) {
            report(node2.test);
          }
        },
        ImportExpression(node2) {
          const { source } = node2;
          if (source.type === "SequenceExpression") {
            if (hasDoubleExcessParens(source)) {
              report(source);
            }
          } else if (hasExcessParens(source)) {
            report(source);
          }
        },
        LogicalExpression: checkBinaryLogical,
        MemberExpression(node2) {
          const shouldAllowWrapOnce = isMemberExpInNewCallee(node2) && doesMemberExpressionContainCallExpression(node2);
          const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node2.object) : hasExcessParens(node2.object) && !(isImmediateFunctionPrototypeMethodCall(
            node2.parent
          ) && node2.parent.callee === node2 && IGNORE_FUNCTION_PROTOTYPE_METHODS);
          if (nodeObjHasExcessParens && precedence(node2.object) >= precedence(node2) && (node2.computed || !(astUtils2.isDecimalInteger(node2.object) || // RegExp literal is allowed to have parens (#1589)
          node2.object.type === "Literal" && node2.object.regex))) {
            report(node2.object);
          }
          if (nodeObjHasExcessParens && node2.object.type === "CallExpression") {
            report(node2.object);
          }
          if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node2.object.type === "NewExpression" && isNewExpressionWithParens(node2.object)) {
            report(node2.object);
          }
          if (nodeObjHasExcessParens && node2.optional && node2.object.type === "ChainExpression") {
            report(node2.object);
          }
          if (node2.computed && hasExcessParens(node2.property)) {
            report(node2.property);
          }
        },
        "MethodDefinition[computed=true]"(node2) {
          if (hasExcessParensWithPrecedence(
            node2.key,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(node2.key);
          }
        },
        NewExpression: checkCallNew,
        ObjectExpression(node2) {
          node2.properties.filter(
            (property) => property.value && hasExcessParensWithPrecedence(
              property.value,
              PRECEDENCE_OF_ASSIGNMENT_EXPR
            )
          ).forEach((property) => report(property.value));
        },
        ObjectPattern(node2) {
          node2.properties.filter((property) => {
            const value = property.value;
            return canBeAssignmentTarget(value) && hasExcessParens(value);
          }).forEach((property) => report(property.value));
        },
        Property(node2) {
          if (node2.computed) {
            const { key } = node2;
            if (key && hasExcessParensWithPrecedence(
              key,
              PRECEDENCE_OF_ASSIGNMENT_EXPR
            )) {
              report(key);
            }
          }
        },
        PropertyDefinition(node2) {
          if (node2.computed && hasExcessParensWithPrecedence(
            node2.key,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(node2.key);
          }
          if (node2.value && hasExcessParensWithPrecedence(
            node2.value,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(node2.value);
          }
        },
        RestElement(node2) {
          const argument = node2.argument;
          if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {
            report(argument);
          }
        },
        ReturnStatement(node2) {
          const returnToken = sourceCode2.getFirstToken(node2);
          if (isReturnAssignException(node2)) {
            return;
          }
          if (node2.argument && hasExcessParensNoLineTerminator(
            returnToken,
            node2.argument
          ) && // RegExp literal is allowed to have parens (#1589)
          !(node2.argument.type === "Literal" && node2.argument.regex)) {
            report(node2.argument);
          }
        },
        SequenceExpression(node2) {
          const precedenceOfNode = precedence(node2);
          node2.expressions.filter(
            (e2) => hasExcessParensWithPrecedence(e2, precedenceOfNode)
          ).forEach(report);
        },
        SwitchCase(node2) {
          if (node2.test && hasExcessParens(node2.test)) {
            report(node2.test);
          }
        },
        SwitchStatement(node2) {
          if (hasExcessParens(node2.discriminant)) {
            report(node2.discriminant);
          }
        },
        ThrowStatement(node2) {
          const throwToken = sourceCode2.getFirstToken(node2);
          if (hasExcessParensNoLineTerminator(throwToken, node2.argument)) {
            report(node2.argument);
          }
        },
        UnaryExpression: checkArgumentWithPrecedence,
        UpdateExpression(node2) {
          if (node2.prefix) {
            checkArgumentWithPrecedence(node2);
          } else {
            const { argument } = node2;
            const operatorToken2 = sourceCode2.getLastToken(node2);
            if (argument.loc.end.line === operatorToken2.loc.start.line) {
              checkArgumentWithPrecedence(node2);
            } else {
              if (hasDoubleExcessParens(argument)) {
                report(argument);
              }
            }
          }
        },
        AwaitExpression: checkArgumentWithPrecedence,
        VariableDeclarator(node2) {
          if (node2.init && hasExcessParensWithPrecedence(
            node2.init,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          ) && // RegExp literal is allowed to have parens (#1589)
          !(node2.init.type === "Literal" && node2.init.regex)) {
            report(node2.init);
          }
        },
        WhileStatement(node2) {
          if (hasExcessParens(node2.test) && !isCondAssignException(node2)) {
            report(node2.test);
          }
        },
        WithStatement(node2) {
          if (hasExcessParens(node2.object)) {
            report(node2.object);
          }
        },
        YieldExpression(node2) {
          if (node2.argument) {
            const yieldToken = sourceCode2.getFirstToken(node2);
            if (precedence(node2.argument) >= precedence(node2) && hasExcessParensNoLineTerminator(
              yieldToken,
              node2.argument
            ) || hasDoubleExcessParens(node2.argument)) {
              report(node2.argument);
            }
          }
        },
        ClassDeclaration: checkClass,
        ClassExpression: checkClass,
        SpreadElement: checkSpreadOperator,
        SpreadProperty: checkSpreadOperator,
        ExperimentalSpreadProperty: checkSpreadOperator,
        TemplateLiteral(node2) {
          node2.expressions.filter((e2) => e2 && hasExcessParens(e2)).forEach(report);
        },
        AssignmentPattern(node2) {
          const { left, right } = node2;
          if (canBeAssignmentTarget(left) && hasExcessParens(left)) {
            report(left);
          }
          if (right && hasExcessParensWithPrecedence(
            right,
            PRECEDENCE_OF_ASSIGNMENT_EXPR
          )) {
            report(right);
          }
        }
      };
    }
  };
  return noExtraParens;
}
var noExtraSemi;
var hasRequiredNoExtraSemi;
function requireNoExtraSemi() {
  if (hasRequiredNoExtraSemi) return noExtraSemi;
  hasRequiredNoExtraSemi = 1;
  const FixTracker = requireFixTracker();
  const astUtils2 = requireAstUtils();
  noExtraSemi = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-extra-semi",
              url: "https://eslint.style/rules/no-extra-semi"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary semicolons",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-extra-semi"
      },
      fixable: "code",
      schema: [],
      messages: {
        unexpected: "Unnecessary semicolon."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function isFixable(nodeOrToken) {
        const nextToken = sourceCode2.getTokenAfter(nodeOrToken);
        if (!nextToken || nextToken.type !== "String") {
          return true;
        }
        const stringNode = sourceCode2.getNodeByRangeIndex(
          nextToken.range[0]
        );
        return !astUtils2.isTopLevelExpressionStatement(stringNode.parent);
      }
      function report(nodeOrToken) {
        context.report({
          node: nodeOrToken,
          messageId: "unexpected",
          fix: isFixable(nodeOrToken) ? (fixer) => (
            /*
             * Expand the replacement range to include the surrounding
             * tokens to avoid conflicting with semi.
             * https://github.com/eslint/eslint/issues/7928
             */
            new FixTracker(fixer, context.sourceCode).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken)
          ) : null
        });
      }
      function checkForPartOfClassBody(firstToken) {
        for (let token = firstToken; token.type === "Punctuator" && !astUtils2.isClosingBraceToken(token); token = sourceCode2.getTokenAfter(token)) {
          if (astUtils2.isSemicolonToken(token)) {
            report(token);
          }
        }
      }
      return {
        /**
         * Reports this empty statement, except if the parent node is a loop.
         * @param {Node} node A EmptyStatement node to be reported.
         * @returns {void}
         */
        EmptyStatement(node2) {
          const parent = node2.parent, allowedParentTypes = [
            "ForStatement",
            "ForInStatement",
            "ForOfStatement",
            "WhileStatement",
            "DoWhileStatement",
            "IfStatement",
            "LabeledStatement",
            "WithStatement"
          ];
          if (!allowedParentTypes.includes(parent.type)) {
            report(node2);
          }
        },
        /**
         * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
         * @param {Node} node A ClassBody node to check.
         * @returns {void}
         */
        ClassBody(node2) {
          checkForPartOfClassBody(sourceCode2.getFirstToken(node2, 1));
        },
        /**
         * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
         * @param {Node} node A MethodDefinition node of the start point.
         * @returns {void}
         */
        "MethodDefinition, PropertyDefinition, StaticBlock"(node2) {
          checkForPartOfClassBody(sourceCode2.getTokenAfter(node2));
        }
      };
    }
  };
  return noExtraSemi;
}
var noFallthrough;
var hasRequiredNoFallthrough;
function requireNoFallthrough() {
  if (hasRequiredNoFallthrough) return noFallthrough;
  hasRequiredNoFallthrough = 1;
  const { directivesPattern } = requireDirectives();
  const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;
  function isAnySegmentReachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return true;
      }
    }
    return false;
  }
  function isFallThroughComment(comment2, fallthroughCommentPattern) {
    return fallthroughCommentPattern.test(comment2) && !directivesPattern.test(comment2.trim());
  }
  function getFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {
    const sourceCode2 = context.sourceCode;
    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === "BlockStatement") {
      const trailingCloseBrace = sourceCode2.getLastToken(
        caseWhichFallsThrough.consequent[0]
      );
      const commentInBlock = sourceCode2.getCommentsBefore(trailingCloseBrace).pop();
      if (commentInBlock && isFallThroughComment(
        commentInBlock.value,
        fallthroughCommentPattern
      )) {
        return commentInBlock;
      }
    }
    const comment2 = sourceCode2.getCommentsBefore(subsequentCase).pop();
    if (comment2 && isFallThroughComment(comment2.value, fallthroughCommentPattern)) {
      return comment2;
    }
    return null;
  }
  function hasBlankLinesBetween(node2, token) {
    return token.loc.start.line > node2.loc.end.line + 1;
  }
  noFallthrough = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowEmptyCase: false,
          reportUnusedFallthroughComment: false
        }
      ],
      docs: {
        description: "Disallow fallthrough of `case` statements",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-fallthrough"
      },
      schema: [
        {
          type: "object",
          properties: {
            commentPattern: {
              type: "string"
            },
            allowEmptyCase: {
              type: "boolean"
            },
            reportUnusedFallthroughComment: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unusedFallthroughComment: "Found a comment that would permit fallthrough, but case cannot fall through.",
        case: "Expected a 'break' statement before 'case'.",
        default: "Expected a 'break' statement before 'default'."
      }
    },
    create(context) {
      const codePathSegments = [];
      let currentCodePathSegments = /* @__PURE__ */ new Set();
      const sourceCode2 = context.sourceCode;
      const [
        { allowEmptyCase, commentPattern, reportUnusedFallthroughComment }
      ] = context.options;
      const fallthroughCommentPattern = commentPattern ? new RegExp(commentPattern, "u") : DEFAULT_FALLTHROUGH_COMMENT;
      let previousCase = null;
      return {
        onCodePathStart() {
          codePathSegments.push(currentCodePathSegments);
          currentCodePathSegments = /* @__PURE__ */ new Set();
        },
        onCodePathEnd() {
          currentCodePathSegments = codePathSegments.pop();
        },
        onUnreachableCodePathSegmentStart(segment) {
          currentCodePathSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          currentCodePathSegments.delete(segment);
        },
        onCodePathSegmentStart(segment) {
          currentCodePathSegments.add(segment);
        },
        onCodePathSegmentEnd(segment) {
          currentCodePathSegments.delete(segment);
        },
        SwitchCase(node2) {
          if (previousCase && previousCase.node.parent === node2.parent) {
            const previousCaseFallthroughComment = getFallthroughComment(
              previousCase.node,
              node2,
              context,
              fallthroughCommentPattern
            );
            if (previousCase.isFallthrough && !previousCaseFallthroughComment) {
              context.report({
                messageId: node2.test ? "case" : "default",
                node: node2
              });
            } else if (reportUnusedFallthroughComment && !previousCase.isSwitchExitReachable && previousCaseFallthroughComment) {
              context.report({
                messageId: "unusedFallthroughComment",
                node: previousCaseFallthroughComment
              });
            }
          }
          previousCase = null;
        },
        "SwitchCase:exit"(node2) {
          const nextToken = sourceCode2.getTokenAfter(node2);
          const isSwitchExitReachable = isAnySegmentReachable(
            currentCodePathSegments
          );
          const isFallthrough = isSwitchExitReachable && (node2.consequent.length > 0 || !allowEmptyCase && hasBlankLinesBetween(node2, nextToken)) && node2.parent.cases.at(-1) !== node2;
          previousCase = {
            node: node2,
            isSwitchExitReachable,
            isFallthrough
          };
        }
      };
    }
  };
  return noFallthrough;
}
var noFloatingDecimal;
var hasRequiredNoFloatingDecimal;
function requireNoFloatingDecimal() {
  if (hasRequiredNoFloatingDecimal) return noFloatingDecimal;
  hasRequiredNoFloatingDecimal = 1;
  const astUtils2 = requireAstUtils();
  noFloatingDecimal = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-floating-decimal",
              url: "https://eslint.style/rules/no-floating-decimal"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow leading or trailing decimal points in numeric literals",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-floating-decimal"
      },
      schema: [],
      fixable: "code",
      messages: {
        leading: "A leading decimal point can be confused with a dot.",
        trailing: "A trailing decimal point can be confused with a dot."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        Literal(node2) {
          if (typeof node2.value === "number") {
            if (node2.raw.startsWith(".")) {
              context.report({
                node: node2,
                messageId: "leading",
                fix(fixer) {
                  const tokenBefore = sourceCode2.getTokenBefore(node2);
                  const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node2.range[0] && !astUtils2.canTokensBeAdjacent(
                    tokenBefore,
                    `0${node2.raw}`
                  );
                  return fixer.insertTextBefore(
                    node2,
                    needsSpaceBefore ? " 0" : "0"
                  );
                }
              });
            }
            if (node2.raw.indexOf(".") === node2.raw.length - 1) {
              context.report({
                node: node2,
                messageId: "trailing",
                fix: (fixer) => fixer.insertTextAfter(node2, "0")
              });
            }
          }
        }
      };
    }
  };
  return noFloatingDecimal;
}
var noFuncAssign;
var hasRequiredNoFuncAssign;
function requireNoFuncAssign() {
  if (hasRequiredNoFuncAssign) return noFuncAssign;
  hasRequiredNoFuncAssign = 1;
  const astUtils2 = requireAstUtils();
  noFuncAssign = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow reassigning `function` declarations",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-func-assign"
      },
      schema: [],
      messages: {
        isAFunction: "'{{name}}' is a function."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkReference(references) {
        astUtils2.getModifyingReferences(references).forEach((reference) => {
          context.report({
            node: reference.identifier,
            messageId: "isAFunction",
            data: {
              name: reference.identifier.name
            }
          });
        });
      }
      function checkVariable(variable) {
        if (variable.defs[0].type === "FunctionName") {
          checkReference(variable.references);
        }
      }
      function checkForFunction(node2) {
        sourceCode2.getDeclaredVariables(node2).forEach(checkVariable);
      }
      return {
        FunctionDeclaration: checkForFunction,
        FunctionExpression: checkForFunction
      };
    }
  };
  return noFuncAssign;
}
var noGlobalAssign;
var hasRequiredNoGlobalAssign;
function requireNoGlobalAssign() {
  if (hasRequiredNoGlobalAssign) return noGlobalAssign;
  hasRequiredNoGlobalAssign = 1;
  noGlobalAssign = {
    meta: {
      type: "suggestion",
      defaultOptions: [{ exceptions: [] }],
      docs: {
        description: "Disallow assignments to native objects or read-only global variables",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-global-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: { type: "string" },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ exceptions }] = context.options;
      function checkReference(reference, index, references) {
        const identifier = reference.identifier;
        if (reference.init === false && reference.isWrite() && /*
         * Destructuring assignments can have multiple default value,
         * so possibly there are multiple writeable references for the same identifier.
         */
        (index === 0 || references[index - 1].identifier !== identifier)) {
          context.report({
            node: identifier,
            messageId: "globalShouldNotBeModified",
            data: {
              name: identifier.name
            }
          });
        }
      }
      function checkVariable(variable) {
        if (variable.writeable === false && !exceptions.includes(variable.name)) {
          variable.references.forEach(checkReference);
        }
      }
      return {
        Program(node2) {
          const globalScope = sourceCode2.getScope(node2);
          globalScope.variables.forEach(checkVariable);
        }
      };
    }
  };
  return noGlobalAssign;
}
var noImplicitCoercion;
var hasRequiredNoImplicitCoercion;
function requireNoImplicitCoercion() {
  if (hasRequiredNoImplicitCoercion) return noImplicitCoercion;
  hasRequiredNoImplicitCoercion = 1;
  const astUtils2 = requireAstUtils();
  const INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;
  const ALLOWABLE_OPERATORS = ["~", "!!", "+", "- -", "-", "*"];
  function isDoubleLogicalNegating(node2) {
    return node2.operator === "!" && node2.argument.type === "UnaryExpression" && node2.argument.operator === "!";
  }
  function isBinaryNegatingOfIndexOf(node2) {
    if (node2.operator !== "~") {
      return false;
    }
    const callNode = astUtils2.skipChainExpression(node2.argument);
    return callNode.type === "CallExpression" && astUtils2.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);
  }
  function isMultiplyByOne(node2) {
    return node2.operator === "*" && (node2.left.type === "Literal" && node2.left.value === 1 || node2.right.type === "Literal" && node2.right.value === 1);
  }
  function isMultiplyByFractionOfOne(node2, sourceCode2) {
    return node2.type === "BinaryExpression" && node2.operator === "*" && node2.right.type === "Literal" && node2.right.value === 1 && node2.parent.type === "BinaryExpression" && node2.parent.operator === "/" && node2.parent.left === node2 && !astUtils2.isParenthesised(sourceCode2, node2);
  }
  function isNumeric(node2) {
    return node2.type === "Literal" && typeof node2.value === "number" || node2.type === "CallExpression" && (node2.callee.name === "Number" || node2.callee.name === "parseInt" || node2.callee.name === "parseFloat");
  }
  function getNonNumericOperand(node2) {
    const left = node2.left, right = node2.right;
    if (right.type !== "BinaryExpression" && !isNumeric(right)) {
      return right;
    }
    if (left.type !== "BinaryExpression" && !isNumeric(left)) {
      return left;
    }
    return null;
  }
  function isStringType(node2) {
    return astUtils2.isStringLiteral(node2) || node2.type === "CallExpression" && node2.callee.type === "Identifier" && node2.callee.name === "String";
  }
  function isEmptyString(node2) {
    return astUtils2.isStringLiteral(node2) && (node2.value === "" || node2.type === "TemplateLiteral" && node2.quasis.length === 1 && node2.quasis[0].value.cooked === "");
  }
  function isConcatWithEmptyString(node2) {
    return node2.operator === "+" && (isEmptyString(node2.left) && !isStringType(node2.right) || isEmptyString(node2.right) && !isStringType(node2.left));
  }
  function isAppendEmptyString(node2) {
    return node2.operator === "+=" && isEmptyString(node2.right);
  }
  function getNonEmptyOperand(node2) {
    return isEmptyString(node2.left) ? node2.right : node2.left;
  }
  noImplicitCoercion = {
    meta: {
      hasSuggestions: true,
      type: "suggestion",
      docs: {
        description: "Disallow shorthand type conversions",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-implicit-coercion"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            boolean: {
              type: "boolean"
            },
            number: {
              type: "boolean"
            },
            string: {
              type: "boolean"
            },
            disallowTemplateShorthand: {
              type: "boolean"
            },
            allow: {
              type: "array",
              items: {
                enum: ALLOWABLE_OPERATORS
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      defaultOptions: [
        {
          allow: [],
          boolean: true,
          disallowTemplateShorthand: false,
          number: true,
          string: true
        }
      ],
      messages: {
        implicitCoercion: "Unexpected implicit coercion encountered. Use `{{recommendation}}` instead.",
        useRecommendation: "Use `{{recommendation}}` instead."
      }
    },
    create(context) {
      const [options] = context.options;
      const sourceCode2 = context.sourceCode;
      function report(node2, recommendation, shouldSuggest, shouldFix) {
        function fix(fixer) {
          const tokenBefore = sourceCode2.getTokenBefore(node2);
          if ((tokenBefore == null ? void 0 : tokenBefore.range[1]) === node2.range[0] && !astUtils2.canTokensBeAdjacent(tokenBefore, recommendation)) {
            return fixer.replaceText(node2, ` ${recommendation}`);
          }
          return fixer.replaceText(node2, recommendation);
        }
        context.report({
          node: node2,
          messageId: "implicitCoercion",
          data: { recommendation },
          fix(fixer) {
            if (!shouldFix) {
              return null;
            }
            return fix(fixer);
          },
          suggest: [
            {
              messageId: "useRecommendation",
              data: { recommendation },
              fix(fixer) {
                if (shouldFix || !shouldSuggest) {
                  return null;
                }
                return fix(fixer);
              }
            }
          ]
        });
      }
      return {
        UnaryExpression(node2) {
          let operatorAllowed;
          operatorAllowed = options.allow.includes("!!");
          if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node2)) {
            const recommendation = `Boolean(${sourceCode2.getText(node2.argument.argument)})`;
            const variable = astUtils2.getVariableByName(
              sourceCode2.getScope(node2),
              "Boolean"
            );
            const booleanExists = (variable == null ? void 0 : variable.identifiers.length) === 0;
            report(node2, recommendation, true, booleanExists);
          }
          operatorAllowed = options.allow.includes("~");
          if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node2)) {
            const comparison = node2.argument.type === "ChainExpression" ? ">= 0" : "!== -1";
            const recommendation = `${sourceCode2.getText(node2.argument)} ${comparison}`;
            report(node2, recommendation, false, false);
          }
          operatorAllowed = options.allow.includes("+");
          if (!operatorAllowed && options.number && node2.operator === "+" && !isNumeric(node2.argument)) {
            const recommendation = `Number(${sourceCode2.getText(node2.argument)})`;
            report(node2, recommendation, true, false);
          }
          operatorAllowed = options.allow.includes("- -");
          if (!operatorAllowed && options.number && node2.operator === "-" && node2.argument.type === "UnaryExpression" && node2.argument.operator === "-" && !isNumeric(node2.argument.argument)) {
            const recommendation = `Number(${sourceCode2.getText(node2.argument.argument)})`;
            report(node2, recommendation, true, false);
          }
        },
        // Use `:exit` to prevent double reporting
        "BinaryExpression:exit"(node2) {
          let operatorAllowed;
          operatorAllowed = options.allow.includes("*");
          const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node2) && !isMultiplyByFractionOfOne(node2, sourceCode2) && getNonNumericOperand(node2);
          if (nonNumericOperand) {
            const recommendation = `Number(${sourceCode2.getText(nonNumericOperand)})`;
            report(node2, recommendation, true, false);
          }
          operatorAllowed = options.allow.includes("-");
          if (!operatorAllowed && options.number && node2.operator === "-" && node2.right.type === "Literal" && node2.right.value === 0 && !isNumeric(node2.left)) {
            const recommendation = `Number(${sourceCode2.getText(node2.left)})`;
            report(node2, recommendation, true, false);
          }
          operatorAllowed = options.allow.includes("+");
          if (!operatorAllowed && options.string && isConcatWithEmptyString(node2)) {
            const recommendation = `String(${sourceCode2.getText(getNonEmptyOperand(node2))})`;
            report(node2, recommendation, true, false);
          }
        },
        AssignmentExpression(node2) {
          const operatorAllowed = options.allow.includes("+");
          if (!operatorAllowed && options.string && isAppendEmptyString(node2)) {
            const code2 = sourceCode2.getText(getNonEmptyOperand(node2));
            const recommendation = `${code2} = String(${code2})`;
            report(node2, recommendation, true, false);
          }
        },
        TemplateLiteral(node2) {
          if (!options.disallowTemplateShorthand) {
            return;
          }
          if (node2.parent.type === "TaggedTemplateExpression") {
            return;
          }
          if (node2.expressions.length !== 1) {
            return;
          }
          if (node2.quasis[0].value.cooked !== "") {
            return;
          }
          if (node2.quasis[1].value.cooked !== "") {
            return;
          }
          if (isStringType(node2.expressions[0])) {
            return;
          }
          const code2 = sourceCode2.getText(node2.expressions[0]);
          const recommendation = `String(${code2})`;
          report(node2, recommendation, true, false);
        }
      };
    }
  };
  return noImplicitCoercion;
}
var noImplicitGlobals;
var hasRequiredNoImplicitGlobals;
function requireNoImplicitGlobals() {
  if (hasRequiredNoImplicitGlobals) return noImplicitGlobals;
  hasRequiredNoImplicitGlobals = 1;
  const ASSIGNMENT_NODES = /* @__PURE__ */ new Set([
    "AssignmentExpression",
    "ForInStatement",
    "ForOfStatement"
  ]);
  noImplicitGlobals = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          lexicalBindings: false
        }
      ],
      docs: {
        description: "Disallow declarations in the global scope",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-implicit-globals"
      },
      schema: [
        {
          type: "object",
          properties: {
            lexicalBindings: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
        globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",
        globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.",
        assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.",
        redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable."
      }
    },
    create(context) {
      const [{ lexicalBindings: checkLexicalBindings }] = context.options;
      const sourceCode2 = context.sourceCode;
      function report(node2, messageId, kind) {
        context.report({
          node: node2,
          messageId,
          data: {
            kind
          }
        });
      }
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          scope.variables.forEach((variable) => {
            const isReadonlyEslintGlobalVariable = variable.writeable === false;
            const isWritableEslintGlobalVariable = variable.writeable === true;
            if (isWritableEslintGlobalVariable) {
              return;
            }
            if (variable.eslintExported) {
              return;
            }
            variable.defs.forEach((def) => {
              const defNode = def.node;
              if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
                if (isReadonlyEslintGlobalVariable) {
                  report(
                    defNode,
                    "redeclarationOfReadonlyGlobal"
                  );
                } else {
                  report(
                    defNode,
                    "globalNonLexicalBinding",
                    def.type === "FunctionName" ? "function" : `'${def.parent.kind}'`
                  );
                }
              }
              if (checkLexicalBindings) {
                if (def.type === "ClassName" || def.type === "Variable" && (def.parent.kind === "let" || def.parent.kind === "const")) {
                  if (isReadonlyEslintGlobalVariable) {
                    report(
                      defNode,
                      "redeclarationOfReadonlyGlobal"
                    );
                  } else {
                    report(
                      defNode,
                      "globalLexicalBinding",
                      def.type === "ClassName" ? "class" : `'${def.parent.kind}'`
                    );
                  }
                }
              }
            });
            if (isReadonlyEslintGlobalVariable && variable.defs.length === 0) {
              variable.references.forEach((reference) => {
                if (reference.isWrite() && !reference.isRead()) {
                  let assignmentParent = reference.identifier.parent;
                  while (assignmentParent && !ASSIGNMENT_NODES.has(assignmentParent.type)) {
                    assignmentParent = assignmentParent.parent;
                  }
                  report(
                    assignmentParent ?? reference.identifier,
                    "assignmentToReadonlyGlobal"
                  );
                }
              });
            }
          });
          scope.implicit.variables.forEach((variable) => {
            variable.defs.forEach((def) => {
              report(def.node, "globalVariableLeak");
            });
          });
        }
      };
    }
  };
  return noImplicitGlobals;
}
var noImpliedEval;
var hasRequiredNoImpliedEval;
function requireNoImpliedEval() {
  if (hasRequiredNoImpliedEval) return noImpliedEval;
  hasRequiredNoImpliedEval = 1;
  const astUtils2 = requireAstUtils();
  const { getStaticValue } = /* @__PURE__ */ requireEslintUtils();
  noImpliedEval = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `eval()`-like methods",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-implied-eval"
      },
      schema: [],
      messages: {
        impliedEval: "Implied eval. Consider passing a function instead of a string.",
        execScript: "Implied eval. Do not use execScript()."
      }
    },
    create(context) {
      const GLOBAL_CANDIDATES = Object.freeze([
        "global",
        "window",
        "globalThis"
      ]);
      const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;
      const sourceCode2 = context.sourceCode;
      function isEvaluatedString(node2) {
        if (node2.type === "Literal" && typeof node2.value === "string" || node2.type === "TemplateLiteral") {
          return true;
        }
        if (node2.type === "BinaryExpression" && node2.operator === "+") {
          return isEvaluatedString(node2.left) || isEvaluatedString(node2.right);
        }
        return false;
      }
      function reportImpliedEvalCallExpression(node2) {
        const [firstArgument] = node2.arguments;
        if (firstArgument) {
          const staticValue = getStaticValue(
            firstArgument,
            sourceCode2.getScope(node2)
          );
          const isStaticString = staticValue && typeof staticValue.value === "string";
          const isString = isStaticString || isEvaluatedString(firstArgument);
          if (isString) {
            const calleeName = node2.callee.type === "Identifier" ? node2.callee.name : astUtils2.getStaticPropertyName(node2.callee);
            const isExecScript = calleeName === "execScript";
            context.report({
              node: node2,
              messageId: isExecScript ? "execScript" : "impliedEval"
            });
          }
        }
      }
      function reportImpliedEvalViaGlobal(globalVar) {
        const { references, name: name2 } = globalVar;
        references.forEach((ref2) => {
          const identifier = ref2.identifier;
          let node2 = identifier.parent;
          while (astUtils2.isSpecificMemberAccess(node2, null, name2)) {
            node2 = node2.parent;
          }
          if (astUtils2.isSpecificMemberAccess(
            node2,
            null,
            EVAL_LIKE_FUNC_PATTERN
          )) {
            const calleeNode = node2.parent.type === "ChainExpression" ? node2.parent : node2;
            const parent = calleeNode.parent;
            if (parent.type === "CallExpression" && parent.callee === calleeNode) {
              reportImpliedEvalCallExpression(parent);
            }
          }
        });
      }
      return {
        CallExpression(node2) {
          if (astUtils2.isSpecificId(
            node2.callee,
            EVAL_LIKE_FUNC_PATTERN
          ) && sourceCode2.isGlobalReference(node2.callee)) {
            reportImpliedEvalCallExpression(node2);
          }
        },
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          GLOBAL_CANDIDATES.map(
            (candidate) => astUtils2.getVariableByName(globalScope, candidate)
          ).filter(
            (globalVar) => !!globalVar && globalVar.defs.length === 0
          ).forEach(reportImpliedEvalViaGlobal);
        }
      };
    }
  };
  return noImpliedEval;
}
var noImportAssign;
var hasRequiredNoImportAssign;
function requireNoImportAssign() {
  if (hasRequiredNoImportAssign) return noImportAssign;
  hasRequiredNoImportAssign = 1;
  const { findVariable } = /* @__PURE__ */ requireEslintUtils();
  const astUtils2 = requireAstUtils();
  const WellKnownMutationFunctions = {
    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,
    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u
  };
  function isAssignmentLeft(node2) {
    const { parent } = node2;
    return parent.type === "AssignmentExpression" && parent.left === node2 || // Destructuring assignments
    parent.type === "ArrayPattern" || parent.type === "Property" && parent.value === node2 && parent.parent.type === "ObjectPattern" || parent.type === "RestElement" || parent.type === "AssignmentPattern" && parent.left === node2;
  }
  function isOperandOfMutationUnaryOperator(node2) {
    const argumentNode = node2.parent.type === "ChainExpression" ? node2.parent : node2;
    const { parent } = argumentNode;
    return parent.type === "UpdateExpression" && parent.argument === argumentNode || parent.type === "UnaryExpression" && parent.operator === "delete" && parent.argument === argumentNode;
  }
  function isIterationVariable(node2) {
    const { parent } = node2;
    return parent.type === "ForInStatement" && parent.left === node2 || parent.type === "ForOfStatement" && parent.left === node2;
  }
  function isArgumentOfWellKnownMutationFunction(node2, scope) {
    const { parent } = node2;
    if (parent.type !== "CallExpression" || parent.arguments[0] !== node2) {
      return false;
    }
    const callee = astUtils2.skipChainExpression(parent.callee);
    if (!astUtils2.isSpecificMemberAccess(
      callee,
      "Object",
      WellKnownMutationFunctions.Object
    ) && !astUtils2.isSpecificMemberAccess(
      callee,
      "Reflect",
      WellKnownMutationFunctions.Reflect
    )) {
      return false;
    }
    const variable = findVariable(scope, callee.object);
    return variable !== null && variable.scope.type === "global";
  }
  function isMemberWrite(id2, scope) {
    const { parent } = id2;
    return parent.type === "MemberExpression" && parent.object === id2 && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id2, scope);
  }
  function getWriteNode(id2) {
    let node2 = id2.parent;
    while (node2 && node2.type !== "AssignmentExpression" && node2.type !== "UpdateExpression" && node2.type !== "UnaryExpression" && node2.type !== "CallExpression" && node2.type !== "ForInStatement" && node2.type !== "ForOfStatement") {
      node2 = node2.parent;
    }
    return node2 || id2;
  }
  noImportAssign = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow assigning to imported bindings",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-import-assign"
      },
      schema: [],
      messages: {
        readonly: "'{{name}}' is read-only.",
        readonlyMember: "The members of '{{name}}' are read-only."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        ImportDeclaration(node2) {
          const scope = sourceCode2.getScope(node2);
          for (const variable of sourceCode2.getDeclaredVariables(node2)) {
            const shouldCheckMembers = variable.defs.some(
              (d2) => d2.node.type === "ImportNamespaceSpecifier"
            );
            let prevIdNode = null;
            for (const reference of variable.references) {
              const idNode = reference.identifier;
              if (idNode === prevIdNode) {
                continue;
              }
              prevIdNode = idNode;
              if (reference.isWrite()) {
                context.report({
                  node: getWriteNode(idNode),
                  messageId: "readonly",
                  data: { name: idNode.name }
                });
              } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {
                context.report({
                  node: getWriteNode(idNode),
                  messageId: "readonlyMember",
                  data: { name: idNode.name }
                });
              }
            }
          }
        }
      };
    }
  };
  return noImportAssign;
}
var noInlineComments;
var hasRequiredNoInlineComments;
function requireNoInlineComments() {
  if (hasRequiredNoInlineComments) return noInlineComments;
  hasRequiredNoInlineComments = 1;
  const astUtils2 = requireAstUtils();
  noInlineComments = {
    meta: {
      type: "suggestion",
      defaultOptions: [{}],
      docs: {
        description: "Disallow inline comments after code",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-inline-comments"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignorePattern: {
              type: "string"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedInlineComment: "Unexpected comment inline with code."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ ignorePattern }] = context.options;
      const customIgnoreRegExp = ignorePattern && new RegExp(ignorePattern, "u");
      function testCodeAroundComment(node2) {
        const startLine = String(sourceCode2.lines[node2.loc.start.line - 1]), endLine = String(sourceCode2.lines[node2.loc.end.line - 1]), preamble = startLine.slice(0, node2.loc.start.column).trim(), postamble = endLine.slice(node2.loc.end.column).trim(), isPreambleEmpty = !preamble, isPostambleEmpty = !postamble;
        if (isPreambleEmpty && isPostambleEmpty) {
          return;
        }
        if (customIgnoreRegExp && customIgnoreRegExp.test(node2.value)) {
          return;
        }
        if ((isPreambleEmpty || preamble === "{") && (isPostambleEmpty || postamble === "}")) {
          const enclosingNode = sourceCode2.getNodeByRangeIndex(
            node2.range[0]
          );
          if (enclosingNode && enclosingNode.type === "JSXEmptyExpression") {
            return;
          }
        }
        if (astUtils2.isDirectiveComment(node2)) {
          return;
        }
        context.report({
          node: node2,
          messageId: "unexpectedInlineComment"
        });
      }
      return {
        Program() {
          sourceCode2.getAllComments().filter((token) => token.type !== "Shebang").forEach(testCodeAroundComment);
        }
      };
    }
  };
  return noInlineComments;
}
var noInnerDeclarations;
var hasRequiredNoInnerDeclarations;
function requireNoInnerDeclarations() {
  if (hasRequiredNoInnerDeclarations) return noInnerDeclarations;
  hasRequiredNoInnerDeclarations = 1;
  const astUtils2 = requireAstUtils();
  const validParent = /* @__PURE__ */ new Set([
    "Program",
    "StaticBlock",
    "ExportNamedDeclaration",
    "ExportDefaultDeclaration"
  ]);
  const validBlockStatementParent = /* @__PURE__ */ new Set([
    "FunctionDeclaration",
    "FunctionExpression",
    "ArrowFunctionExpression"
  ]);
  function getAllowedBodyDescription(node2) {
    let { parent } = node2;
    while (parent) {
      if (parent.type === "StaticBlock") {
        return "class static block body";
      }
      if (astUtils2.isFunction(parent)) {
        return "function body";
      }
      ({ parent } = parent);
    }
    return "program";
  }
  noInnerDeclarations = {
    meta: {
      type: "problem",
      defaultOptions: ["functions", { blockScopedFunctions: "allow" }],
      docs: {
        description: "Disallow variable or `function` declarations in nested blocks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-inner-declarations"
      },
      schema: [
        {
          enum: ["functions", "both"]
        },
        {
          type: "object",
          properties: {
            blockScopedFunctions: {
              enum: ["allow", "disallow"]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        moveDeclToRoot: "Move {{type}} declaration to {{body}} root."
      }
    },
    create(context) {
      const both = context.options[0] === "both";
      const { blockScopedFunctions } = context.options[1];
      const sourceCode2 = context.sourceCode;
      const ecmaVersion2 = context.languageOptions.ecmaVersion;
      function check2(node2) {
        const parent = node2.parent;
        if (parent.type === "BlockStatement" && validBlockStatementParent.has(parent.parent.type)) {
          return;
        }
        if (validParent.has(parent.type)) {
          return;
        }
        context.report({
          node: node2,
          messageId: "moveDeclToRoot",
          data: {
            type: node2.type === "FunctionDeclaration" ? "function" : "variable",
            body: getAllowedBodyDescription(node2)
          }
        });
      }
      return {
        FunctionDeclaration(node2) {
          const isInStrictCode = sourceCode2.getScope(node2).upper.isStrict;
          if (blockScopedFunctions === "allow" && ecmaVersion2 >= 2015 && isInStrictCode) {
            return;
          }
          check2(node2);
        },
        VariableDeclaration(node2) {
          if (both && node2.kind === "var") {
            check2(node2);
          }
        }
      };
    }
  };
  return noInnerDeclarations;
}
var noInvalidRegexp;
var hasRequiredNoInvalidRegexp;
function requireNoInvalidRegexp() {
  if (hasRequiredNoInvalidRegexp) return noInvalidRegexp;
  hasRequiredNoInvalidRegexp = 1;
  const RegExpValidator = requireRegexpp().RegExpValidator;
  const validator = new RegExpValidator();
  const validFlags = "dgimsuvy";
  const undefined1 = void 0;
  noInvalidRegexp = {
    meta: {
      type: "problem",
      defaultOptions: [{}],
      docs: {
        description: "Disallow invalid regular expression strings in `RegExp` constructors",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-invalid-regexp"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowConstructorFlags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        regexMessage: "{{message}}."
      }
    },
    create(context) {
      const [{ allowConstructorFlags }] = context.options;
      let allowedFlags = [];
      if (allowConstructorFlags) {
        const temp = allowConstructorFlags.join("").replace(new RegExp(`[${validFlags}]`, "gu"), "");
        if (temp) {
          allowedFlags = [...new Set(temp)];
        }
      }
      function report(node2, message) {
        context.report({
          node: node2,
          messageId: "regexMessage",
          data: { message }
        });
      }
      function isString(node2) {
        return node2 && node2.type === "Literal" && typeof node2.value === "string";
      }
      function getFlags(node2) {
        if (node2.arguments.length < 2) {
          return "";
        }
        if (isString(node2.arguments[1])) {
          return node2.arguments[1].value;
        }
        return null;
      }
      function validateRegExpPattern(pattern2, flags2) {
        try {
          validator.validatePattern(
            pattern2,
            undefined1,
            undefined1,
            flags2
          );
          return null;
        } catch (err) {
          return err.message;
        }
      }
      function validateRegExpFlags(flags2, flagsToCheck, allFlags) {
        const duplicateFlags = [];
        if (typeof flagsToCheck === "string") {
          for (const flag of flagsToCheck) {
            if (allFlags.includes(flag)) {
              duplicateFlags.push(flag);
            }
          }
        }
        if (flags2 && flags2.includes("u") && flags2.includes("v")) {
          return "Regex 'u' and 'v' flags cannot be used together";
        }
        if (duplicateFlags.length > 0) {
          return `Duplicate flags ('${duplicateFlags.join("")}') supplied to RegExp constructor`;
        }
        if (!flagsToCheck) {
          return null;
        }
        return `Invalid flags supplied to RegExp constructor '${flagsToCheck}'`;
      }
      return {
        "CallExpression, NewExpression"(node2) {
          if (node2.callee.type !== "Identifier" || node2.callee.name !== "RegExp") {
            return;
          }
          const flags2 = getFlags(node2);
          let flagsToCheck = flags2;
          const allFlags = allowedFlags.length > 0 ? validFlags.split("").concat(allowedFlags) : validFlags.split("");
          if (flags2) {
            allFlags.forEach((flag) => {
              flagsToCheck = flagsToCheck.replace(flag, "");
            });
          }
          let message = validateRegExpFlags(
            flags2,
            flagsToCheck,
            allFlags
          );
          if (message) {
            report(node2, message);
            return;
          }
          if (!isString(node2.arguments[0])) {
            return;
          }
          const pattern2 = node2.arguments[0].value;
          message = // If flags are unknown, report the regex only if its pattern is invalid both with and without the "u" flag
          flags2 === null ? validateRegExpPattern(pattern2, {
            unicode: true,
            unicodeSets: false
          }) && validateRegExpPattern(pattern2, {
            unicode: false,
            unicodeSets: true
          }) && validateRegExpPattern(pattern2, {
            unicode: false,
            unicodeSets: false
          }) : validateRegExpPattern(pattern2, {
            unicode: flags2.includes("u"),
            unicodeSets: flags2.includes("v")
          });
          if (message) {
            report(node2, message);
          }
        }
      };
    }
  };
  return noInvalidRegexp;
}
var noInvalidThis;
var hasRequiredNoInvalidThis;
function requireNoInvalidThis() {
  if (hasRequiredNoInvalidThis) return noInvalidThis;
  hasRequiredNoInvalidThis = 1;
  const astUtils2 = requireAstUtils();
  function isCodePathWithLexicalThis(codePath2, node2) {
    return codePath2.origin === "function" && node2.type === "ArrowFunctionExpression";
  }
  noInvalidThis = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      defaultOptions: [{ capIsConstructor: true }],
      docs: {
        description: "Disallow use of `this` in contexts where the value of `this` is `undefined`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-invalid-this"
      },
      schema: [
        {
          type: "object",
          properties: {
            capIsConstructor: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedThis: "Unexpected 'this'."
      }
    },
    create(context) {
      const [{ capIsConstructor }] = context.options;
      const stack = [], sourceCode2 = context.sourceCode;
      stack.getCurrent = function() {
        const current = this.at(-1);
        if (!current.init) {
          current.init = true;
          current.valid = !astUtils2.isDefaultThisBinding(
            current.node,
            sourceCode2,
            { capIsConstructor }
          );
        }
        return current;
      };
      return {
        onCodePathStart(codePath2, node2) {
          if (isCodePathWithLexicalThis(codePath2, node2)) {
            return;
          }
          if (codePath2.origin === "program") {
            const scope = sourceCode2.getScope(node2);
            const features = context.languageOptions.parserOptions.ecmaFeatures || {};
            stack.push({
              init: true,
              node: node2,
              valid: !(node2.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
            });
            return;
          }
          stack.push({
            init: !sourceCode2.getScope(node2).isStrict,
            node: node2,
            valid: true
          });
        },
        onCodePathEnd(codePath2, node2) {
          if (isCodePathWithLexicalThis(codePath2, node2)) {
            return;
          }
          stack.pop();
        },
        "AccessorProperty > *.value"(node2) {
          stack.push({
            init: true,
            node: node2,
            valid: true
          });
        },
        "AccessorProperty:exit"() {
          stack.pop();
        },
        // Reports if `this` of the current context is invalid.
        ThisExpression(node2) {
          if (node2.parent.type === "AccessorProperty" && node2.parent.value === node2) {
            return;
          }
          const current = stack.getCurrent();
          if (current && !current.valid) {
            context.report({
              node: node2,
              messageId: "unexpectedThis"
            });
          }
        }
      };
    }
  };
  return noInvalidThis;
}
var noIrregularWhitespace;
var hasRequiredNoIrregularWhitespace;
function requireNoIrregularWhitespace() {
  if (hasRequiredNoIrregularWhitespace) return noIrregularWhitespace;
  hasRequiredNoIrregularWhitespace = 1;
  const astUtils2 = requireAstUtils();
  const ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u;
  const IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/gu;
  const IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/gu;
  const LINE_BREAK = astUtils2.createGlobalLinebreakMatcher();
  noIrregularWhitespace = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          skipComments: false,
          skipJSXText: false,
          skipRegExps: false,
          skipStrings: true,
          skipTemplates: false
        }
      ],
      docs: {
        description: "Disallow irregular whitespace",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-irregular-whitespace"
      },
      schema: [
        {
          type: "object",
          properties: {
            skipComments: {
              type: "boolean"
            },
            skipStrings: {
              type: "boolean"
            },
            skipTemplates: {
              type: "boolean"
            },
            skipRegExps: {
              type: "boolean"
            },
            skipJSXText: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        noIrregularWhitespace: "Irregular whitespace not allowed."
      }
    },
    create(context) {
      const [
        {
          skipComments,
          skipStrings,
          skipRegExps,
          skipTemplates,
          skipJSXText
        }
      ] = context.options;
      const sourceCode2 = context.sourceCode;
      const commentNodes = sourceCode2.getAllComments();
      let errors = [];
      function removeWhitespaceError(node2) {
        const locStart = node2.loc.start;
        const locEnd = node2.loc.end;
        errors = errors.filter(
          ({ loc: { start: errorLocStart } }) => errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line
        );
      }
      function removeInvalidNodeErrorsInLiteral(node2) {
        const shouldCheckStrings = skipStrings && typeof node2.value === "string";
        const shouldCheckRegExps = skipRegExps && Boolean(node2.regex);
        if (shouldCheckStrings || shouldCheckRegExps) {
          if (ALL_IRREGULARS.test(node2.raw)) {
            removeWhitespaceError(node2);
          }
        }
      }
      function removeInvalidNodeErrorsInTemplateLiteral(node2) {
        if (typeof node2.value.raw === "string") {
          if (ALL_IRREGULARS.test(node2.value.raw)) {
            removeWhitespaceError(node2);
          }
        }
      }
      function removeInvalidNodeErrorsInComment(node2) {
        if (ALL_IRREGULARS.test(node2.value)) {
          removeWhitespaceError(node2);
        }
      }
      function removeInvalidNodeErrorsInJSXText(node2) {
        if (ALL_IRREGULARS.test(node2.raw)) {
          removeWhitespaceError(node2);
        }
      }
      function checkForIrregularWhitespace(node2) {
        const sourceLines = sourceCode2.lines;
        sourceLines.forEach((sourceLine, lineIndex) => {
          const lineNumber = lineIndex + 1;
          let match;
          while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
            errors.push({
              node: node2,
              messageId: "noIrregularWhitespace",
              loc: {
                start: {
                  line: lineNumber,
                  column: match.index
                },
                end: {
                  line: lineNumber,
                  column: match.index + match[0].length
                }
              }
            });
          }
        });
      }
      function checkForIrregularLineTerminators(node2) {
        const source = sourceCode2.getText(), sourceLines = sourceCode2.lines, linebreaks = source.match(LINE_BREAK);
        let lastLineIndex = -1, match;
        while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
          const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
          errors.push({
            node: node2,
            messageId: "noIrregularWhitespace",
            loc: {
              start: {
                line: lineIndex + 1,
                column: sourceLines[lineIndex].length
              },
              end: {
                line: lineIndex + 2,
                column: 0
              }
            }
          });
          lastLineIndex = lineIndex;
        }
      }
      function noop2() {
      }
      const nodes = {};
      if (ALL_IRREGULARS.test(sourceCode2.getText())) {
        nodes.Program = function(node2) {
          checkForIrregularWhitespace(node2);
          checkForIrregularLineTerminators(node2);
        };
        nodes.Literal = removeInvalidNodeErrorsInLiteral;
        nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop2;
        nodes.JSXText = skipJSXText ? removeInvalidNodeErrorsInJSXText : noop2;
        nodes["Program:exit"] = function() {
          if (skipComments) {
            commentNodes.forEach(removeInvalidNodeErrorsInComment);
          }
          errors.forEach((error) => context.report(error));
        };
      } else {
        nodes.Program = noop2;
      }
      return nodes;
    }
  };
  return noIrregularWhitespace;
}
var noIterator;
var hasRequiredNoIterator;
function requireNoIterator() {
  if (hasRequiredNoIterator) return noIterator;
  hasRequiredNoIterator = 1;
  const { getStaticPropertyName } = requireAstUtils();
  noIterator = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of the `__iterator__` property",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-iterator"
      },
      schema: [],
      messages: {
        noIterator: "Reserved name '__iterator__'."
      }
    },
    create(context) {
      return {
        MemberExpression(node2) {
          if (getStaticPropertyName(node2) === "__iterator__") {
            context.report({
              node: node2,
              messageId: "noIterator"
            });
          }
        }
      };
    }
  };
  return noIterator;
}
var noLabelVar;
var hasRequiredNoLabelVar;
function requireNoLabelVar() {
  if (hasRequiredNoLabelVar) return noLabelVar;
  hasRequiredNoLabelVar = 1;
  const astUtils2 = requireAstUtils();
  noLabelVar = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow labels that share a name with a variable",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-label-var"
      },
      schema: [],
      messages: {
        identifierClashWithLabel: "Found identifier with same name as label."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function findIdentifier(scope, name2) {
        return astUtils2.getVariableByName(scope, name2) !== null;
      }
      return {
        LabeledStatement(node2) {
          const scope = sourceCode2.getScope(node2);
          if (findIdentifier(scope, node2.label.name)) {
            context.report({
              node: node2,
              messageId: "identifierClashWithLabel"
            });
          }
        }
      };
    }
  };
  return noLabelVar;
}
var noLabels;
var hasRequiredNoLabels;
function requireNoLabels() {
  if (hasRequiredNoLabels) return noLabels;
  hasRequiredNoLabels = 1;
  const astUtils2 = requireAstUtils();
  noLabels = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowLoop: false,
          allowSwitch: false
        }
      ],
      docs: {
        description: "Disallow labeled statements",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-labels"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowLoop: {
              type: "boolean"
            },
            allowSwitch: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedLabel: "Unexpected labeled statement.",
        unexpectedLabelInBreak: "Unexpected label in break statement.",
        unexpectedLabelInContinue: "Unexpected label in continue statement."
      }
    },
    create(context) {
      const [{ allowLoop, allowSwitch }] = context.options;
      let scopeInfo = null;
      function getBodyKind(node2) {
        if (astUtils2.isLoop(node2)) {
          return "loop";
        }
        if (node2.type === "SwitchStatement") {
          return "switch";
        }
        return "other";
      }
      function isAllowed(kind) {
        switch (kind) {
          case "loop":
            return allowLoop;
          case "switch":
            return allowSwitch;
          default:
            return false;
        }
      }
      function getKind(label) {
        let info = scopeInfo;
        while (info) {
          if (info.label === label) {
            return info.kind;
          }
          info = info.upper;
        }
        return "other";
      }
      return {
        LabeledStatement(node2) {
          scopeInfo = {
            label: node2.label.name,
            kind: getBodyKind(node2.body),
            upper: scopeInfo
          };
        },
        "LabeledStatement:exit"(node2) {
          if (!isAllowed(scopeInfo.kind)) {
            context.report({
              node: node2,
              messageId: "unexpectedLabel"
            });
          }
          scopeInfo = scopeInfo.upper;
        },
        BreakStatement(node2) {
          if (node2.label && !isAllowed(getKind(node2.label.name))) {
            context.report({
              node: node2,
              messageId: "unexpectedLabelInBreak"
            });
          }
        },
        ContinueStatement(node2) {
          if (node2.label && !isAllowed(getKind(node2.label.name))) {
            context.report({
              node: node2,
              messageId: "unexpectedLabelInContinue"
            });
          }
        }
      };
    }
  };
  return noLabels;
}
var noLoneBlocks;
var hasRequiredNoLoneBlocks;
function requireNoLoneBlocks() {
  if (hasRequiredNoLoneBlocks) return noLoneBlocks;
  hasRequiredNoLoneBlocks = 1;
  noLoneBlocks = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary nested blocks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-lone-blocks"
      },
      schema: [],
      messages: {
        redundantBlock: "Block is redundant.",
        redundantNestedBlock: "Nested block is redundant."
      }
    },
    create(context) {
      const loneBlocks = [];
      let ruleDef;
      const sourceCode2 = context.sourceCode;
      function report(node2) {
        const messageId = node2.parent.type === "BlockStatement" || node2.parent.type === "StaticBlock" ? "redundantNestedBlock" : "redundantBlock";
        context.report({
          node: node2,
          messageId
        });
      }
      function isLoneBlock(node2) {
        return node2.parent.type === "BlockStatement" || node2.parent.type === "StaticBlock" || node2.parent.type === "Program" || // Don't report blocks in switch cases if the block is the only statement of the case.
        node2.parent.type === "SwitchCase" && !(node2.parent.consequent[0] === node2 && node2.parent.consequent.length === 1);
      }
      function markLoneBlock(node2) {
        if (loneBlocks.length === 0) {
          return;
        }
        const block = node2.parent;
        if (loneBlocks.at(-1) === block) {
          loneBlocks.pop();
        }
      }
      ruleDef = {
        BlockStatement(node2) {
          if (isLoneBlock(node2)) {
            report(node2);
          }
        }
      };
      if (context.languageOptions.ecmaVersion >= 2015) {
        ruleDef = {
          BlockStatement(node2) {
            if (isLoneBlock(node2)) {
              loneBlocks.push(node2);
            }
          },
          "BlockStatement:exit"(node2) {
            if (loneBlocks.length > 0 && loneBlocks.at(-1) === node2) {
              loneBlocks.pop();
              report(node2);
            } else if ((node2.parent.type === "BlockStatement" || node2.parent.type === "StaticBlock") && node2.parent.body.length === 1) {
              report(node2);
            }
          }
        };
        ruleDef.VariableDeclaration = function(node2) {
          if (node2.kind !== "var") {
            markLoneBlock(node2);
          }
        };
        ruleDef.FunctionDeclaration = function(node2) {
          if (sourceCode2.getScope(node2).isStrict) {
            markLoneBlock(node2);
          }
        };
        ruleDef.ClassDeclaration = markLoneBlock;
      }
      return ruleDef;
    }
  };
  return noLoneBlocks;
}
var noLonelyIf;
var hasRequiredNoLonelyIf;
function requireNoLonelyIf() {
  if (hasRequiredNoLonelyIf) return noLonelyIf;
  hasRequiredNoLonelyIf = 1;
  const astUtils2 = requireAstUtils();
  noLonelyIf = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `if` statements as the only statement in `else` blocks",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-lonely-if"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedLonelyIf: "Unexpected if as the only statement in an else block."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        IfStatement(node2) {
          const parent = node2.parent, grandparent = parent.parent;
          if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && !astUtils2.areBracesNecessary(parent, sourceCode2) && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
            context.report({
              node: node2,
              messageId: "unexpectedLonelyIf",
              fix(fixer) {
                const openingElseCurly = sourceCode2.getFirstToken(parent);
                const closingElseCurly = sourceCode2.getLastToken(parent);
                const elseKeyword = sourceCode2.getTokenBefore(openingElseCurly);
                const tokenAfterElseBlock = sourceCode2.getTokenAfter(closingElseCurly);
                const lastIfToken = sourceCode2.getLastToken(
                  node2.consequent
                );
                const sourceText = sourceCode2.getText();
                if (sourceText.slice(
                  openingElseCurly.range[1],
                  node2.range[0]
                ).trim() || sourceText.slice(
                  node2.range[1],
                  closingElseCurly.range[0]
                ).trim()) {
                  return null;
                }
                if (node2.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node2.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/u.test(
                  tokenAfterElseBlock.value
                ) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
                  return null;
                }
                return fixer.replaceTextRange(
                  [
                    openingElseCurly.range[0],
                    closingElseCurly.range[1]
                  ],
                  (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode2.getText(node2)
                );
              }
            });
          }
        }
      };
    }
  };
  return noLonelyIf;
}
var noLoopFunc;
var hasRequiredNoLoopFunc;
function requireNoLoopFunc() {
  if (hasRequiredNoLoopFunc) return noLoopFunc;
  hasRequiredNoLoopFunc = 1;
  const CONSTANT_BINDINGS = /* @__PURE__ */ new Set(["const", "using", "await using"]);
  function isIIFE(node2) {
    return (node2.type === "FunctionExpression" || node2.type === "ArrowFunctionExpression") && node2.parent && node2.parent.type === "CallExpression" && node2.parent.callee === node2;
  }
  noLoopFunc = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Disallow function declarations that contain unsafe references inside loop statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-loop-func"
      },
      schema: [],
      messages: {
        unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."
      }
    },
    create(context) {
      const SKIPPED_IIFE_NODES = /* @__PURE__ */ new Set();
      const sourceCode2 = context.sourceCode;
      function getContainingLoopNode(node2) {
        for (let currentNode = node2; currentNode.parent; currentNode = currentNode.parent) {
          const parent = currentNode.parent;
          switch (parent.type) {
            case "WhileStatement":
            case "DoWhileStatement":
              return parent;
            case "ForStatement":
              if (parent.init !== currentNode) {
                return parent;
              }
              break;
            case "ForInStatement":
            case "ForOfStatement":
              if (parent.right !== currentNode) {
                return parent;
              }
              break;
            case "ArrowFunctionExpression":
            case "FunctionExpression":
            case "FunctionDeclaration":
              if (SKIPPED_IIFE_NODES.has(parent)) {
                break;
              }
              return null;
          }
        }
        return null;
      }
      function getTopLoopNode(node2, excludedNode) {
        const border = excludedNode ? excludedNode.range[1] : 0;
        let retv = node2;
        let containingLoopNode = node2;
        while (containingLoopNode && containingLoopNode.range[0] >= border) {
          retv = containingLoopNode;
          containingLoopNode = getContainingLoopNode(containingLoopNode);
        }
        return retv;
      }
      function isSafe(loopNode, reference) {
        const variable = reference.resolved;
        const definition = variable && variable.defs[0];
        const declaration = definition && definition.parent;
        const kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";
        if (CONSTANT_BINDINGS.has(kind)) {
          return true;
        }
        if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
          return true;
        }
        const border = getTopLoopNode(
          loopNode,
          kind === "let" ? declaration : null
        ).range[0];
        function isSafeReference(upperRef) {
          const id2 = upperRef.identifier;
          return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id2.range[0] < border;
        }
        return Boolean(variable) && variable.references.every(isSafeReference);
      }
      function checkForLoops(node2) {
        const loopNode = getContainingLoopNode(node2);
        if (!loopNode) {
          return;
        }
        const references = sourceCode2.getScope(node2).through;
        if (!(node2.async || node2.generator)) {
          if (isIIFE(node2)) {
            const isFunctionExpression = node2.type === "FunctionExpression";
            const isFunctionReferenced = isFunctionExpression && node2.id ? references.some(
              (r2) => r2.identifier.name === node2.id.name
            ) : false;
            if (!isFunctionReferenced) {
              SKIPPED_IIFE_NODES.add(node2);
              return;
            }
          }
        }
        const unsafeRefs = [
          ...new Set(
            references.filter((r2) => r2.resolved && !isSafe(loopNode, r2)).map((r2) => r2.identifier.name)
          )
        ];
        if (unsafeRefs.length > 0) {
          context.report({
            node: node2,
            messageId: "unsafeRefs",
            data: { varNames: `'${unsafeRefs.join("', '")}'` }
          });
        }
      }
      return {
        ArrowFunctionExpression: checkForLoops,
        FunctionExpression: checkForLoops,
        FunctionDeclaration: checkForLoops
      };
    }
  };
  return noLoopFunc;
}
var noLossOfPrecision;
var hasRequiredNoLossOfPrecision;
function requireNoLossOfPrecision() {
  if (hasRequiredNoLossOfPrecision) return noLossOfPrecision;
  hasRequiredNoLossOfPrecision = 1;
  class ScientificNotation {
    constructor(coefficient, magnitude) {
      /** @type {string} The digits of the coefficient. A decimal point is implied after the first digit. */
      __publicField(this, "coefficient");
      /** @type {number} The order of magnitude. */
      __publicField(this, "magnitude");
      this.coefficient = coefficient;
      this.magnitude = magnitude;
    }
    /* c8 ignore start -- debug only */
    toString() {
      return `${this.coefficient[0]}${this.coefficient.length > 1 ? `.${this.coefficient.slice(1)}` : ""}e${this.magnitude}`;
    }
    /* c8 ignore stop */
  }
  function isNumber(node2) {
    return typeof node2.value === "number";
  }
  function getRaw(node2) {
    return node2.raw.replace(/_/gu, "");
  }
  function isBaseTen(node2) {
    const prefixes = ["0x", "0X", "0b", "0B", "0o", "0O"];
    return prefixes.every((prefix) => !node2.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node2.raw);
  }
  function notBaseTenLosesPrecision(node2) {
    const rawString = getRaw(node2).toUpperCase();
    let base2;
    if (rawString.startsWith("0B")) {
      base2 = 2;
    } else if (rawString.startsWith("0X")) {
      base2 = 16;
    } else {
      base2 = 8;
    }
    return !rawString.endsWith(node2.value.toString(base2).toUpperCase());
  }
  function removeLeadingZeros(numberAsString) {
    for (let i2 = 0; i2 < numberAsString.length; i2++) {
      if (numberAsString[i2] !== "0") {
        return numberAsString.slice(i2);
      }
    }
    return numberAsString;
  }
  function removeTrailingZeros(numberAsString) {
    for (let i2 = numberAsString.length - 1; i2 >= 0; i2--) {
      if (numberAsString[i2] !== "0") {
        return numberAsString.slice(0, i2 + 1);
      }
    }
    return numberAsString;
  }
  function normalizeInteger(stringInteger) {
    const trimmedInteger = removeLeadingZeros(stringInteger);
    const significantDigits = removeTrailingZeros(trimmedInteger);
    return new ScientificNotation(significantDigits, trimmedInteger.length - 1);
  }
  function normalizeFloat(stringFloat) {
    const trimmedFloat = removeLeadingZeros(stringFloat);
    const indexOfDecimalPoint = trimmedFloat.indexOf(".");
    switch (indexOfDecimalPoint) {
      case 0: {
        const significantDigits = removeLeadingZeros(trimmedFloat.slice(1));
        return new ScientificNotation(
          significantDigits,
          significantDigits.length - trimmedFloat.length
        );
      }
      case -1:
        return new ScientificNotation(
          trimmedFloat,
          trimmedFloat.length - 1
        );
      default:
        return new ScientificNotation(
          trimmedFloat.replace(".", ""),
          indexOfDecimalPoint - 1
        );
    }
  }
  function convertNumberToScientificNotation(stringNumber, parseAsFloat) {
    const splitNumber = stringNumber.split("e");
    const originalCoefficient = splitNumber[0];
    const normalizedNumber = parseAsFloat || stringNumber.includes(".") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);
    if (splitNumber.length > 1) {
      normalizedNumber.magnitude += parseInt(splitNumber[1], 10);
    }
    return normalizedNumber;
  }
  function baseTenLosesPrecision(node2) {
    const rawNumber = getRaw(node2).toLowerCase();
    const normalizedRawNumber = convertNumberToScientificNotation(
      rawNumber,
      false
    );
    const requestedPrecision = normalizedRawNumber.coefficient.length;
    if (requestedPrecision > 100) {
      return true;
    }
    const storedNumber = node2.value.toPrecision(requestedPrecision);
    const normalizedStoredNumber = convertNumberToScientificNotation(
      storedNumber,
      true
    );
    return normalizedRawNumber.magnitude !== normalizedStoredNumber.magnitude || normalizedRawNumber.coefficient !== normalizedStoredNumber.coefficient;
  }
  function losesPrecision(node2) {
    return isBaseTen(node2) ? baseTenLosesPrecision(node2) : notBaseTenLosesPrecision(node2);
  }
  noLossOfPrecision = {
    meta: {
      type: "problem",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Disallow literal numbers that lose precision",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-loss-of-precision"
      },
      schema: [],
      messages: {
        noLossOfPrecision: "This number literal will lose precision at runtime."
      }
    },
    create(context) {
      return {
        Literal(node2) {
          if (node2.value && isNumber(node2) && losesPrecision(node2)) {
            context.report({
              messageId: "noLossOfPrecision",
              node: node2
            });
          }
        }
      };
    }
  };
  return noLossOfPrecision;
}
var noMagicNumbers;
var hasRequiredNoMagicNumbers;
function requireNoMagicNumbers() {
  if (hasRequiredNoMagicNumbers) return noMagicNumbers;
  hasRequiredNoMagicNumbers = 1;
  const astUtils2 = requireAstUtils();
  const MAX_ARRAY_LENGTH = 2 ** 32 - 1;
  function normalizeIgnoreValue(x2) {
    if (typeof x2 === "string") {
      return BigInt(x2.slice(0, -1));
    }
    return x2;
  }
  function isParentTSEnumDeclaration(node2) {
    return node2.parent.type === "TSEnumMember";
  }
  function isTSNumericLiteralType(node2) {
    let ancestor = node2.parent;
    while (ancestor.parent.type === "TSUnionType") {
      ancestor = ancestor.parent;
    }
    return ancestor.parent.type === "TSTypeAliasDeclaration";
  }
  function isParentTSReadonlyPropertyDefinition(node2) {
    var _a2;
    if (((_a2 = node2.parent) == null ? void 0 : _a2.type) === "PropertyDefinition" && node2.parent.readonly) {
      return true;
    }
    return false;
  }
  function isAncestorTSIndexedAccessType(node2) {
    let ancestor = node2.parent;
    while (ancestor.parent.type === "TSUnionType" || ancestor.parent.type === "TSIntersectionType") {
      ancestor = ancestor.parent;
    }
    return ancestor.parent.type === "TSIndexedAccessType";
  }
  noMagicNumbers = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Disallow magic numbers",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-magic-numbers"
      },
      schema: [
        {
          type: "object",
          properties: {
            detectObjects: {
              type: "boolean",
              default: false
            },
            enforceConst: {
              type: "boolean",
              default: false
            },
            ignore: {
              type: "array",
              items: {
                anyOf: [
                  { type: "number" },
                  {
                    type: "string",
                    pattern: "^[+-]?(?:0|[1-9][0-9]*)n$"
                  }
                ]
              },
              uniqueItems: true
            },
            ignoreArrayIndexes: {
              type: "boolean",
              default: false
            },
            ignoreDefaultValues: {
              type: "boolean",
              default: false
            },
            ignoreClassFieldInitialValues: {
              type: "boolean",
              default: false
            },
            ignoreEnums: {
              type: "boolean",
              default: false
            },
            ignoreNumericLiteralTypes: {
              type: "boolean",
              default: false
            },
            ignoreReadonlyClassProperties: {
              type: "boolean",
              default: false
            },
            ignoreTypeIndexes: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        useConst: "Number constants declarations must use 'const'.",
        noMagic: "No magic number: {{raw}}."
      }
    },
    create(context) {
      const config2 = context.options[0] || {}, detectObjects = !!config2.detectObjects, enforceConst = !!config2.enforceConst, ignore2 = new Set((config2.ignore || []).map(normalizeIgnoreValue)), ignoreArrayIndexes = !!config2.ignoreArrayIndexes, ignoreDefaultValues = !!config2.ignoreDefaultValues, ignoreClassFieldInitialValues = !!config2.ignoreClassFieldInitialValues, ignoreEnums = !!config2.ignoreEnums, ignoreNumericLiteralTypes = !!config2.ignoreNumericLiteralTypes, ignoreReadonlyClassProperties = !!config2.ignoreReadonlyClassProperties, ignoreTypeIndexes = !!config2.ignoreTypeIndexes;
      const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
      function isIgnoredValue(value) {
        return ignore2.has(value);
      }
      function isDefaultValue(fullNumberNode) {
        const parent = fullNumberNode.parent;
        return parent.type === "AssignmentPattern" && parent.right === fullNumberNode;
      }
      function isClassFieldInitialValue(fullNumberNode) {
        const parent = fullNumberNode.parent;
        return parent.type === "PropertyDefinition" && parent.value === fullNumberNode;
      }
      function isParseIntRadix(fullNumberNode) {
        const parent = fullNumberNode.parent;
        return parent.type === "CallExpression" && fullNumberNode === parent.arguments[1] && (astUtils2.isSpecificId(parent.callee, "parseInt") || astUtils2.isSpecificMemberAccess(
          parent.callee,
          "Number",
          "parseInt"
        ));
      }
      function isJSXNumber(fullNumberNode) {
        return fullNumberNode.parent.type.indexOf("JSX") === 0;
      }
      function isArrayIndex(fullNumberNode, value) {
        const parent = fullNumberNode.parent;
        return parent.type === "MemberExpression" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === "bigint") && value >= 0 && value < MAX_ARRAY_LENGTH;
      }
      return {
        Literal(node2) {
          if (!astUtils2.isNumericLiteral(node2)) {
            return;
          }
          let fullNumberNode;
          let value;
          let raw;
          if (node2.parent.type === "UnaryExpression" && ["-", "+"].includes(node2.parent.operator)) {
            fullNumberNode = node2.parent;
            value = node2.parent.operator === "-" ? -node2.value : node2.value;
            raw = `${node2.parent.operator}${node2.raw}`;
          } else {
            fullNumberNode = node2;
            value = node2.value;
            raw = node2.raw;
          }
          const parent = fullNumberNode.parent;
          if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || ignoreClassFieldInitialValues && isClassFieldInitialValue(fullNumberNode) || ignoreEnums && isParentTSEnumDeclaration(fullNumberNode) || ignoreNumericLiteralTypes && isTSNumericLiteralType(fullNumberNode) || ignoreTypeIndexes && isAncestorTSIndexedAccessType(fullNumberNode) || ignoreReadonlyClassProperties && isParentTSReadonlyPropertyDefinition(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {
            return;
          }
          if (parent.type === "VariableDeclarator") {
            if (enforceConst && parent.parent.kind !== "const") {
              context.report({
                node: fullNumberNode,
                messageId: "useConst"
              });
            }
          } else if (!okTypes.includes(parent.type) || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
            context.report({
              node: fullNumberNode,
              messageId: "noMagic",
              data: {
                raw
              }
            });
          }
        }
      };
    }
  };
  return noMagicNumbers;
}
var isCombiningCharacter;
var hasRequiredIsCombiningCharacter;
function requireIsCombiningCharacter() {
  if (hasRequiredIsCombiningCharacter) return isCombiningCharacter;
  hasRequiredIsCombiningCharacter = 1;
  isCombiningCharacter = function isCombiningCharacter2(codePoint) {
    return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(codePoint));
  };
  return isCombiningCharacter;
}
var isEmojiModifier;
var hasRequiredIsEmojiModifier;
function requireIsEmojiModifier() {
  if (hasRequiredIsEmojiModifier) return isEmojiModifier;
  hasRequiredIsEmojiModifier = 1;
  isEmojiModifier = function isEmojiModifier2(code2) {
    return code2 >= 127995 && code2 <= 127999;
  };
  return isEmojiModifier;
}
var isRegionalIndicatorSymbol;
var hasRequiredIsRegionalIndicatorSymbol;
function requireIsRegionalIndicatorSymbol() {
  if (hasRequiredIsRegionalIndicatorSymbol) return isRegionalIndicatorSymbol;
  hasRequiredIsRegionalIndicatorSymbol = 1;
  isRegionalIndicatorSymbol = function isRegionalIndicatorSymbol2(code2) {
    return code2 >= 127462 && code2 <= 127487;
  };
  return isRegionalIndicatorSymbol;
}
var isSurrogatePair;
var hasRequiredIsSurrogatePair;
function requireIsSurrogatePair() {
  if (hasRequiredIsSurrogatePair) return isSurrogatePair;
  hasRequiredIsSurrogatePair = 1;
  isSurrogatePair = function isSurrogatePair2(lead, tail) {
    return lead >= 55296 && lead < 56320 && tail >= 56320 && tail < 57344;
  };
  return isSurrogatePair;
}
var unicode;
var hasRequiredUnicode;
function requireUnicode() {
  if (hasRequiredUnicode) return unicode;
  hasRequiredUnicode = 1;
  const isCombiningCharacter2 = requireIsCombiningCharacter();
  const isEmojiModifier2 = requireIsEmojiModifier();
  const isRegionalIndicatorSymbol2 = requireIsRegionalIndicatorSymbol();
  const isSurrogatePair2 = requireIsSurrogatePair();
  unicode = {
    isCombiningCharacter: isCombiningCharacter2,
    isEmojiModifier: isEmojiModifier2,
    isRegionalIndicatorSymbol: isRegionalIndicatorSymbol2,
    isSurrogatePair: isSurrogatePair2
  };
  return unicode;
}
var regularExpressions;
var hasRequiredRegularExpressions;
function requireRegularExpressions() {
  if (hasRequiredRegularExpressions) return regularExpressions;
  hasRequiredRegularExpressions = 1;
  const { RegExpValidator } = requireRegexpp();
  const REGEXPP_LATEST_ECMA_VERSION = 2025;
  function isValidWithUnicodeFlag(ecmaVersion2, pattern2, flag = "u") {
    if (flag === "u" && ecmaVersion2 <= 5) {
      return false;
    }
    if (flag === "v" && ecmaVersion2 <= 2023) {
      return false;
    }
    const validator = new RegExpValidator({
      ecmaVersion: Math.min(ecmaVersion2, REGEXPP_LATEST_ECMA_VERSION)
    });
    try {
      validator.validatePattern(
        pattern2,
        void 0,
        void 0,
        flag === "u" ? {
          unicode: (
            /* uFlag = */
            true
          )
        } : {
          unicodeSets: true
        }
      );
    } catch {
      return false;
    }
    return true;
  }
  regularExpressions = {
    isValidWithUnicodeFlag,
    REGEXPP_LATEST_ECMA_VERSION
  };
  return regularExpressions;
}
var charSource;
var hasRequiredCharSource;
function requireCharSource() {
  if (hasRequiredCharSource) return charSource;
  hasRequiredCharSource = 1;
  class CodeUnit {
    constructor(start, source) {
      this.start = start;
      this.source = source;
    }
    get end() {
      return this.start + this.length;
    }
    get length() {
      return this.source.length;
    }
  }
  class TextReader {
    constructor(source) {
      this.source = source;
      this.pos = 0;
    }
    /**
     * Advances the reading position of the specified number of characters.
     * @param {number} length Number of characters to advance.
     * @returns {void}
     */
    advance(length) {
      this.pos += length;
    }
    /**
     * Reads characters from the source.
     * @param {number} [offset=0] The offset where reading starts, relative to the current position.
     * @param {number} [length=1] Number of characters to read.
     * @returns {string} A substring of source characters.
     */
    read(offset = 0, length = 1) {
      const start = offset + this.pos;
      return this.source.slice(start, start + length);
    }
  }
  const SIMPLE_ESCAPE_SEQUENCES = {
    __proto__: null,
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	",
    v: "\v"
  };
  function readHexSequence(reader, length) {
    const str = reader.read(0, length);
    const charCode = parseInt(str, 16);
    reader.advance(length);
    return String.fromCharCode(charCode);
  }
  function readUnicodeSequence(reader) {
    const regExp = /\{(?<hexDigits>[\dA-F]+)\}/iuy;
    regExp.lastIndex = reader.pos;
    const match = regExp.exec(reader.source);
    if (match) {
      const codePoint = parseInt(match.groups.hexDigits, 16);
      reader.pos = regExp.lastIndex;
      return String.fromCodePoint(codePoint);
    }
    return readHexSequence(reader, 4);
  }
  function readOctalSequence(reader, maxLength) {
    const [octalStr] = reader.read(-1, maxLength).match(/^[0-7]+/u);
    reader.advance(octalStr.length - 1);
    const octal = parseInt(octalStr, 8);
    return String.fromCharCode(octal);
  }
  function readEscapeSequenceOrLineContinuation(reader) {
    const char = reader.read(1);
    reader.advance(2);
    const unitChar = SIMPLE_ESCAPE_SEQUENCES[char];
    if (unitChar) {
      return unitChar;
    }
    switch (char) {
      case "x":
        return readHexSequence(reader, 2);
      case "u":
        return readUnicodeSequence(reader);
      case "\r":
        if (reader.read() === "\n") {
          reader.advance(1);
        }
      case "\n":
      case "\u2028":
      case "\u2029":
        return "";
      case "0":
      case "1":
      case "2":
      case "3":
        return readOctalSequence(reader, 3);
      case "4":
      case "5":
      case "6":
      case "7":
        return readOctalSequence(reader, 2);
      default:
        return char;
    }
  }
  function* mapEscapeSequenceOrLineContinuation(reader) {
    const start = reader.pos;
    const str = readEscapeSequenceOrLineContinuation(reader);
    const end = reader.pos;
    const source = reader.source.slice(start, end);
    switch (str.length) {
      case 0:
        break;
      case 1:
        yield new CodeUnit(start, source);
        break;
      default:
        yield new CodeUnit(start, source);
        yield new CodeUnit(start, source);
        break;
    }
  }
  function parseStringLiteral(source) {
    const reader = new TextReader(source);
    const quote = reader.read();
    reader.advance(1);
    const codeUnits = [];
    for (; ; ) {
      const char = reader.read();
      if (char === quote) {
        break;
      }
      if (char === "\\") {
        codeUnits.push(...mapEscapeSequenceOrLineContinuation(reader));
      } else {
        codeUnits.push(new CodeUnit(reader.pos, char));
        reader.advance(1);
      }
    }
    return codeUnits;
  }
  function parseTemplateToken(source) {
    const reader = new TextReader(source);
    reader.advance(1);
    const codeUnits = [];
    for (; ; ) {
      const char = reader.read();
      if (char === "`" || char === "$" && reader.read(1) === "{") {
        break;
      }
      if (char === "\\") {
        codeUnits.push(...mapEscapeSequenceOrLineContinuation(reader));
      } else {
        let unitSource;
        if (char === "\r" && reader.read(1) === "\n") {
          unitSource = "\r\n";
        } else {
          unitSource = char;
        }
        codeUnits.push(new CodeUnit(reader.pos, unitSource));
        reader.advance(unitSource.length);
      }
    }
    return codeUnits;
  }
  charSource = { parseStringLiteral, parseTemplateToken };
  return charSource;
}
var noMisleadingCharacterClass;
var hasRequiredNoMisleadingCharacterClass;
function requireNoMisleadingCharacterClass() {
  if (hasRequiredNoMisleadingCharacterClass) return noMisleadingCharacterClass;
  hasRequiredNoMisleadingCharacterClass = 1;
  const {
    CALL,
    CONSTRUCT,
    ReferenceTracker,
    getStaticValue,
    getStringIfConstant
  } = /* @__PURE__ */ requireEslintUtils();
  const { RegExpParser, visitRegExpAST } = requireRegexpp();
  const {
    isCombiningCharacter: isCombiningCharacter2,
    isEmojiModifier: isEmojiModifier2,
    isRegionalIndicatorSymbol: isRegionalIndicatorSymbol2,
    isSurrogatePair: isSurrogatePair2
  } = requireUnicode();
  const astUtils2 = requireAstUtils();
  const { isValidWithUnicodeFlag } = requireRegularExpressions();
  const {
    parseStringLiteral,
    parseTemplateToken
  } = requireCharSource();
  function* iterateCharacterSequence(nodes) {
    let seq = [];
    for (const node2 of nodes) {
      switch (node2.type) {
        case "Character":
          seq.push(node2);
          break;
        case "CharacterClassRange":
          seq.push(node2.min);
          yield seq;
          seq = [node2.max];
          break;
        case "CharacterSet":
        case "CharacterClass":
        case "ClassStringDisjunction":
        case "ExpressionCharacterClass":
          if (seq.length > 0) {
            yield seq;
            seq = [];
          }
          break;
      }
    }
    if (seq.length > 0) {
      yield seq;
    }
  }
  function isUnicodeCodePointEscape(char) {
    return /^\\u\{[\da-f]+\}$/iu.test(char.raw);
  }
  const findCharacterSequences = {
    *surrogatePairWithoutUFlag(chars) {
      for (const [index, char] of chars.entries()) {
        const previous = chars[index - 1];
        if (previous && char && isSurrogatePair2(previous.value, char.value) && !isUnicodeCodePointEscape(previous) && !isUnicodeCodePointEscape(char)) {
          yield [previous, char];
        }
      }
    },
    *surrogatePair(chars) {
      for (const [index, char] of chars.entries()) {
        const previous = chars[index - 1];
        if (previous && char && isSurrogatePair2(previous.value, char.value) && (isUnicodeCodePointEscape(previous) || isUnicodeCodePointEscape(char))) {
          yield [previous, char];
        }
      }
    },
    *combiningClass(chars, unfilteredChars) {
      for (const [index, char] of chars.entries()) {
        const previous = unfilteredChars[index - 1];
        if (previous && char && isCombiningCharacter2(char.value) && !isCombiningCharacter2(previous.value)) {
          yield [previous, char];
        }
      }
    },
    *emojiModifier(chars) {
      for (const [index, char] of chars.entries()) {
        const previous = chars[index - 1];
        if (previous && char && isEmojiModifier2(char.value) && !isEmojiModifier2(previous.value)) {
          yield [previous, char];
        }
      }
    },
    *regionalIndicatorSymbol(chars) {
      for (const [index, char] of chars.entries()) {
        const previous = chars[index - 1];
        if (previous && char && isRegionalIndicatorSymbol2(char.value) && isRegionalIndicatorSymbol2(previous.value)) {
          yield [previous, char];
        }
      }
    },
    *zwj(chars) {
      let sequence = null;
      for (const [index, char] of chars.entries()) {
        const previous = chars[index - 1];
        const next = chars[index + 1];
        if (previous && char && next && char.value === 8205 && previous.value !== 8205 && next.value !== 8205) {
          if (sequence) {
            if (sequence.at(-1) === previous) {
              sequence.push(char, next);
            } else {
              yield sequence;
              sequence = chars.slice(index - 1, index + 2);
            }
          } else {
            sequence = chars.slice(index - 1, index + 2);
          }
        }
      }
      if (sequence) {
        yield sequence;
      }
    }
  };
  const kinds = Object.keys(findCharacterSequences);
  function getStaticValueOrRegex(node2, initialScope) {
    if (!node2) {
      return null;
    }
    if (node2.type === "Literal" && node2.regex) {
      return { regex: node2.regex };
    }
    const staticValue = getStaticValue(node2, initialScope);
    if ((staticValue == null ? void 0 : staticValue.value) instanceof RegExp) {
      return null;
    }
    return staticValue;
  }
  function checkForAcceptableEscape(char, charSource2) {
    if (!charSource2.startsWith("\\")) {
      return false;
    }
    const match = new RegExp("(?<=^\\\\+).$", "su").exec(charSource2);
    return (match == null ? void 0 : match[0]) !== String.fromCodePoint(char.value);
  }
  function checkForAcceptableEscapeInString(char, nodeSource, codeUnits) {
    const firstIndex = char.start;
    const lastIndex = char.end - 1;
    const start = codeUnits[firstIndex].start;
    const end = codeUnits[lastIndex].end;
    const charSource2 = nodeSource.slice(start, end);
    return checkForAcceptableEscape(char, charSource2);
  }
  noMisleadingCharacterClass = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowEscape: false
        }
      ],
      docs: {
        description: "Disallow characters which are made with multiple code points in character class syntax",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-misleading-character-class"
      },
      hasSuggestions: true,
      schema: [
        {
          type: "object",
          properties: {
            allowEscape: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
        surrogatePair: "Unexpected surrogate pair in character class.",
        combiningClass: "Unexpected combined character in character class.",
        emojiModifier: "Unexpected modified Emoji in character class.",
        regionalIndicatorSymbol: "Unexpected national flag in character class.",
        zwj: "Unexpected joined character sequence in character class.",
        suggestUnicodeFlag: "Add unicode 'u' flag to regex."
      }
    },
    create(context) {
      const [{ allowEscape }] = context.options;
      const sourceCode2 = context.sourceCode;
      const parser2 = new RegExpParser();
      const checkedPatternNodes = /* @__PURE__ */ new Set();
      function verify(node2, pattern2, flags2, unicodeFixer) {
        let patternNode;
        try {
          patternNode = parser2.parsePattern(pattern2, 0, pattern2.length, {
            unicode: flags2.includes("u"),
            unicodeSets: flags2.includes("v")
          });
        } catch {
          return;
        }
        let codeUnits = null;
        function isAcceptableEscapeSequence(char) {
          if (node2.type === "Literal" && node2.regex) {
            return checkForAcceptableEscape(char, char.raw);
          }
          if (node2.type === "Literal" && typeof node2.value === "string") {
            const nodeSource = node2.raw;
            codeUnits ?? (codeUnits = parseStringLiteral(nodeSource));
            return checkForAcceptableEscapeInString(
              char,
              nodeSource,
              codeUnits
            );
          }
          if (astUtils2.isStaticTemplateLiteral(node2)) {
            const nodeSource = sourceCode2.getText(node2);
            codeUnits ?? (codeUnits = parseTemplateToken(nodeSource));
            return checkForAcceptableEscapeInString(
              char,
              nodeSource,
              codeUnits
            );
          }
          return false;
        }
        const foundKindMatches = /* @__PURE__ */ new Map();
        visitRegExpAST(patternNode, {
          onCharacterClassEnter(ccNode) {
            for (const unfilteredChars of iterateCharacterSequence(
              ccNode.elements
            )) {
              let chars;
              if (allowEscape) {
                chars = unfilteredChars.map(
                  (char) => isAcceptableEscapeSequence(char) ? null : char
                );
              } else {
                chars = unfilteredChars;
              }
              for (const kind of kinds) {
                const matches = findCharacterSequences[kind](
                  chars,
                  unfilteredChars
                );
                if (foundKindMatches.has(kind)) {
                  foundKindMatches.get(kind).push(...matches);
                } else {
                  foundKindMatches.set(kind, [...matches]);
                }
              }
            }
          }
        });
        function getNodeReportLocations(matches) {
          if (!astUtils2.isStaticTemplateLiteral(node2) && node2.type !== "Literal") {
            return matches.length ? [node2.loc] : [];
          }
          return matches.map((chars) => {
            const firstIndex = chars[0].start;
            const lastIndex = chars.at(-1).end - 1;
            let start;
            let end;
            if (node2.type === "TemplateLiteral") {
              const source = sourceCode2.getText(node2);
              const offset = node2.range[0];
              codeUnits ?? (codeUnits = parseTemplateToken(source));
              start = offset + codeUnits[firstIndex].start;
              end = offset + codeUnits[lastIndex].end;
            } else if (typeof node2.value === "string") {
              const source = node2.raw;
              const offset = node2.range[0];
              codeUnits ?? (codeUnits = parseStringLiteral(source));
              start = offset + codeUnits[firstIndex].start;
              end = offset + codeUnits[lastIndex].end;
            } else {
              const offset = node2.range[0] + 1;
              start = offset + firstIndex;
              end = offset + lastIndex + 1;
            }
            return {
              start: sourceCode2.getLocFromIndex(start),
              end: sourceCode2.getLocFromIndex(end)
            };
          });
        }
        for (const [kind, matches] of foundKindMatches) {
          let suggest;
          if (kind === "surrogatePairWithoutUFlag") {
            suggest = [
              {
                messageId: "suggestUnicodeFlag",
                fix: unicodeFixer
              }
            ];
          }
          const locs = getNodeReportLocations(matches);
          for (const loc of locs) {
            context.report({
              node: node2,
              loc,
              messageId: kind,
              suggest
            });
          }
        }
      }
      return {
        "Literal[regex]"(node2) {
          if (checkedPatternNodes.has(node2)) {
            return;
          }
          verify(node2, node2.regex.pattern, node2.regex.flags, (fixer) => {
            if (!isValidWithUnicodeFlag(
              context.languageOptions.ecmaVersion,
              node2.regex.pattern
            )) {
              return null;
            }
            return fixer.insertTextAfter(node2, "u");
          });
        },
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            {
              RegExp: { [CALL]: true, [CONSTRUCT]: true }
            }
          )) {
            let pattern2, flags2;
            const [patternNode, flagsNode] = refNode.arguments;
            const evaluatedPattern = getStaticValueOrRegex(
              patternNode,
              scope
            );
            if (!evaluatedPattern) {
              continue;
            }
            if (flagsNode) {
              if (evaluatedPattern.regex) {
                pattern2 = evaluatedPattern.regex.pattern;
                checkedPatternNodes.add(patternNode);
              } else {
                pattern2 = String(evaluatedPattern.value);
              }
              flags2 = getStringIfConstant(flagsNode, scope);
            } else {
              if (evaluatedPattern.regex) {
                continue;
              }
              pattern2 = String(evaluatedPattern.value);
              flags2 = "";
            }
            if (typeof flags2 === "string") {
              verify(patternNode, pattern2, flags2, (fixer) => {
                if (!isValidWithUnicodeFlag(
                  context.languageOptions.ecmaVersion,
                  pattern2
                )) {
                  return null;
                }
                if (refNode.arguments.length === 1) {
                  const penultimateToken = sourceCode2.getLastToken(refNode, {
                    skip: 1
                  });
                  return fixer.insertTextAfter(
                    penultimateToken,
                    astUtils2.isCommaToken(penultimateToken) ? ' "u",' : ', "u"'
                  );
                }
                if (flagsNode.type === "Literal" && typeof flagsNode.value === "string" || flagsNode.type === "TemplateLiteral") {
                  const range = [
                    flagsNode.range[0],
                    flagsNode.range[1] - 1
                  ];
                  return fixer.insertTextAfterRange(range, "u");
                }
                return null;
              });
            }
          }
        }
      };
    }
  };
  return noMisleadingCharacterClass;
}
var noMixedOperators;
var hasRequiredNoMixedOperators;
function requireNoMixedOperators() {
  if (hasRequiredNoMixedOperators) return noMixedOperators;
  hasRequiredNoMixedOperators = 1;
  const astUtils2 = requireAstUtils();
  const ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
  const BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
  const COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
  const LOGICAL_OPERATORS = ["&&", "||"];
  const RELATIONAL_OPERATORS = ["in", "instanceof"];
  const TERNARY_OPERATOR = ["?:"];
  const COALESCE_OPERATOR = ["??"];
  const ALL_OPERATORS = [].concat(
    ARITHMETIC_OPERATORS,
    BITWISE_OPERATORS,
    COMPARISON_OPERATORS,
    LOGICAL_OPERATORS,
    RELATIONAL_OPERATORS,
    TERNARY_OPERATOR,
    COALESCE_OPERATOR
  );
  const DEFAULT_GROUPS = [
    ARITHMETIC_OPERATORS,
    BITWISE_OPERATORS,
    COMPARISON_OPERATORS,
    LOGICAL_OPERATORS,
    RELATIONAL_OPERATORS
  ];
  const TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;
  function normalizeOptions(options = {}) {
    const hasGroups = options.groups && options.groups.length > 0;
    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
    const allowSamePrecedence = options.allowSamePrecedence !== false;
    return {
      groups,
      allowSamePrecedence
    };
  }
  function includesBothInAGroup(groups, left, right) {
    return groups.some((group) => group.includes(left) && group.includes(right));
  }
  function getChildNode(node2) {
    return node2.type === "ConditionalExpression" ? node2.test : node2.left;
  }
  noMixedOperators = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-mixed-operators",
              url: "https://eslint.style/rules/no-mixed-operators"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow mixed binary operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-mixed-operators"
      },
      schema: [
        {
          type: "object",
          properties: {
            groups: {
              type: "array",
              items: {
                type: "array",
                items: { enum: ALL_OPERATORS },
                minItems: 2,
                uniqueItems: true
              },
              uniqueItems: true
            },
            allowSamePrecedence: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const options = normalizeOptions(context.options[0]);
      function shouldIgnore(node2) {
        const a2 = node2;
        const b = node2.parent;
        return !includesBothInAGroup(
          options.groups,
          a2.operator,
          b.type === "ConditionalExpression" ? "?:" : b.operator
        ) || options.allowSamePrecedence && astUtils2.getPrecedence(a2) === astUtils2.getPrecedence(b);
      }
      function isMixedWithParent(node2) {
        return node2.operator !== node2.parent.operator && !astUtils2.isParenthesised(sourceCode2, node2);
      }
      function getOperatorToken(node2) {
        return sourceCode2.getTokenAfter(
          getChildNode(node2),
          astUtils2.isNotClosingParenToken
        );
      }
      function reportBothOperators(node2) {
        const parent = node2.parent;
        const left = getChildNode(parent) === node2 ? node2 : parent;
        const right = getChildNode(parent) !== node2 ? node2 : parent;
        const data2 = {
          leftOperator: left.operator || "?:",
          rightOperator: right.operator || "?:"
        };
        context.report({
          node: left,
          loc: getOperatorToken(left).loc,
          messageId: "unexpectedMixedOperator",
          data: data2
        });
        context.report({
          node: right,
          loc: getOperatorToken(right).loc,
          messageId: "unexpectedMixedOperator",
          data: data2
        });
      }
      function check2(node2) {
        if (TARGET_NODE_TYPE.test(node2.parent.type) && isMixedWithParent(node2) && !shouldIgnore(node2)) {
          reportBothOperators(node2);
        }
      }
      return {
        BinaryExpression: check2,
        LogicalExpression: check2
      };
    }
  };
  return noMixedOperators;
}
var noMixedRequires;
var hasRequiredNoMixedRequires;
function requireNoMixedRequires() {
  if (hasRequiredNoMixedRequires) return noMixedRequires;
  hasRequiredNoMixedRequires = 1;
  noMixedRequires = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-mixed-requires",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-mixed-requires.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow `require` calls to be mixed with regular variable declarations",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-mixed-requires"
      },
      schema: [
        {
          oneOf: [
            {
              type: "boolean"
            },
            {
              type: "object",
              properties: {
                grouping: {
                  type: "boolean"
                },
                allowCall: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        noMixRequire: "Do not mix 'require' and other declarations.",
        noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires."
      }
    },
    create(context) {
      const options = context.options[0];
      let grouping = false, allowCall = false;
      if (typeof options === "object") {
        grouping = options.grouping;
        allowCall = options.allowCall;
      } else {
        grouping = !!options;
      }
      function getBuiltinModules() {
        return [
          "assert",
          "buffer",
          "child_process",
          "cluster",
          "crypto",
          "dgram",
          "dns",
          "domain",
          "events",
          "fs",
          "http",
          "https",
          "net",
          "os",
          "path",
          "punycode",
          "querystring",
          "readline",
          "repl",
          "smalloc",
          "stream",
          "string_decoder",
          "tls",
          "tty",
          "url",
          "util",
          "v8",
          "vm",
          "zlib"
        ];
      }
      const BUILTIN_MODULES = getBuiltinModules();
      const DECL_REQUIRE = "require", DECL_UNINITIALIZED = "uninitialized", DECL_OTHER = "other";
      const REQ_CORE = "core", REQ_FILE = "file", REQ_MODULE = "module", REQ_COMPUTED = "computed";
      function getDeclarationType(initExpression) {
        if (!initExpression) {
          return DECL_UNINITIALIZED;
        }
        if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
          return DECL_REQUIRE;
        }
        if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
          return getDeclarationType(initExpression.callee);
        }
        if (initExpression.type === "MemberExpression") {
          return getDeclarationType(initExpression.object);
        }
        return DECL_OTHER;
      }
      function inferModuleType(initExpression) {
        if (initExpression.type === "MemberExpression") {
          return inferModuleType(initExpression.object);
        }
        if (initExpression.arguments.length === 0) {
          return REQ_COMPUTED;
        }
        const arg = initExpression.arguments[0];
        if (arg.type !== "Literal" || typeof arg.value !== "string") {
          return REQ_COMPUTED;
        }
        if (BUILTIN_MODULES.includes(arg.value)) {
          return REQ_CORE;
        }
        if (/^\.{0,2}\//u.test(arg.value)) {
          return REQ_FILE;
        }
        return REQ_MODULE;
      }
      function isMixed(declarations) {
        const contains2 = {};
        declarations.forEach((declaration) => {
          const type2 = getDeclarationType(declaration.init);
          contains2[type2] = true;
        });
        return !!(contains2[DECL_REQUIRE] && (contains2[DECL_UNINITIALIZED] || contains2[DECL_OTHER]));
      }
      function isGrouped(declarations) {
        const found = {};
        declarations.forEach((declaration) => {
          if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
            found[inferModuleType(declaration.init)] = true;
          }
        });
        return Object.keys(found).length <= 1;
      }
      return {
        VariableDeclaration(node2) {
          if (isMixed(node2.declarations)) {
            context.report({
              node: node2,
              messageId: "noMixRequire"
            });
          } else if (grouping && !isGrouped(node2.declarations)) {
            context.report({
              node: node2,
              messageId: "noMixCoreModuleFileComputed"
            });
          }
        }
      };
    }
  };
  return noMixedRequires;
}
var noMixedSpacesAndTabs;
var hasRequiredNoMixedSpacesAndTabs;
function requireNoMixedSpacesAndTabs() {
  if (hasRequiredNoMixedSpacesAndTabs) return noMixedSpacesAndTabs;
  hasRequiredNoMixedSpacesAndTabs = 1;
  noMixedSpacesAndTabs = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-mixed-spaces-and-tabs",
              url: "https://eslint.style/rules/no-mixed-spaces-and-tabs"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow mixed spaces and tabs for indentation",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-mixed-spaces-and-tabs"
      },
      schema: [
        {
          enum: ["smart-tabs", true, false]
        }
      ],
      messages: {
        mixedSpacesAndTabs: "Mixed spaces and tabs."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let smartTabs;
      switch (context.options[0]) {
        case true:
        case "smart-tabs":
          smartTabs = true;
          break;
        default:
          smartTabs = false;
      }
      return {
        "Program:exit"(node2) {
          const lines = sourceCode2.lines, comments = sourceCode2.getAllComments(), ignoredCommentLines = /* @__PURE__ */ new Set();
          comments.forEach((comment2) => {
            for (let i2 = comment2.loc.start.line + 1; i2 <= comment2.loc.end.line; i2++) {
              ignoredCommentLines.add(i2);
            }
          });
          let regex = /^(?=( +|\t+))\1(?:\t| )/u;
          if (smartTabs) {
            regex = /^(?=(\t*))\1(?=( +))\2\t/u;
          }
          lines.forEach((line, i2) => {
            const match = regex.exec(line);
            if (match) {
              const lineNumber = i2 + 1;
              const loc = {
                start: {
                  line: lineNumber,
                  column: match[0].length - 2
                },
                end: {
                  line: lineNumber,
                  column: match[0].length
                }
              };
              if (!ignoredCommentLines.has(lineNumber)) {
                const containingNode = sourceCode2.getNodeByRangeIndex(
                  sourceCode2.getIndexFromLoc(loc.start)
                );
                if (!(containingNode && ["Literal", "TemplateElement"].includes(
                  containingNode.type
                ))) {
                  context.report({
                    node: node2,
                    loc,
                    messageId: "mixedSpacesAndTabs"
                  });
                }
              }
            }
          });
        }
      };
    }
  };
  return noMixedSpacesAndTabs;
}
var noMultiAssign;
var hasRequiredNoMultiAssign;
function requireNoMultiAssign() {
  if (hasRequiredNoMultiAssign) return noMultiAssign;
  hasRequiredNoMultiAssign = 1;
  noMultiAssign = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          ignoreNonDeclaration: false
        }
      ],
      docs: {
        description: "Disallow use of chained assignment expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-multi-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreNonDeclaration: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedChain: "Unexpected chained assignment."
      }
    },
    create(context) {
      const [{ ignoreNonDeclaration }] = context.options;
      const selectors = [
        "VariableDeclarator > AssignmentExpression.init",
        "PropertyDefinition > AssignmentExpression.value"
      ];
      if (!ignoreNonDeclaration) {
        selectors.push("AssignmentExpression > AssignmentExpression.right");
      }
      return {
        [selectors](node2) {
          context.report({
            node: node2,
            messageId: "unexpectedChain"
          });
        }
      };
    }
  };
  return noMultiAssign;
}
var noMultiSpaces;
var hasRequiredNoMultiSpaces;
function requireNoMultiSpaces() {
  if (hasRequiredNoMultiSpaces) return noMultiSpaces;
  hasRequiredNoMultiSpaces = 1;
  const astUtils2 = requireAstUtils();
  noMultiSpaces = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-multi-spaces",
              url: "https://eslint.style/rules/no-multi-spaces"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow multiple spaces",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-multi-spaces"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "object",
              patternProperties: {
                "^([A-Z][a-z]*)+$": {
                  type: "boolean"
                }
              },
              additionalProperties: false
            },
            ignoreEOLComments: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        multipleSpaces: "Multiple spaces found before '{{displayValue}}'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const options = context.options[0] || {};
      const ignoreEOLComments = options.ignoreEOLComments;
      const exceptions = Object.assign(
        { Property: true },
        options.exceptions
      );
      const hasExceptions = Object.keys(exceptions).some(
        (key) => exceptions[key]
      );
      function formatReportedCommentValue(token) {
        const valueLines = token.value.split("\n");
        const value = valueLines[0];
        const formattedValue = `${value.slice(0, 12)}...`;
        return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
      }
      return {
        Program() {
          sourceCode2.tokensAndComments.forEach(
            (leftToken, leftIndex, tokensAndComments) => {
              if (leftIndex === tokensAndComments.length - 1) {
                return;
              }
              const rightToken = tokensAndComments[leftIndex + 1];
              if (!sourceCode2.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
                return;
              }
              if (ignoreEOLComments && astUtils2.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
                return;
              }
              if (hasExceptions) {
                const parentNode = sourceCode2.getNodeByRangeIndex(
                  rightToken.range[0] - 1
                );
                if (parentNode && exceptions[parentNode.type]) {
                  return;
                }
              }
              let displayValue;
              if (rightToken.type === "Block") {
                displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
              } else if (rightToken.type === "Line") {
                displayValue = `//${formatReportedCommentValue(rightToken)}`;
              } else {
                displayValue = rightToken.value;
              }
              context.report({
                node: rightToken,
                loc: {
                  start: leftToken.loc.end,
                  end: rightToken.loc.start
                },
                messageId: "multipleSpaces",
                data: { displayValue },
                fix: (fixer) => fixer.replaceTextRange(
                  [leftToken.range[1], rightToken.range[0]],
                  " "
                )
              });
            }
          );
        }
      };
    }
  };
  return noMultiSpaces;
}
var noMultiStr;
var hasRequiredNoMultiStr;
function requireNoMultiStr() {
  if (hasRequiredNoMultiStr) return noMultiStr;
  hasRequiredNoMultiStr = 1;
  const astUtils2 = requireAstUtils();
  noMultiStr = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow multiline strings",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-multi-str"
      },
      schema: [],
      messages: {
        multilineString: "Multiline support is limited to browsers supporting ES5 only."
      }
    },
    create(context) {
      function isJSXElement(node2) {
        return node2.type.indexOf("JSX") === 0;
      }
      return {
        Literal(node2) {
          if (astUtils2.LINEBREAK_MATCHER.test(node2.raw) && !isJSXElement(node2.parent)) {
            context.report({
              node: node2,
              messageId: "multilineString"
            });
          }
        }
      };
    }
  };
  return noMultiStr;
}
var noMultipleEmptyLines;
var hasRequiredNoMultipleEmptyLines;
function requireNoMultipleEmptyLines() {
  if (hasRequiredNoMultipleEmptyLines) return noMultipleEmptyLines;
  hasRequiredNoMultipleEmptyLines = 1;
  noMultipleEmptyLines = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-multiple-empty-lines",
              url: "https://eslint.style/rules/no-multiple-empty-lines"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow multiple empty lines",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-multiple-empty-lines"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            max: {
              type: "integer",
              minimum: 0
            },
            maxEOF: {
              type: "integer",
              minimum: 0
            },
            maxBOF: {
              type: "integer",
              minimum: 0
            }
          },
          required: ["max"],
          additionalProperties: false
        }
      ],
      messages: {
        blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
        blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
        consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
      }
    },
    create(context) {
      let max = 2, maxEOF = max, maxBOF = max;
      if (context.options.length) {
        max = context.options[0].max;
        maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
        maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
      }
      const sourceCode2 = context.sourceCode;
      const allLines = sourceCode2.lines.at(-1) === "" ? sourceCode2.lines.slice(0, -1) : sourceCode2.lines;
      const templateLiteralLines = /* @__PURE__ */ new Set();
      return {
        TemplateLiteral(node2) {
          node2.quasis.forEach((literalPart) => {
            for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
              templateLiteralLines.add(ignoredLine);
            }
          });
        },
        "Program:exit"(node2) {
          return allLines.reduce((nonEmptyLineNumbers, line, index) => {
            if (line.trim() || templateLiteralLines.has(index + 1)) {
              nonEmptyLineNumbers.push(index + 1);
            }
            return nonEmptyLineNumbers;
          }, []).concat(allLines.length + 1).reduce((lastLineNumber, lineNumber) => {
            let messageId, maxAllowed;
            if (lastLineNumber === 0) {
              messageId = "blankBeginningOfFile";
              maxAllowed = maxBOF;
            } else if (lineNumber === allLines.length + 1) {
              messageId = "blankEndOfFile";
              maxAllowed = maxEOF;
            } else {
              messageId = "consecutiveBlank";
              maxAllowed = max;
            }
            if (lineNumber - lastLineNumber - 1 > maxAllowed) {
              context.report({
                node: node2,
                loc: {
                  start: {
                    line: lastLineNumber + maxAllowed + 1,
                    column: 0
                  },
                  end: { line: lineNumber, column: 0 }
                },
                messageId,
                data: {
                  max: maxAllowed,
                  pluralizedLines: maxAllowed === 1 ? "line" : "lines"
                },
                fix(fixer) {
                  const rangeStart = sourceCode2.getIndexFromLoc({
                    line: lastLineNumber + 1,
                    column: 0
                  });
                  const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                  const rangeEnd2 = lineNumberAfterRemovedLines <= allLines.length ? sourceCode2.getIndexFromLoc({
                    line: lineNumberAfterRemovedLines,
                    column: 0
                  }) : sourceCode2.text.length;
                  return fixer.removeRange([
                    rangeStart,
                    rangeEnd2
                  ]);
                }
              });
            }
            return lineNumber;
          }, 0);
        }
      };
    }
  };
  return noMultipleEmptyLines;
}
var noNativeReassign;
var hasRequiredNoNativeReassign;
function requireNoNativeReassign() {
  if (hasRequiredNoNativeReassign) return noNativeReassign;
  hasRequiredNoNativeReassign = 1;
  noNativeReassign = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow assignments to native objects or read-only global variables",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-native-reassign"
      },
      deprecated: {
        message: "Renamed rule.",
        url: "https://eslint.org/blog/2016/08/eslint-v3.3.0-released/#deprecated-rules",
        deprecatedSince: "3.3.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            rule: {
              name: "no-global-assign",
              url: "https://eslint.org/docs/rules/no-global-assign"
            }
          }
        ]
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: { type: "string" },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        nativeReassign: "Read-only global '{{name}}' should not be modified."
      }
    },
    create(context) {
      const config2 = context.options[0];
      const exceptions = config2 && config2.exceptions || [];
      const sourceCode2 = context.sourceCode;
      function checkReference(reference, index, references) {
        const identifier = reference.identifier;
        if (reference.init === false && reference.isWrite() && /*
         * Destructuring assignments can have multiple default value,
         * so possibly there are multiple writeable references for the same identifier.
         */
        (index === 0 || references[index - 1].identifier !== identifier)) {
          context.report({
            node: identifier,
            messageId: "nativeReassign",
            data: identifier
          });
        }
      }
      function checkVariable(variable) {
        if (variable.writeable === false && !exceptions.includes(variable.name)) {
          variable.references.forEach(checkReference);
        }
      }
      return {
        Program(node2) {
          const globalScope = sourceCode2.getScope(node2);
          globalScope.variables.forEach(checkVariable);
        }
      };
    }
  };
  return noNativeReassign;
}
var noNegatedCondition;
var hasRequiredNoNegatedCondition;
function requireNoNegatedCondition() {
  if (hasRequiredNoNegatedCondition) return noNegatedCondition;
  hasRequiredNoNegatedCondition = 1;
  noNegatedCondition = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow negated conditions",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-negated-condition"
      },
      schema: [],
      messages: {
        unexpectedNegated: "Unexpected negated condition."
      }
    },
    create(context) {
      function hasElseWithoutCondition(node2) {
        return node2.alternate && node2.alternate.type !== "IfStatement";
      }
      function isNegatedUnaryExpression(test) {
        return test.type === "UnaryExpression" && test.operator === "!";
      }
      function isNegatedBinaryExpression(test) {
        return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
      }
      function isNegatedIf(node2) {
        return isNegatedUnaryExpression(node2.test) || isNegatedBinaryExpression(node2.test);
      }
      return {
        IfStatement(node2) {
          if (!hasElseWithoutCondition(node2)) {
            return;
          }
          if (isNegatedIf(node2)) {
            context.report({
              node: node2,
              messageId: "unexpectedNegated"
            });
          }
        },
        ConditionalExpression(node2) {
          if (isNegatedIf(node2)) {
            context.report({
              node: node2,
              messageId: "unexpectedNegated"
            });
          }
        }
      };
    }
  };
  return noNegatedCondition;
}
var noNegatedInLhs;
var hasRequiredNoNegatedInLhs;
function requireNoNegatedInLhs() {
  if (hasRequiredNoNegatedInLhs) return noNegatedInLhs;
  hasRequiredNoNegatedInLhs = 1;
  noNegatedInLhs = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow negating the left operand in `in` expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-negated-in-lhs"
      },
      deprecated: {
        message: "Renamed rule.",
        url: "https://eslint.org/blog/2016/08/eslint-v3.3.0-released/#deprecated-rules",
        deprecatedSince: "3.3.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            rule: {
              name: "no-unsafe-negation",
              url: "https://eslint.org/docs/rules/no-unsafe-negation"
            }
          }
        ]
      },
      schema: [],
      messages: {
        negatedLHS: "The 'in' expression's left operand is negated."
      }
    },
    create(context) {
      return {
        BinaryExpression(node2) {
          if (node2.operator === "in" && node2.left.type === "UnaryExpression" && node2.left.operator === "!") {
            context.report({ node: node2, messageId: "negatedLHS" });
          }
        }
      };
    }
  };
  return noNegatedInLhs;
}
var noNestedTernary;
var hasRequiredNoNestedTernary;
function requireNoNestedTernary() {
  if (hasRequiredNoNestedTernary) return noNestedTernary;
  hasRequiredNoNestedTernary = 1;
  noNestedTernary = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow nested ternary expressions",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-nested-ternary"
      },
      schema: [],
      messages: {
        noNestedTernary: "Do not nest ternary expressions."
      }
    },
    create(context) {
      return {
        ConditionalExpression(node2) {
          if (node2.alternate.type === "ConditionalExpression" || node2.consequent.type === "ConditionalExpression") {
            context.report({
              node: node2,
              messageId: "noNestedTernary"
            });
          }
        }
      };
    }
  };
  return noNestedTernary;
}
var noNew;
var hasRequiredNoNew;
function requireNoNew() {
  if (hasRequiredNoNew) return noNew;
  hasRequiredNoNew = 1;
  noNew = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators outside of assignments or comparisons",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-new"
      },
      schema: [],
      messages: {
        noNewStatement: "Do not use 'new' for side effects."
      }
    },
    create(context) {
      return {
        "ExpressionStatement > NewExpression"(node2) {
          context.report({
            node: node2.parent,
            messageId: "noNewStatement"
          });
        }
      };
    }
  };
  return noNew;
}
var noNewFunc;
var hasRequiredNoNewFunc;
function requireNoNewFunc() {
  if (hasRequiredNoNewFunc) return noNewFunc;
  hasRequiredNoNewFunc = 1;
  const astUtils2 = requireAstUtils();
  const callMethods = /* @__PURE__ */ new Set(["apply", "bind", "call"]);
  noNewFunc = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators with the `Function` object",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-new-func"
      },
      schema: [],
      messages: {
        noFunctionConstructor: "The Function constructor is eval."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          const variable = globalScope.set.get("Function");
          if (variable && variable.defs.length === 0) {
            variable.references.forEach((ref2) => {
              const idNode = ref2.identifier;
              const { parent } = idNode;
              let evalNode;
              if (parent) {
                if (idNode === parent.callee && (parent.type === "NewExpression" || parent.type === "CallExpression")) {
                  evalNode = parent;
                } else if (parent.type === "MemberExpression" && idNode === parent.object && callMethods.has(
                  astUtils2.getStaticPropertyName(parent)
                )) {
                  const maybeCallee = parent.parent.type === "ChainExpression" ? parent.parent : parent;
                  if (maybeCallee.parent.type === "CallExpression" && maybeCallee.parent.callee === maybeCallee) {
                    evalNode = maybeCallee.parent;
                  }
                }
              }
              if (evalNode) {
                context.report({
                  node: evalNode,
                  messageId: "noFunctionConstructor"
                });
              }
            });
          }
        }
      };
    }
  };
  return noNewFunc;
}
var noNewNativeNonconstructor;
var hasRequiredNoNewNativeNonconstructor;
function requireNoNewNativeNonconstructor() {
  if (hasRequiredNoNewNativeNonconstructor) return noNewNativeNonconstructor;
  hasRequiredNoNewNativeNonconstructor = 1;
  const nonConstructorGlobalFunctionNames = ["Symbol", "BigInt"];
  noNewNativeNonconstructor = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `new` operators with global non-constructor functions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-new-native-nonconstructor"
      },
      schema: [],
      messages: {
        noNewNonconstructor: "`{{name}}` cannot be called as a constructor."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          for (const nonConstructorName of nonConstructorGlobalFunctionNames) {
            const variable = globalScope.set.get(nonConstructorName);
            if (variable && variable.defs.length === 0) {
              variable.references.forEach((ref2) => {
                const idNode = ref2.identifier;
                const parent = idNode.parent;
                if (parent && parent.type === "NewExpression" && parent.callee === idNode) {
                  context.report({
                    node: idNode,
                    messageId: "noNewNonconstructor",
                    data: { name: nonConstructorName }
                  });
                }
              });
            }
          }
        }
      };
    }
  };
  return noNewNativeNonconstructor;
}
var noNewObject;
var hasRequiredNoNewObject;
function requireNoNewObject() {
  if (hasRequiredNoNewObject) return noNewObject;
  hasRequiredNoNewObject = 1;
  const astUtils2 = requireAstUtils();
  noNewObject = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `Object` constructors",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-new-object"
      },
      deprecated: {
        message: "The new rule flags more situations where object literal syntax can be used, and it does not report a problem when the `Object` constructor is invoked with an argument.",
        url: "https://eslint.org/blog/2023/09/eslint-v8.50.0-released/",
        deprecatedSince: "8.50.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            rule: {
              name: "no-object-constructor",
              url: "https://eslint.org/docs/rules/no-object-constructor"
            }
          }
        ]
      },
      schema: [],
      messages: {
        preferLiteral: "The object literal notation {} is preferable."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        NewExpression(node2) {
          const variable = astUtils2.getVariableByName(
            sourceCode2.getScope(node2),
            node2.callee.name
          );
          if (variable && variable.identifiers.length > 0) {
            return;
          }
          if (node2.callee.name === "Object") {
            context.report({
              node: node2,
              messageId: "preferLiteral"
            });
          }
        }
      };
    }
  };
  return noNewObject;
}
var noNewRequire;
var hasRequiredNoNewRequire;
function requireNoNewRequire() {
  if (hasRequiredNoNewRequire) return noNewRequire;
  hasRequiredNoNewRequire = 1;
  noNewRequire = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-new-require",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-new-require.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators with calls to `require`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-new-require"
      },
      schema: [],
      messages: {
        noNewRequire: "Unexpected use of new with require."
      }
    },
    create(context) {
      return {
        NewExpression(node2) {
          if (node2.callee.type === "Identifier" && node2.callee.name === "require") {
            context.report({
              node: node2,
              messageId: "noNewRequire"
            });
          }
        }
      };
    }
  };
  return noNewRequire;
}
var noNewSymbol;
var hasRequiredNoNewSymbol;
function requireNoNewSymbol() {
  if (hasRequiredNoNewSymbol) return noNewSymbol;
  hasRequiredNoNewSymbol = 1;
  noNewSymbol = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `new` operators with the `Symbol` object",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-new-symbol"
      },
      deprecated: {
        message: "The rule was replaced with a more general rule.",
        url: "https://eslint.org/docs/latest/use/migrate-to-9.0.0#eslint-recommended",
        deprecatedSince: "9.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            rule: {
              name: "no-new-native-nonconstructor",
              url: "https://eslint.org/docs/latest/rules/no-new-native-nonconstructor"
            }
          }
        ]
      },
      schema: [],
      messages: {
        noNewSymbol: "`Symbol` cannot be called as a constructor."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          const variable = globalScope.set.get("Symbol");
          if (variable && variable.defs.length === 0) {
            variable.references.forEach((ref2) => {
              const idNode = ref2.identifier;
              const parent = idNode.parent;
              if (parent && parent.type === "NewExpression" && parent.callee === idNode) {
                context.report({
                  node: idNode,
                  messageId: "noNewSymbol"
                });
              }
            });
          }
        }
      };
    }
  };
  return noNewSymbol;
}
var noNewWrappers;
var hasRequiredNoNewWrappers;
function requireNoNewWrappers() {
  if (hasRequiredNoNewWrappers) return noNewWrappers;
  hasRequiredNoNewWrappers = 1;
  const { getVariableByName } = requireAstUtils();
  noNewWrappers = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-new-wrappers"
      },
      schema: [],
      messages: {
        noConstructor: "Do not use {{fn}} as a constructor."
      }
    },
    create(context) {
      const { sourceCode: sourceCode2 } = context;
      return {
        NewExpression(node2) {
          const wrapperObjects = ["String", "Number", "Boolean"];
          const { name: name2 } = node2.callee;
          if (wrapperObjects.includes(name2)) {
            const variable = getVariableByName(
              sourceCode2.getScope(node2),
              name2
            );
            if (variable && variable.identifiers.length === 0) {
              context.report({
                node: node2,
                messageId: "noConstructor",
                data: { fn: name2 }
              });
            }
          }
        }
      };
    }
  };
  return noNewWrappers;
}
var noNonoctalDecimalEscape;
var hasRequiredNoNonoctalDecimalEscape;
function requireNoNonoctalDecimalEscape() {
  if (hasRequiredNoNonoctalDecimalEscape) return noNonoctalDecimalEscape;
  hasRequiredNoNonoctalDecimalEscape = 1;
  const QUICK_TEST_REGEX = /\\[89]/u;
  function getUnicodeEscape(character) {
    return `\\u${character.charCodeAt(0).toString(16).padStart(4, "0")}`;
  }
  noNonoctalDecimalEscape = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `\\8` and `\\9` escape sequences in string literals",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-nonoctal-decimal-escape"
      },
      hasSuggestions: true,
      schema: [],
      messages: {
        decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.",
        // suggestions
        refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",
        escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function createSuggestion(messageId, range, replacement) {
        return {
          messageId,
          data: {
            original: sourceCode2.getText().slice(...range),
            replacement
          },
          fix(fixer) {
            return fixer.replaceTextRange(range, replacement);
          }
        };
      }
      return {
        Literal(node2) {
          if (typeof node2.value !== "string") {
            return;
          }
          if (!QUICK_TEST_REGEX.test(node2.raw)) {
            return;
          }
          const regex = /(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy;
          let match;
          while (match = regex.exec(node2.raw)) {
            const { previousEscape, decimalEscape } = match.groups;
            const decimalEscapeRangeEnd = node2.range[0] + match.index + match[0].length;
            const decimalEscapeRangeStart = decimalEscapeRangeEnd - decimalEscape.length;
            const decimalEscapeRange = [
              decimalEscapeRangeStart,
              decimalEscapeRangeEnd
            ];
            const suggest = [];
            if (previousEscape === "\\0") {
              suggest.push(
                createSuggestion(
                  // "\0\8" -> "\u00008"
                  "refactor",
                  [
                    decimalEscapeRangeStart - previousEscape.length,
                    decimalEscapeRangeEnd
                  ],
                  `${getUnicodeEscape("\0")}${decimalEscape[1]}`
                ),
                createSuggestion(
                  // "\8" -> "\u0038"
                  "refactor",
                  decimalEscapeRange,
                  getUnicodeEscape(decimalEscape[1])
                )
              );
            } else {
              suggest.push(
                createSuggestion(
                  // "\8" -> "8"
                  "refactor",
                  decimalEscapeRange,
                  decimalEscape[1]
                )
              );
            }
            suggest.push(
              createSuggestion(
                // "\8" -> "\\8"
                "escapeBackslash",
                decimalEscapeRange,
                `\\${decimalEscape}`
              )
            );
            context.report({
              node: node2,
              loc: {
                start: sourceCode2.getLocFromIndex(
                  decimalEscapeRangeStart
                ),
                end: sourceCode2.getLocFromIndex(
                  decimalEscapeRangeEnd
                )
              },
              messageId: "decimalEscape",
              data: {
                decimalEscape
              },
              suggest
            });
          }
        }
      };
    }
  };
  return noNonoctalDecimalEscape;
}
var noObjCalls;
var hasRequiredNoObjCalls;
function requireNoObjCalls() {
  if (hasRequiredNoObjCalls) return noObjCalls;
  hasRequiredNoObjCalls = 1;
  const {
    CALL,
    CONSTRUCT,
    ReferenceTracker
  } = /* @__PURE__ */ requireEslintUtils();
  const getPropertyName = requireAstUtils().getStaticPropertyName;
  const nonCallableGlobals = ["Atomics", "JSON", "Math", "Reflect", "Intl"];
  function getReportNodeName(node2) {
    if (node2.type === "ChainExpression") {
      return getReportNodeName(node2.expression);
    }
    if (node2.type === "MemberExpression") {
      return getPropertyName(node2);
    }
    return node2.name;
  }
  noObjCalls = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow calling global object properties as functions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-obj-calls"
      },
      schema: [],
      messages: {
        unexpectedCall: "'{{name}}' is not a function.",
        unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          const traceMap = {};
          for (const g2 of nonCallableGlobals) {
            traceMap[g2] = {
              [CALL]: true,
              [CONSTRUCT]: true
            };
          }
          for (const {
            node: refNode,
            path
          } of tracker.iterateGlobalReferences(traceMap)) {
            const name2 = getReportNodeName(refNode.callee);
            const ref2 = path[0];
            const messageId = name2 === ref2 ? "unexpectedCall" : "unexpectedRefCall";
            context.report({
              node: refNode,
              messageId,
              data: { name: name2, ref: ref2 }
            });
          }
        }
      };
    }
  };
  return noObjCalls;
}
var noObjectConstructor;
var hasRequiredNoObjectConstructor;
function requireNoObjectConstructor() {
  if (hasRequiredNoObjectConstructor) return noObjectConstructor;
  hasRequiredNoObjectConstructor = 1;
  const {
    getVariableByName,
    isArrowToken,
    isStartOfExpressionStatement,
    needsPrecedingSemicolon
  } = requireAstUtils();
  noObjectConstructor = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow calls to the `Object` constructor without an argument",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-object-constructor"
      },
      hasSuggestions: true,
      schema: [],
      messages: {
        preferLiteral: "The object literal notation {} is preferable.",
        useLiteral: "Replace with '{{replacement}}'.",
        useLiteralAfterSemicolon: "Replace with '{{replacement}}', add preceding semicolon."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function needsParentheses(node2) {
        if (isStartOfExpressionStatement(node2)) {
          return true;
        }
        const prevToken = sourceCode2.getTokenBefore(node2);
        if (prevToken && isArrowToken(prevToken)) {
          return true;
        }
        return false;
      }
      function check2(node2) {
        if (node2.callee.type !== "Identifier" || node2.callee.name !== "Object" || node2.arguments.length) {
          return;
        }
        const variable = getVariableByName(
          sourceCode2.getScope(node2),
          "Object"
        );
        if (variable && variable.identifiers.length === 0) {
          let replacement;
          let fixText;
          let messageId = "useLiteral";
          if (needsParentheses(node2)) {
            replacement = "({})";
            if (needsPrecedingSemicolon(sourceCode2, node2)) {
              fixText = ";({})";
              messageId = "useLiteralAfterSemicolon";
            } else {
              fixText = "({})";
            }
          } else {
            replacement = fixText = "{}";
          }
          context.report({
            node: node2,
            messageId: "preferLiteral",
            suggest: [
              {
                messageId,
                data: { replacement },
                fix: (fixer) => fixer.replaceText(node2, fixText)
              }
            ]
          });
        }
      }
      return {
        CallExpression: check2,
        NewExpression: check2
      };
    }
  };
  return noObjectConstructor;
}
var noOctal;
var hasRequiredNoOctal;
function requireNoOctal() {
  if (hasRequiredNoOctal) return noOctal;
  hasRequiredNoOctal = 1;
  noOctal = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow octal literals",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-octal"
      },
      schema: [],
      messages: {
        noOctal: "Octal literals should not be used."
      }
    },
    create(context) {
      return {
        Literal(node2) {
          if (typeof node2.value === "number" && /^0\d/u.test(node2.raw)) {
            context.report({
              node: node2,
              messageId: "noOctal"
            });
          }
        }
      };
    }
  };
  return noOctal;
}
var noOctalEscape;
var hasRequiredNoOctalEscape;
function requireNoOctalEscape() {
  if (hasRequiredNoOctalEscape) return noOctalEscape;
  hasRequiredNoOctalEscape = 1;
  noOctalEscape = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow octal escape sequences in string literals",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-octal-escape"
      },
      schema: [],
      messages: {
        octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."
      }
    },
    create(context) {
      return {
        Literal(node2) {
          if (typeof node2.value !== "string") {
            return;
          }
          const match = node2.raw.match(
            /^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su
          );
          if (match) {
            context.report({
              node: node2,
              messageId: "octalEscapeSequence",
              data: { sequence: match[1] }
            });
          }
        }
      };
    }
  };
  return noOctalEscape;
}
var noParamReassign;
var hasRequiredNoParamReassign;
function requireNoParamReassign() {
  if (hasRequiredNoParamReassign) return noParamReassign;
  hasRequiredNoParamReassign = 1;
  const stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
  noParamReassign = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow reassigning function parameters",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-param-reassign"
      },
      schema: [
        {
          oneOf: [
            {
              type: "object",
              properties: {
                props: {
                  enum: [false]
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                props: {
                  enum: [true]
                },
                ignorePropertyModificationsFor: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: true
                },
                ignorePropertyModificationsForRegex: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: true
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.",
        assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'."
      }
    },
    create(context) {
      const props = context.options[0] && context.options[0].props;
      const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];
      const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];
      const sourceCode2 = context.sourceCode;
      function isModifyingProp(reference) {
        let node2 = reference.identifier;
        let parent = node2.parent;
        while (parent && (!stopNodePattern.test(parent.type) || parent.type === "ForInStatement" || parent.type === "ForOfStatement")) {
          switch (parent.type) {
            case "AssignmentExpression":
              return parent.left === node2;
            case "UpdateExpression":
              return true;
            case "UnaryExpression":
              if (parent.operator === "delete") {
                return true;
              }
              break;
            case "ForInStatement":
            case "ForOfStatement":
              if (parent.left === node2) {
                return true;
              }
              return false;
            case "CallExpression":
              if (parent.callee !== node2) {
                return false;
              }
              break;
            case "MemberExpression":
              if (parent.property === node2) {
                return false;
              }
              break;
            case "Property":
              if (parent.key === node2) {
                return false;
              }
              break;
            case "ConditionalExpression":
              if (parent.test === node2) {
                return false;
              }
              break;
          }
          node2 = parent;
          parent = node2.parent;
        }
        return false;
      }
      function isIgnoredPropertyAssignment(identifierName) {
        return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(
          (ignored) => new RegExp(ignored, "u").test(identifierName)
        );
      }
      function checkReference(reference, index, references) {
        const identifier = reference.identifier;
        if (identifier && !reference.init && /*
         * Destructuring assignments can have multiple default value,
         * so possibly there are multiple writeable references for the same identifier.
         */
        (index === 0 || references[index - 1].identifier !== identifier)) {
          if (reference.isWrite()) {
            context.report({
              node: identifier,
              messageId: "assignmentToFunctionParam",
              data: { name: identifier.name }
            });
          } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {
            context.report({
              node: identifier,
              messageId: "assignmentToFunctionParamProp",
              data: { name: identifier.name }
            });
          }
        }
      }
      function checkVariable(variable) {
        if (variable.defs[0].type === "Parameter") {
          variable.references.forEach(checkReference);
        }
      }
      function checkForFunction(node2) {
        sourceCode2.getDeclaredVariables(node2).forEach(checkVariable);
      }
      return {
        // `:exit` is needed for the `node.parent` property of identifier nodes.
        "FunctionDeclaration:exit": checkForFunction,
        "FunctionExpression:exit": checkForFunction,
        "ArrowFunctionExpression:exit": checkForFunction
      };
    }
  };
  return noParamReassign;
}
var noPathConcat;
var hasRequiredNoPathConcat;
function requireNoPathConcat() {
  if (hasRequiredNoPathConcat) return noPathConcat;
  hasRequiredNoPathConcat = 1;
  noPathConcat = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-path-concat",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-path-concat.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow string concatenation with `__dirname` and `__filename`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-path-concat"
      },
      schema: [],
      messages: {
        usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths."
      }
    },
    create(context) {
      const MATCHER = /^__(?:dir|file)name$/u;
      return {
        BinaryExpression(node2) {
          const left = node2.left, right = node2.right;
          if (node2.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {
            context.report({
              node: node2,
              messageId: "usePathFunctions"
            });
          }
        }
      };
    }
  };
  return noPathConcat;
}
var noPlusplus;
var hasRequiredNoPlusplus;
function requireNoPlusplus() {
  if (hasRequiredNoPlusplus) return noPlusplus;
  hasRequiredNoPlusplus = 1;
  function isForStatementUpdate(node2) {
    const parent = node2.parent;
    return parent.type === "ForStatement" && parent.update === node2;
  }
  function isForLoopAfterthought(node2) {
    const parent = node2.parent;
    if (parent.type === "SequenceExpression") {
      return isForLoopAfterthought(parent);
    }
    return isForStatementUpdate(node2);
  }
  noPlusplus = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowForLoopAfterthoughts: false
        }
      ],
      docs: {
        description: "Disallow the unary operators `++` and `--`",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-plusplus"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowForLoopAfterthoughts: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedUnaryOp: "Unary operator '{{operator}}' used."
      }
    },
    create(context) {
      const [{ allowForLoopAfterthoughts }] = context.options;
      return {
        UpdateExpression(node2) {
          if (allowForLoopAfterthoughts && isForLoopAfterthought(node2)) {
            return;
          }
          context.report({
            node: node2,
            messageId: "unexpectedUnaryOp",
            data: {
              operator: node2.operator
            }
          });
        }
      };
    }
  };
  return noPlusplus;
}
var noProcessEnv;
var hasRequiredNoProcessEnv;
function requireNoProcessEnv() {
  if (hasRequiredNoProcessEnv) return noProcessEnv;
  hasRequiredNoProcessEnv = 1;
  noProcessEnv = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-process-env",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-process-env.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow the use of `process.env`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-process-env"
      },
      schema: [],
      messages: {
        unexpectedProcessEnv: "Unexpected use of process.env."
      }
    },
    create(context) {
      return {
        MemberExpression(node2) {
          const objectName = node2.object.name, propertyName2 = node2.property.name;
          if (objectName === "process" && !node2.computed && propertyName2 && propertyName2 === "env") {
            context.report({ node: node2, messageId: "unexpectedProcessEnv" });
          }
        }
      };
    }
  };
  return noProcessEnv;
}
var noProcessExit;
var hasRequiredNoProcessExit;
function requireNoProcessExit() {
  if (hasRequiredNoProcessExit) return noProcessExit;
  hasRequiredNoProcessExit = 1;
  noProcessExit = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-process-exit",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-process-exit.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow the use of `process.exit()`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-process-exit"
      },
      schema: [],
      messages: {
        noProcessExit: "Don't use process.exit(); throw an error instead."
      }
    },
    create(context) {
      return {
        "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node2) {
          context.report({
            node: node2.parent,
            messageId: "noProcessExit"
          });
        }
      };
    }
  };
  return noProcessExit;
}
var noPromiseExecutorReturn;
var hasRequiredNoPromiseExecutorReturn;
function requireNoPromiseExecutorReturn() {
  if (hasRequiredNoPromiseExecutorReturn) return noPromiseExecutorReturn;
  hasRequiredNoPromiseExecutorReturn = 1;
  const astUtils2 = requireAstUtils();
  const functionTypesToCheck = /* @__PURE__ */ new Set([
    "ArrowFunctionExpression",
    "FunctionExpression"
  ]);
  function isPromiseExecutor(node2, sourceCode2) {
    const parent = node2.parent;
    return parent.type === "NewExpression" && parent.arguments[0] === node2 && parent.callee.type === "Identifier" && parent.callee.name === "Promise" && sourceCode2.isGlobalReference(parent.callee);
  }
  function expressionIsVoid(node2) {
    return node2.type === "UnaryExpression" && node2.operator === "void";
  }
  function voidPrependFixer(sourceCode2, node2, fixer) {
    const requiresParens = (
      // prepending `void ` will fail if the node has a lower precedence than void
      astUtils2.getPrecedence(node2) < astUtils2.getPrecedence({
        type: "UnaryExpression",
        operator: "void"
      }) && // check if there are parentheses around the node to avoid redundant parentheses
      !astUtils2.isParenthesised(sourceCode2, node2)
    );
    const returnOrArrowToken = sourceCode2.getTokenBefore(
      node2,
      node2.parent.type === "ArrowFunctionExpression" ? astUtils2.isArrowToken : (
        // isReturnToken
        (token) => token.type === "Keyword" && token.value === "return"
      )
    );
    const firstToken = sourceCode2.getTokenAfter(returnOrArrowToken);
    const prependSpace = (
      // is return token, as => allows void to be adjacent
      returnOrArrowToken.value === "return" && // If two tokens (return and "(") are adjacent
      returnOrArrowToken.range[1] === firstToken.range[0]
    );
    return [
      fixer.insertTextBefore(
        firstToken,
        `${prependSpace ? " " : ""}void ${requiresParens ? "(" : ""}`
      ),
      fixer.insertTextAfter(node2, requiresParens ? ")" : "")
    ];
  }
  function curlyWrapFixer(sourceCode2, node2, fixer) {
    const arrowToken = sourceCode2.getTokenBefore(
      node2.body,
      astUtils2.isArrowToken
    );
    const firstToken = sourceCode2.getTokenAfter(arrowToken);
    const lastToken = sourceCode2.getLastToken(node2);
    return [
      fixer.insertTextBefore(firstToken, "{"),
      fixer.insertTextAfter(lastToken, "}")
    ];
  }
  noPromiseExecutorReturn = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowVoid: false
        }
      ],
      docs: {
        description: "Disallow returning values from Promise executor functions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-promise-executor-return"
      },
      hasSuggestions: true,
      schema: [
        {
          type: "object",
          properties: {
            allowVoid: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        returnsValue: "Return values from promise executor functions cannot be read.",
        // arrow and function suggestions
        prependVoid: "Prepend `void` to the expression.",
        // only arrow suggestions
        wrapBraces: "Wrap the expression in `{}`."
      }
    },
    create(context) {
      let funcInfo = null;
      const sourceCode2 = context.sourceCode;
      const [{ allowVoid }] = context.options;
      return {
        onCodePathStart(_, node2) {
          funcInfo = {
            upper: funcInfo,
            shouldCheck: functionTypesToCheck.has(node2.type) && isPromiseExecutor(node2, sourceCode2)
          };
          if (
            // Is a Promise executor
            funcInfo.shouldCheck && node2.type === "ArrowFunctionExpression" && node2.expression && // Except void
            !(allowVoid && expressionIsVoid(node2.body))
          ) {
            const suggest = [];
            if (allowVoid) {
              suggest.push({
                messageId: "prependVoid",
                fix(fixer) {
                  return voidPrependFixer(
                    sourceCode2,
                    node2.body,
                    fixer
                  );
                }
              });
            }
            if (!(node2.body.type === "FunctionExpression" && !node2.body.id)) {
              suggest.push({
                messageId: "wrapBraces",
                fix(fixer) {
                  return curlyWrapFixer(sourceCode2, node2, fixer);
                }
              });
            }
            context.report({
              node: node2.body,
              messageId: "returnsValue",
              suggest
            });
          }
        },
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        ReturnStatement(node2) {
          if (!(funcInfo.shouldCheck && node2.argument)) {
            return;
          }
          if (!allowVoid) {
            context.report({ node: node2, messageId: "returnsValue" });
            return;
          }
          if (expressionIsVoid(node2.argument)) {
            return;
          }
          context.report({
            node: node2,
            messageId: "returnsValue",
            suggest: [
              {
                messageId: "prependVoid",
                fix(fixer) {
                  return voidPrependFixer(
                    sourceCode2,
                    node2.argument,
                    fixer
                  );
                }
              }
            ]
          });
        }
      };
    }
  };
  return noPromiseExecutorReturn;
}
var noProto;
var hasRequiredNoProto;
function requireNoProto() {
  if (hasRequiredNoProto) return noProto;
  hasRequiredNoProto = 1;
  const { getStaticPropertyName } = requireAstUtils();
  noProto = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of the `__proto__` property",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-proto"
      },
      schema: [],
      messages: {
        unexpectedProto: "The '__proto__' property is deprecated."
      }
    },
    create(context) {
      return {
        MemberExpression(node2) {
          if (getStaticPropertyName(node2) === "__proto__") {
            context.report({ node: node2, messageId: "unexpectedProto" });
          }
        }
      };
    }
  };
  return noProto;
}
var noPrototypeBuiltins;
var hasRequiredNoPrototypeBuiltins;
function requireNoPrototypeBuiltins() {
  if (hasRequiredNoPrototypeBuiltins) return noPrototypeBuiltins;
  hasRequiredNoPrototypeBuiltins = 1;
  const astUtils2 = requireAstUtils();
  function isAfterOptional(node2) {
    let leftNode;
    if (node2.type === "MemberExpression") {
      leftNode = node2.object;
    } else if (node2.type === "CallExpression") {
      leftNode = node2.callee;
    } else {
      return false;
    }
    if (node2.optional) {
      return true;
    }
    return isAfterOptional(leftNode);
  }
  noPrototypeBuiltins = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow calling some `Object.prototype` methods directly on objects",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-prototype-builtins"
      },
      hasSuggestions: true,
      schema: [],
      messages: {
        prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object.",
        callObjectPrototype: "Call Object.prototype.{{prop}} explicitly."
      }
    },
    create(context) {
      const DISALLOWED_PROPS = /* @__PURE__ */ new Set([
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable"
      ]);
      function disallowBuiltIns(node2) {
        const callee = astUtils2.skipChainExpression(node2.callee);
        if (callee.type !== "MemberExpression") {
          return;
        }
        const propName = astUtils2.getStaticPropertyName(callee);
        if (propName !== null && DISALLOWED_PROPS.has(propName)) {
          context.report({
            messageId: "prototypeBuildIn",
            loc: callee.property.loc,
            data: { prop: propName },
            node: node2,
            suggest: [
              {
                messageId: "callObjectPrototype",
                data: { prop: propName },
                fix(fixer) {
                  const sourceCode2 = context.sourceCode;
                  if (isAfterOptional(node2)) {
                    return null;
                  }
                  if (node2.callee.type === "ChainExpression") {
                    return null;
                  }
                  const objectVariable = astUtils2.getVariableByName(
                    sourceCode2.getScope(node2),
                    "Object"
                  );
                  if (!objectVariable || objectVariable.scope.type !== "global" || objectVariable.defs.length > 0) {
                    return null;
                  }
                  let objectText = sourceCode2.getText(
                    callee.object
                  );
                  if (astUtils2.getPrecedence(callee.object) <= astUtils2.getPrecedence({
                    type: "SequenceExpression"
                  })) {
                    objectText = `(${objectText})`;
                  }
                  const openParenToken = sourceCode2.getTokenAfter(
                    node2.callee,
                    astUtils2.isOpeningParenToken
                  );
                  const isEmptyParameters = node2.arguments.length === 0;
                  const delim = isEmptyParameters ? "" : ", ";
                  const fixes = [
                    fixer.replaceText(
                      callee,
                      `Object.prototype.${propName}.call`
                    ),
                    fixer.insertTextAfter(
                      openParenToken,
                      objectText + delim
                    )
                  ];
                  return fixes;
                }
              }
            ]
          });
        }
      }
      return {
        CallExpression: disallowBuiltIns
      };
    }
  };
  return noPrototypeBuiltins;
}
var noRedeclare;
var hasRequiredNoRedeclare;
function requireNoRedeclare() {
  if (hasRequiredNoRedeclare) return noRedeclare;
  hasRequiredNoRedeclare = 1;
  const astUtils2 = requireAstUtils();
  noRedeclare = {
    meta: {
      type: "suggestion",
      defaultOptions: [{ builtinGlobals: true }],
      docs: {
        description: "Disallow variable redeclaration",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-redeclare"
      },
      messages: {
        redeclared: "'{{id}}' is already defined.",
        redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
        redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
      },
      schema: [
        {
          type: "object",
          properties: {
            builtinGlobals: { type: "boolean" }
          },
          additionalProperties: false
        }
      ]
    },
    create(context) {
      const [{ builtinGlobals }] = context.options;
      const sourceCode2 = context.sourceCode;
      function* iterateDeclarations(variable) {
        if (builtinGlobals && (variable.eslintImplicitGlobalSetting === "readonly" || variable.eslintImplicitGlobalSetting === "writable")) {
          yield { type: "builtin" };
        }
        for (const id2 of variable.identifiers) {
          yield { type: "syntax", node: id2, loc: id2.loc };
        }
        if (variable.eslintExplicitGlobalComments) {
          for (const comment2 of variable.eslintExplicitGlobalComments) {
            yield {
              type: "comment",
              node: comment2,
              loc: astUtils2.getNameLocationInGlobalDirectiveComment(
                sourceCode2,
                comment2,
                variable.name
              )
            };
          }
        }
      }
      function findVariablesInScope(scope) {
        for (const variable of scope.variables) {
          const [declaration, ...extraDeclarations] = iterateDeclarations(variable);
          if (extraDeclarations.length === 0) {
            continue;
          }
          const detailMessageId = declaration.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax";
          const data2 = { id: variable.name };
          for (const { type: type2, node: node2, loc } of extraDeclarations) {
            const messageId = type2 === declaration.type ? "redeclared" : detailMessageId;
            context.report({ node: node2, loc, messageId, data: data2 });
          }
        }
      }
      function checkForBlock(node2) {
        const scope = sourceCode2.getScope(node2);
        if (scope.block === node2) {
          findVariablesInScope(scope);
        }
      }
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          findVariablesInScope(scope);
          if (scope.type === "global" && scope.childScopes[0] && // The special scope's block is the Program node.
          scope.block === scope.childScopes[0].block) {
            findVariablesInScope(scope.childScopes[0]);
          }
        },
        FunctionDeclaration: checkForBlock,
        FunctionExpression: checkForBlock,
        ArrowFunctionExpression: checkForBlock,
        StaticBlock: checkForBlock,
        BlockStatement: checkForBlock,
        ForStatement: checkForBlock,
        ForInStatement: checkForBlock,
        ForOfStatement: checkForBlock,
        SwitchStatement: checkForBlock
      };
    }
  };
  return noRedeclare;
}
var noRegexSpaces;
var hasRequiredNoRegexSpaces;
function requireNoRegexSpaces() {
  if (hasRequiredNoRegexSpaces) return noRegexSpaces;
  hasRequiredNoRegexSpaces = 1;
  const astUtils2 = requireAstUtils();
  const regexpp2 = requireRegexpp();
  const regExpParser = new regexpp2.RegExpParser();
  const DOUBLE_SPACE = / {2}/u;
  function isString(node2) {
    return node2 && node2.type === "Literal" && typeof node2.value === "string";
  }
  noRegexSpaces = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow multiple spaces in regular expressions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-regex-spaces"
      },
      schema: [],
      fixable: "code",
      messages: {
        multipleSpaces: "Spaces are hard to count. Use {{{length}}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkRegex(nodeToReport, pattern2, rawPattern, rawPatternStartRange, flags2) {
        if (!DOUBLE_SPACE.test(rawPattern)) {
          return;
        }
        const characterClassNodes = [];
        let regExpAST;
        try {
          regExpAST = regExpParser.parsePattern(
            pattern2,
            0,
            pattern2.length,
            {
              unicode: flags2.includes("u"),
              unicodeSets: flags2.includes("v")
            }
          );
        } catch {
          return;
        }
        regexpp2.visitRegExpAST(regExpAST, {
          onCharacterClassEnter(ccNode) {
            characterClassNodes.push(ccNode);
          }
        });
        const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;
        let match;
        while (match = spacesPattern.exec(pattern2)) {
          const {
            1: { length },
            index
          } = match;
          if (characterClassNodes.every(
            ({ start, end }) => index < start || end <= index
          )) {
            context.report({
              node: nodeToReport,
              messageId: "multipleSpaces",
              data: { length },
              fix(fixer) {
                if (pattern2 !== rawPattern) {
                  return null;
                }
                return fixer.replaceTextRange(
                  [
                    rawPatternStartRange + index,
                    rawPatternStartRange + index + length
                  ],
                  ` {${length}}`
                );
              }
            });
            return;
          }
        }
      }
      function checkLiteral(node2) {
        if (node2.regex) {
          const pattern2 = node2.regex.pattern;
          const rawPattern = node2.raw.slice(1, node2.raw.lastIndexOf("/"));
          const rawPatternStartRange = node2.range[0] + 1;
          const flags2 = node2.regex.flags;
          checkRegex(
            node2,
            pattern2,
            rawPattern,
            rawPatternStartRange,
            flags2
          );
        }
      }
      function checkFunction(node2) {
        const scope = sourceCode2.getScope(node2);
        const regExpVar = astUtils2.getVariableByName(scope, "RegExp");
        const shadowed = regExpVar && regExpVar.defs.length > 0;
        const patternNode = node2.arguments[0];
        if (node2.callee.type === "Identifier" && node2.callee.name === "RegExp" && isString(patternNode) && !shadowed) {
          const pattern2 = patternNode.value;
          const rawPattern = patternNode.raw.slice(1, -1);
          const rawPatternStartRange = patternNode.range[0] + 1;
          let flags2;
          if (node2.arguments.length < 2) {
            flags2 = "";
          } else {
            const flagsNode = node2.arguments[1];
            if (isString(flagsNode)) {
              flags2 = flagsNode.value;
            } else {
              return;
            }
          }
          checkRegex(
            node2,
            pattern2,
            rawPattern,
            rawPatternStartRange,
            flags2
          );
        }
      }
      return {
        Literal: checkLiteral,
        CallExpression: checkFunction,
        NewExpression: checkFunction
      };
    }
  };
  return noRegexSpaces;
}
var noRestrictedExports;
var hasRequiredNoRestrictedExports;
function requireNoRestrictedExports() {
  if (hasRequiredNoRestrictedExports) return noRestrictedExports;
  hasRequiredNoRestrictedExports = 1;
  const astUtils2 = requireAstUtils();
  noRestrictedExports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified names in exports",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-restricted-exports"
      },
      schema: [
        {
          anyOf: [
            {
              type: "object",
              properties: {
                restrictedNamedExports: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: true
                },
                restrictedNamedExportsPattern: { type: "string" }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                restrictedNamedExports: {
                  type: "array",
                  items: {
                    type: "string",
                    pattern: "^(?!default$)"
                  },
                  uniqueItems: true
                },
                restrictedNamedExportsPattern: { type: "string" },
                restrictDefaultExports: {
                  type: "object",
                  properties: {
                    // Allow/Disallow `export default foo; export default 42; export default function foo() {}` format
                    direct: {
                      type: "boolean"
                    },
                    // Allow/Disallow `export { foo as default };` declarations
                    named: {
                      type: "boolean"
                    },
                    //  Allow/Disallow `export { default } from "mod"; export { default as default } from "mod";` declarations
                    defaultFrom: {
                      type: "boolean"
                    },
                    //  Allow/Disallow `export { foo as default } from "mod";` declarations
                    namedFrom: {
                      type: "boolean"
                    },
                    //  Allow/Disallow `export * as default from "mod"`; declarations
                    namespaceFrom: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        restrictedNamed: "'{{name}}' is restricted from being used as an exported name.",
        restrictedDefault: "Exporting 'default' is restricted."
      }
    },
    create(context) {
      const restrictedNames = new Set(
        context.options[0] && context.options[0].restrictedNamedExports
      );
      const restrictedNamePattern = context.options[0] && context.options[0].restrictedNamedExportsPattern;
      const restrictDefaultExports = context.options[0] && context.options[0].restrictDefaultExports;
      const sourceCode2 = context.sourceCode;
      function checkExportedName(node2) {
        const name2 = astUtils2.getModuleExportName(node2);
        let matchesRestrictedNamePattern = false;
        if (restrictedNamePattern && name2 !== "default") {
          const patternRegex = new RegExp(restrictedNamePattern, "u");
          matchesRestrictedNamePattern = patternRegex.test(name2);
        }
        if (matchesRestrictedNamePattern || restrictedNames.has(name2)) {
          context.report({
            node: node2,
            messageId: "restrictedNamed",
            data: { name: name2 }
          });
          return;
        }
        if (name2 === "default") {
          if (node2.parent.type === "ExportAllDeclaration") {
            if (restrictDefaultExports && restrictDefaultExports.namespaceFrom) {
              context.report({
                node: node2,
                messageId: "restrictedDefault"
              });
            }
          } else {
            const isSourceSpecified = !!node2.parent.parent.source;
            const specifierLocalName = astUtils2.getModuleExportName(
              node2.parent.local
            );
            if (!isSourceSpecified && restrictDefaultExports && restrictDefaultExports.named) {
              context.report({
                node: node2,
                messageId: "restrictedDefault"
              });
              return;
            }
            if (isSourceSpecified && restrictDefaultExports) {
              if (specifierLocalName === "default" && restrictDefaultExports.defaultFrom || specifierLocalName !== "default" && restrictDefaultExports.namedFrom) {
                context.report({
                  node: node2,
                  messageId: "restrictedDefault"
                });
              }
            }
          }
        }
      }
      return {
        ExportAllDeclaration(node2) {
          if (node2.exported) {
            checkExportedName(node2.exported);
          }
        },
        ExportDefaultDeclaration(node2) {
          if (restrictDefaultExports && restrictDefaultExports.direct) {
            context.report({
              node: node2,
              messageId: "restrictedDefault"
            });
          }
        },
        ExportNamedDeclaration(node2) {
          const declaration = node2.declaration;
          if (declaration) {
            if (declaration.type === "FunctionDeclaration" || declaration.type === "ClassDeclaration") {
              checkExportedName(declaration.id);
            } else if (declaration.type === "VariableDeclaration") {
              sourceCode2.getDeclaredVariables(declaration).map(
                (v2) => v2.defs.find((d2) => d2.parent === declaration)
              ).map((d2) => d2.name).forEach(checkExportedName);
            }
          } else {
            node2.specifiers.map((s2) => s2.exported).forEach(checkExportedName);
          }
        }
      };
    }
  };
  return noRestrictedExports;
}
var noRestrictedGlobals;
var hasRequiredNoRestrictedGlobals;
function requireNoRestrictedGlobals() {
  if (hasRequiredNoRestrictedGlobals) return noRestrictedGlobals;
  hasRequiredNoRestrictedGlobals = 1;
  const astUtils2 = requireAstUtils();
  const TYPE_NODES = /* @__PURE__ */ new Set([
    "TSTypeReference",
    "TSInterfaceHeritage",
    "TSClassImplements",
    "TSTypeQuery",
    "TSQualifiedName"
  ]);
  const GLOBAL_OBJECTS = /* @__PURE__ */ new Set(["globalThis", "self", "window"]);
  const arrayOfGlobals = {
    type: "array",
    items: {
      oneOf: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            name: { type: "string" },
            message: { type: "string" }
          },
          required: ["name"],
          additionalProperties: false
        }
      ]
    },
    uniqueItems: true,
    minItems: 0
  };
  noRestrictedGlobals = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      docs: {
        description: "Disallow specified global variables",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-restricted-globals"
      },
      schema: {
        anyOf: [
          arrayOfGlobals,
          {
            type: "array",
            items: [
              {
                type: "object",
                properties: {
                  globals: arrayOfGlobals,
                  checkGlobalObject: {
                    type: "boolean"
                  },
                  globalObjects: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    uniqueItems: true
                  }
                },
                required: ["globals"],
                additionalProperties: false
              }
            ],
            additionalItems: false
          }
        ]
      },
      messages: {
        defaultMessage: "Unexpected use of '{{name}}'.",
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        customMessage: "Unexpected use of '{{name}}'. {{customMessage}}"
      }
    },
    create(context) {
      const { sourceCode: sourceCode2, options } = context;
      const isGlobalsObject = typeof options[0] === "object" && Object.hasOwn(options[0], "globals");
      const restrictedGlobals = isGlobalsObject ? options[0].globals : options;
      const checkGlobalObject = isGlobalsObject ? options[0].checkGlobalObject : false;
      const userGlobalObjects = isGlobalsObject ? options[0].globalObjects || [] : [];
      const globalObjects = /* @__PURE__ */ new Set([
        ...GLOBAL_OBJECTS,
        ...userGlobalObjects
      ]);
      if (restrictedGlobals.length === 0) {
        return {};
      }
      const restrictedGlobalMessages = restrictedGlobals.reduce(
        (memo, option) => {
          if (typeof option === "string") {
            memo[option] = null;
          } else {
            memo[option.name] = option.message;
          }
          return memo;
        },
        {}
      );
      function reportReference(reference) {
        const name2 = reference.identifier.name, customMessage = restrictedGlobalMessages[name2], messageId = customMessage ? "customMessage" : "defaultMessage";
        context.report({
          node: reference.identifier,
          messageId,
          data: {
            name: name2,
            customMessage
          }
        });
      }
      function isRestricted(name2) {
        return Object.hasOwn(restrictedGlobalMessages, name2);
      }
      function isInTypeContext(reference) {
        const parent = reference.identifier.parent;
        return TYPE_NODES.has(parent.type);
      }
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          scope.variables.forEach((variable) => {
            if (!variable.defs.length && isRestricted(variable.name)) {
              variable.references.forEach((reference) => {
                if (!isInTypeContext(reference)) {
                  reportReference(reference);
                }
              });
            }
          });
          scope.through.forEach((reference) => {
            if (isRestricted(reference.identifier.name) && !isInTypeContext(reference)) {
              reportReference(reference);
            }
          });
        },
        "Program:exit"(node2) {
          if (!checkGlobalObject) {
            return;
          }
          const globalScope = sourceCode2.getScope(node2);
          globalObjects.forEach((globalObjectName) => {
            const variable = astUtils2.getVariableByName(
              globalScope,
              globalObjectName
            );
            if (!variable) {
              return;
            }
            variable.references.forEach((reference) => {
              const identifier = reference.identifier;
              let parent = identifier.parent;
              while (astUtils2.isSpecificMemberAccess(
                parent,
                null,
                globalObjectName
              )) {
                parent = parent.parent;
              }
              const propertyName2 = astUtils2.getStaticPropertyName(parent);
              if (propertyName2 && isRestricted(propertyName2)) {
                const customMessage = restrictedGlobalMessages[propertyName2];
                const messageId = customMessage ? "customMessage" : "defaultMessage";
                context.report({
                  node: parent.property,
                  messageId,
                  data: {
                    name: propertyName2,
                    customMessage
                  }
                });
              }
            });
          });
        }
      };
    }
  };
  return noRestrictedGlobals;
}
var ignore;
var hasRequiredIgnore;
function requireIgnore() {
  if (hasRequiredIgnore) return ignore;
  hasRequiredIgnore = 1;
  function makeArray(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  const EMPTY = "";
  const SPACE = " ";
  const ESCAPE = "\\";
  const REGEX_TEST_BLANK_LINE = /^\s+$/;
  const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
  const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
  const REGEX_SPLITALL_CRLF = /\r?\n/g;
  const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
  const SLASH = "/";
  let TMP_KEY_IGNORE = "node-ignore";
  if (typeof Symbol !== "undefined") {
    TMP_KEY_IGNORE = Symbol.for("node-ignore");
  }
  const KEY_IGNORE = TMP_KEY_IGNORE;
  const define = (object, key, value) => Object.defineProperty(object, key, { value });
  const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  const RETURN_FALSE = () => false;
  const sanitizeRange = (range) => range.replace(
    REGEX_REGEXP_RANGE,
    (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
  );
  const cleanRangeBackSlash = (slashes) => {
    const { length } = slashes;
    return slashes.slice(0, length - length % 2);
  };
  const REPLACERS = [
    [
      // remove BOM
      // TODO:
      // Other similar zero-width characters?
      /^\uFEFF/,
      () => EMPTY
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a ) -> (a)
      // (a \ ) -> (a  )
      /((?:\\\\)*?)(\\?\s+)$/,
      (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
    ],
    // replace (\ ) with ' '
    // (\ ) -> ' '
    // (\\ ) -> '\\ '
    // (\\\ ) -> '\\ '
    [
      /(\\+?)\s/g,
      (_, m1) => {
        const { length } = m1;
        return m1.slice(0, length - length % 2) + SPACE;
      }
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
      /[\\$.|*+(){^]/g,
      (match) => `\\${match}`
    ],
    [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    // leading slash
    [
      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => "^"
    ],
    // replace special metacharacter slash after the leading slash
    [
      /\//g,
      () => "\\/"
    ],
    [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,
      // '**/foo' <-> 'foo'
      () => "^(?:.*\\/)?"
    ],
    // starting
    [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    // two globstars
    [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer
      // Check if it is not the last `'/**'`
      (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'
      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule,
      //    coz trailing single wildcard will be handed by [trailing wildcard]
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (_, p1, p2) => {
        const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
        return p1 + unescaped;
      }
    ],
    [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ESCAPE
    ],
    [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => ESCAPE
    ],
    [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.
      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
    ],
    // ending
    [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,
      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38
      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
    ],
    // trailing wildcard
    [
      /(\^|\\\/)?\\\*$/,
      (_, p1) => {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    ]
  ];
  const regexCache = /* @__PURE__ */ Object.create(null);
  const makeRegex = (pattern2, ignoreCase) => {
    let source = regexCache[pattern2];
    if (!source) {
      source = REPLACERS.reduce(
        (prev, [matcher2, replacer]) => prev.replace(matcher2, replacer.bind(pattern2)),
        pattern2
      );
      regexCache[pattern2] = source;
    }
    return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
  };
  const isString = (subject) => typeof subject === "string";
  const checkPattern = (pattern2) => pattern2 && isString(pattern2) && !REGEX_TEST_BLANK_LINE.test(pattern2) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern2) && pattern2.indexOf("#") !== 0;
  const splitPattern = (pattern2) => pattern2.split(REGEX_SPLITALL_CRLF);
  class IgnoreRule {
    constructor(origin, pattern2, negative, regex) {
      this.origin = origin;
      this.pattern = pattern2;
      this.negative = negative;
      this.regex = regex;
    }
  }
  const createRule = (pattern2, ignoreCase) => {
    const origin = pattern2;
    let negative = false;
    if (pattern2.indexOf("!") === 0) {
      negative = true;
      pattern2 = pattern2.substr(1);
    }
    pattern2 = pattern2.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
    const regex = makeRegex(pattern2, ignoreCase);
    return new IgnoreRule(
      origin,
      pattern2,
      negative,
      regex
    );
  };
  const throwError = (message, Ctor) => {
    throw new Ctor(message);
  };
  const checkPath = (path, originalPath, doThrow) => {
    if (!isString(path)) {
      return doThrow(
        `path must be a string, but got \`${originalPath}\``,
        TypeError
      );
    }
    if (!path) {
      return doThrow(`path must not be empty`, TypeError);
    }
    if (checkPath.isNotRelative(path)) {
      const r2 = "`path.relative()`d";
      return doThrow(
        `path should be a ${r2} string, but got "${originalPath}"`,
        RangeError
      );
    }
    return true;
  };
  const isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
  checkPath.isNotRelative = isNotRelative;
  checkPath.convert = (p2) => p2;
  class Ignore {
    constructor({
      ignorecase = true,
      ignoreCase = ignorecase,
      allowRelativePaths = false
    } = {}) {
      define(this, KEY_IGNORE, true);
      this._rules = [];
      this._ignoreCase = ignoreCase;
      this._allowRelativePaths = allowRelativePaths;
      this._initCache();
    }
    _initCache() {
      this._ignoreCache = /* @__PURE__ */ Object.create(null);
      this._testCache = /* @__PURE__ */ Object.create(null);
    }
    _addPattern(pattern2) {
      if (pattern2 && pattern2[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern2._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern2)) {
        const rule = createRule(pattern2, this._ignoreCase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(pattern2) {
      this._added = false;
      makeArray(
        isString(pattern2) ? splitPattern(pattern2) : pattern2
      ).forEach(this._addPattern, this);
      if (this._added) {
        this._initCache();
      }
      return this;
    }
    // legacy
    addPattern(pattern2) {
      return this.add(pattern2);
    }
    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored
    _testOne(path, checkUnignored) {
      let ignored = false;
      let unignored = false;
      this._rules.forEach((rule) => {
        const { negative } = rule;
        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
          return;
        }
        const matched = rule.regex.test(path);
        if (matched) {
          ignored = !negative;
          unignored = negative;
        }
      });
      return {
        ignored,
        unignored
      };
    }
    // @returns {TestResult}
    _test(originalPath, cache2, checkUnignored, slices) {
      const path = originalPath && checkPath.convert(originalPath);
      checkPath(
        path,
        originalPath,
        this._allowRelativePaths ? RETURN_FALSE : throwError
      );
      return this._t(path, cache2, checkUnignored, slices);
    }
    _t(path, cache2, checkUnignored, slices) {
      if (path in cache2) {
        return cache2[path];
      }
      if (!slices) {
        slices = path.split(SLASH);
      }
      slices.pop();
      if (!slices.length) {
        return cache2[path] = this._testOne(path, checkUnignored);
      }
      const parent = this._t(
        slices.join(SLASH) + SLASH,
        cache2,
        checkUnignored,
        slices
      );
      return cache2[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
    }
    ignores(path) {
      return this._test(path, this._ignoreCache, false).ignored;
    }
    createFilter() {
      return (path) => !this.ignores(path);
    }
    filter(paths) {
      return makeArray(paths).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(path) {
      return this._test(path, this._testCache, true);
    }
  }
  const factory = (options) => new Ignore(options);
  const isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
  factory.isPathValid = isPathValid;
  factory.default = factory;
  ignore = factory;
  if (
    // Detect `process` so that it can run in browsers.
    typeof browser$1$1 !== "undefined" && (browser$1$1.env && browser$1$1.env.IGNORE_TEST_WIN32 || browser$1$1.platform === "win32")
  ) {
    const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
    checkPath.convert = makePosix;
    const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
    checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
  }
  return ignore;
}
var noRestrictedImports;
var hasRequiredNoRestrictedImports;
function requireNoRestrictedImports() {
  if (hasRequiredNoRestrictedImports) return noRestrictedImports;
  hasRequiredNoRestrictedImports = 1;
  const astUtils2 = requireAstUtils();
  const ignore2 = requireIgnore();
  const arrayOfStringsOrObjects = {
    type: "array",
    items: {
      anyOf: [
        { type: "string" },
        {
          type: "object",
          properties: {
            name: { type: "string" },
            message: {
              type: "string",
              minLength: 1
            },
            importNames: {
              type: "array",
              items: {
                type: "string"
              }
            },
            allowImportNames: {
              type: "array",
              items: {
                type: "string"
              }
            },
            allowTypeImports: {
              type: "boolean",
              description: "Whether to allow type-only imports for a path."
            }
          },
          additionalProperties: false,
          required: ["name"],
          not: { required: ["importNames", "allowImportNames"] }
        }
      ]
    },
    uniqueItems: true
  };
  const arrayOfStringsOrObjectPatterns = {
    anyOf: [
      {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true
      },
      {
        type: "array",
        items: {
          type: "object",
          properties: {
            importNames: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: true
            },
            allowImportNames: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: true
            },
            group: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: true
            },
            regex: {
              type: "string"
            },
            importNamePattern: {
              type: "string"
            },
            allowImportNamePattern: {
              type: "string"
            },
            message: {
              type: "string",
              minLength: 1
            },
            caseSensitive: {
              type: "boolean"
            },
            allowTypeImports: {
              type: "boolean",
              description: "Whether to allow type-only imports for a pattern."
            }
          },
          additionalProperties: false,
          not: {
            anyOf: [
              { required: ["importNames", "allowImportNames"] },
              {
                required: [
                  "importNamePattern",
                  "allowImportNamePattern"
                ]
              },
              { required: ["importNames", "allowImportNamePattern"] },
              { required: ["importNamePattern", "allowImportNames"] },
              {
                required: [
                  "allowImportNames",
                  "allowImportNamePattern"
                ]
              }
            ]
          },
          oneOf: [{ required: ["group"] }, { required: ["regex"] }]
        },
        uniqueItems: true
      }
    ]
  };
  noRestrictedImports = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Disallow specified modules when loaded by `import`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-restricted-imports"
      },
      messages: {
        path: "'{{importSource}}' import is restricted from being used.",
        pathWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{importSource}}' import is restricted from being used. {{customMessage}}"
        ),
        patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
        patternWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}"
        ),
        patternAndImportName: "'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.",
        patternAndImportNameWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}"
        ),
        patternAndEverything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.",
        patternAndEverythingWithRegexImportName: "* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used.",
        patternAndEverythingWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}"
        ),
        patternAndEverythingWithRegexImportNameAndCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "* import is invalid because import name matching '{{importNames}}' pattern from '{{importSource}}' is restricted from being used. {{customMessage}}"
        ),
        everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
        everythingWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}"
        ),
        importName: "'{{importName}}' import from '{{importSource}}' is restricted.",
        importNameWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"
        ),
        allowedImportName: "'{{importName}}' import from '{{importSource}}' is restricted because only '{{allowedImportNames}}' import(s) is/are allowed.",
        allowedImportNameWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{importName}}' import from '{{importSource}}' is restricted because only '{{allowedImportNames}}' import(s) is/are allowed. {{customMessage}}"
        ),
        everythingWithAllowImportNames: "* import is invalid because only '{{allowedImportNames}}' from '{{importSource}}' is/are allowed.",
        everythingWithAllowImportNamesAndCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "* import is invalid because only '{{allowedImportNames}}' from '{{importSource}}' is/are allowed. {{customMessage}}"
        ),
        allowedImportNamePattern: "'{{importName}}' import from '{{importSource}}' is restricted because only imports that match the pattern '{{allowedImportNamePattern}}' are allowed from '{{importSource}}'.",
        allowedImportNamePatternWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{importName}}' import from '{{importSource}}' is restricted because only imports that match the pattern '{{allowedImportNamePattern}}' are allowed from '{{importSource}}'. {{customMessage}}"
        ),
        everythingWithAllowedImportNamePattern: "* import is invalid because only imports that match the pattern '{{allowedImportNamePattern}}' from '{{importSource}}' are allowed.",
        everythingWithAllowedImportNamePatternWithCustomMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "* import is invalid because only imports that match the pattern '{{allowedImportNamePattern}}' from '{{importSource}}' are allowed. {{customMessage}}"
        )
      },
      schema: {
        anyOf: [
          arrayOfStringsOrObjects,
          {
            type: "array",
            items: [
              {
                type: "object",
                properties: {
                  paths: arrayOfStringsOrObjects,
                  patterns: arrayOfStringsOrObjectPatterns
                },
                additionalProperties: false
              }
            ],
            additionalItems: false
          }
        ]
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const options = Array.isArray(context.options) ? context.options : [];
      const isPathAndPatternsObject = typeof options[0] === "object" && (Object.hasOwn(options[0], "paths") || Object.hasOwn(options[0], "patterns"));
      const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
      const groupedRestrictedPaths = restrictedPaths.reduce(
        (memo, importSource) => {
          const path = typeof importSource === "string" ? importSource : importSource.name;
          if (!memo[path]) {
            memo[path] = [];
          }
          if (typeof importSource === "string") {
            memo[path].push({});
          } else {
            memo[path].push({
              message: importSource.message,
              importNames: importSource.importNames,
              allowImportNames: importSource.allowImportNames,
              allowTypeImports: importSource.allowTypeImports
            });
          }
          return memo;
        },
        /* @__PURE__ */ Object.create(null)
      );
      let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
      if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === "string") {
        restrictedPatterns = [{ group: restrictedPatterns }];
      }
      const restrictedPatternGroups = restrictedPatterns.map(
        ({
          group,
          regex,
          message,
          caseSensitive,
          importNames,
          importNamePattern,
          allowImportNames,
          allowImportNamePattern,
          allowTypeImports
        }) => ({
          ...group ? {
            matcher: ignore2({
              allowRelativePaths: true,
              ignorecase: !caseSensitive
            }).add(group)
          } : {},
          ...typeof regex === "string" ? {
            regexMatcher: new RegExp(
              regex,
              caseSensitive ? "u" : "iu"
            )
          } : {},
          customMessage: message,
          importNames,
          importNamePattern,
          allowImportNames,
          allowImportNamePattern,
          allowTypeImports
        })
      );
      if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {
        return {};
      }
      function isTypeOnlyImport(node2) {
        var _a2;
        return node2.importKind === "type" || ((_a2 = node2.specifiers) == null ? void 0 : _a2.length) > 0 && node2.specifiers.every(
          (specifier) => specifier.importKind === "type"
        );
      }
      function isTypeOnlySpecifier(specifier) {
        return specifier.importKind === "type" || specifier.exportKind === "type";
      }
      function isTypeOnlyExport(node2) {
        var _a2;
        return node2.exportKind === "type" || ((_a2 = node2.specifiers) == null ? void 0 : _a2.length) > 0 && node2.specifiers.every(
          (specifier) => specifier.exportKind === "type"
        );
      }
      function checkRestrictedPathAndReport(importSource, importNames, node2) {
        if (!Object.hasOwn(groupedRestrictedPaths, importSource)) {
          return;
        }
        groupedRestrictedPaths[importSource].forEach(
          (restrictedPathEntry) => {
            const customMessage = restrictedPathEntry.message;
            const restrictedImportNames = restrictedPathEntry.importNames;
            const allowedImportNames = restrictedPathEntry.allowImportNames;
            const allowTypeImports = restrictedPathEntry.allowTypeImports;
            if (allowTypeImports && (node2.type === "ImportDeclaration" || node2.type === "TSImportEqualsDeclaration") && isTypeOnlyImport(node2)) {
              return;
            }
            if (allowTypeImports && (node2.type === "ExportNamedDeclaration" || node2.type === "ExportAllDeclaration") && isTypeOnlyExport(node2)) {
              return;
            }
            if (!restrictedImportNames && !allowedImportNames) {
              context.report({
                node: node2,
                messageId: customMessage ? "pathWithCustomMessage" : "path",
                data: {
                  importSource,
                  customMessage
                }
              });
              return;
            }
            importNames.forEach((specifiers, importName) => {
              if (importName === "*") {
                const [specifier] = specifiers;
                if (restrictedImportNames) {
                  context.report({
                    node: node2,
                    messageId: customMessage ? "everythingWithCustomMessage" : "everything",
                    loc: specifier.loc,
                    data: {
                      importSource,
                      importNames: restrictedImportNames,
                      customMessage
                    }
                  });
                } else if (allowedImportNames) {
                  context.report({
                    node: node2,
                    messageId: customMessage ? "everythingWithAllowImportNamesAndCustomMessage" : "everythingWithAllowImportNames",
                    loc: specifier.loc,
                    data: {
                      importSource,
                      allowedImportNames,
                      customMessage
                    }
                  });
                }
                return;
              }
              if (restrictedImportNames && restrictedImportNames.includes(importName)) {
                specifiers.forEach((specifier) => {
                  if (allowTypeImports && isTypeOnlySpecifier(specifier.specifier)) {
                    return;
                  }
                  context.report({
                    node: node2,
                    messageId: customMessage ? "importNameWithCustomMessage" : "importName",
                    loc: specifier.loc,
                    data: {
                      importSource,
                      customMessage,
                      importName
                    }
                  });
                });
              }
              if (allowedImportNames && !allowedImportNames.includes(importName)) {
                specifiers.forEach((specifier) => {
                  if (allowTypeImports && isTypeOnlySpecifier(specifier.specifier)) {
                    return;
                  }
                  context.report({
                    node: node2,
                    loc: specifier.loc,
                    messageId: customMessage ? "allowedImportNameWithCustomMessage" : "allowedImportName",
                    data: {
                      importSource,
                      customMessage,
                      importName,
                      allowedImportNames
                    }
                  });
                });
              }
            });
          }
        );
      }
      function reportPathForPatterns(node2, group, importNames, importSource) {
        if (group.allowTypeImports && (node2.type === "ImportDeclaration" || node2.type === "TSImportEqualsDeclaration") && isTypeOnlyImport(node2)) {
          return;
        }
        if (group.allowTypeImports && (node2.type === "ExportNamedDeclaration" || node2.type === "ExportAllDeclaration") && isTypeOnlyExport(node2)) {
          return;
        }
        const customMessage = group.customMessage;
        const restrictedImportNames = group.importNames;
        const restrictedImportNamePattern = group.importNamePattern ? new RegExp(group.importNamePattern, "u") : null;
        const allowedImportNames = group.allowImportNames;
        const allowedImportNamePattern = group.allowImportNamePattern ? new RegExp(group.allowImportNamePattern, "u") : null;
        if (!restrictedImportNames && !allowedImportNames && !restrictedImportNamePattern && !allowedImportNamePattern) {
          context.report({
            node: node2,
            messageId: customMessage ? "patternWithCustomMessage" : "patterns",
            data: {
              importSource,
              customMessage
            }
          });
          return;
        }
        importNames.forEach((specifiers, importName) => {
          if (importName === "*") {
            const [specifier] = specifiers;
            if (restrictedImportNames) {
              context.report({
                node: node2,
                messageId: customMessage ? "patternAndEverythingWithCustomMessage" : "patternAndEverything",
                loc: specifier.loc,
                data: {
                  importSource,
                  importNames: restrictedImportNames,
                  customMessage
                }
              });
            } else if (allowedImportNames) {
              context.report({
                node: node2,
                messageId: customMessage ? "everythingWithAllowImportNamesAndCustomMessage" : "everythingWithAllowImportNames",
                loc: specifier.loc,
                data: {
                  importSource,
                  allowedImportNames,
                  customMessage
                }
              });
            } else if (allowedImportNamePattern) {
              context.report({
                node: node2,
                messageId: customMessage ? "everythingWithAllowedImportNamePatternWithCustomMessage" : "everythingWithAllowedImportNamePattern",
                loc: specifier.loc,
                data: {
                  importSource,
                  allowedImportNamePattern,
                  customMessage
                }
              });
            } else {
              context.report({
                node: node2,
                messageId: customMessage ? "patternAndEverythingWithRegexImportNameAndCustomMessage" : "patternAndEverythingWithRegexImportName",
                loc: specifier.loc,
                data: {
                  importSource,
                  importNames: restrictedImportNamePattern,
                  customMessage
                }
              });
            }
            return;
          }
          if (restrictedImportNames && restrictedImportNames.includes(importName) || restrictedImportNamePattern && restrictedImportNamePattern.test(importName)) {
            specifiers.forEach((specifier) => {
              if (group.allowTypeImports && isTypeOnlySpecifier(specifier.specifier)) {
                return;
              }
              context.report({
                node: node2,
                messageId: customMessage ? "patternAndImportNameWithCustomMessage" : "patternAndImportName",
                loc: specifier.loc,
                data: {
                  importSource,
                  customMessage,
                  importName
                }
              });
            });
          }
          if (allowedImportNames && !allowedImportNames.includes(importName)) {
            specifiers.forEach((specifier) => {
              if (group.allowTypeImports && isTypeOnlySpecifier(specifier.specifier)) {
                return;
              }
              context.report({
                node: node2,
                messageId: customMessage ? "allowedImportNameWithCustomMessage" : "allowedImportName",
                loc: specifier.loc,
                data: {
                  importSource,
                  customMessage,
                  importName,
                  allowedImportNames
                }
              });
            });
          } else if (allowedImportNamePattern && !allowedImportNamePattern.test(importName)) {
            specifiers.forEach((specifier) => {
              if (group.allowTypeImports && isTypeOnlySpecifier(specifier.specifier)) {
                return;
              }
              context.report({
                node: node2,
                messageId: customMessage ? "allowedImportNamePatternWithCustomMessage" : "allowedImportNamePattern",
                loc: specifier.loc,
                data: {
                  importSource,
                  customMessage,
                  importName,
                  allowedImportNamePattern
                }
              });
            });
          }
        });
      }
      function isRestrictedPattern(importSource, group) {
        return group.regexMatcher ? group.regexMatcher.test(importSource) : group.matcher.ignores(importSource);
      }
      function checkNode(node2) {
        const importSource = node2.source.value.trim();
        const importNames = /* @__PURE__ */ new Map();
        if (node2.type === "ExportAllDeclaration") {
          const starToken = sourceCode2.getFirstToken(node2, 1);
          importNames.set("*", [{ loc: starToken.loc }]);
        } else if (node2.specifiers) {
          for (const specifier of node2.specifiers) {
            let name2;
            const specifierData = { loc: specifier.loc, specifier };
            if (specifier.type === "ImportDefaultSpecifier") {
              name2 = "default";
            } else if (specifier.type === "ImportNamespaceSpecifier") {
              name2 = "*";
            } else if (specifier.imported) {
              name2 = astUtils2.getModuleExportName(specifier.imported);
            } else if (specifier.local) {
              name2 = astUtils2.getModuleExportName(specifier.local);
            }
            if (typeof name2 === "string") {
              if (importNames.has(name2)) {
                importNames.get(name2).push(specifierData);
              } else {
                importNames.set(name2, [specifierData]);
              }
            }
          }
        }
        checkRestrictedPathAndReport(importSource, importNames, node2);
        restrictedPatternGroups.forEach((group) => {
          if (isRestrictedPattern(importSource, group)) {
            reportPathForPatterns(
              node2,
              group,
              importNames,
              importSource
            );
          }
        });
      }
      return {
        ImportDeclaration: checkNode,
        ExportNamedDeclaration(node2) {
          if (node2.source) {
            checkNode(node2);
          }
        },
        ExportAllDeclaration: checkNode,
        // Add support for TypeScript import equals declarations
        TSImportEqualsDeclaration(node2) {
          if (node2.moduleReference.type === "TSExternalModuleReference") {
            const importSource = node2.moduleReference.expression.value;
            const importNames = /* @__PURE__ */ new Map();
            checkRestrictedPathAndReport(
              importSource,
              importNames,
              node2
            );
            restrictedPatternGroups.forEach((group) => {
              if (isRestrictedPattern(importSource, group)) {
                reportPathForPatterns(
                  node2,
                  group,
                  importNames,
                  importSource
                );
              }
            });
          }
        }
      };
    }
  };
  return noRestrictedImports;
}
var noRestrictedModules;
var hasRequiredNoRestrictedModules;
function requireNoRestrictedModules() {
  if (hasRequiredNoRestrictedModules) return noRestrictedModules;
  hasRequiredNoRestrictedModules = 1;
  const astUtils2 = requireAstUtils();
  const ignore2 = requireIgnore();
  const arrayOfStrings = {
    type: "array",
    items: { type: "string" },
    uniqueItems: true
  };
  const arrayOfStringsOrObjects = {
    type: "array",
    items: {
      anyOf: [
        { type: "string" },
        {
          type: "object",
          properties: {
            name: { type: "string" },
            message: {
              type: "string",
              minLength: 1
            }
          },
          additionalProperties: false,
          required: ["name"]
        }
      ]
    },
    uniqueItems: true
  };
  noRestrictedModules = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-restricted-require",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-restricted-require.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow specified modules when loaded by `require`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-restricted-modules"
      },
      schema: {
        anyOf: [
          arrayOfStringsOrObjects,
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                paths: arrayOfStringsOrObjects,
                patterns: arrayOfStrings
              },
              additionalProperties: false
            },
            additionalItems: false
          }
        ]
      },
      messages: {
        defaultMessage: "'{{name}}' module is restricted from being used.",
        customMessage: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{name}}' module is restricted from being used. {{customMessage}}"
        ),
        patternMessage: "'{{name}}' module is restricted from being used by a pattern."
      }
    },
    create(context) {
      const options = Array.isArray(context.options) ? context.options : [];
      const isPathAndPatternsObject = typeof options[0] === "object" && (Object.hasOwn(options[0], "paths") || Object.hasOwn(options[0], "patterns"));
      const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
      const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
      const restrictedPathMessages = restrictedPaths.reduce(
        (memo, importName) => {
          if (typeof importName === "string") {
            memo[importName] = null;
          } else {
            memo[importName.name] = importName.message;
          }
          return memo;
        },
        {}
      );
      if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
        return {};
      }
      const ig = ignore2({ allowRelativePaths: true }).add(restrictedPatterns);
      function isStringLiteral(node2) {
        return node2 && node2.type === "Literal" && typeof node2.value === "string";
      }
      function isRequireCall(node2) {
        return node2.callee.type === "Identifier" && node2.callee.name === "require";
      }
      function getFirstArgumentString(node2) {
        if (isStringLiteral(node2)) {
          return node2.value.trim();
        }
        if (astUtils2.isStaticTemplateLiteral(node2)) {
          return node2.quasis[0].value.cooked.trim();
        }
        return null;
      }
      function reportPath(node2, name2) {
        const customMessage = restrictedPathMessages[name2];
        const messageId = customMessage ? "customMessage" : "defaultMessage";
        context.report({
          node: node2,
          messageId,
          data: {
            name: name2,
            customMessage
          }
        });
      }
      function isRestrictedPath(name2) {
        return Object.hasOwn(restrictedPathMessages, name2);
      }
      return {
        CallExpression(node2) {
          if (isRequireCall(node2)) {
            if (node2.arguments.length) {
              const name2 = getFirstArgumentString(node2.arguments[0]);
              if (name2) {
                if (isRestrictedPath(name2)) {
                  reportPath(node2, name2);
                }
                if (restrictedPatterns.length > 0 && ig.ignores(name2)) {
                  context.report({
                    node: node2,
                    messageId: "patternMessage",
                    data: { name: name2 }
                  });
                }
              }
            }
          }
        }
      };
    }
  };
  return noRestrictedModules;
}
var noRestrictedProperties;
var hasRequiredNoRestrictedProperties;
function requireNoRestrictedProperties() {
  if (hasRequiredNoRestrictedProperties) return noRestrictedProperties;
  hasRequiredNoRestrictedProperties = 1;
  const astUtils2 = requireAstUtils();
  noRestrictedProperties = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow certain properties on certain objects",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-restricted-properties"
      },
      schema: {
        type: "array",
        items: {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            allowObjects: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            },
            allowProperties: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            },
            message: {
              type: "string"
            }
          },
          anyOf: [
            {
              required: ["object"]
            },
            {
              required: ["property"]
            }
          ],
          not: {
            anyOf: [
              { required: ["allowObjects", "object"] },
              { required: ["allowProperties", "property"] }
            ]
          },
          additionalProperties: false
        },
        uniqueItems: true
      },
      messages: {
        restrictedObjectProperty: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{objectName}}.{{propertyName}}' is restricted from being used.{{allowedPropertiesMessage}}{{message}}"
        ),
        restrictedProperty: (
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          "'{{propertyName}}' is restricted from being used.{{allowedObjectsMessage}}{{message}}"
        )
      }
    },
    create(context) {
      const restrictedCalls = context.options;
      if (restrictedCalls.length === 0) {
        return {};
      }
      const restrictedProperties = /* @__PURE__ */ new Map();
      const globallyRestrictedObjects = /* @__PURE__ */ new Map();
      const globallyRestrictedProperties = /* @__PURE__ */ new Map();
      restrictedCalls.forEach((option) => {
        const objectName = option.object;
        const propertyName2 = option.property;
        if (typeof objectName === "undefined") {
          globallyRestrictedProperties.set(propertyName2, {
            allowObjects: option.allowObjects,
            message: option.message
          });
        } else if (typeof propertyName2 === "undefined") {
          globallyRestrictedObjects.set(objectName, {
            allowProperties: option.allowProperties,
            message: option.message
          });
        } else {
          if (!restrictedProperties.has(objectName)) {
            restrictedProperties.set(objectName, /* @__PURE__ */ new Map());
          }
          restrictedProperties.get(objectName).set(propertyName2, {
            message: option.message
          });
        }
      });
      function isAllowed(name2, allowedList) {
        if (!allowedList) {
          return false;
        }
        return allowedList.includes(name2);
      }
      function checkPropertyAccess(node2, objectName, propertyName2) {
        if (propertyName2 === null) {
          return;
        }
        const matchedObject = restrictedProperties.get(objectName);
        const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName2) : globallyRestrictedObjects.get(objectName);
        const globalMatchedProperty = globallyRestrictedProperties.get(propertyName2);
        if (matchedObjectProperty && !isAllowed(propertyName2, matchedObjectProperty.allowProperties)) {
          const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
          const allowedPropertiesMessage = matchedObjectProperty.allowProperties ? ` Only these properties are allowed: ${matchedObjectProperty.allowProperties.join(", ")}.` : "";
          context.report({
            node: node2,
            messageId: "restrictedObjectProperty",
            data: {
              objectName,
              propertyName: propertyName2,
              message,
              allowedPropertiesMessage
            }
          });
        } else if (globalMatchedProperty && !isAllowed(objectName, globalMatchedProperty.allowObjects)) {
          const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
          const allowedObjectsMessage = globalMatchedProperty.allowObjects ? ` Property '${propertyName2}' is only allowed on these objects: ${globalMatchedProperty.allowObjects.join(", ")}.` : "";
          context.report({
            node: node2,
            messageId: "restrictedProperty",
            data: {
              propertyName: propertyName2,
              message,
              allowedObjectsMessage
            }
          });
        }
      }
      return {
        MemberExpression(node2) {
          checkPropertyAccess(
            node2,
            node2.object && node2.object.name,
            astUtils2.getStaticPropertyName(node2)
          );
        },
        ObjectPattern(node2) {
          let objectName = null;
          if (node2.parent.type === "VariableDeclarator") {
            if (node2.parent.init && node2.parent.init.type === "Identifier") {
              objectName = node2.parent.init.name;
            }
          } else if (node2.parent.type === "AssignmentExpression" || node2.parent.type === "AssignmentPattern") {
            if (node2.parent.right.type === "Identifier") {
              objectName = node2.parent.right.name;
            }
          }
          node2.properties.forEach((property) => {
            checkPropertyAccess(
              node2,
              objectName,
              astUtils2.getStaticPropertyName(property)
            );
          });
        }
      };
    }
  };
  return noRestrictedProperties;
}
var noRestrictedSyntax;
var hasRequiredNoRestrictedSyntax;
function requireNoRestrictedSyntax() {
  if (hasRequiredNoRestrictedSyntax) return noRestrictedSyntax;
  hasRequiredNoRestrictedSyntax = 1;
  noRestrictedSyntax = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow specified syntax",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-restricted-syntax"
      },
      schema: {
        type: "array",
        items: {
          oneOf: [
            {
              type: "string"
            },
            {
              type: "object",
              properties: {
                selector: { type: "string" },
                message: { type: "string" }
              },
              required: ["selector"],
              additionalProperties: false
            }
          ]
        },
        uniqueItems: true,
        minItems: 0
      },
      messages: {
        // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
        restrictedSyntax: "{{message}}"
      }
    },
    create(context) {
      return context.options.reduce((result, selectorOrObject) => {
        const isStringFormat = typeof selectorOrObject === "string";
        const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);
        const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
        const message = hasCustomMessage ? selectorOrObject.message : `Using '${selector}' is not allowed.`;
        return Object.assign(result, {
          [selector](node2) {
            context.report({
              node: node2,
              messageId: "restrictedSyntax",
              data: { message }
            });
          }
        });
      }, {});
    }
  };
  return noRestrictedSyntax;
}
var noReturnAssign;
var hasRequiredNoReturnAssign;
function requireNoReturnAssign() {
  if (hasRequiredNoReturnAssign) return noReturnAssign;
  hasRequiredNoReturnAssign = 1;
  const astUtils2 = requireAstUtils();
  const SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;
  noReturnAssign = {
    meta: {
      type: "suggestion",
      defaultOptions: ["except-parens"],
      docs: {
        description: "Disallow assignment operators in `return` statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-return-assign"
      },
      schema: [
        {
          enum: ["except-parens", "always"]
        }
      ],
      messages: {
        returnAssignment: "Return statement should not contain assignment.",
        arrowAssignment: "Arrow function should not return assignment."
      }
    },
    create(context) {
      const always = context.options[0] !== "except-parens";
      const sourceCode2 = context.sourceCode;
      return {
        AssignmentExpression(node2) {
          if (!always && astUtils2.isParenthesised(sourceCode2, node2)) {
            return;
          }
          let currentChild = node2;
          let parent = currentChild.parent;
          while (parent && !SENTINEL_TYPE.test(parent.type)) {
            currentChild = parent;
            parent = parent.parent;
          }
          if (parent && parent.type === "ReturnStatement") {
            context.report({
              node: parent,
              messageId: "returnAssignment"
            });
          } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === currentChild) {
            context.report({
              node: parent,
              messageId: "arrowAssignment"
            });
          }
        }
      };
    }
  };
  return noReturnAssign;
}
var noReturnAwait;
var hasRequiredNoReturnAwait;
function requireNoReturnAwait() {
  if (hasRequiredNoReturnAwait) return noReturnAwait;
  hasRequiredNoReturnAwait = 1;
  const astUtils2 = requireAstUtils();
  noReturnAwait = {
    meta: {
      hasSuggestions: true,
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary `return await`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-return-await"
      },
      fixable: null,
      deprecated: {
        message: "The original assumption of the rule no longer holds true because of engine optimization.",
        deprecatedSince: "8.46.0",
        availableUntil: null,
        replacedBy: []
      },
      schema: [],
      messages: {
        removeAwait: "Remove redundant `await`.",
        redundantUseOfAwait: "Redundant use of `await` on a return value."
      }
    },
    create(context) {
      function reportUnnecessaryAwait(node2) {
        context.report({
          node: context.sourceCode.getFirstToken(node2),
          loc: node2.loc,
          messageId: "redundantUseOfAwait",
          suggest: [
            {
              messageId: "removeAwait",
              fix(fixer) {
                const sourceCode2 = context.sourceCode;
                const [awaitToken, tokenAfterAwait] = sourceCode2.getFirstTokens(node2, 2);
                const areAwaitAndAwaitedExpressionOnTheSameLine = awaitToken.loc.start.line === tokenAfterAwait.loc.start.line;
                if (!areAwaitAndAwaitedExpressionOnTheSameLine) {
                  return null;
                }
                const [startOfAwait, endOfAwait] = awaitToken.range;
                const characterAfterAwait = sourceCode2.text[endOfAwait];
                const trimLength = characterAfterAwait === " " ? 1 : 0;
                const range = [
                  startOfAwait,
                  endOfAwait + trimLength
                ];
                return fixer.removeRange(range);
              }
            }
          ]
        });
      }
      function hasErrorHandler(node2) {
        let ancestor = node2;
        while (!astUtils2.isFunction(ancestor) && ancestor.type !== "Program") {
          if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
            return true;
          }
          ancestor = ancestor.parent;
        }
        return false;
      }
      function isInTailCallPosition(node2) {
        if (node2.parent.type === "ArrowFunctionExpression") {
          return true;
        }
        if (node2.parent.type === "ReturnStatement") {
          return !hasErrorHandler(node2.parent);
        }
        if (node2.parent.type === "ConditionalExpression" && (node2 === node2.parent.consequent || node2 === node2.parent.alternate)) {
          return isInTailCallPosition(node2.parent);
        }
        if (node2.parent.type === "LogicalExpression" && node2 === node2.parent.right) {
          return isInTailCallPosition(node2.parent);
        }
        if (node2.parent.type === "SequenceExpression" && node2 === node2.parent.expressions.at(-1)) {
          return isInTailCallPosition(node2.parent);
        }
        return false;
      }
      return {
        AwaitExpression(node2) {
          if (isInTailCallPosition(node2) && !hasErrorHandler(node2)) {
            reportUnnecessaryAwait(node2);
          }
        }
      };
    }
  };
  return noReturnAwait;
}
var noScriptUrl;
var hasRequiredNoScriptUrl;
function requireNoScriptUrl() {
  if (hasRequiredNoScriptUrl) return noScriptUrl;
  hasRequiredNoScriptUrl = 1;
  const astUtils2 = requireAstUtils();
  noScriptUrl = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `javascript:` URLs",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-script-url"
      },
      schema: [],
      messages: {
        unexpectedScriptURL: "Script URL is a form of eval."
      }
    },
    create(context) {
      function check2(node2) {
        const value = astUtils2.getStaticStringValue(node2);
        if (typeof value === "string" && value.toLowerCase().indexOf("javascript:") === 0) {
          context.report({ node: node2, messageId: "unexpectedScriptURL" });
        }
      }
      return {
        Literal(node2) {
          if (node2.value && typeof node2.value === "string") {
            check2(node2);
          }
        },
        TemplateLiteral(node2) {
          if (!(node2.parent && node2.parent.type === "TaggedTemplateExpression")) {
            check2(node2);
          }
        }
      };
    }
  };
  return noScriptUrl;
}
var noSelfAssign;
var hasRequiredNoSelfAssign;
function requireNoSelfAssign() {
  if (hasRequiredNoSelfAssign) return noSelfAssign;
  hasRequiredNoSelfAssign = 1;
  const astUtils2 = requireAstUtils();
  const SPACES = /\s+/gu;
  function eachSelfAssignment(left, right, props, report) {
    if (!left || !right) ;
    else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
      report(right);
    } else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
      const end = Math.min(left.elements.length, right.elements.length);
      for (let i2 = 0; i2 < end; ++i2) {
        const leftElement = left.elements[i2];
        const rightElement = right.elements[i2];
        if (leftElement && leftElement.type === "RestElement" && i2 < right.elements.length - 1) {
          break;
        }
        eachSelfAssignment(leftElement, rightElement, props, report);
        if (rightElement && rightElement.type === "SpreadElement") {
          break;
        }
      }
    } else if (left.type === "RestElement" && right.type === "SpreadElement") {
      eachSelfAssignment(left.argument, right.argument, props, report);
    } else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
      let startJ = 0;
      for (let i2 = right.properties.length - 1; i2 >= 0; --i2) {
        const propType = right.properties[i2].type;
        if (propType === "SpreadElement" || propType === "ExperimentalSpreadProperty") {
          startJ = i2 + 1;
          break;
        }
      }
      for (let i2 = 0; i2 < left.properties.length; ++i2) {
        for (let j = startJ; j < right.properties.length; ++j) {
          eachSelfAssignment(
            left.properties[i2],
            right.properties[j],
            props,
            report
          );
        }
      }
    } else if (left.type === "Property" && right.type === "Property" && right.kind === "init" && !right.method) {
      const leftName = astUtils2.getStaticPropertyName(left);
      if (leftName !== null && leftName === astUtils2.getStaticPropertyName(right)) {
        eachSelfAssignment(left.value, right.value, props, report);
      }
    } else if (props && astUtils2.skipChainExpression(left).type === "MemberExpression" && astUtils2.skipChainExpression(right).type === "MemberExpression" && astUtils2.isSameReference(left, right)) {
      report(right);
    }
  }
  noSelfAssign = {
    meta: {
      type: "problem",
      defaultOptions: [{ props: true }],
      docs: {
        description: "Disallow assignments where both sides are exactly the same",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-self-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            props: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        selfAssignment: "'{{name}}' is assigned to itself."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ props }] = context.options;
      function report(node2) {
        context.report({
          node: node2,
          messageId: "selfAssignment",
          data: {
            name: sourceCode2.getText(node2).replace(SPACES, "")
          }
        });
      }
      return {
        AssignmentExpression(node2) {
          if (["=", "&&=", "||=", "??="].includes(node2.operator)) {
            eachSelfAssignment(node2.left, node2.right, props, report);
          }
        }
      };
    }
  };
  return noSelfAssign;
}
var noSelfCompare;
var hasRequiredNoSelfCompare;
function requireNoSelfCompare() {
  if (hasRequiredNoSelfCompare) return noSelfCompare;
  hasRequiredNoSelfCompare = 1;
  noSelfCompare = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow comparisons where both sides are exactly the same",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-self-compare"
      },
      schema: [],
      messages: {
        comparingToSelf: "Comparing to itself is potentially pointless."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function hasSameTokens(nodeA, nodeB) {
        const tokensA = sourceCode2.getTokens(nodeA);
        const tokensB = sourceCode2.getTokens(nodeB);
        return tokensA.length === tokensB.length && tokensA.every(
          (token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value
        );
      }
      return {
        BinaryExpression(node2) {
          const operators = /* @__PURE__ */ new Set([
            "===",
            "==",
            "!==",
            "!=",
            ">",
            "<",
            ">=",
            "<="
          ]);
          if (operators.has(node2.operator) && hasSameTokens(node2.left, node2.right)) {
            context.report({ node: node2, messageId: "comparingToSelf" });
          }
        }
      };
    }
  };
  return noSelfCompare;
}
var noSequences;
var hasRequiredNoSequences;
function requireNoSequences() {
  if (hasRequiredNoSequences) return noSequences;
  hasRequiredNoSequences = 1;
  const astUtils2 = requireAstUtils();
  noSequences = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow comma operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-sequences"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowInParentheses: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      defaultOptions: [
        {
          allowInParentheses: true
        }
      ],
      messages: {
        unexpectedCommaExpression: "Unexpected use of comma operator."
      }
    },
    create(context) {
      const [{ allowInParentheses }] = context.options;
      const sourceCode2 = context.sourceCode;
      const parenthesized = {
        DoWhileStatement: "test",
        IfStatement: "test",
        SwitchStatement: "discriminant",
        WhileStatement: "test",
        WithStatement: "object",
        ArrowFunctionExpression: "body"
        /*
         * Omitting CallExpression - commas are parsed as argument separators
         * Omitting NewExpression - commas are parsed as argument separators
         * Omitting ForInStatement - parts aren't individually parenthesised
         * Omitting ForStatement - parts aren't individually parenthesised
         */
      };
      function requiresExtraParens(node2) {
        return node2.parent && parenthesized[node2.parent.type] && node2 === node2.parent[parenthesized[node2.parent.type]];
      }
      function isParenthesised(node2) {
        return astUtils2.isParenthesised(sourceCode2, node2);
      }
      function isParenthesisedTwice(node2) {
        const previousToken = sourceCode2.getTokenBefore(node2, 1), nextToken = sourceCode2.getTokenAfter(node2, 1);
        return isParenthesised(node2) && previousToken && nextToken && astUtils2.isOpeningParenToken(previousToken) && previousToken.range[1] <= node2.range[0] && astUtils2.isClosingParenToken(nextToken) && nextToken.range[0] >= node2.range[1];
      }
      return {
        SequenceExpression(node2) {
          if (node2.parent.type === "ForStatement" && (node2 === node2.parent.init || node2 === node2.parent.update)) {
            return;
          }
          if (allowInParentheses) {
            if (requiresExtraParens(node2)) {
              if (isParenthesisedTwice(node2)) {
                return;
              }
            } else {
              if (isParenthesised(node2)) {
                return;
              }
            }
          }
          const firstCommaToken = sourceCode2.getTokenAfter(
            node2.expressions[0],
            astUtils2.isCommaToken
          );
          context.report({
            node: node2,
            loc: firstCommaToken.loc,
            messageId: "unexpectedCommaExpression"
          });
        }
      };
    }
  };
  return noSequences;
}
var noSetterReturn;
var hasRequiredNoSetterReturn;
function requireNoSetterReturn() {
  if (hasRequiredNoSetterReturn) return noSetterReturn;
  hasRequiredNoSetterReturn = 1;
  const astUtils2 = requireAstUtils();
  function isArgumentOfGlobalMethodCall(node2, sourceCode2, objectName, methodName, index) {
    const callNode = node2.parent;
    return callNode.type === "CallExpression" && callNode.arguments[index] === node2 && astUtils2.isSpecificMemberAccess(
      callNode.callee,
      objectName,
      methodName
    ) && sourceCode2.isGlobalReference(
      astUtils2.skipChainExpression(callNode.callee).object
    );
  }
  function isPropertyDescriptor(node2, sourceCode2) {
    if (isArgumentOfGlobalMethodCall(
      node2,
      sourceCode2,
      "Object",
      "defineProperty",
      2
    ) || isArgumentOfGlobalMethodCall(
      node2,
      sourceCode2,
      "Reflect",
      "defineProperty",
      2
    )) {
      return true;
    }
    const parent = node2.parent;
    if (parent.type === "Property" && parent.value === node2) {
      const grandparent = parent.parent;
      if (grandparent.type === "ObjectExpression" && (isArgumentOfGlobalMethodCall(
        grandparent,
        sourceCode2,
        "Object",
        "create",
        1
      ) || isArgumentOfGlobalMethodCall(
        grandparent,
        sourceCode2,
        "Object",
        "defineProperties",
        1
      ))) {
        return true;
      }
    }
    return false;
  }
  function isSetter(node2, sourceCode2) {
    const parent = node2.parent;
    if ((parent.type === "Property" || parent.type === "MethodDefinition") && parent.kind === "set" && parent.value === node2) {
      return true;
    }
    if (parent.type === "Property" && parent.value === node2 && astUtils2.getStaticPropertyName(parent) === "set" && parent.parent.type === "ObjectExpression" && isPropertyDescriptor(parent.parent, sourceCode2)) {
      return true;
    }
    return false;
  }
  noSetterReturn = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow returning values from setters",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-setter-return"
      },
      schema: [],
      messages: {
        returnsValue: "Setter cannot return a value."
      }
    },
    create(context) {
      let funcInfo = null;
      const sourceCode2 = context.sourceCode;
      function enterFunction(node2) {
        funcInfo = {
          upper: funcInfo,
          isSetter: isSetter(node2, sourceCode2)
        };
      }
      function exitFunction() {
        funcInfo = funcInfo.upper;
      }
      function report(node2) {
        context.report({ node: node2, messageId: "returnsValue" });
      }
      return {
        /*
         * Function declarations cannot be setters, but we still have to track them in the `funcInfo` stack to avoid
         * false positives, because a ReturnStatement node can belong to a function declaration inside a setter.
         *
         * Note: A previously declared function can be referenced and actually used as a setter in a property descriptor,
         * but that's out of scope for this rule.
         */
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        ArrowFunctionExpression(node2) {
          enterFunction(node2);
          if (funcInfo.isSetter && node2.expression) {
            report(node2.body);
          }
        },
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression:exit": exitFunction,
        "ArrowFunctionExpression:exit": exitFunction,
        ReturnStatement(node2) {
          if (funcInfo && funcInfo.isSetter && node2.argument) {
            report(node2);
          }
        }
      };
    }
  };
  return noSetterReturn;
}
var noShadow;
var hasRequiredNoShadow;
function requireNoShadow() {
  if (hasRequiredNoShadow) return noShadow;
  hasRequiredNoShadow = 1;
  const astUtils2 = requireAstUtils();
  const FUNC_EXPR_NODE_TYPES = /* @__PURE__ */ new Set([
    "ArrowFunctionExpression",
    "FunctionExpression"
  ]);
  const CALL_EXPR_NODE_TYPE = /* @__PURE__ */ new Set(["CallExpression"]);
  const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;
  const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
  const TYPES_HOISTED_NODES = /* @__PURE__ */ new Set([
    "TSInterfaceDeclaration",
    "TSTypeAliasDeclaration"
  ]);
  const ALLOWED_FUNCTION_VARIABLE_DEF_TYPES = /* @__PURE__ */ new Set([
    "TSCallSignatureDeclaration",
    "TSFunctionType",
    "TSMethodSignature",
    "TSEmptyBodyFunctionExpression",
    "TSDeclareFunction",
    "TSConstructSignatureDeclaration",
    "TSConstructorType"
  ]);
  noShadow = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      defaultOptions: [
        {
          allow: [],
          builtinGlobals: false,
          hoist: "functions",
          ignoreOnInitialization: false,
          ignoreTypeValueShadow: true,
          ignoreFunctionTypeParameterNameValueShadow: true
        }
      ],
      docs: {
        description: "Disallow variable declarations from shadowing variables declared in the outer scope",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-shadow"
      },
      schema: [
        {
          type: "object",
          properties: {
            builtinGlobals: { type: "boolean" },
            hoist: {
              enum: [
                "all",
                "functions",
                "never",
                "types",
                "functions-and-types"
              ]
            },
            allow: {
              type: "array",
              items: {
                type: "string"
              }
            },
            ignoreOnInitialization: { type: "boolean" },
            ignoreTypeValueShadow: { type: "boolean" },
            ignoreFunctionTypeParameterNameValueShadow: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
        noShadowGlobal: "'{{name}}' is already a global variable."
      }
    },
    create(context) {
      const [
        {
          builtinGlobals,
          hoist,
          allow,
          ignoreOnInitialization,
          ignoreTypeValueShadow,
          ignoreFunctionTypeParameterNameValueShadow
        }
      ] = context.options;
      const sourceCode2 = context.sourceCode;
      function isGlobalAugmentation(scope) {
        return scope.block.kind === "global" || !!scope.upper && isGlobalAugmentation(scope.upper);
      }
      function isThisParam(variable) {
        return variable.name === "this";
      }
      function isTypeValueShadow(variable, shadowedVariable) {
        var _a2;
        if (ignoreTypeValueShadow !== true) {
          return false;
        }
        if (!("isValueVariable" in variable)) {
          return false;
        }
        const firstDefinition = shadowedVariable.defs[0];
        const isTypeImport = firstDefinition && ((_a2 = firstDefinition.parent) == null ? void 0 : _a2.type) === "ImportDeclaration" && (firstDefinition.parent.importKind === "type" || firstDefinition.parent.specifiers.some(
          (s2) => s2.importKind === "type"
        ));
        const isShadowedValue = !firstDefinition || (isTypeImport ? false : shadowedVariable.isValueVariable);
        return variable.isValueVariable !== isShadowedValue;
      }
      function isFunctionTypeParameterNameValueShadow(variable) {
        if (ignoreFunctionTypeParameterNameValueShadow !== true) {
          return false;
        }
        return variable.defs.some(
          (def) => ALLOWED_FUNCTION_VARIABLE_DEF_TYPES.has(def.node.type)
        );
      }
      function isTypeParameterOfStaticMethod(variable) {
        const typeParameter = variable.identifiers[0].parent;
        const typeParameterDecl = typeParameter.parent;
        if (typeParameterDecl.type !== "TSTypeParameterDeclaration") {
          return false;
        }
        const functionExpr = typeParameterDecl.parent;
        const methodDefinition = functionExpr.parent;
        return methodDefinition.static;
      }
      function isGenericOfAStaticMethodShadow(variable) {
        return isTypeParameterOfStaticMethod(variable);
      }
      function isInRange(node2, location) {
        return node2 && node2.range[0] <= location && location <= node2.range[1];
      }
      function findSelfOrAncestor(node2, match) {
        let currentNode = node2;
        while (currentNode && !match(currentNode)) {
          currentNode = currentNode.parent;
        }
        return currentNode;
      }
      function getOuterScope(scope) {
        const upper = scope.upper;
        if (upper && upper.type === "function-expression-name") {
          return upper.upper;
        }
        return upper;
      }
      function isInitPatternNode(variable, shadowedVariable) {
        const outerDef = shadowedVariable.defs[0];
        if (!outerDef) {
          return false;
        }
        const { variableScope } = variable.scope;
        if (!(FUNC_EXPR_NODE_TYPES.has(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {
          return false;
        }
        const fun = variableScope.block;
        const { parent } = fun;
        const callExpression = findSelfOrAncestor(
          parent,
          (node3) => CALL_EXPR_NODE_TYPE.has(node3.type)
        );
        if (!callExpression) {
          return false;
        }
        let node2 = outerDef.name;
        const location = callExpression.range[1];
        while (node2) {
          if (node2.type === "VariableDeclarator") {
            if (isInRange(node2.init, location)) {
              return true;
            }
            if (FOR_IN_OF_TYPE.test(node2.parent.parent.type) && isInRange(node2.parent.parent.right, location)) {
              return true;
            }
            break;
          } else if (node2.type === "AssignmentPattern") {
            if (isInRange(node2.right, location)) {
              return true;
            }
          } else if (SENTINEL_TYPE.test(node2.type)) {
            break;
          }
          node2 = node2.parent;
        }
        return false;
      }
      function isAllowed(variable) {
        return allow.includes(variable.name);
      }
      function isDuplicatedClassNameVariable(variable) {
        const block = variable.scope.block;
        return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
      }
      function isOnInitializer(variable, scopeVar) {
        const outerScope = scopeVar.scope;
        const outerDef = scopeVar.defs[0];
        const outer = outerDef && outerDef.parent && outerDef.parent.range;
        const innerScope = variable.scope;
        const innerDef = variable.defs[0];
        const inner = innerDef && innerDef.name.range;
        return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
      }
      function getNameRange(variable) {
        const def = variable.defs[0];
        return def && def.name.range;
      }
      function getDeclaredLocation(variable) {
        const identifier = variable.identifiers[0];
        let obj;
        if (identifier) {
          obj = {
            global: false,
            line: identifier.loc.start.line,
            column: identifier.loc.start.column + 1
          };
        } else {
          obj = {
            global: true
          };
        }
        return obj;
      }
      function isInTdz(variable, scopeVar) {
        const outerDef = scopeVar.defs[0];
        const inner = getNameRange(variable);
        const outer = getNameRange(scopeVar);
        if (!outer || inner[1] >= outer[0]) {
          return false;
        }
        if (hoist === "types") {
          return !TYPES_HOISTED_NODES.has(outerDef.node.type);
        }
        if (hoist === "functions-and-types") {
          return outerDef.node.type !== "FunctionDeclaration" && !TYPES_HOISTED_NODES.has(outerDef.node.type);
        }
        return inner && outer && inner[1] < outer[0] && // Excepts FunctionDeclaration if is {"hoist":"function"}.
        (hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
      }
      function isDeclareInDTSFile(variable) {
        const fileName = context.filename;
        if (!fileName.endsWith(".d.ts") && !fileName.endsWith(".d.cts") && !fileName.endsWith(".d.mts")) {
          return false;
        }
        return variable.defs.some(
          (def) => def.type === "Variable" && def.parent.declare || def.type === "ClassName" && def.node.declare || def.type === "TSEnumName" && def.node.declare || def.type === "TSModuleName" && def.node.declare
        );
      }
      function isDuplicatedEnumNameVariable(variable) {
        const block = variable.scope.block;
        return block.type === "TSEnumDeclaration" && block.id === variable.identifiers[0];
      }
      function isExternalDeclarationMerging(scope, variable, shadowedVariable) {
        var _a2, _b;
        const firstDefinition = shadowedVariable.defs[0];
        if (!firstDefinition || !firstDefinition.parent) {
          return false;
        }
        const isTypeImport = firstDefinition.parent.type === "ImportDeclaration" && (firstDefinition.parent.importKind === "type" || ((_a2 = firstDefinition.parent.specifiers) == null ? void 0 : _a2.some(
          (s2) => s2.type === "ImportSpecifier" && s2.importKind === "type" && s2.local.name === shadowedVariable.name
        )));
        if (!isTypeImport) {
          return false;
        }
        const moduleDecl = findSelfOrAncestor(
          (_b = variable.identifiers[0]) == null ? void 0 : _b.parent,
          (node2) => node2.type === "TSModuleDeclaration"
        );
        if (!moduleDecl) {
          return false;
        }
        const importSource = firstDefinition.parent.source.value;
        const moduleName = moduleDecl.id.type === "Literal" ? moduleDecl.id.value : moduleDecl.id.name;
        return importSource === moduleName;
      }
      function checkForShadows(scope) {
        if (isGlobalAugmentation(scope)) {
          return;
        }
        const variables = scope.variables;
        for (let i2 = 0; i2 < variables.length; ++i2) {
          const variable = variables[i2];
          if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isDuplicatedEnumNameVariable(variable) || isAllowed(variable) || isDeclareInDTSFile(variable) || isThisParam(variable)) {
            continue;
          }
          const shadowed = astUtils2.getVariableByName(
            scope.upper,
            variable.name
          );
          if (shadowed && (shadowed.identifiers.length > 0 || builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(ignoreOnInitialization && isInitPatternNode(variable, shadowed)) && !(hoist !== "all" && isInTdz(variable, shadowed)) && !isTypeValueShadow(variable, shadowed) && !isFunctionTypeParameterNameValueShadow(variable) && !isGenericOfAStaticMethodShadow(variable) && !isExternalDeclarationMerging(scope, variable, shadowed)) {
            const location = getDeclaredLocation(shadowed);
            const messageId = location.global ? "noShadowGlobal" : "noShadow";
            const data2 = { name: variable.name };
            if (!location.global) {
              data2.shadowedLine = location.line;
              data2.shadowedColumn = location.column;
            }
            context.report({
              node: variable.identifiers[0],
              messageId,
              data: data2
            });
          }
        }
      }
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          const stack = globalScope.childScopes.slice();
          while (stack.length) {
            const scope = stack.pop();
            stack.push(...scope.childScopes);
            checkForShadows(scope);
          }
        }
      };
    }
  };
  return noShadow;
}
var noShadowRestrictedNames;
var hasRequiredNoShadowRestrictedNames;
function requireNoShadowRestrictedNames() {
  if (hasRequiredNoShadowRestrictedNames) return noShadowRestrictedNames;
  hasRequiredNoShadowRestrictedNames = 1;
  function safelyShadowsUndefined(variable) {
    return variable.name === "undefined" && variable.references.every((ref2) => !ref2.isWrite()) && variable.defs.every(
      (def) => def.node.type === "VariableDeclarator" && def.node.init === null
    );
  }
  noShadowRestrictedNames = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          reportGlobalThis: false
        }
      ],
      docs: {
        description: "Disallow identifiers from shadowing restricted names",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-shadow-restricted-names"
      },
      schema: [
        {
          type: "object",
          properties: {
            reportGlobalThis: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        shadowingRestrictedName: "Shadowing of global property '{{name}}'."
      }
    },
    create(context) {
      const [{ reportGlobalThis }] = context.options;
      const RESTRICTED = /* @__PURE__ */ new Set([
        "undefined",
        "NaN",
        "Infinity",
        "arguments",
        "eval"
      ]);
      if (reportGlobalThis) {
        RESTRICTED.add("globalThis");
      }
      const sourceCode2 = context.sourceCode;
      const reportedNodes = /* @__PURE__ */ new Set();
      return {
        "VariableDeclaration, :function, CatchClause, ImportDeclaration, ClassDeclaration, ClassExpression"(node2) {
          for (const variable of sourceCode2.getDeclaredVariables(node2)) {
            if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {
              for (const def of variable.defs) {
                const nodeToReport = def.name;
                if (!reportedNodes.has(nodeToReport)) {
                  reportedNodes.add(nodeToReport);
                  context.report({
                    node: nodeToReport,
                    messageId: "shadowingRestrictedName",
                    data: {
                      name: variable.name
                    }
                  });
                }
              }
            }
          }
        }
      };
    }
  };
  return noShadowRestrictedNames;
}
var noSpacedFunc;
var hasRequiredNoSpacedFunc;
function requireNoSpacedFunc() {
  if (hasRequiredNoSpacedFunc) return noSpacedFunc;
  hasRequiredNoSpacedFunc = 1;
  noSpacedFunc = {
    meta: {
      type: "layout",
      docs: {
        description: "Disallow spacing between function identifiers and their applications (deprecated)",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-spaced-func"
      },
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2016/08/eslint-v3.3.0-released/#deprecated-rules",
        deprecatedSince: "3.3.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "function-call-spacing",
              url: "https://eslint.style/rules/function-call-spacing"
            }
          }
        ]
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        noSpacedFunction: "Unexpected space between function name and paren."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function detectOpenSpaces(node2) {
        const lastCalleeToken = sourceCode2.getLastToken(node2.callee);
        let prevToken = lastCalleeToken, parenToken = sourceCode2.getTokenAfter(lastCalleeToken);
        while (parenToken && parenToken.range[1] < node2.range[1] && parenToken.value !== "(") {
          prevToken = parenToken;
          parenToken = sourceCode2.getTokenAfter(parenToken);
        }
        if (parenToken && parenToken.range[1] < node2.range[1] && sourceCode2.isSpaceBetweenTokens(prevToken, parenToken)) {
          context.report({
            node: node2,
            loc: lastCalleeToken.loc.start,
            messageId: "noSpacedFunction",
            fix(fixer) {
              return fixer.removeRange([
                prevToken.range[1],
                parenToken.range[0]
              ]);
            }
          });
        }
      }
      return {
        CallExpression: detectOpenSpaces,
        NewExpression: detectOpenSpaces
      };
    }
  };
  return noSpacedFunc;
}
var noSparseArrays;
var hasRequiredNoSparseArrays;
function requireNoSparseArrays() {
  if (hasRequiredNoSparseArrays) return noSparseArrays;
  hasRequiredNoSparseArrays = 1;
  const astUtils2 = requireAstUtils();
  noSparseArrays = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow sparse arrays",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-sparse-arrays"
      },
      schema: [],
      messages: {
        unexpectedSparseArray: "Unexpected comma in middle of array."
      }
    },
    create(context) {
      return {
        ArrayExpression(node2) {
          if (!node2.elements.includes(null)) {
            return;
          }
          const { sourceCode: sourceCode2 } = context;
          let commaToken;
          for (const [index, element] of node2.elements.entries()) {
            if (index === node2.elements.length - 1 && element) {
              return;
            }
            commaToken = sourceCode2.getTokenAfter(
              element ?? commaToken ?? sourceCode2.getFirstToken(node2),
              astUtils2.isCommaToken
            );
            if (element) {
              continue;
            }
            context.report({
              node: node2,
              loc: commaToken.loc,
              messageId: "unexpectedSparseArray"
            });
          }
        }
      };
    }
  };
  return noSparseArrays;
}
var noSync;
var hasRequiredNoSync;
function requireNoSync() {
  if (hasRequiredNoSync) return noSync;
  hasRequiredNoSync = 1;
  noSync = {
    meta: {
      deprecated: {
        message: "Node.js rules were moved out of ESLint core.",
        url: "https://eslint.org/docs/latest/use/migrating-to-7.0.0#deprecate-node-rules",
        deprecatedSince: "7.0.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "eslint-plugin-n now maintains deprecated Node.js-related rules.",
            plugin: {
              name: "eslint-plugin-n",
              url: "https://github.com/eslint-community/eslint-plugin-n"
            },
            rule: {
              name: "no-sync",
              url: "https://github.com/eslint-community/eslint-plugin-n/tree/master/docs/rules/no-sync.md"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Disallow synchronous methods",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-sync"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAtRootLevel: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        noSync: "Unexpected sync method: '{{propertyName}}'."
      }
    },
    create(context) {
      const selector = context.options[0] && context.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";
      return {
        [selector](node2) {
          context.report({
            node: node2,
            messageId: "noSync",
            data: {
              propertyName: node2.property.name
            }
          });
        }
      };
    }
  };
  return noSync;
}
var noTabs;
var hasRequiredNoTabs;
function requireNoTabs() {
  if (hasRequiredNoTabs) return noTabs;
  hasRequiredNoTabs = 1;
  const tabRegex = /\t+/gu;
  const anyNonWhitespaceRegex = /\S/u;
  noTabs = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-tabs",
              url: "https://eslint.style/rules/no-tabs"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow all tabs",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-tabs"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowIndentationTabs: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedTab: "Unexpected tab character."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;
      return {
        Program(node2) {
          sourceCode2.getLines().forEach((line, index) => {
            let match;
            while ((match = tabRegex.exec(line)) !== null) {
              if (allowIndentationTabs && !anyNonWhitespaceRegex.test(
                line.slice(0, match.index)
              )) {
                continue;
              }
              context.report({
                node: node2,
                loc: {
                  start: {
                    line: index + 1,
                    column: match.index
                  },
                  end: {
                    line: index + 1,
                    column: match.index + match[0].length
                  }
                },
                messageId: "unexpectedTab"
              });
            }
          });
        }
      };
    }
  };
  return noTabs;
}
var noTemplateCurlyInString;
var hasRequiredNoTemplateCurlyInString;
function requireNoTemplateCurlyInString() {
  if (hasRequiredNoTemplateCurlyInString) return noTemplateCurlyInString;
  hasRequiredNoTemplateCurlyInString = 1;
  noTemplateCurlyInString = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow template literal placeholder syntax in regular strings",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-template-curly-in-string"
      },
      schema: [],
      messages: {
        unexpectedTemplateExpression: "Unexpected template string expression."
      }
    },
    create(context) {
      const regex = /\$\{[^}]+\}/u;
      return {
        Literal(node2) {
          if (typeof node2.value === "string" && regex.test(node2.value)) {
            context.report({
              node: node2,
              messageId: "unexpectedTemplateExpression"
            });
          }
        }
      };
    }
  };
  return noTemplateCurlyInString;
}
var noTernary;
var hasRequiredNoTernary;
function requireNoTernary() {
  if (hasRequiredNoTernary) return noTernary;
  hasRequiredNoTernary = 1;
  noTernary = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow ternary operators",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-ternary"
      },
      schema: [],
      messages: {
        noTernaryOperator: "Ternary operator used."
      }
    },
    create(context) {
      return {
        ConditionalExpression(node2) {
          context.report({ node: node2, messageId: "noTernaryOperator" });
        }
      };
    }
  };
  return noTernary;
}
var noThisBeforeSuper;
var hasRequiredNoThisBeforeSuper;
function requireNoThisBeforeSuper() {
  if (hasRequiredNoThisBeforeSuper) return noThisBeforeSuper;
  hasRequiredNoThisBeforeSuper = 1;
  const astUtils2 = requireAstUtils();
  function isConstructorFunction(node2) {
    return node2.type === "FunctionExpression" && node2.parent.type === "MethodDefinition" && node2.parent.kind === "constructor";
  }
  class SegmentInfo {
    constructor() {
      /**
       * Indicates whether `super()` is called in all code paths.
       * @type {boolean}
       */
      __publicField(this, "superCalled", false);
      /**
       * The array of invalid ThisExpression and Super nodes.
       * @type {ASTNode[]}
       */
      __publicField(this, "invalidNodes", []);
    }
  }
  noThisBeforeSuper = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow `this`/`super` before calling `super()` in constructors",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-this-before-super"
      },
      schema: [],
      messages: {
        noBeforeSuper: "'{{kind}}' is not allowed before 'super()'."
      }
    },
    create(context) {
      let funcInfo = null;
      let segInfoMap = /* @__PURE__ */ Object.create(null);
      function isCalled(segment) {
        var _a2;
        return !segment.reachable || ((_a2 = segInfoMap[segment.id]) == null ? void 0 : _a2.superCalled);
      }
      function isInConstructorOfDerivedClass() {
        return Boolean(
          funcInfo && funcInfo.isConstructor && funcInfo.hasExtends
        );
      }
      function isEverySegmentCalled(segments) {
        for (const segment of segments) {
          if (!isCalled(segment)) {
            return false;
          }
        }
        return true;
      }
      function isBeforeCallOfSuper() {
        return isInConstructorOfDerivedClass() && !isEverySegmentCalled(funcInfo.currentSegments);
      }
      function setInvalid(node2) {
        const segments = funcInfo.currentSegments;
        for (const segment of segments) {
          if (segment.reachable) {
            segInfoMap[segment.id].invalidNodes.push(node2);
          }
        }
      }
      function setSuperCalled() {
        const segments = funcInfo.currentSegments;
        for (const segment of segments) {
          if (segment.reachable) {
            segInfoMap[segment.id].superCalled = true;
          }
        }
      }
      return {
        /**
         * Adds information of a constructor into the stack.
         * @param {CodePath} codePath A code path which was started.
         * @param {ASTNode} node The current node.
         * @returns {void}
         */
        onCodePathStart(codePath2, node2) {
          if (isConstructorFunction(node2)) {
            const classNode = node2.parent.parent.parent;
            funcInfo = {
              upper: funcInfo,
              isConstructor: true,
              hasExtends: Boolean(
                classNode.superClass && !astUtils2.isNullOrUndefined(
                  classNode.superClass
                )
              ),
              codePath: codePath2,
              currentSegments: /* @__PURE__ */ new Set()
            };
          } else {
            funcInfo = {
              upper: funcInfo,
              isConstructor: false,
              hasExtends: false,
              codePath: codePath2,
              currentSegments: /* @__PURE__ */ new Set()
            };
          }
        },
        /**
         * Removes the top of stack item.
         *
         * And this traverses all segments of this code path then reports every
         * invalid node.
         * @param {CodePath} codePath A code path which was ended.
         * @returns {void}
         */
        onCodePathEnd(codePath2) {
          const isDerivedClass = funcInfo.hasExtends;
          funcInfo = funcInfo.upper;
          if (!isDerivedClass) {
            return;
          }
          const reported = /* @__PURE__ */ new Set();
          codePath2.traverseSegments((segment, controller) => {
            const info = segInfoMap[segment.id];
            const invalidNodes = info.invalidNodes.filter(
              /*
               * Avoid duplicate reports.
               * When there is a `finally`, invalidNodes may contain already reported node.
               */
              (node2) => !reported.has(node2)
            );
            for (const invalidNode of invalidNodes) {
              reported.add(invalidNode);
              context.report({
                messageId: "noBeforeSuper",
                node: invalidNode,
                data: {
                  kind: invalidNode.type === "Super" ? "super" : "this"
                }
              });
            }
            if (info.superCalled) {
              controller.skip();
            }
          });
        },
        /**
         * Initialize information of a given code path segment.
         * @param {CodePathSegment} segment A code path segment to initialize.
         * @returns {void}
         */
        onCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
          if (!isInConstructorOfDerivedClass()) {
            return;
          }
          segInfoMap[segment.id] = {
            superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
            invalidNodes: []
          };
        },
        onUnreachableCodePathSegmentStart(segment) {
          funcInfo.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        onCodePathSegmentEnd(segment) {
          funcInfo.currentSegments.delete(segment);
        },
        /**
         * Update information of the code path segment when a code path was
         * looped.
         * @param {CodePathSegment} fromSegment The code path segment of the
         *      end of a loop.
         * @param {CodePathSegment} toSegment A code path segment of the head
         *      of a loop.
         * @returns {void}
         */
        onCodePathSegmentLoop(fromSegment, toSegment) {
          if (!isInConstructorOfDerivedClass()) {
            return;
          }
          funcInfo.codePath.traverseSegments(
            { first: toSegment, last: fromSegment },
            (segment, controller) => {
              const info = segInfoMap[segment.id] ?? new SegmentInfo();
              if (info.superCalled) {
                controller.skip();
              } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
                info.superCalled = true;
              }
              segInfoMap[segment.id] = info;
            }
          );
        },
        /**
         * Reports if this is before `super()`.
         * @param {ASTNode} node A target node.
         * @returns {void}
         */
        ThisExpression(node2) {
          if (isBeforeCallOfSuper()) {
            setInvalid(node2);
          }
        },
        /**
         * Reports if this is before `super()`.
         * @param {ASTNode} node A target node.
         * @returns {void}
         */
        Super(node2) {
          if (!astUtils2.isCallee(node2) && isBeforeCallOfSuper()) {
            setInvalid(node2);
          }
        },
        /**
         * Marks `super()` called.
         * @param {ASTNode} node A target node.
         * @returns {void}
         */
        "CallExpression:exit"(node2) {
          if (node2.callee.type === "Super" && isBeforeCallOfSuper()) {
            setSuperCalled();
          }
        },
        /**
         * Resets state.
         * @returns {void}
         */
        "Program:exit"() {
          segInfoMap = /* @__PURE__ */ Object.create(null);
        }
      };
    }
  };
  return noThisBeforeSuper;
}
var noThrowLiteral;
var hasRequiredNoThrowLiteral;
function requireNoThrowLiteral() {
  if (hasRequiredNoThrowLiteral) return noThrowLiteral;
  hasRequiredNoThrowLiteral = 1;
  const astUtils2 = requireAstUtils();
  noThrowLiteral = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow throwing literals as exceptions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-throw-literal"
      },
      schema: [],
      messages: {
        object: "Expected an error object to be thrown.",
        undef: "Do not throw undefined."
      }
    },
    create(context) {
      return {
        ThrowStatement(node2) {
          if (!astUtils2.couldBeError(node2.argument)) {
            context.report({ node: node2, messageId: "object" });
          } else if (node2.argument.type === "Identifier") {
            if (node2.argument.name === "undefined") {
              context.report({ node: node2, messageId: "undef" });
            }
          }
        }
      };
    }
  };
  return noThrowLiteral;
}
var noTrailingSpaces;
var hasRequiredNoTrailingSpaces;
function requireNoTrailingSpaces() {
  if (hasRequiredNoTrailingSpaces) return noTrailingSpaces;
  hasRequiredNoTrailingSpaces = 1;
  const astUtils2 = requireAstUtils();
  noTrailingSpaces = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-trailing-spaces",
              url: "https://eslint.style/rules/no-trailing-spaces"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow trailing whitespace at the end of lines",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-trailing-spaces"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            skipBlankLines: {
              type: "boolean",
              default: false
            },
            ignoreComments: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        trailingSpace: "Trailing spaces not allowed."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const BLANK_CLASS = "[ 	            ​　]", SKIP_BLANK = `^${BLANK_CLASS}*$`, NONBLANK = `${BLANK_CLASS}+$`;
      const options = context.options[0] || {}, skipBlankLines = options.skipBlankLines || false, ignoreComments = options.ignoreComments || false;
      function report(node2, location, fixRange) {
        context.report({
          node: node2,
          loc: location,
          messageId: "trailingSpace",
          fix(fixer) {
            return fixer.removeRange(fixRange);
          }
        });
      }
      function getCommentLineNumbers(comments) {
        const lines = /* @__PURE__ */ new Set();
        comments.forEach((comment2) => {
          const endLine = comment2.type === "Block" ? comment2.loc.end.line - 1 : comment2.loc.end.line;
          for (let i2 = comment2.loc.start.line; i2 <= endLine; i2++) {
            lines.add(i2);
          }
        });
        return lines;
      }
      return {
        Program: function checkTrailingSpaces(node2) {
          const re = new RegExp(NONBLANK, "u"), skipMatch = new RegExp(SKIP_BLANK, "u"), lines = sourceCode2.lines, linebreaks = sourceCode2.getText().match(astUtils2.createGlobalLinebreakMatcher()), comments = sourceCode2.getAllComments(), commentLineNumbers = getCommentLineNumbers(comments);
          let totalLength = 0;
          for (let i2 = 0, ii = lines.length; i2 < ii; i2++) {
            const lineNumber = i2 + 1;
            const linebreakLength = linebreaks && linebreaks[i2] ? linebreaks[i2].length : 1;
            const lineLength = lines[i2].length + linebreakLength;
            const matches = re.exec(lines[i2]);
            if (matches) {
              const location = {
                start: {
                  line: lineNumber,
                  column: matches.index
                },
                end: {
                  line: lineNumber,
                  column: lineLength - linebreakLength
                }
              };
              const rangeStart = totalLength + location.start.column;
              const rangeEnd2 = totalLength + location.end.column;
              const containingNode = sourceCode2.getNodeByRangeIndex(rangeStart);
              if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd2 < containingNode.parent.range[1]) {
                totalLength += lineLength;
                continue;
              }
              if (skipBlankLines && skipMatch.test(lines[i2])) {
                totalLength += lineLength;
                continue;
              }
              const fixRange = [rangeStart, rangeEnd2];
              if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {
                report(node2, location, fixRange);
              }
            }
            totalLength += lineLength;
          }
        }
      };
    }
  };
  return noTrailingSpaces;
}
var noUnassignedVars;
var hasRequiredNoUnassignedVars;
function requireNoUnassignedVars() {
  if (hasRequiredNoUnassignedVars) return noUnassignedVars;
  hasRequiredNoUnassignedVars = 1;
  noUnassignedVars = {
    meta: {
      type: "problem",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Disallow `let` or `var` variables that are read but never assigned",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-unassigned-vars"
      },
      schema: [],
      messages: {
        unassigned: "'{{name}}' is always 'undefined' because it's never assigned."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let insideDeclareModule = false;
      return {
        "TSModuleDeclaration[declare=true]"() {
          insideDeclareModule = true;
        },
        "TSModuleDeclaration[declare=true]:exit"() {
          insideDeclareModule = false;
        },
        VariableDeclarator(node2) {
          const declaration = node2.parent;
          const shouldSkip = node2.init || node2.id.type !== "Identifier" || declaration.kind === "const" || declaration.declare || insideDeclareModule;
          if (shouldSkip) {
            return;
          }
          const [variable] = sourceCode2.getDeclaredVariables(node2);
          if (!variable) {
            return;
          }
          let hasRead = false;
          for (const reference of variable.references) {
            if (reference.isWrite()) {
              return;
            }
            if (reference.isRead()) {
              hasRead = true;
            }
          }
          if (!hasRead) {
            return;
          }
          context.report({
            node: node2,
            messageId: "unassigned",
            data: { name: node2.id.name }
          });
        }
      };
    }
  };
  return noUnassignedVars;
}
var noUndef;
var hasRequiredNoUndef;
function requireNoUndef() {
  if (hasRequiredNoUndef) return noUndef;
  hasRequiredNoUndef = 1;
  function hasTypeOfOperator(node2) {
    const parent = node2.parent;
    return parent.type === "UnaryExpression" && parent.operator === "typeof";
  }
  noUndef = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          typeof: false
        }
      ],
      docs: {
        description: "Disallow the use of undeclared variables unless mentioned in `/*global */` comments",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-undef"
      },
      schema: [
        {
          type: "object",
          properties: {
            typeof: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        undef: "'{{name}}' is not defined."
      }
    },
    create(context) {
      const [{ typeof: considerTypeOf }] = context.options;
      const sourceCode2 = context.sourceCode;
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          globalScope.through.forEach((ref2) => {
            const identifier = ref2.identifier;
            if (!considerTypeOf && hasTypeOfOperator(identifier)) {
              return;
            }
            context.report({
              node: identifier,
              messageId: "undef",
              data: identifier
            });
          });
        }
      };
    }
  };
  return noUndef;
}
var noUndefInit;
var hasRequiredNoUndefInit;
function requireNoUndefInit() {
  if (hasRequiredNoUndefInit) return noUndefInit;
  hasRequiredNoUndefInit = 1;
  const astUtils2 = requireAstUtils();
  const CONSTANT_BINDINGS = /* @__PURE__ */ new Set(["const", "using", "await using"]);
  noUndefInit = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow initializing variables to `undefined`",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-undef-init"
      },
      schema: [],
      fixable: "code",
      messages: {
        unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        VariableDeclarator(node2) {
          const name2 = sourceCode2.getText(node2.id), init = node2.init && node2.init.name, scope = sourceCode2.getScope(node2), undefinedVar = astUtils2.getVariableByName(
            scope,
            "undefined"
          ), shadowed = undefinedVar && undefinedVar.defs.length > 0, lastToken = sourceCode2.getLastToken(node2);
          if (init === "undefined" && !CONSTANT_BINDINGS.has(node2.parent.kind) && !shadowed) {
            context.report({
              node: node2,
              messageId: "unnecessaryUndefinedInit",
              data: { name: name2 },
              fix(fixer) {
                if (node2.parent.kind === "var") {
                  return null;
                }
                if (node2.id.type === "ArrayPattern" || node2.id.type === "ObjectPattern") {
                  return null;
                }
                if (sourceCode2.commentsExistBetween(
                  node2.id,
                  lastToken
                )) {
                  return null;
                }
                return fixer.removeRange([
                  node2.id.range[1],
                  node2.range[1]
                ]);
              }
            });
          }
        }
      };
    }
  };
  return noUndefInit;
}
var noUndefined;
var hasRequiredNoUndefined;
function requireNoUndefined() {
  if (hasRequiredNoUndefined) return noUndefined;
  hasRequiredNoUndefined = 1;
  noUndefined = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `undefined` as an identifier",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-undefined"
      },
      schema: [],
      messages: {
        unexpectedUndefined: "Unexpected use of undefined."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function report(node2) {
        context.report({
          node: node2,
          messageId: "unexpectedUndefined"
        });
      }
      function checkScope(scope) {
        const undefinedVar = scope.set.get("undefined");
        if (!undefinedVar) {
          return;
        }
        const references = undefinedVar.references;
        const defs = undefinedVar.defs;
        references.filter((ref2) => !ref2.init).forEach((ref2) => report(ref2.identifier));
        defs.forEach((def) => report(def.name));
      }
      return {
        "Program:exit"(node2) {
          const globalScope = sourceCode2.getScope(node2);
          const stack = [globalScope];
          while (stack.length) {
            const scope = stack.pop();
            stack.push(...scope.childScopes);
            checkScope(scope);
          }
        }
      };
    }
  };
  return noUndefined;
}
var noUnderscoreDangle;
var hasRequiredNoUnderscoreDangle;
function requireNoUnderscoreDangle() {
  if (hasRequiredNoUnderscoreDangle) return noUnderscoreDangle;
  hasRequiredNoUnderscoreDangle = 1;
  noUnderscoreDangle = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allow: [],
          allowAfterSuper: false,
          allowAfterThis: false,
          allowAfterThisConstructor: false,
          allowFunctionParams: true,
          allowInArrayDestructuring: true,
          allowInObjectDestructuring: true,
          enforceInClassFields: false,
          enforceInMethodNames: false
        }
      ],
      docs: {
        description: "Disallow dangling underscores in identifiers",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-underscore-dangle"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                type: "string"
              }
            },
            allowAfterThis: {
              type: "boolean"
            },
            allowAfterSuper: {
              type: "boolean"
            },
            allowAfterThisConstructor: {
              type: "boolean"
            },
            enforceInMethodNames: {
              type: "boolean"
            },
            allowFunctionParams: {
              type: "boolean"
            },
            enforceInClassFields: {
              type: "boolean"
            },
            allowInArrayDestructuring: {
              type: "boolean"
            },
            allowInObjectDestructuring: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'."
      }
    },
    create(context) {
      const [
        {
          allow,
          allowAfterSuper,
          allowAfterThis,
          allowAfterThisConstructor,
          allowFunctionParams,
          allowInArrayDestructuring,
          allowInObjectDestructuring,
          enforceInClassFields,
          enforceInMethodNames
        }
      ] = context.options;
      const sourceCode2 = context.sourceCode;
      function isAllowed(identifier) {
        return allow.includes(identifier);
      }
      function hasDanglingUnderscore(identifier) {
        const len = identifier.length;
        return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
      }
      function isSpecialCaseIdentifierForMemberExpression(identifier) {
        return identifier === "__proto__";
      }
      function isSpecialCaseIdentifierInVariableExpression(identifier) {
        return identifier === "_";
      }
      function isThisConstructorReference(node2) {
        return node2.object.type === "MemberExpression" && node2.object.property.name === "constructor" && node2.object.object.type === "ThisExpression";
      }
      function checkForDanglingUnderscoreInFunctionParameters(node2) {
        if (!allowFunctionParams) {
          node2.params.forEach((param) => {
            const { type: type2 } = param;
            let nodeToCheck;
            if (type2 === "RestElement") {
              nodeToCheck = param.argument;
            } else if (type2 === "AssignmentPattern") {
              nodeToCheck = param.left;
            } else {
              nodeToCheck = param;
            }
            if (nodeToCheck.type === "Identifier") {
              const identifier = nodeToCheck.name;
              if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
                context.report({
                  node: param,
                  messageId: "unexpectedUnderscore",
                  data: {
                    identifier
                  }
                });
              }
            }
          });
        }
      }
      function checkForDanglingUnderscoreInFunction(node2) {
        if (node2.type === "FunctionDeclaration" && node2.id) {
          const identifier = node2.id.name;
          if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
            context.report({
              node: node2,
              messageId: "unexpectedUnderscore",
              data: {
                identifier
              }
            });
          }
        }
        checkForDanglingUnderscoreInFunctionParameters(node2);
      }
      function checkForDanglingUnderscoreInVariableExpression(node2) {
        sourceCode2.getDeclaredVariables(node2).forEach((variable) => {
          const definition = variable.defs.find((def) => def.node === node2);
          const identifierNode = definition.name;
          const identifier = identifierNode.name;
          let parent = identifierNode.parent;
          while (![
            "VariableDeclarator",
            "ArrayPattern",
            "ObjectPattern"
          ].includes(parent.type)) {
            parent = parent.parent;
          }
          if (hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier) && !(allowInArrayDestructuring && parent.type === "ArrayPattern") && !(allowInObjectDestructuring && parent.type === "ObjectPattern")) {
            context.report({
              node: node2,
              messageId: "unexpectedUnderscore",
              data: {
                identifier
              }
            });
          }
        });
      }
      function checkForDanglingUnderscoreInMemberExpression(node2) {
        const identifier = node2.property.name, isMemberOfThis = node2.object.type === "ThisExpression", isMemberOfSuper = node2.object.type === "Super", isMemberOfThisConstructor = isThisConstructorReference(node2);
        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
          context.report({
            node: node2,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      }
      function checkForDanglingUnderscoreInMethod(node2) {
        const identifier = node2.key.name;
        const isMethod = node2.type === "MethodDefinition" || node2.type === "Property" && node2.method;
        if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
          context.report({
            node: node2,
            messageId: "unexpectedUnderscore",
            data: {
              identifier: node2.key.type === "PrivateIdentifier" ? `#${identifier}` : identifier
            }
          });
        }
      }
      function checkForDanglingUnderscoreInClassField(node2) {
        const identifier = node2.key.name;
        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && enforceInClassFields && !isAllowed(identifier)) {
          context.report({
            node: node2,
            messageId: "unexpectedUnderscore",
            data: {
              identifier: node2.key.type === "PrivateIdentifier" ? `#${identifier}` : identifier
            }
          });
        }
      }
      return {
        FunctionDeclaration: checkForDanglingUnderscoreInFunction,
        VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,
        MemberExpression: checkForDanglingUnderscoreInMemberExpression,
        MethodDefinition: checkForDanglingUnderscoreInMethod,
        PropertyDefinition: checkForDanglingUnderscoreInClassField,
        Property: checkForDanglingUnderscoreInMethod,
        FunctionExpression: checkForDanglingUnderscoreInFunction,
        ArrowFunctionExpression: checkForDanglingUnderscoreInFunction
      };
    }
  };
  return noUnderscoreDangle;
}
var noUnexpectedMultiline;
var hasRequiredNoUnexpectedMultiline;
function requireNoUnexpectedMultiline() {
  if (hasRequiredNoUnexpectedMultiline) return noUnexpectedMultiline;
  hasRequiredNoUnexpectedMultiline = 1;
  const astUtils2 = requireAstUtils();
  noUnexpectedMultiline = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow confusing multiline expressions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unexpected-multiline"
      },
      schema: [],
      messages: {
        function: "Unexpected newline between function and ( of function call.",
        property: "Unexpected newline between object and [ of property access.",
        taggedTemplate: "Unexpected newline between template tag and template literal.",
        division: "Unexpected newline between numerator and division operator."
      }
    },
    create(context) {
      const REGEX_FLAG_MATCHER = /^[gimsuy]+$/u;
      const sourceCode2 = context.sourceCode;
      function checkForBreakAfter(node2, messageId) {
        const openParen = sourceCode2.getTokenAfter(
          node2,
          astUtils2.isNotClosingParenToken
        );
        const nodeExpressionEnd = sourceCode2.getTokenBefore(openParen);
        if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
          context.report({
            node: node2,
            loc: openParen.loc,
            messageId
          });
        }
      }
      return {
        MemberExpression(node2) {
          if (!node2.computed || node2.optional) {
            return;
          }
          checkForBreakAfter(node2.object, "property");
        },
        TaggedTemplateExpression(node2) {
          const { quasi } = node2;
          const tokenBefore = sourceCode2.getTokenBefore(quasi);
          if (tokenBefore.loc.end.line !== quasi.loc.start.line) {
            context.report({
              node: node2,
              loc: {
                start: quasi.loc.start,
                end: {
                  line: quasi.loc.start.line,
                  column: quasi.loc.start.column + 1
                }
              },
              messageId: "taggedTemplate"
            });
          }
        },
        CallExpression(node2) {
          if (node2.arguments.length === 0 || node2.optional) {
            return;
          }
          checkForBreakAfter(node2.callee, "function");
        },
        "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node2) {
          const secondSlash = sourceCode2.getTokenAfter(
            node2,
            (token) => token.value === "/"
          );
          const tokenAfterOperator = sourceCode2.getTokenAfter(secondSlash);
          if (tokenAfterOperator.type === "Identifier" && REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
            checkForBreakAfter(node2.left, "division");
          }
        }
      };
    }
  };
  return noUnexpectedMultiline;
}
var noUnmodifiedLoopCondition;
var hasRequiredNoUnmodifiedLoopCondition;
function requireNoUnmodifiedLoopCondition() {
  if (hasRequiredNoUnmodifiedLoopCondition) return noUnmodifiedLoopCondition;
  hasRequiredNoUnmodifiedLoopCondition = 1;
  const Traverser = requireTraverser(), astUtils2 = requireAstUtils();
  const SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;
  const LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u;
  const GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;
  const SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;
  const DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;
  function isWriteReference(reference) {
    if (reference.init) {
      const def = reference.resolved && reference.resolved.defs[0];
      if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
        return false;
      }
    }
    return reference.isWrite();
  }
  function isUnmodified(condition) {
    return !condition.modified;
  }
  function isUnmodifiedAndNotBelongToGroup(condition) {
    return !(condition.modified || condition.group);
  }
  function isInRange(node2, reference) {
    const or = node2.range;
    const ir = reference.identifier.range;
    return or[0] <= ir[0] && ir[1] <= or[1];
  }
  const isInLoop = {
    WhileStatement: isInRange,
    DoWhileStatement: isInRange,
    ForStatement(node2, reference) {
      return isInRange(node2, reference) && !(node2.init && isInRange(node2.init, reference));
    }
  };
  function getEncloseFunctionDeclaration(reference) {
    let node2 = reference.identifier;
    while (node2) {
      if (node2.type === "FunctionDeclaration") {
        return node2.id ? node2 : null;
      }
      node2 = node2.parent;
    }
    return null;
  }
  function updateModifiedFlag(conditions, modifiers2) {
    for (let i2 = 0; i2 < conditions.length; ++i2) {
      const condition = conditions[i2];
      for (let j = 0; !condition.modified && j < modifiers2.length; ++j) {
        const modifier = modifiers2[j];
        let funcNode, funcVar;
        const inLoop = condition.isInLoop(modifier) || Boolean(
          (funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils2.getVariableByName(
            modifier.from.upper,
            funcNode.id.name
          )) && funcVar.references.some(condition.isInLoop)
        );
        condition.modified = inLoop;
      }
    }
  }
  noUnmodifiedLoopCondition = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unmodified loop conditions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-unmodified-loop-condition"
      },
      schema: [],
      messages: {
        loopConditionNotModified: "'{{name}}' is not modified in this loop."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let groupMap = null;
      function report(condition) {
        const node2 = condition.reference.identifier;
        context.report({
          node: node2,
          messageId: "loopConditionNotModified",
          data: node2
        });
      }
      function registerConditionsToGroup(conditions) {
        for (let i2 = 0; i2 < conditions.length; ++i2) {
          const condition = conditions[i2];
          if (condition.group) {
            let group = groupMap.get(condition.group);
            if (!group) {
              group = [];
              groupMap.set(condition.group, group);
            }
            group.push(condition);
          }
        }
      }
      function checkConditionsInGroup(conditions) {
        if (conditions.every(isUnmodified)) {
          conditions.forEach(report);
        }
      }
      function hasDynamicExpressions(root) {
        let retv = false;
        Traverser.traverse(root, {
          visitorKeys: sourceCode2.visitorKeys,
          enter(node2) {
            if (DYNAMIC_PATTERN.test(node2.type)) {
              retv = true;
              this.break();
            } else if (SKIP_PATTERN.test(node2.type)) {
              this.skip();
            }
          }
        });
        return retv;
      }
      function toLoopCondition(reference) {
        if (reference.init) {
          return null;
        }
        let group = null;
        let child = reference.identifier;
        let node2 = child.parent;
        while (node2) {
          if (SENTINEL_PATTERN.test(node2.type)) {
            if (LOOP_PATTERN.test(node2.type) && node2.test === child) {
              return {
                reference,
                group,
                isInLoop: isInLoop[node2.type].bind(null, node2),
                modified: false
              };
            }
            break;
          }
          if (GROUP_PATTERN.test(node2.type)) {
            if (hasDynamicExpressions(node2)) {
              break;
            } else {
              group = node2;
            }
          }
          child = node2;
          node2 = node2.parent;
        }
        return null;
      }
      function checkReferences(variable) {
        const conditions = variable.references.map(toLoopCondition).filter(Boolean);
        if (conditions.length === 0) {
          return;
        }
        registerConditionsToGroup(conditions);
        const modifiers2 = variable.references.filter(isWriteReference);
        if (modifiers2.length > 0) {
          updateModifiedFlag(conditions, modifiers2);
        }
        conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
      }
      return {
        "Program:exit"(node2) {
          const queue2 = [sourceCode2.getScope(node2)];
          groupMap = /* @__PURE__ */ new Map();
          let scope;
          while (scope = queue2.pop()) {
            queue2.push(...scope.childScopes);
            scope.variables.forEach(checkReferences);
          }
          groupMap.forEach(checkConditionsInGroup);
          groupMap = null;
        }
      };
    }
  };
  return noUnmodifiedLoopCondition;
}
var noUnneededTernary;
var hasRequiredNoUnneededTernary;
function requireNoUnneededTernary() {
  if (hasRequiredNoUnneededTernary) return noUnneededTernary;
  hasRequiredNoUnneededTernary = 1;
  const astUtils2 = requireAstUtils();
  const BOOLEAN_OPERATORS = /* @__PURE__ */ new Set([
    "==",
    "===",
    "!=",
    "!==",
    ">",
    ">=",
    "<",
    "<=",
    "in",
    "instanceof"
  ]);
  const OPERATOR_INVERSES = {
    "==": "!=",
    "!=": "==",
    "===": "!==",
    "!==": "==="
    // Operators like < and >= are not true inverses, since both will return false with NaN.
  };
  const OR_PRECEDENCE = astUtils2.getPrecedence({
    type: "LogicalExpression",
    operator: "||"
  });
  noUnneededTernary = {
    meta: {
      type: "suggestion",
      defaultOptions: [{ defaultAssignment: true }],
      docs: {
        description: "Disallow ternary operators when simpler alternatives exist",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-unneeded-ternary"
      },
      schema: [
        {
          type: "object",
          properties: {
            defaultAssignment: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.",
        unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment."
      }
    },
    create(context) {
      const [{ defaultAssignment }] = context.options;
      const sourceCode2 = context.sourceCode;
      function isBooleanLiteral(node2) {
        return node2.type === "Literal" && typeof node2.value === "boolean";
      }
      function invertExpression(node2) {
        if (node2.type === "BinaryExpression" && Object.hasOwn(OPERATOR_INVERSES, node2.operator)) {
          const operatorToken2 = sourceCode2.getFirstTokenBetween(
            node2.left,
            node2.right,
            (token) => token.value === node2.operator
          );
          const text = sourceCode2.getText();
          return text.slice(node2.range[0], operatorToken2.range[0]) + OPERATOR_INVERSES[node2.operator] + text.slice(operatorToken2.range[1], node2.range[1]);
        }
        if (astUtils2.getPrecedence(node2) < astUtils2.getPrecedence({ type: "UnaryExpression" })) {
          return `!(${astUtils2.getParenthesisedText(sourceCode2, node2)})`;
        }
        return `!${astUtils2.getParenthesisedText(sourceCode2, node2)}`;
      }
      function isBooleanExpression(node2) {
        return node2.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node2.operator) || node2.type === "UnaryExpression" && node2.operator === "!";
      }
      function matchesDefaultAssignment(node2) {
        return node2.test.type === "Identifier" && node2.consequent.type === "Identifier" && node2.test.name === node2.consequent.name;
      }
      return {
        ConditionalExpression(node2) {
          if (isBooleanLiteral(node2.alternate) && isBooleanLiteral(node2.consequent)) {
            context.report({
              node: node2,
              messageId: "unnecessaryConditionalExpression",
              fix(fixer) {
                if (node2.consequent.value === node2.alternate.value) {
                  return node2.test.type === "Identifier" ? fixer.replaceText(
                    node2,
                    node2.consequent.value.toString()
                  ) : null;
                }
                if (node2.alternate.value) {
                  return fixer.replaceText(
                    node2,
                    invertExpression(node2.test)
                  );
                }
                return fixer.replaceText(
                  node2,
                  isBooleanExpression(node2.test) ? astUtils2.getParenthesisedText(
                    sourceCode2,
                    node2.test
                  ) : `!${invertExpression(node2.test)}`
                );
              }
            });
          } else if (!defaultAssignment && matchesDefaultAssignment(node2)) {
            context.report({
              node: node2,
              messageId: "unnecessaryConditionalAssignment",
              fix(fixer) {
                const shouldParenthesizeAlternate = (astUtils2.getPrecedence(node2.alternate) < OR_PRECEDENCE || astUtils2.isCoalesceExpression(
                  node2.alternate
                )) && !astUtils2.isParenthesised(
                  sourceCode2,
                  node2.alternate
                );
                const alternateText = shouldParenthesizeAlternate ? `(${sourceCode2.getText(node2.alternate)})` : astUtils2.getParenthesisedText(
                  sourceCode2,
                  node2.alternate
                );
                const testText = astUtils2.getParenthesisedText(
                  sourceCode2,
                  node2.test
                );
                return fixer.replaceText(
                  node2,
                  `${testText} || ${alternateText}`
                );
              }
            });
          }
        }
      };
    }
  };
  return noUnneededTernary;
}
var noUnreachable;
var hasRequiredNoUnreachable;
function requireNoUnreachable() {
  if (hasRequiredNoUnreachable) return noUnreachable;
  hasRequiredNoUnreachable = 1;
  function isInitialized(node2) {
    return Boolean(node2.init);
  }
  function areAllSegmentsUnreachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return false;
      }
    }
    return true;
  }
  class ConsecutiveRange {
    constructor(sourceCode2) {
      this.sourceCode = sourceCode2;
      this.startNode = null;
      this.endNode = null;
    }
    /**
     * The location object of this range.
     * @type {Object}
     */
    get location() {
      return {
        start: this.startNode.loc.start,
        end: this.endNode.loc.end
      };
    }
    /**
     * `true` if this range is empty.
     * @type {boolean}
     */
    get isEmpty() {
      return !(this.startNode && this.endNode);
    }
    /**
     * Checks whether the given node is inside of this range.
     * @param {ASTNode|Token} node The node to check.
     * @returns {boolean} `true` if the node is inside of this range.
     */
    contains(node2) {
      return node2.range[0] >= this.startNode.range[0] && node2.range[1] <= this.endNode.range[1];
    }
    /**
     * Checks whether the given node is consecutive to this range.
     * @param {ASTNode} node The node to check.
     * @returns {boolean} `true` if the node is consecutive to this range.
     */
    isConsecutive(node2) {
      return this.contains(this.sourceCode.getTokenBefore(node2));
    }
    /**
     * Merges the given node to this range.
     * @param {ASTNode} node The node to merge.
     * @returns {void}
     */
    merge(node2) {
      this.endNode = node2;
    }
    /**
     * Resets this range by the given node or null.
     * @param {ASTNode|null} node The node to reset, or null.
     * @returns {void}
     */
    reset(node2) {
      this.startNode = this.endNode = node2;
    }
  }
  noUnreachable = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unreachable"
      },
      schema: [],
      messages: {
        unreachableCode: "Unreachable code."
      }
    },
    create(context) {
      let constructorInfo = null;
      const range = new ConsecutiveRange(context.sourceCode);
      const codePathSegments = [];
      let currentCodePathSegments = /* @__PURE__ */ new Set();
      function reportIfUnreachable(node2) {
        let nextNode = null;
        if (node2 && (node2.type === "PropertyDefinition" || areAllSegmentsUnreachable(currentCodePathSegments))) {
          if (range.isEmpty) {
            range.reset(node2);
            return;
          }
          if (range.contains(node2)) {
            return;
          }
          if (range.isConsecutive(node2)) {
            range.merge(node2);
            return;
          }
          nextNode = node2;
        }
        if (!range.isEmpty) {
          context.report({
            messageId: "unreachableCode",
            loc: range.location,
            node: range.startNode
          });
        }
        range.reset(nextNode);
      }
      return {
        // Manages the current code path.
        onCodePathStart() {
          codePathSegments.push(currentCodePathSegments);
          currentCodePathSegments = /* @__PURE__ */ new Set();
        },
        onCodePathEnd() {
          currentCodePathSegments = codePathSegments.pop();
        },
        onUnreachableCodePathSegmentStart(segment) {
          currentCodePathSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          currentCodePathSegments.delete(segment);
        },
        onCodePathSegmentEnd(segment) {
          currentCodePathSegments.delete(segment);
        },
        onCodePathSegmentStart(segment) {
          currentCodePathSegments.add(segment);
        },
        // Registers for all statement nodes (excludes FunctionDeclaration).
        BlockStatement: reportIfUnreachable,
        BreakStatement: reportIfUnreachable,
        ClassDeclaration: reportIfUnreachable,
        ContinueStatement: reportIfUnreachable,
        DebuggerStatement: reportIfUnreachable,
        DoWhileStatement: reportIfUnreachable,
        ExpressionStatement: reportIfUnreachable,
        ForInStatement: reportIfUnreachable,
        ForOfStatement: reportIfUnreachable,
        ForStatement: reportIfUnreachable,
        IfStatement: reportIfUnreachable,
        ImportDeclaration: reportIfUnreachable,
        LabeledStatement: reportIfUnreachable,
        ReturnStatement: reportIfUnreachable,
        SwitchStatement: reportIfUnreachable,
        ThrowStatement: reportIfUnreachable,
        TryStatement: reportIfUnreachable,
        VariableDeclaration(node2) {
          if (node2.kind !== "var" || node2.declarations.some(isInitialized)) {
            reportIfUnreachable(node2);
          }
        },
        WhileStatement: reportIfUnreachable,
        WithStatement: reportIfUnreachable,
        ExportNamedDeclaration: reportIfUnreachable,
        ExportDefaultDeclaration: reportIfUnreachable,
        ExportAllDeclaration: reportIfUnreachable,
        "Program:exit"() {
          reportIfUnreachable();
        },
        /*
         * Instance fields defined in a subclass are never created if the constructor of the subclass
         * doesn't call `super()`, so their definitions are unreachable code.
         */
        "MethodDefinition[kind='constructor']"() {
          constructorInfo = {
            upper: constructorInfo,
            hasSuperCall: false
          };
        },
        "MethodDefinition[kind='constructor']:exit"(node2) {
          const { hasSuperCall } = constructorInfo;
          constructorInfo = constructorInfo.upper;
          if (!node2.value.body) {
            return;
          }
          const classDefinition = node2.parent.parent;
          if (classDefinition.superClass && !hasSuperCall) {
            for (const element of classDefinition.body.body) {
              if (element.type === "PropertyDefinition" && !element.static) {
                reportIfUnreachable(element);
              }
            }
          }
        },
        "CallExpression > Super.callee"() {
          if (constructorInfo) {
            constructorInfo.hasSuperCall = true;
          }
        }
      };
    }
  };
  return noUnreachable;
}
var noUnreachableLoop;
var hasRequiredNoUnreachableLoop;
function requireNoUnreachableLoop() {
  if (hasRequiredNoUnreachableLoop) return noUnreachableLoop;
  hasRequiredNoUnreachableLoop = 1;
  const allLoopTypes = [
    "WhileStatement",
    "DoWhileStatement",
    "ForStatement",
    "ForInStatement",
    "ForOfStatement"
  ];
  function isAnySegmentReachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return true;
      }
    }
    return false;
  }
  function isLoopingTarget(node2) {
    const parent = node2.parent;
    if (parent) {
      switch (parent.type) {
        case "WhileStatement":
          return node2 === parent.test;
        case "DoWhileStatement":
          return node2 === parent.body;
        case "ForStatement":
          return node2 === (parent.update || parent.test || parent.body);
        case "ForInStatement":
        case "ForOfStatement":
          return node2 === parent.left;
      }
    }
    return false;
  }
  function getDifference(arrA, arrB) {
    return arrA.filter((a2) => !arrB.includes(a2));
  }
  noUnreachableLoop = {
    meta: {
      type: "problem",
      defaultOptions: [{ ignore: [] }],
      docs: {
        description: "Disallow loops with a body that allows only one iteration",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-unreachable-loop"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignore: {
              type: "array",
              items: {
                enum: allLoopTypes
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        invalid: "Invalid loop. Its body allows only one iteration."
      }
    },
    create(context) {
      const [{ ignore: ignoredLoopTypes }] = context.options;
      const loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes), loopSelector = loopTypesToCheck.join(","), loopsByTargetSegments = /* @__PURE__ */ new Map(), loopsToReport = /* @__PURE__ */ new Set();
      const codePathSegments = [];
      let currentCodePathSegments = /* @__PURE__ */ new Set();
      return {
        onCodePathStart() {
          codePathSegments.push(currentCodePathSegments);
          currentCodePathSegments = /* @__PURE__ */ new Set();
        },
        onCodePathEnd() {
          currentCodePathSegments = codePathSegments.pop();
        },
        onUnreachableCodePathSegmentStart(segment) {
          currentCodePathSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          currentCodePathSegments.delete(segment);
        },
        onCodePathSegmentEnd(segment) {
          currentCodePathSegments.delete(segment);
        },
        onCodePathSegmentStart(segment, node2) {
          currentCodePathSegments.add(segment);
          if (isLoopingTarget(node2)) {
            const loop = node2.parent;
            loopsByTargetSegments.set(segment, loop);
          }
        },
        onCodePathSegmentLoop(_, toSegment, node2) {
          const loop = loopsByTargetSegments.get(toSegment);
          if (node2 === loop || node2.type === "ContinueStatement") {
            loopsToReport.delete(loop);
          }
        },
        [loopSelector](node2) {
          if (isAnySegmentReachable(currentCodePathSegments)) {
            loopsToReport.add(node2);
          }
        },
        "Program:exit"() {
          loopsToReport.forEach(
            (node2) => context.report({ node: node2, messageId: "invalid" })
          );
        }
      };
    }
  };
  return noUnreachableLoop;
}
var noUnsafeFinally;
var hasRequiredNoUnsafeFinally;
function requireNoUnsafeFinally() {
  if (hasRequiredNoUnsafeFinally) return noUnsafeFinally;
  hasRequiredNoUnsafeFinally = 1;
  const SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
  const SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;
  const SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;
  noUnsafeFinally = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow control flow statements in `finally` blocks",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unsafe-finally"
      },
      schema: [],
      messages: {
        unsafeUsage: "Unsafe usage of {{nodeType}}."
      }
    },
    create(context) {
      function isFinallyBlock(node2) {
        return node2.parent.type === "TryStatement" && node2.parent.finalizer === node2;
      }
      function isInFinallyBlock(node2, label) {
        let labelInside = false;
        let sentinelNodeType;
        if (node2.type === "BreakStatement" && !node2.label) {
          sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
        } else if (node2.type === "ContinueStatement") {
          sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
        } else {
          sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
        }
        for (let currentNode = node2; currentNode && !sentinelNodeType.test(currentNode.type); currentNode = currentNode.parent) {
          if (currentNode.parent.label && label && currentNode.parent.label.name === label.name) {
            labelInside = true;
          }
          if (isFinallyBlock(currentNode)) {
            if (label && labelInside) {
              return false;
            }
            return true;
          }
        }
        return false;
      }
      function check2(node2) {
        if (isInFinallyBlock(node2, node2.label)) {
          context.report({
            messageId: "unsafeUsage",
            data: {
              nodeType: node2.type
            },
            node: node2,
            line: node2.loc.line,
            column: node2.loc.column
          });
        }
      }
      return {
        ReturnStatement: check2,
        ThrowStatement: check2,
        BreakStatement: check2,
        ContinueStatement: check2
      };
    }
  };
  return noUnsafeFinally;
}
var noUnsafeNegation;
var hasRequiredNoUnsafeNegation;
function requireNoUnsafeNegation() {
  if (hasRequiredNoUnsafeNegation) return noUnsafeNegation;
  hasRequiredNoUnsafeNegation = 1;
  const astUtils2 = requireAstUtils();
  function isInOrInstanceOfOperator(op) {
    return op === "in" || op === "instanceof";
  }
  function isOrderingRelationalOperator(op) {
    return op === "<" || op === ">" || op === ">=" || op === "<=";
  }
  function isNegation(node2) {
    return node2.type === "UnaryExpression" && node2.operator === "!";
  }
  noUnsafeNegation = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          enforceForOrderingRelations: false
        }
      ],
      docs: {
        description: "Disallow negating the left operand of relational operators",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unsafe-negation"
      },
      hasSuggestions: true,
      schema: [
        {
          type: "object",
          properties: {
            enforceForOrderingRelations: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: null,
      messages: {
        unexpected: "Unexpected negating the left operand of '{{operator}}' operator.",
        suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",
        suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ enforceForOrderingRelations }] = context.options;
      return {
        BinaryExpression(node2) {
          const operator2 = node2.operator;
          const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator2);
          if ((isInOrInstanceOfOperator(operator2) || orderingRelationRuleApplies) && isNegation(node2.left) && !astUtils2.isParenthesised(sourceCode2, node2.left)) {
            context.report({
              node: node2,
              loc: node2.left.loc,
              messageId: "unexpected",
              data: { operator: operator2 },
              suggest: [
                {
                  messageId: "suggestNegatedExpression",
                  data: { operator: operator2 },
                  fix(fixer) {
                    const negationToken = sourceCode2.getFirstToken(node2.left);
                    const fixRange = [
                      negationToken.range[1],
                      node2.range[1]
                    ];
                    const text = sourceCode2.text.slice(
                      fixRange[0],
                      fixRange[1]
                    );
                    return fixer.replaceTextRange(
                      fixRange,
                      `(${text})`
                    );
                  }
                },
                {
                  messageId: "suggestParenthesisedNegation",
                  fix(fixer) {
                    return fixer.replaceText(
                      node2.left,
                      `(${sourceCode2.getText(node2.left)})`
                    );
                  }
                }
              ]
            });
          }
        }
      };
    }
  };
  return noUnsafeNegation;
}
var noUnsafeOptionalChaining;
var hasRequiredNoUnsafeOptionalChaining;
function requireNoUnsafeOptionalChaining() {
  if (hasRequiredNoUnsafeOptionalChaining) return noUnsafeOptionalChaining;
  hasRequiredNoUnsafeOptionalChaining = 1;
  const UNSAFE_ARITHMETIC_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "/", "*", "%", "**"]);
  const UNSAFE_ASSIGNMENT_OPERATORS = /* @__PURE__ */ new Set([
    "+=",
    "-=",
    "/=",
    "*=",
    "%=",
    "**="
  ]);
  const UNSAFE_RELATIONAL_OPERATORS = /* @__PURE__ */ new Set(["in", "instanceof"]);
  function isDestructuringPattern(node2) {
    return node2.type === "ObjectPattern" || node2.type === "ArrayPattern";
  }
  noUnsafeOptionalChaining = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          disallowArithmeticOperators: false
        }
      ],
      docs: {
        description: "Disallow use of optional chaining in contexts where the `undefined` value is not allowed",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unsafe-optional-chaining"
      },
      schema: [
        {
          type: "object",
          properties: {
            disallowArithmeticOperators: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: null,
      messages: {
        unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",
        unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN."
      }
    },
    create(context) {
      const [{ disallowArithmeticOperators }] = context.options;
      function reportUnsafeUsage(node2) {
        context.report({
          messageId: "unsafeOptionalChain",
          node: node2
        });
      }
      function reportUnsafeArithmetic(node2) {
        context.report({
          messageId: "unsafeArithmetic",
          node: node2
        });
      }
      function checkUndefinedShortCircuit(node2, reportFunc) {
        if (!node2) {
          return;
        }
        switch (node2.type) {
          case "LogicalExpression":
            if (node2.operator === "||" || node2.operator === "??") {
              checkUndefinedShortCircuit(node2.right, reportFunc);
            } else if (node2.operator === "&&") {
              checkUndefinedShortCircuit(node2.left, reportFunc);
              checkUndefinedShortCircuit(node2.right, reportFunc);
            }
            break;
          case "SequenceExpression":
            checkUndefinedShortCircuit(
              node2.expressions.at(-1),
              reportFunc
            );
            break;
          case "ConditionalExpression":
            checkUndefinedShortCircuit(node2.consequent, reportFunc);
            checkUndefinedShortCircuit(node2.alternate, reportFunc);
            break;
          case "AwaitExpression":
            checkUndefinedShortCircuit(node2.argument, reportFunc);
            break;
          case "ChainExpression":
            reportFunc(node2);
            break;
        }
      }
      function checkUnsafeUsage(node2) {
        checkUndefinedShortCircuit(node2, reportUnsafeUsage);
      }
      function checkUnsafeArithmetic(node2) {
        checkUndefinedShortCircuit(node2, reportUnsafeArithmetic);
      }
      return {
        "AssignmentExpression, AssignmentPattern"(node2) {
          if (isDestructuringPattern(node2.left)) {
            checkUnsafeUsage(node2.right);
          }
        },
        "ClassDeclaration, ClassExpression"(node2) {
          checkUnsafeUsage(node2.superClass);
        },
        CallExpression(node2) {
          if (!node2.optional) {
            checkUnsafeUsage(node2.callee);
          }
        },
        NewExpression(node2) {
          checkUnsafeUsage(node2.callee);
        },
        VariableDeclarator(node2) {
          if (isDestructuringPattern(node2.id)) {
            checkUnsafeUsage(node2.init);
          }
        },
        MemberExpression(node2) {
          if (!node2.optional) {
            checkUnsafeUsage(node2.object);
          }
        },
        TaggedTemplateExpression(node2) {
          checkUnsafeUsage(node2.tag);
        },
        ForOfStatement(node2) {
          checkUnsafeUsage(node2.right);
        },
        SpreadElement(node2) {
          if (node2.parent && node2.parent.type !== "ObjectExpression") {
            checkUnsafeUsage(node2.argument);
          }
        },
        BinaryExpression(node2) {
          if (UNSAFE_RELATIONAL_OPERATORS.has(node2.operator)) {
            checkUnsafeUsage(node2.right);
          }
          if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node2.operator)) {
            checkUnsafeArithmetic(node2.right);
            checkUnsafeArithmetic(node2.left);
          }
        },
        WithStatement(node2) {
          checkUnsafeUsage(node2.object);
        },
        UnaryExpression(node2) {
          if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node2.operator)) {
            checkUnsafeArithmetic(node2.argument);
          }
        },
        AssignmentExpression(node2) {
          if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node2.operator)) {
            checkUnsafeArithmetic(node2.right);
          }
        }
      };
    }
  };
  return noUnsafeOptionalChaining;
}
var noUnusedExpressions;
var hasRequiredNoUnusedExpressions;
function requireNoUnusedExpressions() {
  if (hasRequiredNoUnusedExpressions) return noUnusedExpressions;
  hasRequiredNoUnusedExpressions = 1;
  const astUtils2 = requireAstUtils();
  function alwaysTrue() {
    return true;
  }
  function alwaysFalse() {
    return false;
  }
  noUnusedExpressions = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      docs: {
        description: "Disallow unused expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-unused-expressions"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowShortCircuit: {
              type: "boolean"
            },
            allowTernary: {
              type: "boolean"
            },
            allowTaggedTemplates: {
              type: "boolean"
            },
            enforceForJSX: {
              type: "boolean"
            },
            ignoreDirectives: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      defaultOptions: [
        {
          allowShortCircuit: false,
          allowTernary: false,
          allowTaggedTemplates: false,
          enforceForJSX: false,
          ignoreDirectives: false
        }
      ],
      messages: {
        unusedExpression: "Expected an assignment or function call and instead saw an expression."
      }
    },
    create(context) {
      const [
        {
          allowShortCircuit,
          allowTernary,
          allowTaggedTemplates,
          enforceForJSX,
          ignoreDirectives
        }
      ] = context.options;
      function looksLikeDirective(node2) {
        return node2.type === "ExpressionStatement" && node2.expression.type === "Literal" && typeof node2.expression.value === "string";
      }
      function takeWhile(predicate, list) {
        for (let i2 = 0; i2 < list.length; ++i2) {
          if (!predicate(list[i2])) {
            return list.slice(0, i2);
          }
        }
        return list.slice();
      }
      function directives2(node2) {
        return takeWhile(looksLikeDirective, node2.body);
      }
      function isDirective(node2) {
        return astUtils2.isTopLevelExpressionStatement(node2) && directives2(node2.parent).includes(node2);
      }
      const Checker = Object.assign(/* @__PURE__ */ Object.create(null), {
        isDisallowed(node2) {
          return (Checker[node2.type] || alwaysFalse)(node2);
        },
        ArrayExpression: alwaysTrue,
        ArrowFunctionExpression: alwaysTrue,
        BinaryExpression: alwaysTrue,
        ChainExpression(node2) {
          return Checker.isDisallowed(node2.expression);
        },
        ClassExpression: alwaysTrue,
        ConditionalExpression(node2) {
          if (allowTernary) {
            return Checker.isDisallowed(node2.consequent) || Checker.isDisallowed(node2.alternate);
          }
          return true;
        },
        FunctionExpression: alwaysTrue,
        Identifier: alwaysTrue,
        JSXElement() {
          return enforceForJSX;
        },
        JSXFragment() {
          return enforceForJSX;
        },
        Literal: alwaysTrue,
        LogicalExpression(node2) {
          if (allowShortCircuit) {
            return Checker.isDisallowed(node2.right);
          }
          return true;
        },
        MemberExpression: alwaysTrue,
        MetaProperty: alwaysTrue,
        ObjectExpression: alwaysTrue,
        SequenceExpression: alwaysTrue,
        TaggedTemplateExpression() {
          return !allowTaggedTemplates;
        },
        TemplateLiteral: alwaysTrue,
        ThisExpression: alwaysTrue,
        UnaryExpression(node2) {
          return node2.operator !== "void" && node2.operator !== "delete";
        },
        // TypeScript-specific node types
        TSAsExpression(node2) {
          return Checker.isDisallowed(node2.expression);
        },
        TSTypeAssertion(node2) {
          return Checker.isDisallowed(node2.expression);
        },
        TSNonNullExpression(node2) {
          return Checker.isDisallowed(node2.expression);
        },
        TSInstantiationExpression(node2) {
          return Checker.isDisallowed(node2.expression);
        }
      });
      return {
        ExpressionStatement(node2) {
          if (Checker.isDisallowed(node2.expression) && !astUtils2.isDirective(node2) && !(ignoreDirectives && isDirective(node2))) {
            context.report({ node: node2, messageId: "unusedExpression" });
          }
        }
      };
    }
  };
  return noUnusedExpressions;
}
var noUnusedLabels;
var hasRequiredNoUnusedLabels;
function requireNoUnusedLabels() {
  if (hasRequiredNoUnusedLabels) return noUnusedLabels;
  hasRequiredNoUnusedLabels = 1;
  const astUtils2 = requireAstUtils();
  noUnusedLabels = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unused labels",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unused-labels"
      },
      schema: [],
      fixable: "code",
      messages: {
        unused: "'{{name}}:' is defined but never used."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let scopeInfo = null;
      function enterLabeledScope(node2) {
        scopeInfo = {
          label: node2.label.name,
          used: false,
          upper: scopeInfo
        };
      }
      function isFixable(node2) {
        if (sourceCode2.getTokenAfter(node2.label, {
          includeComments: true
        }) !== sourceCode2.getTokenBefore(node2.body, { includeComments: true })) {
          return false;
        }
        let ancestor = node2.parent;
        while (ancestor.type === "LabeledStatement") {
          ancestor = ancestor.parent;
        }
        if (ancestor.type === "Program" || ancestor.type === "BlockStatement" && astUtils2.isFunction(ancestor.parent)) {
          const { body } = node2;
          if (body.type === "ExpressionStatement" && (body.expression.type === "Literal" && typeof body.expression.value === "string" || astUtils2.isStaticTemplateLiteral(body.expression))) {
            return false;
          }
        }
        return true;
      }
      function exitLabeledScope(node2) {
        if (!scopeInfo.used) {
          context.report({
            node: node2.label,
            messageId: "unused",
            data: node2.label,
            fix: isFixable(node2) ? (fixer) => fixer.removeRange([
              node2.range[0],
              node2.body.range[0]
            ]) : null
          });
        }
        scopeInfo = scopeInfo.upper;
      }
      function markAsUsed(node2) {
        if (!node2.label) {
          return;
        }
        const label = node2.label.name;
        let info = scopeInfo;
        while (info) {
          if (info.label === label) {
            info.used = true;
            break;
          }
          info = info.upper;
        }
      }
      return {
        LabeledStatement: enterLabeledScope,
        "LabeledStatement:exit": exitLabeledScope,
        BreakStatement: markAsUsed,
        ContinueStatement: markAsUsed
      };
    }
  };
  return noUnusedLabels;
}
var noUnusedPrivateClassMembers;
var hasRequiredNoUnusedPrivateClassMembers;
function requireNoUnusedPrivateClassMembers() {
  if (hasRequiredNoUnusedPrivateClassMembers) return noUnusedPrivateClassMembers;
  hasRequiredNoUnusedPrivateClassMembers = 1;
  noUnusedPrivateClassMembers = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unused private class members",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unused-private-class-members"
      },
      schema: [],
      messages: {
        unusedPrivateClassMember: "'{{classMemberName}}' is defined but never used."
      }
    },
    create(context) {
      const trackedClasses = [];
      function isWriteOnlyAssignment(privateIdentifierNode) {
        const parentStatement = privateIdentifierNode.parent.parent;
        const isAssignmentExpression = parentStatement.type === "AssignmentExpression";
        if (!isAssignmentExpression && parentStatement.type !== "ForInStatement" && parentStatement.type !== "ForOfStatement" && parentStatement.type !== "AssignmentPattern") {
          return false;
        }
        if (parentStatement.left !== privateIdentifierNode.parent) {
          return false;
        }
        if (isAssignmentExpression && parentStatement.operator !== "=") {
          return parentStatement.parent.type === "ExpressionStatement";
        }
        return true;
      }
      return {
        // Collect all declared members up front and assume they are all unused
        ClassBody(classBodyNode) {
          const privateMembers = /* @__PURE__ */ new Map();
          trackedClasses.unshift(privateMembers);
          for (const bodyMember of classBodyNode.body) {
            if (bodyMember.type === "PropertyDefinition" || bodyMember.type === "MethodDefinition") {
              if (bodyMember.key.type === "PrivateIdentifier") {
                privateMembers.set(bodyMember.key.name, {
                  declaredNode: bodyMember,
                  isAccessor: bodyMember.type === "MethodDefinition" && (bodyMember.kind === "set" || bodyMember.kind === "get")
                });
              }
            }
          }
        },
        /*
         * Process all usages of the private identifier and remove a member from
         * `declaredAndUnusedPrivateMembers` if we deem it used.
         */
        PrivateIdentifier(privateIdentifierNode) {
          const classBody = trackedClasses.find(
            (classProperties) => classProperties.has(privateIdentifierNode.name)
          );
          if (!classBody) {
            return;
          }
          const memberDefinition = classBody.get(
            privateIdentifierNode.name
          );
          if (memberDefinition.isUsed) {
            return;
          }
          if (privateIdentifierNode.parent.type === "PropertyDefinition" || privateIdentifierNode.parent.type === "MethodDefinition") {
            return;
          }
          if (memberDefinition.isAccessor) {
            memberDefinition.isUsed = true;
            return;
          }
          if (isWriteOnlyAssignment(privateIdentifierNode)) {
            return;
          }
          const wrappingExpressionType = privateIdentifierNode.parent.parent.type;
          const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;
          if (wrappingExpressionType === "UpdateExpression" && parentOfWrappingExpressionType === "ExpressionStatement") {
            return;
          }
          if (wrappingExpressionType === "Property" && parentOfWrappingExpressionType === "ObjectPattern" && privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {
            return;
          }
          if (wrappingExpressionType === "RestElement") {
            return;
          }
          if (wrappingExpressionType === "ArrayPattern") {
            return;
          }
          memberDefinition.isUsed = true;
        },
        /*
         * Post-process the class members and report any remaining members.
         * Since private members can only be accessed in the current class context,
         * we can safely assume that all usages are within the current class body.
         */
        "ClassBody:exit"() {
          const unusedPrivateMembers = trackedClasses.shift();
          for (const [
            classMemberName,
            { declaredNode, isUsed }
          ] of unusedPrivateMembers.entries()) {
            if (isUsed) {
              continue;
            }
            context.report({
              node: declaredNode,
              loc: declaredNode.key.loc,
              messageId: "unusedPrivateClassMember",
              data: {
                classMemberName: `#${classMemberName}`
              }
            });
          }
        }
      };
    }
  };
  return noUnusedPrivateClassMembers;
}
var noUnusedVars;
var hasRequiredNoUnusedVars;
function requireNoUnusedVars() {
  if (hasRequiredNoUnusedVars) return noUnusedVars;
  hasRequiredNoUnusedVars = 1;
  const astUtils2 = requireAstUtils();
  noUnusedVars = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow unused variables",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-unused-vars"
      },
      hasSuggestions: true,
      schema: [
        {
          oneOf: [
            {
              enum: ["all", "local"]
            },
            {
              type: "object",
              properties: {
                vars: {
                  enum: ["all", "local"]
                },
                varsIgnorePattern: {
                  type: "string"
                },
                args: {
                  enum: ["all", "after-used", "none"]
                },
                ignoreRestSiblings: {
                  type: "boolean"
                },
                argsIgnorePattern: {
                  type: "string"
                },
                caughtErrors: {
                  enum: ["all", "none"]
                },
                caughtErrorsIgnorePattern: {
                  type: "string"
                },
                destructuredArrayIgnorePattern: {
                  type: "string"
                },
                ignoreClassWithStaticInitBlock: {
                  type: "boolean"
                },
                ignoreUsingDeclarations: {
                  type: "boolean"
                },
                reportUsedIgnorePattern: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}.",
        usedIgnoredVar: "'{{varName}}' is marked as ignored but is used{{additional}}.",
        removeVar: "Remove unused variable '{{varName}}'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;
      const config2 = {
        vars: "all",
        args: "after-used",
        ignoreRestSiblings: false,
        caughtErrors: "all",
        ignoreClassWithStaticInitBlock: false,
        ignoreUsingDeclarations: false,
        reportUsedIgnorePattern: false
      };
      const firstOption = context.options[0];
      if (firstOption) {
        if (typeof firstOption === "string") {
          config2.vars = firstOption;
        } else {
          config2.vars = firstOption.vars || config2.vars;
          config2.args = firstOption.args || config2.args;
          config2.ignoreRestSiblings = firstOption.ignoreRestSiblings || config2.ignoreRestSiblings;
          config2.caughtErrors = firstOption.caughtErrors || config2.caughtErrors;
          config2.ignoreClassWithStaticInitBlock = firstOption.ignoreClassWithStaticInitBlock || config2.ignoreClassWithStaticInitBlock;
          config2.ignoreUsingDeclarations = firstOption.ignoreUsingDeclarations || config2.ignoreUsingDeclarations;
          config2.reportUsedIgnorePattern = firstOption.reportUsedIgnorePattern || config2.reportUsedIgnorePattern;
          if (firstOption.varsIgnorePattern) {
            config2.varsIgnorePattern = new RegExp(
              firstOption.varsIgnorePattern,
              "u"
            );
          }
          if (firstOption.argsIgnorePattern) {
            config2.argsIgnorePattern = new RegExp(
              firstOption.argsIgnorePattern,
              "u"
            );
          }
          if (firstOption.caughtErrorsIgnorePattern) {
            config2.caughtErrorsIgnorePattern = new RegExp(
              firstOption.caughtErrorsIgnorePattern,
              "u"
            );
          }
          if (firstOption.destructuredArrayIgnorePattern) {
            config2.destructuredArrayIgnorePattern = new RegExp(
              firstOption.destructuredArrayIgnorePattern,
              "u"
            );
          }
        }
      }
      function defToVariableType(def) {
        if (config2.destructuredArrayIgnorePattern && def.name.parent.type === "ArrayPattern") {
          return "array-destructure";
        }
        switch (def.type) {
          case "CatchClause":
            return "catch-clause";
          case "Parameter":
            return "parameter";
          default:
            return "variable";
        }
      }
      function getVariableDescription(variableType) {
        let pattern2;
        let variableDescription;
        switch (variableType) {
          case "array-destructure":
            pattern2 = config2.destructuredArrayIgnorePattern;
            variableDescription = "elements of array destructuring";
            break;
          case "catch-clause":
            pattern2 = config2.caughtErrorsIgnorePattern;
            variableDescription = "caught errors";
            break;
          case "parameter":
            pattern2 = config2.argsIgnorePattern;
            variableDescription = "args";
            break;
          case "variable":
            pattern2 = config2.varsIgnorePattern;
            variableDescription = "vars";
            break;
          default:
            throw new Error(
              `Unexpected variable type: ${variableType}`
            );
        }
        if (pattern2) {
          pattern2 = pattern2.toString();
        }
        return [variableDescription, pattern2];
      }
      function getDefinedMessageData(unusedVar) {
        const def = unusedVar.defs && unusedVar.defs[0];
        let additionalMessageData = "";
        if (def) {
          const [variableDescription, pattern2] = getVariableDescription(
            defToVariableType(def)
          );
          if (pattern2 && variableDescription) {
            additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern2}`;
          }
        }
        return {
          varName: unusedVar.name,
          action: "defined",
          additional: additionalMessageData
        };
      }
      function getAssignedMessageData(unusedVar) {
        const def = unusedVar.defs && unusedVar.defs[0];
        let additionalMessageData = "";
        if (def) {
          const [variableDescription, pattern2] = getVariableDescription(
            defToVariableType(def)
          );
          if (pattern2 && variableDescription) {
            additionalMessageData = `. Allowed unused ${variableDescription} must match ${pattern2}`;
          }
        }
        return {
          varName: unusedVar.name,
          action: "assigned a value",
          additional: additionalMessageData
        };
      }
      function getUsedIgnoredMessageData(variable, variableType) {
        const [variableDescription, pattern2] = getVariableDescription(variableType);
        let additionalMessageData = "";
        if (pattern2 && variableDescription) {
          additionalMessageData = `. Used ${variableDescription} must not match ${pattern2}`;
        }
        return {
          varName: variable.name,
          additional: additionalMessageData
        };
      }
      const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;
      function isExported(variable) {
        const definition = variable.defs[0];
        if (definition) {
          let node2 = definition.node;
          if (node2.type === "VariableDeclarator") {
            node2 = node2.parent;
          } else if (definition.type === "Parameter") {
            return false;
          }
          return node2.parent.type.indexOf("Export") === 0;
        }
        return false;
      }
      function usesExplicitResourceManagement(variable) {
        const [definition] = variable.defs;
        return (definition == null ? void 0 : definition.type) === "Variable" && (definition.parent.kind === "using" || definition.parent.kind === "await using");
      }
      function hasRestSibling(node2) {
        return node2.type === "Property" && node2.parent.type === "ObjectPattern" && REST_PROPERTY_TYPE.test(node2.parent.properties.at(-1).type);
      }
      function hasRestSpreadSibling(variable) {
        if (config2.ignoreRestSiblings) {
          const hasRestSiblingDefinition = variable.defs.some(
            (def) => hasRestSibling(def.name.parent)
          );
          const hasRestSiblingReference = variable.references.some(
            (ref2) => hasRestSibling(ref2.identifier.parent)
          );
          return hasRestSiblingDefinition || hasRestSiblingReference;
        }
        return false;
      }
      function isReadRef(ref2) {
        return ref2.isRead();
      }
      function isSelfReference(ref2, nodes) {
        let scope = ref2.from;
        while (scope) {
          if (nodes.includes(scope.block)) {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      }
      function getFunctionDefinitions(variable) {
        const functionDefinitions = [];
        variable.defs.forEach((def) => {
          const { type: type2, node: node2 } = def;
          if (type2 === "FunctionName") {
            functionDefinitions.push(node2);
          }
          if (type2 === "Variable" && node2.init && (node2.init.type === "FunctionExpression" || node2.init.type === "ArrowFunctionExpression")) {
            functionDefinitions.push(node2.init);
          }
        });
        return functionDefinitions;
      }
      function isInside(inner, outer) {
        return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
      }
      function isUnusedExpression(node2) {
        const parent = node2.parent;
        if (parent.type === "ExpressionStatement") {
          return true;
        }
        if (parent.type === "SequenceExpression") {
          const isLastExpression = parent.expressions.at(-1) === node2;
          if (!isLastExpression) {
            return true;
          }
          return isUnusedExpression(parent);
        }
        return false;
      }
      function getRhsNode(ref2, prevRhsNode) {
        const id2 = ref2.identifier;
        const parent = id2.parent;
        const refScope = ref2.from.variableScope;
        const varScope = ref2.resolved.scope.variableScope;
        const canBeUsedLater = refScope !== varScope || astUtils2.isInLoop(id2);
        if (prevRhsNode && isInside(id2, prevRhsNode)) {
          return prevRhsNode;
        }
        if (parent.type === "AssignmentExpression" && isUnusedExpression(parent) && id2 === parent.left && !canBeUsedLater) {
          return parent.right;
        }
        return null;
      }
      function isStorableFunction(funcNode, rhsNode) {
        let node2 = funcNode;
        let parent = funcNode.parent;
        while (parent && isInside(parent, rhsNode)) {
          switch (parent.type) {
            case "SequenceExpression":
              if (parent.expressions.at(-1) !== node2) {
                return false;
              }
              break;
            case "CallExpression":
            case "NewExpression":
              return parent.callee !== node2;
            case "AssignmentExpression":
            case "TaggedTemplateExpression":
            case "YieldExpression":
              return true;
            default:
              if (STATEMENT_TYPE.test(parent.type)) {
                return true;
              }
          }
          node2 = parent;
          parent = parent.parent;
        }
        return false;
      }
      function isInsideOfStorableFunction(id2, rhsNode) {
        const funcNode = astUtils2.getUpperFunction(id2);
        return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
      }
      function isReadForItself(ref2, rhsNode) {
        const id2 = ref2.identifier;
        const parent = id2.parent;
        return ref2.isRead() && // self update. e.g. `a += 1`, `a++`
        (parent.type === "AssignmentExpression" && parent.left === id2 && isUnusedExpression(parent) && !astUtils2.isLogicalAssignmentOperator(parent.operator) || parent.type === "UpdateExpression" && isUnusedExpression(parent) || // in RHS of an assignment for itself. e.g. `a = a + 1`
        rhsNode && isInside(id2, rhsNode) && !isInsideOfStorableFunction(id2, rhsNode));
      }
      function isForInOfRef(ref2) {
        let target = ref2.identifier.parent;
        if (target.type === "VariableDeclarator") {
          target = target.parent.parent;
        }
        if (target.type !== "ForInStatement" && target.type !== "ForOfStatement") {
          return false;
        }
        if (target.body.type === "BlockStatement") {
          target = target.body.body[0];
        } else {
          target = target.body;
        }
        if (!target) {
          return false;
        }
        return target.type === "ReturnStatement";
      }
      function isUsedVariable(variable) {
        if (variable.eslintUsed) {
          return true;
        }
        const functionNodes = getFunctionDefinitions(variable);
        const isFunctionDefinition = functionNodes.length > 0;
        let rhsNode = null;
        return variable.references.some((ref2) => {
          if (isForInOfRef(ref2)) {
            return true;
          }
          const forItself = isReadForItself(ref2, rhsNode);
          rhsNode = getRhsNode(ref2, rhsNode);
          return isReadRef(ref2) && !forItself && !(isFunctionDefinition && isSelfReference(ref2, functionNodes));
        });
      }
      function isAfterLastUsedArg(variable) {
        const def = variable.defs[0];
        const params = sourceCode2.getDeclaredVariables(def.node);
        const posteriorParams = params.slice(params.indexOf(variable) + 1);
        return !posteriorParams.some(
          (v2) => v2.references.length > 0 || v2.eslintUsed
        );
      }
      function collectUnusedVariables(scope, unusedVars) {
        const variables = scope.variables;
        const childScopes = scope.childScopes;
        let i2, l2;
        if (scope.type !== "global" || config2.vars === "all") {
          for (i2 = 0, l2 = variables.length; i2 < l2; ++i2) {
            const variable = variables[i2];
            if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
              continue;
            }
            if (scope.functionExpressionScope) {
              continue;
            }
            if (!config2.reportUsedIgnorePattern && variable.eslintUsed) {
              continue;
            }
            if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
              continue;
            }
            const def = variable.defs[0];
            if (def) {
              const type2 = def.type;
              const refUsedInArrayPatterns = variable.references.some(
                (ref2) => ref2.identifier.parent.type === "ArrayPattern"
              );
              if ((def.name.parent.type === "ArrayPattern" || refUsedInArrayPatterns) && config2.destructuredArrayIgnorePattern && config2.destructuredArrayIgnorePattern.test(
                def.name.name
              )) {
                if (config2.reportUsedIgnorePattern && isUsedVariable(variable)) {
                  context.report({
                    node: def.name,
                    messageId: "usedIgnoredVar",
                    data: getUsedIgnoredMessageData(
                      variable,
                      "array-destructure"
                    )
                  });
                }
                continue;
              }
              if (type2 === "ClassName") {
                const hasStaticBlock = def.node.body.body.some(
                  (node2) => node2.type === "StaticBlock"
                );
                if (config2.ignoreClassWithStaticInitBlock && hasStaticBlock) {
                  continue;
                }
              }
              if (type2 === "CatchClause") {
                if (config2.caughtErrors === "none") {
                  continue;
                }
                if (config2.caughtErrorsIgnorePattern && config2.caughtErrorsIgnorePattern.test(
                  def.name.name
                )) {
                  if (config2.reportUsedIgnorePattern && isUsedVariable(variable)) {
                    context.report({
                      node: def.name,
                      messageId: "usedIgnoredVar",
                      data: getUsedIgnoredMessageData(
                        variable,
                        "catch-clause"
                      )
                    });
                  }
                  continue;
                }
              } else if (type2 === "Parameter") {
                if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
                  continue;
                }
                if (config2.args === "none") {
                  continue;
                }
                if (config2.argsIgnorePattern && config2.argsIgnorePattern.test(def.name.name)) {
                  if (config2.reportUsedIgnorePattern && isUsedVariable(variable)) {
                    context.report({
                      node: def.name,
                      messageId: "usedIgnoredVar",
                      data: getUsedIgnoredMessageData(
                        variable,
                        "parameter"
                      )
                    });
                  }
                  continue;
                }
                if (config2.args === "after-used" && astUtils2.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                  continue;
                }
              } else {
                if (config2.varsIgnorePattern && config2.varsIgnorePattern.test(def.name.name)) {
                  if (config2.reportUsedIgnorePattern && isUsedVariable(variable)) {
                    context.report({
                      node: def.name,
                      messageId: "usedIgnoredVar",
                      data: getUsedIgnoredMessageData(
                        variable,
                        "variable"
                      )
                    });
                  }
                  continue;
                }
              }
            }
            if (!isUsedVariable(variable) && !isExported(variable) && !(config2.ignoreUsingDeclarations && usesExplicitResourceManagement(variable)) && !hasRestSpreadSibling(variable)) {
              unusedVars.push(variable);
            }
          }
        }
        for (i2 = 0, l2 = childScopes.length; i2 < l2; ++i2) {
          collectUnusedVariables(childScopes[i2], unusedVars);
        }
        return unusedVars;
      }
      function handleFixes(fixer, unusedVar) {
        const id2 = unusedVar.identifiers[0];
        const parent = id2.parent;
        const parentType = parent.type;
        const tokenBefore = sourceCode2.getTokenBefore(id2);
        const tokenAfter = sourceCode2.getTokenAfter(id2);
        const isFunction = astUtils2.isFunction;
        const isLoop = astUtils2.isLoop;
        const allWriteReferences = unusedVar.references.filter(
          (ref2) => ref2.isWrite()
        );
        function getPreviousTokenStart(node2, skips) {
          return sourceCode2.getTokenBefore(node2, skips).range[0];
        }
        function getNextTokenEnd(node2, skips) {
          return sourceCode2.getTokenAfter(node2, skips).range[1];
        }
        function getTokenBeforeValue(node2) {
          return sourceCode2.getTokenBefore(node2).value;
        }
        function getTokenAfterValue(node2) {
          return sourceCode2.getTokenAfter(node2).value;
        }
        function hasSingleElement(node2) {
          return node2.elements.filter((e2) => e2 !== null).length === 1;
        }
        function hasImportOfCertainType(node2, type2) {
          return node2.specifiers.some((e2) => e2.type === type2);
        }
        function isDeclarationNotSafeToRemove(nextToken, prevToken) {
          return nextToken.type === "String" || prevToken && !astUtils2.isSemicolonToken(prevToken) && !astUtils2.isOpeningBraceToken(prevToken);
        }
        function fixFunctionParameters(node2) {
          const parentNode = node2.parent;
          if (isFunction(parentNode)) {
            if (parentNode.params.length === 1) {
              return fixer.removeRange(node2.range);
            }
            if (getTokenBeforeValue(node2) === "(" && getTokenAfterValue(node2) === ",") {
              return fixer.removeRange([
                node2.range[0],
                getNextTokenEnd(node2)
              ]);
            }
            return fixer.removeRange([
              getPreviousTokenStart(node2),
              node2.range[1]
            ]);
          }
          return null;
        }
        function fixVariables(node2) {
          const parentNode = node2.parent;
          if (parentNode.type === "VariableDeclarator") {
            if (isLoop(parentNode.parent.parent)) {
              return null;
            }
            if (parentNode.parent.declarations.length === 1) {
              const nextToken = sourceCode2.getTokenAfter(
                parentNode.parent
              );
              const prevToken = sourceCode2.getTokenBefore(
                parentNode.parent
              );
              if (nextToken && isDeclarationNotSafeToRemove(nextToken, prevToken)) {
                return null;
              }
              return fixer.removeRange(parentNode.parent.range);
            }
            if (getTokenBeforeValue(parentNode) === ",") {
              return fixer.removeRange([
                getPreviousTokenStart(parentNode),
                parentNode.range[1]
              ]);
            }
            return fixer.removeRange([
              parentNode.range[0],
              getNextTokenEnd(parentNode)
            ]);
          }
          if (getTokenBeforeValue(node2) === ":") {
            if (parentNode.parent.type === "ObjectPattern") {
              return fixObjectWithValueSeparator(node2);
            }
          }
          return fixFunctionParameters(node2);
        }
        function fixNestedObjectVariable(node2) {
          const parentNode = node2.parent;
          if (parentNode.parent.parent.parent.type === "ObjectPattern" && parentNode.parent.properties.length === 1) {
            return fixNestedObjectVariable(parentNode.parent);
          }
          if (parentNode.parent.type === "ObjectPattern") {
            if (parentNode.parent.properties.length === 1) {
              return fixVariables(parentNode.parent);
            }
            if (getTokenBeforeValue(parentNode) === "{") {
              return fixer.removeRange([
                parentNode.range[0],
                getNextTokenEnd(parentNode)
              ]);
            }
            return fixer.removeRange([
              getPreviousTokenStart(parentNode),
              parentNode.range[1]
            ]);
          }
          return null;
        }
        function fixNestedArrayVariable(node2) {
          const parentNode = node2.parent;
          if (parentNode.parent.type === "ArrayPattern" && hasSingleElement(parentNode)) {
            return fixNestedArrayVariable(parentNode);
          }
          if (hasSingleElement(parentNode)) {
            if (getTokenBeforeValue(parentNode) === ":") {
              return fixVariables(parentNode);
            }
            if (parentNode.parent.type === "RestElement") {
              return fixRestInPattern(parentNode.parent);
            }
            return fixVariables(parentNode);
          }
          if (getTokenBeforeValue(node2) === "," && getTokenAfterValue(node2) === "]") {
            return fixer.removeRange([
              getPreviousTokenStart(node2),
              node2.range[1]
            ]);
          }
          return fixer.removeRange(node2.range);
        }
        function fixObjectWithValueSeparator(node2) {
          const parentNode = node2.parent.parent;
          if (parentNode.parent.type === "ArrayPattern" && parentNode.properties.length === 1) {
            return fixNestedArrayVariable(parentNode);
          }
          return fixNestedObjectVariable(node2);
        }
        function fixRestInPattern(node2) {
          const parentNode = node2.parent;
          if (isFunction(parentNode)) {
            if (parentNode.params.length === 1) {
              return fixer.removeRange(node2.range);
            }
            return fixer.removeRange([
              getPreviousTokenStart(node2),
              node2.range[1]
            ]);
          }
          if (parentNode.type === "ArrayPattern") {
            if (hasSingleElement(parentNode)) {
              if (parentNode.parent.type === "ArrayPattern") {
                return fixNestedArrayVariable(parentNode);
              }
              return fixVariables(parentNode);
            }
            return fixer.removeRange([
              getPreviousTokenStart(node2),
              node2.range[1]
            ]);
          }
          return null;
        }
        if (allWriteReferences.some(
          (ref2) => ref2.identifier.range[0] !== id2.range[0]
        )) {
          return null;
        }
        if (parentType === "VariableDeclarator") {
          if (parent.parent.declarations.length === 1) {
            if (isLoop(parent.parent.parent) && parent.parent.parent.body !== parent.parent) {
              return null;
            }
            if (parent.parent.parent.type === "IfStatement" || isLoop(parent.parent.parent) || parent.parent.parent.type === "WithStatement" && parent.parent.parent.body === parent.parent) {
              return fixer.replaceText(parent.parent, ";");
            }
            const nextToken = sourceCode2.getTokenAfter(parent.parent);
            const prevToken = sourceCode2.getTokenBefore(parent.parent);
            if (nextToken && isDeclarationNotSafeToRemove(nextToken, prevToken)) {
              return null;
            }
            return fixer.removeRange(parent.parent.range);
          }
          if (tokenBefore.value === ",") {
            return fixer.removeRange([
              tokenBefore.range[0],
              parent.range[1]
            ]);
          }
          return fixer.removeRange([
            parent.range[0],
            getNextTokenEnd(parent)
          ]);
        }
        if (parent.parent.type === "ObjectPattern") {
          if (parent.parent.properties.length === 1) {
            if (parent.parent.parent.type === "RestElement") {
              return fixRestInPattern(parent.parent.parent);
            }
            if (parent.parent.parent.type === "ArrayPattern") {
              return fixNestedArrayVariable(parent.parent);
            }
            return fixVariables(parent.parent);
          }
          if (tokenBefore.value === ":") {
            if (getTokenBeforeValue(parent) === "{" && getTokenAfterValue(parent) === ",") {
              return fixer.removeRange([
                parent.range[0],
                getNextTokenEnd(parent)
              ]);
            }
            return fixer.removeRange([
              getPreviousTokenStart(parent),
              id2.range[1]
            ]);
          }
        }
        if (parentType === "ArrayPattern") {
          if (hasSingleElement(parent)) {
            if (parent.parent.type === "RestElement") {
              return fixRestInPattern(parent.parent);
            }
            if (parent.parent.type === "ArrayPattern") {
              return fixNestedArrayVariable(parent);
            }
            return fixVariables(parent);
          }
          if (tokenBefore.value === "," && tokenAfter.value === ",") {
            return fixer.removeRange(id2.range);
          }
        }
        if (parentType === "RestElement") {
          if (parent.parent.type === "ArrayPattern") {
            if (hasSingleElement(parent.parent)) {
              if (parent.parent.parent.type === "ArrayPattern") {
                return fixNestedArrayVariable(parent.parent);
              }
              return fixVariables(parent.parent);
            }
            return fixer.removeRange([
              getPreviousTokenStart(id2, 1),
              id2.range[1]
            ]);
          }
          if (parent.parent.type === "ObjectPattern") {
            if (parent.parent.properties.length === 1) {
              return fixVariables(parent.parent);
            }
            return fixer.removeRange([
              getPreviousTokenStart(id2, 1),
              id2.range[1]
            ]);
          }
          if (isFunction(parent.parent)) {
            if (parent.parent.params.length === 1) {
              return fixer.removeRange(parent.range);
            }
            return fixer.removeRange([
              getPreviousTokenStart(parent),
              parent.range[1]
            ]);
          }
        }
        if (parentType === "AssignmentPattern") {
          if (parent.parent.type === "ArrayPattern") {
            return fixNestedArrayVariable(parent);
          }
          if (parent.parent.parent.type === "ObjectPattern") {
            if (parent.parent.parent.properties.length === 1) {
              if (parent.parent.parent.parent.type === "ArrayPattern") {
                return fixNestedArrayVariable(parent.parent.parent);
              }
              return fixVariables(parent.parent.parent);
            }
            if (getTokenBeforeValue(parent.parent) === "{" && getTokenAfterValue(parent.parent) === ",") {
              return fixer.removeRange([
                parent.parent.range[0],
                getNextTokenEnd(parent.parent)
              ]);
            }
            return fixer.removeRange([
              getPreviousTokenStart(parent.parent),
              parent.parent.range[1]
            ]);
          }
          if (isFunction(parent.parent)) {
            return fixFunctionParameters(parent);
          }
        }
        if (parentType === "FunctionDeclaration" && parent.id === id2) {
          return fixer.removeRange(parent.range);
        }
        if (parentType === "ImportDefaultSpecifier") {
          if (!hasImportOfCertainType(parent.parent, "ImportSpecifier") && !hasImportOfCertainType(
            parent.parent,
            "ImportNamespaceSpecifier"
          )) {
            return fixer.removeRange([
              parent.range[0],
              parent.parent.source.range[0]
            ]);
          }
          return fixer.removeRange([id2.range[0], tokenAfter.range[1]]);
        }
        if (parentType === "ImportSpecifier") {
          if (parent.parent.specifiers.filter(
            (e2) => e2.type === "ImportSpecifier"
          ).length === 1) {
            if (!hasImportOfCertainType(
              parent.parent,
              "ImportDefaultSpecifier"
            )) {
              return fixer.removeRange(parent.parent.range);
            }
            return fixer.removeRange([
              getPreviousTokenStart(parent, 1),
              tokenAfter.range[1]
            ]);
          }
          if (getTokenBeforeValue(parent) === "{") {
            return fixer.removeRange([
              parent.range[0],
              getNextTokenEnd(parent)
            ]);
          }
          return fixer.removeRange([
            getPreviousTokenStart(parent),
            parent.range[1]
          ]);
        }
        if (parentType === "ImportNamespaceSpecifier") {
          if (hasImportOfCertainType(
            parent.parent,
            "ImportDefaultSpecifier"
          )) {
            return fixer.removeRange([
              getPreviousTokenStart(parent),
              parent.range[1]
            ]);
          }
          return fixer.removeRange([
            parent.range[0],
            parent.parent.source.range[0]
          ]);
        }
        if (parentType === "CatchClause") {
          return null;
        }
        if (parentType === "ClassDeclaration") {
          return fixer.removeRange(parent.range);
        }
        if ((tokenBefore == null ? void 0 : tokenBefore.value) === ",") {
          return fixer.removeRange([tokenBefore.range[0], id2.range[1]]);
        }
        if (tokenAfter.value === ",") {
          if (tokenBefore.value === "(") {
            return fixer.removeRange([
              id2.range[0],
              tokenAfter.range[1]
            ]);
          }
          if (tokenBefore.value === "{") {
            return fixer.removeRange([
              id2.range[0],
              tokenAfter.range[1]
            ]);
          }
        }
        if (parentType === "ArrowFunctionExpression" && parent.params.length === 1 && (tokenAfter == null ? void 0 : tokenAfter.value) !== ")") {
          return fixer.replaceText(id2, "()");
        }
        return fixer.removeRange(id2.range);
      }
      return {
        "Program:exit"(programNode) {
          const unusedVars = collectUnusedVariables(
            sourceCode2.getScope(programNode),
            []
          );
          for (let i2 = 0, l2 = unusedVars.length; i2 < l2; ++i2) {
            const unusedVar = unusedVars[i2];
            if (unusedVar.defs.length > 0) {
              const writeReferences = unusedVar.references.filter(
                (ref2) => ref2.isWrite() && ref2.from.variableScope === unusedVar.scope.variableScope
              );
              let referenceToReport;
              if (writeReferences.length > 0) {
                referenceToReport = writeReferences.at(-1);
              }
              context.report({
                node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],
                messageId: "unusedVar",
                data: unusedVar.references.some(
                  (ref2) => ref2.isWrite()
                ) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar),
                suggest: [
                  {
                    messageId: "removeVar",
                    data: {
                      varName: unusedVar.name
                    },
                    fix(fixer) {
                      return handleFixes(fixer, unusedVar);
                    }
                  }
                ]
              });
            } else if (unusedVar.eslintExplicitGlobalComments) {
              const directiveComment = unusedVar.eslintExplicitGlobalComments[0];
              context.report({
                node: programNode,
                loc: astUtils2.getNameLocationInGlobalDirectiveComment(
                  sourceCode2,
                  directiveComment,
                  unusedVar.name
                ),
                messageId: "unusedVar",
                data: getDefinedMessageData(unusedVar)
              });
            }
          }
        }
      };
    }
  };
  return noUnusedVars;
}
var noUseBeforeDefine;
var hasRequiredNoUseBeforeDefine;
function requireNoUseBeforeDefine() {
  if (hasRequiredNoUseBeforeDefine) return noUseBeforeDefine;
  hasRequiredNoUseBeforeDefine = 1;
  const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
  const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;
  function parseOptions(options) {
    if (typeof options === "object" && options !== null) {
      return options;
    }
    const functions = typeof options === "string" ? options !== "nofunc" : true;
    return {
      functions,
      classes: true,
      variables: true,
      allowNamedExports: false,
      enums: true,
      typedefs: true,
      ignoreTypeReferences: true
    };
  }
  function isInRange(node2, location) {
    return node2 && node2.range[0] <= location && location <= node2.range[1];
  }
  function isInClassStaticInitializerRange(node2, location) {
    return node2.body.some(
      (classMember) => classMember.type === "StaticBlock" && isInRange(classMember, location) || classMember.type === "PropertyDefinition" && classMember.static && classMember.value && isInRange(classMember.value, location)
    );
  }
  function isClassStaticInitializerScope(scope) {
    if (scope.type === "class-static-block") {
      return true;
    }
    if (scope.type === "class-field-initializer") {
      const propertyDefinition = scope.block.parent;
      return propertyDefinition.static;
    }
    return false;
  }
  function isFromSeparateExecutionContext(reference) {
    const variable = reference.resolved;
    let scope = reference.from;
    while (variable.scope.variableScope !== scope.variableScope) {
      if (isClassStaticInitializerScope(scope.variableScope)) {
        scope = scope.variableScope.upper;
      } else {
        return true;
      }
    }
    return false;
  }
  function isEvaluatedDuringInitialization(reference) {
    if (isFromSeparateExecutionContext(reference)) {
      return false;
    }
    const location = reference.identifier.range[1];
    const definition = reference.resolved.defs[0];
    if (definition.type === "ClassName") {
      const classDefinition = definition.node;
      return isInRange(classDefinition, location) && /*
       * Class binding is initialized before running static initializers.
       * For example, `class C { static foo = C; static { bar = C; } }` is valid.
       */
      !isInClassStaticInitializerRange(classDefinition.body, location);
    }
    let node2 = definition.name.parent;
    while (node2) {
      if (node2.type === "VariableDeclarator") {
        if (isInRange(node2.init, location)) {
          return true;
        }
        if (FOR_IN_OF_TYPE.test(node2.parent.parent.type) && isInRange(node2.parent.parent.right, location)) {
          return true;
        }
        break;
      } else if (node2.type === "AssignmentPattern") {
        if (isInRange(node2.right, location)) {
          return true;
        }
      } else if (SENTINEL_TYPE.test(node2.type)) {
        break;
      }
      node2 = node2.parent;
    }
    return false;
  }
  function referenceContainsTypeQuery(node2) {
    switch (node2.type) {
      case "TSTypeQuery":
        return true;
      case "TSQualifiedName":
      case "Identifier":
        return referenceContainsTypeQuery(node2.parent);
      default:
        return false;
    }
  }
  function isClassRefInClassDecorator(variable, reference) {
    if (variable.defs[0].type !== "ClassName") {
      return false;
    }
    if (!variable.defs[0].node.decorators || variable.defs[0].node.decorators.length === 0) {
      return false;
    }
    for (const deco of variable.defs[0].node.decorators) {
      if (reference.identifier.range[0] >= deco.range[0] && reference.identifier.range[1] <= deco.range[1]) {
        return true;
      }
    }
    return false;
  }
  noUseBeforeDefine = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "problem",
      docs: {
        description: "Disallow the use of variables before they are defined",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-use-before-define"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["nofunc"]
            },
            {
              type: "object",
              properties: {
                functions: { type: "boolean" },
                classes: { type: "boolean" },
                variables: { type: "boolean" },
                allowNamedExports: { type: "boolean" },
                enums: { type: "boolean" },
                typedefs: { type: "boolean" },
                ignoreTypeReferences: { type: "boolean" }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      defaultOptions: [
        {
          classes: true,
          functions: true,
          variables: true,
          allowNamedExports: false,
          enums: true,
          typedefs: true,
          ignoreTypeReferences: true
        }
      ],
      messages: {
        usedBeforeDefined: "'{{name}}' was used before it was defined."
      }
    },
    create(context) {
      const options = parseOptions(context.options[0]);
      const sourceCode2 = context.sourceCode;
      function shouldCheck(reference) {
        if (reference.init) {
          return false;
        }
        const { identifier } = reference;
        if (options.allowNamedExports && identifier.parent.type === "ExportSpecifier" && identifier.parent.local === identifier) {
          return false;
        }
        const variable = reference.resolved;
        if (!variable || variable.defs.length === 0) {
          return false;
        }
        const definitionType = variable.defs[0].type;
        if (!options.functions && definitionType === "FunctionName") {
          return false;
        }
        if ((!options.variables && definitionType === "Variable" || !options.classes && definitionType === "ClassName") && // don't skip checking the reference if it's in the same execution context, because of TDZ
        isFromSeparateExecutionContext(reference)) {
          return false;
        }
        if (!options.enums && definitionType === "TSEnumName") {
          return false;
        }
        if (!options.typedefs && definitionType === "Type") {
          return false;
        }
        if (options.ignoreTypeReferences && (referenceContainsTypeQuery(identifier) || identifier.parent.type === "TSTypeReference")) {
          return false;
        }
        if (identifier.parent.type === "TSQualifiedName") {
          let currentNode = identifier.parent;
          while (currentNode.type === "TSQualifiedName") {
            currentNode = currentNode.left;
          }
          if (currentNode === identifier) {
            return true;
          }
          return false;
        }
        if (isClassRefInClassDecorator(variable, reference)) {
          return false;
        }
        return true;
      }
      function checkReferencesInScope(scope) {
        scope.references.filter(shouldCheck).forEach((reference) => {
          const variable = reference.resolved;
          const definitionIdentifier = variable.defs[0].name;
          if (reference.identifier.range[1] < definitionIdentifier.range[1] || isEvaluatedDuringInitialization(reference) && reference.identifier.parent.type !== "TSTypeReference") {
            context.report({
              node: reference.identifier,
              messageId: "usedBeforeDefined",
              data: reference.identifier
            });
          }
        });
        scope.childScopes.forEach(checkReferencesInScope);
      }
      return {
        Program(node2) {
          checkReferencesInScope(sourceCode2.getScope(node2));
        }
      };
    }
  };
  return noUseBeforeDefine;
}
var noUselessAssignment;
var hasRequiredNoUselessAssignment;
function requireNoUselessAssignment() {
  if (hasRequiredNoUselessAssignment) return noUselessAssignment;
  hasRequiredNoUselessAssignment = 1;
  const { findVariable } = /* @__PURE__ */ requireEslintUtils();
  function* extractIdentifiersFromPattern(pattern2) {
    switch (pattern2.type) {
      case "Identifier":
        yield pattern2;
        return;
      case "ObjectPattern":
        for (const property of pattern2.properties) {
          yield* extractIdentifiersFromPattern(
            property.type === "Property" ? property.value : property
          );
        }
        return;
      case "ArrayPattern":
        for (const element of pattern2.elements) {
          if (!element) {
            continue;
          }
          yield* extractIdentifiersFromPattern(element);
        }
        return;
      case "RestElement":
        yield* extractIdentifiersFromPattern(pattern2.argument);
        return;
      case "AssignmentPattern":
        yield* extractIdentifiersFromPattern(pattern2.left);
    }
  }
  function isIdentifierEvaluatedAfterAssignment(assignment, identifier) {
    if (identifier.range[0] < assignment.identifier.range[1]) {
      return false;
    }
    if (assignment.expression && assignment.expression.range[0] <= identifier.range[0] && identifier.range[1] <= assignment.expression.range[1]) {
      return false;
    }
    return true;
  }
  function isIdentifierUsedBetweenAssignedAndEqualSign(assignment, identifier) {
    if (!assignment.expression) {
      return false;
    }
    return assignment.identifier.range[1] <= identifier.range[0] && identifier.range[1] <= assignment.expression.range[0];
  }
  noUselessAssignment = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow variable assignments when the value is not used",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-useless-assignment"
      },
      schema: [],
      messages: {
        unnecessaryAssignment: "This assigned value is not used in subsequent statements."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let scopeStack = null;
      const codePathStartScopes = /* @__PURE__ */ new Set();
      function getCodePathStartScope(scope) {
        let target = scope;
        while (target) {
          if (codePathStartScopes.has(target)) {
            return target;
          }
          target = target.upper;
        }
        return null;
      }
      function verify(target) {
        function isIdentifierUsedInSegment(segment, identifier) {
          const segmentInfo = target.segments[segment.id];
          return segmentInfo.first && segmentInfo.last && segmentInfo.first.range[0] <= identifier.range[0] && identifier.range[1] <= segmentInfo.last.range[1];
        }
        function verifyAssignmentIsUsed(targetAssignment, allAssignments) {
          const isAssignmentInTryBlock = target.tryStatementBlocks.some(
            (tryBlock) => tryBlock.range[0] <= targetAssignment.identifier.range[0] && targetAssignment.identifier.range[1] <= tryBlock.range[1]
          );
          if (isAssignmentInTryBlock) {
            return;
          }
          const subsequentSegmentData = {
            /**
             * Cache of subsequent segment information list that have already been iterated.
             * @type {SubsequentSegmentData[]}
             */
            results: [],
            /**
             * Subsequent segments that have already been iterated on. Used to avoid infinite loops.
             * @type {Set<CodePathSegment>}
             */
            subsequentSegments: /* @__PURE__ */ new Set(),
            /**
             * Unexplored code path segment.
             * If additional iterations are needed, consume this information and iterate.
             * @type {CodePathSegment[]}
             */
            queueSegments: targetAssignment.segments.flatMap(
              (segment) => segment.nextSegments
            )
          };
          function* getSubsequentSegments() {
            yield* subsequentSegmentData.results;
            while (subsequentSegmentData.queueSegments.length > 0) {
              const nextSegment = subsequentSegmentData.queueSegments.shift();
              if (subsequentSegmentData.subsequentSegments.has(
                nextSegment
              )) {
                continue;
              }
              subsequentSegmentData.subsequentSegments.add(
                nextSegment
              );
              const assignmentInSegment = allAssignments.find(
                (otherAssignment) => otherAssignment.segments.includes(
                  nextSegment
                ) && !isIdentifierUsedBetweenAssignedAndEqualSign(
                  otherAssignment,
                  targetAssignment.identifier
                )
              );
              if (!assignmentInSegment) {
                subsequentSegmentData.queueSegments.push(
                  ...nextSegment.nextSegments
                );
              }
              const result = {
                segment: nextSegment,
                assignment: assignmentInSegment
              };
              subsequentSegmentData.results.push(result);
              yield result;
            }
          }
          if (targetAssignment.variable.references.some(
            (ref2) => ref2.identifier.type !== "Identifier"
          )) {
            return;
          }
          const readReferences = targetAssignment.variable.references.filter(
            (reference) => reference.isRead()
          );
          if (!readReferences.length) {
            return;
          }
          const otherAssignmentAfterTargetAssignment = allAssignments.find((assignment) => {
            if (assignment === targetAssignment || assignment.segments.length && assignment.segments.every(
              (segment) => !targetAssignment.segments.includes(
                segment
              )
            )) {
              return false;
            }
            if (isIdentifierEvaluatedAfterAssignment(
              targetAssignment,
              assignment.identifier
            )) {
              return true;
            }
            if (assignment.expression && assignment.expression.range[0] <= targetAssignment.identifier.range[0] && targetAssignment.identifier.range[1] <= assignment.expression.range[1]) {
              return true;
            }
            return false;
          });
          for (const reference of readReferences) {
            if (target.scope !== getCodePathStartScope(reference.from)) {
              return;
            }
            if (isIdentifierEvaluatedAfterAssignment(
              targetAssignment,
              reference.identifier
            ) && (isIdentifierUsedBetweenAssignedAndEqualSign(
              targetAssignment,
              reference.identifier
            ) || targetAssignment.segments.some(
              (segment) => isIdentifierUsedInSegment(
                segment,
                reference.identifier
              )
            ))) {
              if (otherAssignmentAfterTargetAssignment && isIdentifierEvaluatedAfterAssignment(
                otherAssignmentAfterTargetAssignment,
                reference.identifier
              )) {
                continue;
              }
              return;
            }
            if (otherAssignmentAfterTargetAssignment) {
              continue;
            }
            for (const subsequentSegment of getSubsequentSegments()) {
              if (isIdentifierUsedInSegment(
                subsequentSegment.segment,
                reference.identifier
              )) {
                if (subsequentSegment.assignment && isIdentifierEvaluatedAfterAssignment(
                  subsequentSegment.assignment,
                  reference.identifier
                )) {
                  continue;
                }
                return;
              }
            }
          }
          context.report({
            node: targetAssignment.identifier,
            messageId: "unnecessaryAssignment"
          });
        }
        for (const assignments of target.assignments.values()) {
          assignments.sort(
            (a2, b) => a2.identifier.range[0] - b.identifier.range[0]
          );
          for (const assignment of assignments) {
            verifyAssignmentIsUsed(assignment, assignments);
          }
        }
      }
      return {
        onCodePathStart(codePath2, node2) {
          const scope = sourceCode2.getScope(node2);
          scopeStack = {
            upper: scopeStack,
            codePath: codePath2,
            scope,
            segments: /* @__PURE__ */ Object.create(null),
            currentSegments: /* @__PURE__ */ new Set(),
            assignments: /* @__PURE__ */ new Map(),
            tryStatementBlocks: []
          };
          codePathStartScopes.add(scopeStack.scope);
        },
        onCodePathEnd() {
          verify(scopeStack);
          scopeStack = scopeStack.upper;
        },
        onCodePathSegmentStart(segment) {
          const segmentInfo = { segment, first: null, last: null };
          scopeStack.segments[segment.id] = segmentInfo;
          scopeStack.currentSegments.add(segment);
        },
        onCodePathSegmentEnd(segment) {
          scopeStack.currentSegments.delete(segment);
        },
        TryStatement(node2) {
          scopeStack.tryStatementBlocks.push(node2.block);
        },
        Identifier(node2) {
          for (const segment of scopeStack.currentSegments) {
            const segmentInfo = scopeStack.segments[segment.id];
            if (!segmentInfo.first) {
              segmentInfo.first = node2;
            }
            segmentInfo.last = node2;
          }
        },
        ":matches(VariableDeclarator[init!=null], AssignmentExpression, UpdateExpression):exit"(node2) {
          if (scopeStack.currentSegments.size === 0) {
            return;
          }
          const assignments = scopeStack.assignments;
          let pattern2;
          let expression = null;
          if (node2.type === "VariableDeclarator") {
            pattern2 = node2.id;
            expression = node2.init;
          } else if (node2.type === "AssignmentExpression") {
            pattern2 = node2.left;
            expression = node2.right;
          } else {
            pattern2 = node2.argument;
          }
          for (const identifier of extractIdentifiersFromPattern(
            pattern2
          )) {
            const scope = sourceCode2.getScope(identifier);
            const variable = findVariable(scope, identifier);
            if (!variable) {
              continue;
            }
            if (variable.scope.type === "global" && variable.defs.length === 0) {
              continue;
            }
            if (scopeStack.scope !== getCodePathStartScope(variable.scope)) {
              continue;
            }
            if (variable.eslintUsed) {
              continue;
            }
            if (variable.scope.type === "module") {
              if (variable.defs.some(
                (def) => def.type === "Variable" && def.parent.parent.type === "ExportNamedDeclaration" || def.type === "FunctionName" && (def.node.parent.type === "ExportNamedDeclaration" || def.node.parent.type === "ExportDefaultDeclaration") || def.type === "ClassName" && (def.node.parent.type === "ExportNamedDeclaration" || def.node.parent.type === "ExportDefaultDeclaration")
              )) {
                continue;
              }
              if (variable.references.some(
                (reference) => reference.identifier.parent.type === "ExportSpecifier"
              )) {
                continue;
              }
            }
            let list = assignments.get(variable);
            if (!list) {
              list = [];
              assignments.set(variable, list);
            }
            list.push({
              variable,
              identifier,
              node: node2,
              expression,
              segments: [...scopeStack.currentSegments]
            });
          }
        }
      };
    }
  };
  return noUselessAssignment;
}
var noUselessBackreference;
var hasRequiredNoUselessBackreference;
function requireNoUselessBackreference() {
  if (hasRequiredNoUselessBackreference) return noUselessBackreference;
  hasRequiredNoUselessBackreference = 1;
  const {
    CALL,
    CONSTRUCT,
    ReferenceTracker,
    getStringIfConstant
  } = /* @__PURE__ */ requireEslintUtils();
  const { RegExpParser, visitRegExpAST } = requireRegexpp();
  const parser2 = new RegExpParser();
  function getPathToRoot(node2) {
    const path = [];
    let current = node2;
    do {
      path.push(current);
      current = current.parent;
    } while (current);
    return path;
  }
  function isLookaround(node2) {
    return node2.type === "Assertion" && (node2.kind === "lookahead" || node2.kind === "lookbehind");
  }
  function isNegativeLookaround(node2) {
    return isLookaround(node2) && node2.negate;
  }
  noUselessBackreference = {
    meta: {
      type: "problem",
      docs: {
        description: "Disallow useless backreferences in regular expressions",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-useless-backreference"
      },
      schema: [],
      messages: {
        nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} from within that group.",
        forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which appears later in the pattern.",
        backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which appears before in the same lookbehind.",
        disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which is in another alternative.",
        intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}'{{ otherGroups }} which is in a negative lookaround."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkRegex(node2, pattern2, flags2) {
        let regExpAST;
        try {
          regExpAST = parser2.parsePattern(pattern2, 0, pattern2.length, {
            unicode: flags2.includes("u"),
            unicodeSets: flags2.includes("v")
          });
        } catch {
          return;
        }
        visitRegExpAST(regExpAST, {
          onBackreferenceEnter(bref) {
            const groups = [bref.resolved].flat(), brefPath = getPathToRoot(bref);
            const problems = groups.map((group2) => {
              const groupPath = getPathToRoot(group2);
              if (brefPath.includes(group2)) {
                return {
                  messageId: "nested",
                  group: group2
                };
              }
              let i2 = brefPath.length - 1, j = groupPath.length - 1;
              do {
                i2--;
                j--;
              } while (brefPath[i2] === groupPath[j]);
              const indexOfLowestCommonAncestor = j + 1, groupCut = groupPath.slice(
                0,
                indexOfLowestCommonAncestor
              ), commonPath = groupPath.slice(
                indexOfLowestCommonAncestor
              ), lowestCommonLookaround = commonPath.find(isLookaround), isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === "lookbehind";
              if (groupCut.at(-1).type === "Alternative") {
                return {
                  messageId: "disjunctive",
                  group: group2
                };
              }
              if (!isMatchingBackward && bref.end <= group2.start) {
                return {
                  messageId: "forward",
                  group: group2
                };
              }
              if (isMatchingBackward && group2.end <= bref.start) {
                return {
                  messageId: "backward",
                  group: group2
                };
              }
              if (groupCut.some(isNegativeLookaround)) {
                return {
                  messageId: "intoNegativeLookaround",
                  group: group2
                };
              }
              return null;
            });
            if (problems.length === 0 || problems.some((problem) => !problem)) {
              return;
            }
            let problemsToReport;
            const problemsInSameDisjunction = problems.filter(
              (problem) => problem.messageId !== "disjunctive"
            );
            if (problemsInSameDisjunction.length) {
              problemsToReport = problemsInSameDisjunction;
            } else {
              problemsToReport = problems;
            }
            const [{ messageId, group }, ...other] = problemsToReport;
            let otherGroups = "";
            if (other.length === 1) {
              otherGroups = " and another group";
            } else if (other.length > 1) {
              otherGroups = ` and other ${other.length} groups`;
            }
            context.report({
              node: node2,
              messageId,
              data: {
                bref: bref.raw,
                group: group.raw,
                otherGroups
              }
            });
          }
        });
      }
      return {
        "Literal[regex]"(node2) {
          const { pattern: pattern2, flags: flags2 } = node2.regex;
          checkRegex(node2, pattern2, flags2);
        },
        Program(node2) {
          const scope = sourceCode2.getScope(node2), tracker = new ReferenceTracker(scope), traceMap = {
            RegExp: {
              [CALL]: true,
              [CONSTRUCT]: true
            }
          };
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            traceMap
          )) {
            const [patternNode, flagsNode] = refNode.arguments, pattern2 = getStringIfConstant(patternNode, scope), flags2 = getStringIfConstant(flagsNode, scope);
            if (typeof pattern2 === "string") {
              checkRegex(refNode, pattern2, flags2 || "");
            }
          }
        }
      };
    }
  };
  return noUselessBackreference;
}
var noUselessCall;
var hasRequiredNoUselessCall;
function requireNoUselessCall() {
  if (hasRequiredNoUselessCall) return noUselessCall;
  hasRequiredNoUselessCall = 1;
  const astUtils2 = requireAstUtils();
  function isCallOrNonVariadicApply(node2) {
    const callee = astUtils2.skipChainExpression(node2.callee);
    return callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.computed === false && (callee.property.name === "call" && node2.arguments.length >= 1 || callee.property.name === "apply" && node2.arguments.length === 2 && node2.arguments[1].type === "ArrayExpression");
  }
  function isValidThisArg(expectedThis, thisArg, sourceCode2) {
    if (!expectedThis) {
      return astUtils2.isNullOrUndefined(thisArg);
    }
    return astUtils2.equalTokens(expectedThis, thisArg, sourceCode2);
  }
  noUselessCall = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary calls to `.call()` and `.apply()`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-useless-call"
      },
      schema: [],
      messages: {
        unnecessaryCall: "Unnecessary '.{{name}}()'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        CallExpression(node2) {
          if (!isCallOrNonVariadicApply(node2)) {
            return;
          }
          const callee = astUtils2.skipChainExpression(node2.callee);
          const applied = astUtils2.skipChainExpression(callee.object);
          const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
          const thisArg = node2.arguments[0];
          if (isValidThisArg(expectedThis, thisArg, sourceCode2)) {
            context.report({
              node: node2,
              messageId: "unnecessaryCall",
              data: { name: callee.property.name }
            });
          }
        }
      };
    }
  };
  return noUselessCall;
}
var noUselessCatch;
var hasRequiredNoUselessCatch;
function requireNoUselessCatch() {
  if (hasRequiredNoUselessCatch) return noUselessCatch;
  hasRequiredNoUselessCatch = 1;
  noUselessCatch = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary `catch` clauses",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-useless-catch"
      },
      schema: [],
      messages: {
        unnecessaryCatchClause: "Unnecessary catch clause.",
        unnecessaryCatch: "Unnecessary try/catch wrapper."
      }
    },
    create(context) {
      return {
        CatchClause(node2) {
          if (node2.param && node2.param.type === "Identifier" && node2.body.body.length && node2.body.body[0].type === "ThrowStatement" && node2.body.body[0].argument.type === "Identifier" && node2.body.body[0].argument.name === node2.param.name) {
            if (node2.parent.finalizer) {
              context.report({
                node: node2,
                messageId: "unnecessaryCatchClause"
              });
            } else {
              context.report({
                node: node2.parent,
                messageId: "unnecessaryCatch"
              });
            }
          }
        }
      };
    }
  };
  return noUselessCatch;
}
var noUselessComputedKey;
var hasRequiredNoUselessComputedKey;
function requireNoUselessComputedKey() {
  if (hasRequiredNoUselessComputedKey) return noUselessComputedKey;
  hasRequiredNoUselessComputedKey = 1;
  const astUtils2 = requireAstUtils();
  function hasUselessComputedKey(node2) {
    if (!node2.computed) {
      return false;
    }
    const { key } = node2;
    if (key.type !== "Literal") {
      return false;
    }
    const { value } = key;
    if (typeof value !== "number" && typeof value !== "string") {
      return false;
    }
    switch (node2.type) {
      case "Property":
        if (node2.parent.type === "ObjectExpression") {
          return value !== "__proto__";
        }
        return true;
      case "PropertyDefinition":
        if (node2.static) {
          return value !== "constructor" && value !== "prototype";
        }
        return value !== "constructor";
      case "MethodDefinition":
        if (node2.static) {
          return value !== "prototype";
        }
        return value !== "constructor";
      default:
        throw new Error(`Unexpected node type: ${node2.type}`);
    }
  }
  noUselessComputedKey = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          enforceForClassMembers: true
        }
      ],
      docs: {
        description: "Disallow unnecessary computed property keys in objects and classes",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-useless-computed-key"
      },
      schema: [
        {
          type: "object",
          properties: {
            enforceForClassMembers: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ enforceForClassMembers }] = context.options;
      function check2(node2) {
        if (hasUselessComputedKey(node2)) {
          const { key } = node2;
          context.report({
            node: node2,
            messageId: "unnecessarilyComputedProperty",
            data: { property: sourceCode2.getText(key) },
            fix(fixer) {
              const leftSquareBracket = sourceCode2.getTokenBefore(
                key,
                astUtils2.isOpeningBracketToken
              );
              const rightSquareBracket = sourceCode2.getTokenAfter(
                key,
                astUtils2.isClosingBracketToken
              );
              if (sourceCode2.commentsExistBetween(
                leftSquareBracket,
                rightSquareBracket
              )) {
                return null;
              }
              const tokenBeforeLeftBracket = sourceCode2.getTokenBefore(leftSquareBracket);
              const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils2.canTokensBeAdjacent(
                tokenBeforeLeftBracket,
                sourceCode2.getFirstToken(key)
              );
              const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
              return fixer.replaceTextRange(
                [
                  leftSquareBracket.range[0],
                  rightSquareBracket.range[1]
                ],
                replacementKey
              );
            }
          });
        }
      }
      function noop2() {
      }
      return {
        Property: check2,
        MethodDefinition: enforceForClassMembers ? check2 : noop2,
        PropertyDefinition: enforceForClassMembers ? check2 : noop2
      };
    }
  };
  return noUselessComputedKey;
}
var noUselessConcat;
var hasRequiredNoUselessConcat;
function requireNoUselessConcat() {
  if (hasRequiredNoUselessConcat) return noUselessConcat;
  hasRequiredNoUselessConcat = 1;
  const astUtils2 = requireAstUtils();
  function isConcatenation(node2) {
    return node2.type === "BinaryExpression" && node2.operator === "+";
  }
  function isConcatOperatorToken(token) {
    return token.value === "+" && token.type === "Punctuator";
  }
  function getLeft(node2) {
    let left = node2.left;
    while (isConcatenation(left)) {
      left = left.right;
    }
    return left;
  }
  function getRight(node2) {
    let right = node2.right;
    while (isConcatenation(right)) {
      right = right.left;
    }
    return right;
  }
  noUselessConcat = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary concatenation of literals or template literals",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-useless-concat"
      },
      schema: [],
      messages: {
        unexpectedConcat: "Unexpected string concatenation of literals."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        BinaryExpression(node2) {
          if (node2.operator !== "+") {
            return;
          }
          const left = getLeft(node2);
          const right = getRight(node2);
          if (astUtils2.isStringLiteral(left) && astUtils2.isStringLiteral(right) && astUtils2.isTokenOnSameLine(left, right)) {
            const operatorToken2 = sourceCode2.getFirstTokenBetween(
              left,
              right,
              isConcatOperatorToken
            );
            context.report({
              node: node2,
              loc: operatorToken2.loc,
              messageId: "unexpectedConcat"
            });
          }
        }
      };
    }
  };
  return noUselessConcat;
}
var noUselessConstructor;
var hasRequiredNoUselessConstructor;
function requireNoUselessConstructor() {
  if (hasRequiredNoUselessConstructor) return noUselessConstructor;
  hasRequiredNoUselessConstructor = 1;
  const astUtils2 = requireAstUtils();
  function hasDecoratorsOrParameterProperty(node2) {
    return node2.value.params.some(
      (param) => {
        var _a2;
        return ((_a2 = param.decorators) == null ? void 0 : _a2.length) || param.type === "TSParameterProperty";
      }
    );
  }
  function hasUsefulAccessibility(node2) {
    switch (node2.accessibility) {
      case "protected":
      case "private":
        return true;
      case "public":
        return !!node2.parent.parent.superClass;
      default:
        return false;
    }
  }
  function isSingleSuperCall(body) {
    return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
  }
  function isSimple(node2) {
    return node2.type === "Identifier" || node2.type === "RestElement";
  }
  function isSpreadArguments(superArgs) {
    return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
  }
  function isValidIdentifierPair(ctorParam, superArg) {
    return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
  }
  function isValidRestSpreadPair(ctorParam, superArg) {
    return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
  }
  function isValidPair(ctorParam, superArg) {
    return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
  }
  function isPassingThrough(ctorParams, superArgs) {
    if (ctorParams.length !== superArgs.length) {
      return false;
    }
    for (let i2 = 0; i2 < ctorParams.length; ++i2) {
      if (!isValidPair(ctorParams[i2], superArgs[i2])) {
        return false;
      }
    }
    return true;
  }
  function isRedundantSuperCall(body, ctorParams) {
    return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
  }
  noUselessConstructor = {
    meta: {
      dialects: ["javascript", "typescript"],
      language: "javascript",
      type: "suggestion",
      docs: {
        description: "Disallow unnecessary constructors",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-useless-constructor"
      },
      hasSuggestions: true,
      schema: [],
      messages: {
        noUselessConstructor: "Useless constructor.",
        removeConstructor: "Remove the constructor."
      }
    },
    create(context) {
      function checkForConstructor(node2) {
        if (node2.kind !== "constructor" || node2.value.type !== "FunctionExpression" || hasDecoratorsOrParameterProperty(node2) || hasUsefulAccessibility(node2)) {
          return;
        }
        if (!node2.value.body) {
          return;
        }
        const body = node2.value.body.body;
        const ctorParams = node2.value.params;
        const superClass = node2.parent.parent.superClass;
        if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
          context.report({
            node: node2,
            messageId: "noUselessConstructor",
            suggest: [
              {
                messageId: "removeConstructor",
                *fix(fixer) {
                  const nextToken = context.sourceCode.getTokenAfter(node2);
                  const addSemiColon = nextToken.type === "Punctuator" && nextToken.value === "[" && astUtils2.needsPrecedingSemicolon(
                    context.sourceCode,
                    node2
                  );
                  yield fixer.replaceText(
                    node2,
                    addSemiColon ? ";" : ""
                  );
                }
              }
            ]
          });
        }
      }
      return {
        MethodDefinition: checkForConstructor
      };
    }
  };
  return noUselessConstructor;
}
var noUselessEscape;
var hasRequiredNoUselessEscape;
function requireNoUselessEscape() {
  if (hasRequiredNoUselessEscape) return noUselessEscape;
  hasRequiredNoUselessEscape = 1;
  const astUtils2 = requireAstUtils();
  const { RegExpParser, visitRegExpAST } = requireRegexpp();
  function union(setA, setB) {
    return new Set(
      function* () {
        yield* setA;
        yield* setB;
      }()
    );
  }
  const VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils2.LINEBREAKS);
  const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
  const REGEX_NON_CHARCLASS_ESCAPES = union(
    REGEX_GENERAL_ESCAPES,
    new Set("^/.$*+?[{}|()Bk")
  );
  const REGEX_CLASSSET_CHARACTER_ESCAPES = union(
    REGEX_GENERAL_ESCAPES,
    new Set("q/[{}|()-")
  );
  const REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR = new Set(
    "!#$%&*+,.:;<=>?@^`~"
  );
  noUselessEscape = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowRegexCharacters: []
        }
      ],
      docs: {
        description: "Disallow unnecessary escape characters",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-useless-escape"
      },
      hasSuggestions: true,
      messages: {
        unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
        removeEscape: "Remove the `\\`. This maintains the current functionality.",
        removeEscapeDoNotKeepSemantics: "Remove the `\\` if it was inserted by mistake.",
        escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
      },
      schema: [
        {
          type: "object",
          properties: {
            allowRegexCharacters: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ]
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ allowRegexCharacters }] = context.options;
      const parser2 = new RegExpParser();
      function report(node2, startOffset, character, disableEscapeBackslashSuggest) {
        const rangeStart = node2.range[0] + startOffset;
        const range = [rangeStart, rangeStart + 1];
        const start = sourceCode2.getLocFromIndex(rangeStart);
        context.report({
          node: node2,
          loc: {
            start,
            end: { line: start.line, column: start.column + 1 }
          },
          messageId: "unnecessaryEscape",
          data: { character },
          suggest: [
            {
              // Removing unnecessary `\` characters in a directive is not guaranteed to maintain functionality.
              messageId: astUtils2.isDirective(node2.parent) ? "removeEscapeDoNotKeepSemantics" : "removeEscape",
              fix(fixer) {
                return fixer.removeRange(range);
              }
            },
            ...disableEscapeBackslashSuggest ? [] : [
              {
                messageId: "escapeBackslash",
                fix(fixer) {
                  return fixer.insertTextBeforeRange(
                    range,
                    "\\"
                  );
                }
              }
            ]
          ]
        });
      }
      function validateString(node2, match) {
        const isTemplateElement = node2.type === "TemplateElement";
        const escapedChar = match[0][1];
        let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
        let isQuoteEscape;
        if (isTemplateElement) {
          isQuoteEscape = escapedChar === "`";
          if (escapedChar === "$") {
            isUnnecessaryEscape = match.input[match.index + 2] !== "{";
          } else if (escapedChar === "{") {
            isUnnecessaryEscape = match.input[match.index - 1] !== "$";
          }
        } else {
          isQuoteEscape = escapedChar === node2.raw[0];
        }
        if (isUnnecessaryEscape && !isQuoteEscape) {
          report(node2, match.index, match[0].slice(1));
        }
      }
      function validateRegExp(node2) {
        const { pattern: pattern2, flags: flags2 } = node2.regex;
        let patternNode;
        const unicode2 = flags2.includes("u");
        const unicodeSets = flags2.includes("v");
        try {
          patternNode = parser2.parsePattern(pattern2, 0, pattern2.length, {
            unicode: unicode2,
            unicodeSets
          });
        } catch {
          return;
        }
        const characterClassStack = [];
        visitRegExpAST(patternNode, {
          onCharacterClassEnter: (characterClassNode) => characterClassStack.unshift(characterClassNode),
          onCharacterClassLeave: () => characterClassStack.shift(),
          onExpressionCharacterClassEnter: (characterClassNode) => characterClassStack.unshift(characterClassNode),
          onExpressionCharacterClassLeave: () => characterClassStack.shift(),
          onCharacterEnter(characterNode) {
            if (!characterNode.raw.startsWith("\\")) {
              return;
            }
            const escapedChar = characterNode.raw.slice(1);
            if (escapedChar !== String.fromCodePoint(characterNode.value) || allowRegexCharacters.includes(escapedChar)) {
              return;
            }
            let allowedEscapes;
            if (characterClassStack.length) {
              allowedEscapes = unicodeSets ? REGEX_CLASSSET_CHARACTER_ESCAPES : REGEX_GENERAL_ESCAPES;
            } else {
              allowedEscapes = REGEX_NON_CHARCLASS_ESCAPES;
            }
            if (allowedEscapes.has(escapedChar)) {
              return;
            }
            const reportedIndex = characterNode.start + 1;
            let disableEscapeBackslashSuggest = false;
            if (characterClassStack.length) {
              const characterClassNode = characterClassStack[0];
              if (escapedChar === "^") {
                if (characterClassNode.start + 1 === characterNode.start) {
                  return;
                }
              }
              if (!unicodeSets) {
                if (escapedChar === "-") {
                  if (characterClassNode.start + 1 !== characterNode.start && characterNode.end !== characterClassNode.end - 1) {
                    return;
                  }
                }
              } else {
                if (REGEX_CLASS_SET_RESERVED_DOUBLE_PUNCTUATOR.has(
                  escapedChar
                )) {
                  if (pattern2[characterNode.end] === escapedChar) {
                    return;
                  }
                  if (pattern2[characterNode.start - 1] === escapedChar) {
                    if (escapedChar !== "^") {
                      return;
                    }
                    if (!characterClassNode.negate) {
                      return;
                    }
                    const negateCaretIndex = characterClassNode.start + 1;
                    if (negateCaretIndex < characterNode.start - 1) {
                      return;
                    }
                  }
                }
                if (characterNode.parent.type === "ClassIntersection" || characterNode.parent.type === "ClassSubtraction") {
                  disableEscapeBackslashSuggest = true;
                }
              }
            }
            report(
              node2,
              reportedIndex,
              escapedChar,
              disableEscapeBackslashSuggest
            );
          }
        });
      }
      function check2(node2) {
        const isTemplateElement = node2.type === "TemplateElement";
        if (isTemplateElement && node2.parent && node2.parent.parent && node2.parent.parent.type === "TaggedTemplateExpression" && node2.parent === node2.parent.parent.quasi) {
          return;
        }
        if (typeof node2.value === "string" || isTemplateElement) {
          if (node2.parent.type === "JSXAttribute" || node2.parent.type === "JSXElement" || node2.parent.type === "JSXFragment") {
            return;
          }
          const value = isTemplateElement ? sourceCode2.getText(node2) : node2.raw;
          const pattern2 = /\\\D/gu;
          let match;
          while (match = pattern2.exec(value)) {
            validateString(node2, match);
          }
        } else if (node2.regex) {
          validateRegExp(node2);
        }
      }
      return {
        Literal: check2,
        TemplateElement: check2
      };
    }
  };
  return noUselessEscape;
}
var noUselessRename;
var hasRequiredNoUselessRename;
function requireNoUselessRename() {
  if (hasRequiredNoUselessRename) return noUselessRename;
  hasRequiredNoUselessRename = 1;
  const astUtils2 = requireAstUtils();
  noUselessRename = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          ignoreDestructuring: false,
          ignoreImport: false,
          ignoreExport: false
        }
      ],
      docs: {
        description: "Disallow renaming import, export, and destructured assignments to the same name",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-useless-rename"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            ignoreDestructuring: { type: "boolean" },
            ignoreImport: { type: "boolean" },
            ignoreExport: { type: "boolean" }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ ignoreDestructuring, ignoreImport, ignoreExport }] = context.options;
      function reportError(node2, initial, type2) {
        const name2 = initial.type === "Identifier" ? initial.name : initial.value;
        return context.report({
          node: node2,
          messageId: "unnecessarilyRenamed",
          data: {
            name: name2,
            type: type2
          },
          fix(fixer) {
            const replacementNode = node2.type === "Property" ? node2.value : node2.local;
            if (sourceCode2.getCommentsInside(node2).length > sourceCode2.getCommentsInside(replacementNode).length) {
              return null;
            }
            if (replacementNode.type === "AssignmentPattern" && astUtils2.isParenthesised(
              sourceCode2,
              replacementNode.left
            )) {
              return null;
            }
            return fixer.replaceText(
              node2,
              sourceCode2.getText(replacementNode)
            );
          }
        });
      }
      function checkDestructured(node2) {
        if (ignoreDestructuring) {
          return;
        }
        for (const property of node2.properties) {
          if (property.type !== "Property" || property.shorthand || property.computed) {
            continue;
          }
          const key = property.key.type === "Identifier" && property.key.name || property.key.type === "Literal" && property.key.value;
          const renamedKey = property.value.type === "AssignmentPattern" ? property.value.left.name : property.value.name;
          if (key === renamedKey) {
            reportError(
              property,
              property.key,
              "Destructuring assignment"
            );
          }
        }
      }
      function checkImport(node2) {
        if (ignoreImport) {
          return;
        }
        if (node2.imported.range[0] !== node2.local.range[0] && astUtils2.getModuleExportName(node2.imported) === node2.local.name) {
          reportError(node2, node2.imported, "Import");
        }
      }
      function checkExport(node2) {
        if (ignoreExport) {
          return;
        }
        if (node2.local.range[0] !== node2.exported.range[0] && astUtils2.getModuleExportName(node2.local) === astUtils2.getModuleExportName(node2.exported)) {
          reportError(node2, node2.local, "Export");
        }
      }
      return {
        ObjectPattern: checkDestructured,
        ImportSpecifier: checkImport,
        ExportSpecifier: checkExport
      };
    }
  };
  return noUselessRename;
}
var noUselessReturn;
var hasRequiredNoUselessReturn;
function requireNoUselessReturn() {
  if (hasRequiredNoUselessReturn) return noUselessReturn;
  hasRequiredNoUselessReturn = 1;
  const astUtils2 = requireAstUtils(), FixTracker = requireFixTracker();
  function remove2(array, element) {
    const index = array.indexOf(element);
    if (index !== -1) {
      array.splice(index, 1);
    }
  }
  function isRemovable(node2) {
    return astUtils2.STATEMENT_LIST_PARENTS.has(node2.parent.type);
  }
  function isInFinally(node2) {
    for (let currentNode = node2; currentNode && currentNode.parent && !astUtils2.isFunction(currentNode); currentNode = currentNode.parent) {
      if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
        return true;
      }
    }
    return false;
  }
  function isAnySegmentReachable(segments) {
    for (const segment of segments) {
      if (segment.reachable) {
        return true;
      }
    }
    return false;
  }
  noUselessReturn = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow redundant return statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-useless-return"
      },
      fixable: "code",
      schema: [],
      messages: {
        unnecessaryReturn: "Unnecessary return statement."
      }
    },
    create(context) {
      const segmentInfoMap = /* @__PURE__ */ new WeakMap();
      const sourceCode2 = context.sourceCode;
      let scopeInfo = null;
      function isReturned(segment) {
        const info = segmentInfoMap.get(segment);
        return !info || info.returned;
      }
      function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {
        const traversedSegments = providedTraversedSegments || /* @__PURE__ */ new WeakSet();
        for (const segment of prevSegments) {
          if (!segment.reachable) {
            if (!traversedSegments.has(segment)) {
              traversedSegments.add(segment);
              getUselessReturns(
                uselessReturns,
                segment.allPrevSegments.filter(isReturned),
                traversedSegments
              );
            }
            continue;
          }
          if (segmentInfoMap.has(segment)) {
            uselessReturns.push(
              ...segmentInfoMap.get(segment).uselessReturns
            );
          }
        }
        return uselessReturns;
      }
      function markReturnStatementsOnSegmentAsUsed(segment, usedUnreachableSegments) {
        if (!segment.reachable) {
          usedUnreachableSegments.add(segment);
          segment.allPrevSegments.filter(isReturned).filter(
            (prevSegment) => !usedUnreachableSegments.has(prevSegment)
          ).forEach(
            (prevSegment) => markReturnStatementsOnSegmentAsUsed(
              prevSegment,
              usedUnreachableSegments
            )
          );
          return;
        }
        const info = segmentInfoMap.get(segment);
        if (!info) {
          return;
        }
        info.uselessReturns = info.uselessReturns.filter((node2) => {
          if (scopeInfo.traversedTryBlockStatements && scopeInfo.traversedTryBlockStatements.length > 0) {
            const returnInitialRange = node2.range[0];
            const returnFinalRange = node2.range[1];
            const areBlocksInRange = scopeInfo.traversedTryBlockStatements.some(
              (tryBlockStatement) => {
                const blockInitialRange = tryBlockStatement.range[0];
                const blockFinalRange = tryBlockStatement.range[1];
                return returnInitialRange >= blockInitialRange && returnFinalRange <= blockFinalRange;
              }
            );
            if (areBlocksInRange) {
              return true;
            }
          }
          remove2(scopeInfo.uselessReturns, node2);
          return false;
        });
      }
      function markReturnStatementsOnCurrentSegmentsAsUsed() {
        scopeInfo.currentSegments.forEach(
          (segment) => markReturnStatementsOnSegmentAsUsed(segment, /* @__PURE__ */ new Set())
        );
      }
      return {
        // Makes and pushes a new scope information.
        onCodePathStart(codePath2) {
          scopeInfo = {
            upper: scopeInfo,
            uselessReturns: [],
            traversedTryBlockStatements: [],
            codePath: codePath2,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        // Reports useless return statements if exist.
        onCodePathEnd() {
          for (const node2 of scopeInfo.uselessReturns) {
            context.report({
              node: node2,
              loc: node2.loc,
              messageId: "unnecessaryReturn",
              fix(fixer) {
                if (isRemovable(node2) && !sourceCode2.getCommentsInside(node2).length) {
                  return new FixTracker(fixer, sourceCode2).retainEnclosingFunction(node2).remove(node2);
                }
                return null;
              }
            });
          }
          scopeInfo = scopeInfo.upper;
        },
        /*
         * Initializes segments.
         * NOTE: This event is notified for only reachable segments.
         */
        onCodePathSegmentStart(segment) {
          scopeInfo.currentSegments.add(segment);
          const info = {
            uselessReturns: getUselessReturns(
              [],
              segment.allPrevSegments
            ),
            returned: false
          };
          segmentInfoMap.set(segment, info);
        },
        onUnreachableCodePathSegmentStart(segment) {
          scopeInfo.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          scopeInfo.currentSegments.delete(segment);
        },
        onCodePathSegmentEnd(segment) {
          scopeInfo.currentSegments.delete(segment);
        },
        // Adds ReturnStatement node to check whether it's useless or not.
        ReturnStatement(node2) {
          if (node2.argument) {
            markReturnStatementsOnCurrentSegmentsAsUsed();
          }
          if (node2.argument || astUtils2.isInLoop(node2) || isInFinally(node2) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
          !isAnySegmentReachable(scopeInfo.currentSegments)) {
            return;
          }
          for (const segment of scopeInfo.currentSegments) {
            const info = segmentInfoMap.get(segment);
            if (info) {
              info.uselessReturns.push(node2);
              info.returned = true;
            }
          }
          scopeInfo.uselessReturns.push(node2);
        },
        "TryStatement > BlockStatement.block:exit"(node2) {
          scopeInfo.traversedTryBlockStatements.push(node2);
        },
        "TryStatement:exit"() {
          scopeInfo.traversedTryBlockStatements.pop();
        },
        /*
         * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
         * Removes return statements of the current segments from the useless return statement list.
         */
        ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
      };
    }
  };
  return noUselessReturn;
}
var noVar;
var hasRequiredNoVar;
function requireNoVar() {
  if (hasRequiredNoVar) return noVar;
  hasRequiredNoVar = 1;
  const astUtils2 = requireAstUtils();
  function isGlobal(variable) {
    return Boolean(variable.scope) && variable.scope.type === "global";
  }
  function getEnclosingFunctionScope(scope) {
    let currentScope = scope;
    while (currentScope.type !== "function" && currentScope.type !== "global") {
      currentScope = currentScope.upper;
    }
    return currentScope;
  }
  function isReferencedInClosure(variable) {
    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);
    return variable.references.some(
      (reference) => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope
    );
  }
  function isLoopAssignee(node2) {
    return (node2.parent.type === "ForOfStatement" || node2.parent.type === "ForInStatement") && node2 === node2.parent.left;
  }
  function isDeclarationInitialized(node2) {
    return node2.declarations.every((declarator) => declarator.init !== null);
  }
  const SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;
  function getScopeNode(node2) {
    for (let currentNode = node2; currentNode; currentNode = currentNode.parent) {
      if (SCOPE_NODE_TYPE.test(currentNode.type)) {
        return currentNode;
      }
    }
    return null;
  }
  function isRedeclared(variable) {
    return variable.defs.length >= 2;
  }
  function isUsedFromOutsideOf(scopeNode) {
    function isOutsideOfScope(reference) {
      const scope = scopeNode.range;
      const id2 = reference.identifier.range;
      return id2[0] < scope[0] || id2[1] > scope[1];
    }
    return function(variable) {
      return variable.references.some(isOutsideOfScope);
    };
  }
  function hasReferenceInTDZ(node2) {
    const initStart = node2.range[0];
    const initEnd = node2.range[1];
    return (variable) => {
      const id2 = variable.defs[0].name;
      const idStart = id2.range[0];
      const defaultValue = id2.parent.type === "AssignmentPattern" ? id2.parent.right : null;
      const defaultStart = defaultValue && defaultValue.range[0];
      const defaultEnd = defaultValue && defaultValue.range[1];
      return variable.references.some((reference) => {
        const start = reference.identifier.range[0];
        const end = reference.identifier.range[1];
        return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || !astUtils2.isFunction(node2) && start >= initStart && end <= initEnd);
      });
    };
  }
  function hasNameDisallowedForLetDeclarations(variable) {
    return variable.name === "let";
  }
  noVar = {
    meta: {
      type: "suggestion",
      dialects: ["typescript", "javascript"],
      language: "javascript",
      docs: {
        description: "Require `let` or `const` instead of `var`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-var"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedVar: "Unexpected var, use let or const instead."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function hasSelfReferenceInTDZ(declarator) {
        if (!declarator.init) {
          return false;
        }
        const variables = sourceCode2.getDeclaredVariables(declarator);
        return variables.some(hasReferenceInTDZ(declarator.init));
      }
      function canFix(node2) {
        const variables = sourceCode2.getDeclaredVariables(node2);
        const scopeNode = getScopeNode(node2);
        if (node2.parent.type === "SwitchCase" || node2.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {
          return false;
        }
        if (astUtils2.isInLoop(node2)) {
          if (variables.some(isReferencedInClosure)) {
            return false;
          }
          if (!isLoopAssignee(node2) && !isDeclarationInitialized(node2)) {
            return false;
          }
        }
        if (!isLoopAssignee(node2) && !(node2.parent.type === "ForStatement" && node2.parent.init === node2) && !astUtils2.STATEMENT_LIST_PARENTS.has(node2.parent.type)) {
          return false;
        }
        return true;
      }
      function report(node2) {
        context.report({
          node: node2,
          messageId: "unexpectedVar",
          fix(fixer) {
            const varToken = sourceCode2.getFirstToken(node2, {
              filter: (t2) => t2.value === "var"
            });
            return canFix(node2) ? fixer.replaceText(varToken, "let") : null;
          }
        });
      }
      return {
        "VariableDeclaration:exit"(node2) {
          if (node2.kind !== "var") {
            return;
          }
          if (node2.parent.type === "TSModuleBlock" && node2.parent.parent.type === "TSModuleDeclaration" && node2.parent.parent.global) {
            return;
          }
          report(node2);
        }
      };
    }
  };
  return noVar;
}
var noVoid;
var hasRequiredNoVoid;
function requireNoVoid() {
  if (hasRequiredNoVoid) return noVoid;
  hasRequiredNoVoid = 1;
  noVoid = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowAsStatement: false
        }
      ],
      docs: {
        description: "Disallow `void` operators",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-void"
      },
      messages: {
        noVoid: "Expected 'undefined' and instead saw 'void'."
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAsStatement: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ]
    },
    create(context) {
      const [{ allowAsStatement }] = context.options;
      return {
        'UnaryExpression[operator="void"]'(node2) {
          if (allowAsStatement && node2.parent && node2.parent.type === "ExpressionStatement") {
            return;
          }
          context.report({
            node: node2,
            messageId: "noVoid"
          });
        }
      };
    }
  };
  return noVoid;
}
var noWarningComments;
var hasRequiredNoWarningComments;
function requireNoWarningComments() {
  if (hasRequiredNoWarningComments) return noWarningComments;
  hasRequiredNoWarningComments = 1;
  const escapeRegExp = requireEscapeStringRegexp();
  const astUtils2 = requireAstUtils();
  const CHAR_LIMIT = 40;
  noWarningComments = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          location: "start",
          terms: ["todo", "fixme", "xxx"]
        }
      ],
      docs: {
        description: "Disallow specified warning terms in comments",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/no-warning-comments"
      },
      schema: [
        {
          type: "object",
          properties: {
            terms: {
              type: "array",
              items: {
                type: "string"
              }
            },
            location: {
              enum: ["start", "anywhere"]
            },
            decoration: {
              type: "array",
              items: {
                type: "string",
                pattern: "^\\S$"
              },
              minItems: 1,
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ decoration, location, terms: warningTerms }] = context.options;
      const escapedDecoration = escapeRegExp(
        decoration ? decoration.join("") : ""
      );
      const selfConfigRegEx = /\bno-warning-comments\b/u;
      function convertToRegExp(term) {
        const escaped = escapeRegExp(term);
        const wordBoundary = "\\b";
        let prefix = "";
        if (location === "start") {
          prefix = `^[\\s${escapedDecoration}]*`;
        } else if (/^\w/u.test(term)) {
          prefix = wordBoundary;
        }
        const suffix = /\w$/u.test(term) ? wordBoundary : "";
        const flags2 = "iu";
        return new RegExp(`${prefix}${escaped}${suffix}`, flags2);
      }
      const warningRegExps = warningTerms.map(convertToRegExp);
      function commentContainsWarningTerm(comment2) {
        const matches = [];
        warningRegExps.forEach((regex, index) => {
          if (regex.test(comment2)) {
            matches.push(warningTerms[index]);
          }
        });
        return matches;
      }
      function checkComment(node2) {
        const comment2 = node2.value;
        if (astUtils2.isDirectiveComment(node2) && selfConfigRegEx.test(comment2)) {
          return;
        }
        const matches = commentContainsWarningTerm(comment2);
        matches.forEach((matchedTerm) => {
          let commentToDisplay = "";
          let truncated = false;
          for (const c2 of comment2.trim().split(/\s+/u)) {
            const tmp = commentToDisplay ? `${commentToDisplay} ${c2}` : c2;
            if (tmp.length <= CHAR_LIMIT) {
              commentToDisplay = tmp;
            } else {
              truncated = true;
              break;
            }
          }
          context.report({
            node: node2,
            messageId: "unexpectedComment",
            data: {
              matchedTerm,
              comment: `${commentToDisplay}${truncated ? "..." : ""}`
            }
          });
        });
      }
      return {
        Program() {
          const comments = sourceCode2.getAllComments();
          comments.filter((token) => token.type !== "Shebang").forEach(checkComment);
        }
      };
    }
  };
  return noWarningComments;
}
var noWhitespaceBeforeProperty;
var hasRequiredNoWhitespaceBeforeProperty;
function requireNoWhitespaceBeforeProperty() {
  if (hasRequiredNoWhitespaceBeforeProperty) return noWhitespaceBeforeProperty;
  hasRequiredNoWhitespaceBeforeProperty = 1;
  const astUtils2 = requireAstUtils();
  noWhitespaceBeforeProperty = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "no-whitespace-before-property",
              url: "https://eslint.style/rules/no-whitespace-before-property"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Disallow whitespace before properties",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/no-whitespace-before-property"
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function reportError(node2, leftToken, rightToken) {
        context.report({
          node: node2,
          messageId: "unexpectedWhitespace",
          data: {
            propName: sourceCode2.getText(node2.property)
          },
          fix(fixer) {
            let replacementText = "";
            if (!node2.computed && !node2.optional && astUtils2.isDecimalInteger(node2.object)) {
              return null;
            }
            if (sourceCode2.commentsExistBetween(leftToken, rightToken)) {
              return null;
            }
            if (node2.optional) {
              replacementText = "?.";
            } else if (!node2.computed) {
              replacementText = ".";
            }
            return fixer.replaceTextRange(
              [leftToken.range[1], rightToken.range[0]],
              replacementText
            );
          }
        });
      }
      return {
        MemberExpression(node2) {
          let rightToken;
          let leftToken;
          if (!astUtils2.isTokenOnSameLine(node2.object, node2.property)) {
            return;
          }
          if (node2.computed) {
            rightToken = sourceCode2.getTokenBefore(
              node2.property,
              astUtils2.isOpeningBracketToken
            );
            leftToken = sourceCode2.getTokenBefore(
              rightToken,
              node2.optional ? 1 : 0
            );
          } else {
            rightToken = sourceCode2.getFirstToken(node2.property);
            leftToken = sourceCode2.getTokenBefore(rightToken, 1);
          }
          if (sourceCode2.isSpaceBetweenTokens(leftToken, rightToken)) {
            reportError(node2, leftToken, rightToken);
          }
        }
      };
    }
  };
  return noWhitespaceBeforeProperty;
}
var noWith;
var hasRequiredNoWith;
function requireNoWith() {
  if (hasRequiredNoWith) return noWith;
  hasRequiredNoWith = 1;
  noWith = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `with` statements",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/no-with"
      },
      schema: [],
      messages: {
        unexpectedWith: "Unexpected use of 'with' statement."
      }
    },
    create(context) {
      return {
        WithStatement(node2) {
          context.report({ node: node2, messageId: "unexpectedWith" });
        }
      };
    }
  };
  return noWith;
}
var nonblockStatementBodyPosition;
var hasRequiredNonblockStatementBodyPosition;
function requireNonblockStatementBodyPosition() {
  if (hasRequiredNonblockStatementBodyPosition) return nonblockStatementBodyPosition;
  hasRequiredNonblockStatementBodyPosition = 1;
  const POSITION_SCHEMA = { enum: ["beside", "below", "any"] };
  nonblockStatementBodyPosition = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "nonblock-statement-body-position",
              url: "https://eslint.style/rules/nonblock-statement-body-position"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce the location of single-line statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/nonblock-statement-body-position"
      },
      fixable: "whitespace",
      schema: [
        POSITION_SCHEMA,
        {
          properties: {
            overrides: {
              properties: {
                if: POSITION_SCHEMA,
                else: POSITION_SCHEMA,
                while: POSITION_SCHEMA,
                do: POSITION_SCHEMA,
                for: POSITION_SCHEMA
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectNoLinebreak: "Expected no linebreak before this statement.",
        expectLinebreak: "Expected a linebreak before this statement."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function getOption(keywordName) {
        return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || "beside";
      }
      function validateStatement(node2, keywordName) {
        const option = getOption(keywordName);
        if (node2.type === "BlockStatement" || option === "any") {
          return;
        }
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        if (tokenBefore.loc.end.line === node2.loc.start.line && option === "below") {
          context.report({
            node: node2,
            messageId: "expectLinebreak",
            fix: (fixer) => fixer.insertTextBefore(node2, "\n")
          });
        } else if (tokenBefore.loc.end.line !== node2.loc.start.line && option === "beside") {
          context.report({
            node: node2,
            messageId: "expectNoLinebreak",
            fix(fixer) {
              if (sourceCode2.getText().slice(tokenBefore.range[1], node2.range[0]).trim()) {
                return null;
              }
              return fixer.replaceTextRange(
                [tokenBefore.range[1], node2.range[0]],
                " "
              );
            }
          });
        }
      }
      return {
        IfStatement(node2) {
          validateStatement(node2.consequent, "if");
          if (node2.alternate && node2.alternate.type !== "IfStatement") {
            validateStatement(node2.alternate, "else");
          }
        },
        WhileStatement: (node2) => validateStatement(node2.body, "while"),
        DoWhileStatement: (node2) => validateStatement(node2.body, "do"),
        ForStatement: (node2) => validateStatement(node2.body, "for"),
        ForInStatement: (node2) => validateStatement(node2.body, "for"),
        ForOfStatement: (node2) => validateStatement(node2.body, "for")
      };
    }
  };
  return nonblockStatementBodyPosition;
}
var objectCurlyNewline;
var hasRequiredObjectCurlyNewline;
function requireObjectCurlyNewline() {
  if (hasRequiredObjectCurlyNewline) return objectCurlyNewline;
  hasRequiredObjectCurlyNewline = 1;
  const astUtils2 = requireAstUtils();
  const OPTION_VALUE = {
    oneOf: [
      {
        enum: ["always", "never"]
      },
      {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minProperties: {
            type: "integer",
            minimum: 0
          },
          consistent: {
            type: "boolean"
          }
        },
        additionalProperties: false,
        minProperties: 1
      }
    ]
  };
  function normalizeOptionValue(value) {
    let multiline = false;
    let minProperties = Number.POSITIVE_INFINITY;
    let consistent = false;
    if (value) {
      if (value === "always") {
        minProperties = 0;
      } else if (value === "never") {
        minProperties = Number.POSITIVE_INFINITY;
      } else {
        multiline = Boolean(value.multiline);
        minProperties = value.minProperties || Number.POSITIVE_INFINITY;
        consistent = Boolean(value.consistent);
      }
    } else {
      consistent = true;
    }
    return { multiline, minProperties, consistent };
  }
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }
  function isNodeSpecificOption(option) {
    return isObject(option) || typeof option === "string";
  }
  function normalizeOptions(options) {
    if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {
      return {
        ObjectExpression: normalizeOptionValue(options.ObjectExpression),
        ObjectPattern: normalizeOptionValue(options.ObjectPattern),
        ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
        ExportNamedDeclaration: normalizeOptionValue(
          options.ExportDeclaration
        )
      };
    }
    const value = normalizeOptionValue(options);
    return {
      ObjectExpression: value,
      ObjectPattern: value,
      ImportDeclaration: value,
      ExportNamedDeclaration: value
    };
  }
  function areLineBreaksRequired(node2, options, first, last) {
    let objectProperties;
    if (node2.type === "ObjectExpression" || node2.type === "ObjectPattern") {
      objectProperties = node2.properties;
    } else {
      objectProperties = node2.specifiers.filter(
        (s2) => s2.type === "ImportSpecifier" || s2.type === "ExportSpecifier"
      );
    }
    return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;
  }
  objectCurlyNewline = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "object-curly-newline",
              url: "https://eslint.style/rules/object-curly-newline"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent line breaks after opening and before closing braces",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/object-curly-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            OPTION_VALUE,
            {
              type: "object",
              properties: {
                ObjectExpression: OPTION_VALUE,
                ObjectPattern: OPTION_VALUE,
                ImportDeclaration: OPTION_VALUE,
                ExportDeclaration: OPTION_VALUE
              },
              additionalProperties: false,
              minProperties: 1
            }
          ]
        }
      ],
      messages: {
        unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
        unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
        expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
        expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const normalizedOptions = normalizeOptions(context.options[0]);
      function check2(node2) {
        const options = normalizedOptions[node2.type];
        if (node2.type === "ImportDeclaration" && !node2.specifiers.some(
          (specifier) => specifier.type === "ImportSpecifier"
        ) || node2.type === "ExportNamedDeclaration" && !node2.specifiers.some(
          (specifier) => specifier.type === "ExportSpecifier"
        )) {
          return;
        }
        const openBrace = sourceCode2.getFirstToken(
          node2,
          (token) => token.value === "{"
        );
        let closeBrace;
        if (node2.typeAnnotation) {
          closeBrace = sourceCode2.getTokenBefore(node2.typeAnnotation);
        } else {
          closeBrace = sourceCode2.getLastToken(
            node2,
            (token) => token.value === "}"
          );
        }
        let first = sourceCode2.getTokenAfter(openBrace, {
          includeComments: true
        });
        let last = sourceCode2.getTokenBefore(closeBrace, {
          includeComments: true
        });
        const needsLineBreaks = areLineBreaksRequired(
          node2,
          options,
          first,
          last
        );
        const hasCommentsFirstToken = astUtils2.isCommentToken(first);
        const hasCommentsLastToken = astUtils2.isCommentToken(last);
        first = sourceCode2.getTokenAfter(openBrace);
        last = sourceCode2.getTokenBefore(closeBrace);
        if (needsLineBreaks) {
          if (astUtils2.isTokenOnSameLine(openBrace, first)) {
            context.report({
              messageId: "expectedLinebreakAfterOpeningBrace",
              node: node2,
              loc: openBrace.loc,
              fix(fixer) {
                if (hasCommentsFirstToken) {
                  return null;
                }
                return fixer.insertTextAfter(openBrace, "\n");
              }
            });
          }
          if (astUtils2.isTokenOnSameLine(last, closeBrace)) {
            context.report({
              messageId: "expectedLinebreakBeforeClosingBrace",
              node: node2,
              loc: closeBrace.loc,
              fix(fixer) {
                if (hasCommentsLastToken) {
                  return null;
                }
                return fixer.insertTextBefore(closeBrace, "\n");
              }
            });
          }
        } else {
          const consistent = options.consistent;
          const hasLineBreakBetweenOpenBraceAndFirst = !astUtils2.isTokenOnSameLine(openBrace, first);
          const hasLineBreakBetweenCloseBraceAndLast = !astUtils2.isTokenOnSameLine(last, closeBrace);
          if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
            context.report({
              messageId: "unexpectedLinebreakAfterOpeningBrace",
              node: node2,
              loc: openBrace.loc,
              fix(fixer) {
                if (hasCommentsFirstToken) {
                  return null;
                }
                return fixer.removeRange([
                  openBrace.range[1],
                  first.range[0]
                ]);
              }
            });
          }
          if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
            context.report({
              messageId: "unexpectedLinebreakBeforeClosingBrace",
              node: node2,
              loc: closeBrace.loc,
              fix(fixer) {
                if (hasCommentsLastToken) {
                  return null;
                }
                return fixer.removeRange([
                  last.range[1],
                  closeBrace.range[0]
                ]);
              }
            });
          }
        }
      }
      return {
        ObjectExpression: check2,
        ObjectPattern: check2,
        ImportDeclaration: check2,
        ExportNamedDeclaration: check2
      };
    }
  };
  return objectCurlyNewline;
}
var objectCurlySpacing;
var hasRequiredObjectCurlySpacing;
function requireObjectCurlySpacing() {
  if (hasRequiredObjectCurlySpacing) return objectCurlySpacing;
  hasRequiredObjectCurlySpacing = 1;
  const astUtils2 = requireAstUtils();
  objectCurlySpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "object-curly-spacing",
              url: "https://eslint.style/rules/object-curly-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside braces",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/object-curly-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            arraysInObjects: {
              type: "boolean"
            },
            objectsInObjects: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        requireSpaceBefore: "A space is required before '{{token}}'.",
        requireSpaceAfter: "A space is required after '{{token}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
        unexpectedSpaceAfter: "There should be no space after '{{token}}'."
      }
    },
    create(context) {
      const spaced = context.options[0] === "always", sourceCode2 = context.sourceCode;
      function isOptionSet(option) {
        return context.options[1] ? context.options[1][option] === !spaced : false;
      }
      const options = {
        spaced,
        arraysInObjectsException: isOptionSet("arraysInObjects"),
        objectsInObjectsException: isOptionSet("objectsInObjects")
      };
      function reportNoBeginningSpace(node2, token) {
        const nextToken = context.sourceCode.getTokenAfter(token, {
          includeComments: true
        });
        context.report({
          node: node2,
          loc: { start: token.loc.end, end: nextToken.loc.start },
          messageId: "unexpectedSpaceAfter",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.removeRange([
              token.range[1],
              nextToken.range[0]
            ]);
          }
        });
      }
      function reportNoEndingSpace(node2, token) {
        const previousToken = context.sourceCode.getTokenBefore(token, {
          includeComments: true
        });
        context.report({
          node: node2,
          loc: { start: previousToken.loc.end, end: token.loc.start },
          messageId: "unexpectedSpaceBefore",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.removeRange([
              previousToken.range[1],
              token.range[0]
            ]);
          }
        });
      }
      function reportRequiredBeginningSpace(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "requireSpaceAfter",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
      function reportRequiredEndingSpace(node2, token) {
        context.report({
          node: node2,
          loc: token.loc,
          messageId: "requireSpaceBefore",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
      function validateBraceSpacing(node2, first, second, penultimate, last) {
        if (astUtils2.isTokenOnSameLine(first, second)) {
          const firstSpaced = sourceCode2.isSpaceBetweenTokens(
            first,
            second
          );
          if (options.spaced && !firstSpaced) {
            reportRequiredBeginningSpace(node2, first);
          }
          if (!options.spaced && firstSpaced && second.type !== "Line") {
            reportNoBeginningSpace(node2, first);
          }
        }
        if (astUtils2.isTokenOnSameLine(penultimate, last)) {
          const shouldCheckPenultimate = options.arraysInObjectsException && astUtils2.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils2.isClosingBraceToken(penultimate);
          const penultimateType = shouldCheckPenultimate && sourceCode2.getNodeByRangeIndex(penultimate.range[0]).type;
          const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;
          const lastSpaced = sourceCode2.isSpaceBetweenTokens(
            penultimate,
            last
          );
          if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
            reportRequiredEndingSpace(node2, last);
          }
          if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
            reportNoEndingSpace(node2, last);
          }
        }
      }
      function getClosingBraceOfObject(node2) {
        const lastProperty = node2.properties.at(-1);
        return sourceCode2.getTokenAfter(
          lastProperty,
          astUtils2.isClosingBraceToken
        );
      }
      function checkForObject(node2) {
        if (node2.properties.length === 0) {
          return;
        }
        const first = sourceCode2.getFirstToken(node2), last = getClosingBraceOfObject(node2), second = sourceCode2.getTokenAfter(first, {
          includeComments: true
        }), penultimate = sourceCode2.getTokenBefore(last, {
          includeComments: true
        });
        validateBraceSpacing(node2, first, second, penultimate, last);
      }
      function checkForImport(node2) {
        if (node2.specifiers.length === 0) {
          return;
        }
        let firstSpecifier = node2.specifiers[0];
        const lastSpecifier = node2.specifiers.at(-1);
        if (lastSpecifier.type !== "ImportSpecifier") {
          return;
        }
        if (firstSpecifier.type !== "ImportSpecifier") {
          firstSpecifier = node2.specifiers[1];
        }
        const first = sourceCode2.getTokenBefore(firstSpecifier), last = sourceCode2.getTokenAfter(
          lastSpecifier,
          astUtils2.isNotCommaToken
        ), second = sourceCode2.getTokenAfter(first, {
          includeComments: true
        }), penultimate = sourceCode2.getTokenBefore(last, {
          includeComments: true
        });
        validateBraceSpacing(node2, first, second, penultimate, last);
      }
      function checkForExport(node2) {
        if (node2.specifiers.length === 0) {
          return;
        }
        const firstSpecifier = node2.specifiers[0], lastSpecifier = node2.specifiers.at(-1), first = sourceCode2.getTokenBefore(firstSpecifier), last = sourceCode2.getTokenAfter(
          lastSpecifier,
          astUtils2.isNotCommaToken
        ), second = sourceCode2.getTokenAfter(first, {
          includeComments: true
        }), penultimate = sourceCode2.getTokenBefore(last, {
          includeComments: true
        });
        validateBraceSpacing(node2, first, second, penultimate, last);
      }
      return {
        // var {x} = y;
        ObjectPattern: checkForObject,
        // var y = {x: 'y'}
        ObjectExpression: checkForObject,
        // import {y} from 'x';
        ImportDeclaration: checkForImport,
        // export {name} from 'yo';
        ExportNamedDeclaration: checkForExport
      };
    }
  };
  return objectCurlySpacing;
}
var objectPropertyNewline;
var hasRequiredObjectPropertyNewline;
function requireObjectPropertyNewline() {
  if (hasRequiredObjectPropertyNewline) return objectPropertyNewline;
  hasRequiredObjectPropertyNewline = 1;
  objectPropertyNewline = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "object-property-newline",
              url: "https://eslint.style/rules/object-property-newline"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce placing object properties on separate lines",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/object-property-newline"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAllPropertiesOnSameLine: {
              type: "boolean",
              default: false
            },
            allowMultiplePropertiesPerLine: {
              // Deprecated
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "whitespace",
      messages: {
        propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
        propertiesOnNewline: "Object properties must go on a new line."
      }
    },
    create(context) {
      const allowSameLine = context.options[0] && (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine);
      const messageId = allowSameLine ? "propertiesOnNewlineAll" : "propertiesOnNewline";
      const sourceCode2 = context.sourceCode;
      return {
        ObjectExpression(node2) {
          if (allowSameLine) {
            if (node2.properties.length > 1) {
              const firstTokenOfFirstProperty = sourceCode2.getFirstToken(node2.properties[0]);
              const lastTokenOfLastProperty = sourceCode2.getLastToken(
                node2.properties.at(-1)
              );
              if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
                return;
              }
            }
          }
          for (let i2 = 1; i2 < node2.properties.length; i2++) {
            const lastTokenOfPreviousProperty = sourceCode2.getLastToken(
              node2.properties[i2 - 1]
            );
            const firstTokenOfCurrentProperty = sourceCode2.getFirstToken(node2.properties[i2]);
            if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
              context.report({
                node: node2,
                loc: firstTokenOfCurrentProperty.loc,
                messageId,
                fix(fixer) {
                  const comma2 = sourceCode2.getTokenBefore(
                    firstTokenOfCurrentProperty
                  );
                  const rangeAfterComma = [
                    comma2.range[1],
                    firstTokenOfCurrentProperty.range[0]
                  ];
                  if (sourceCode2.text.slice(
                    rangeAfterComma[0],
                    rangeAfterComma[1]
                  ).trim()) {
                    return null;
                  }
                  return fixer.replaceTextRange(
                    rangeAfterComma,
                    "\n"
                  );
                }
              });
            }
          }
        }
      };
    }
  };
  return objectPropertyNewline;
}
var objectShorthand;
var hasRequiredObjectShorthand;
function requireObjectShorthand() {
  if (hasRequiredObjectShorthand) return objectShorthand;
  hasRequiredObjectShorthand = 1;
  const OPTIONS = {
    always: "always",
    never: "never",
    methods: "methods",
    properties: "properties",
    consistent: "consistent",
    consistentAsNeeded: "consistent-as-needed"
  };
  const astUtils2 = requireAstUtils();
  const CTOR_PREFIX_REGEX = /[^_$0-9]/u;
  const JSDOC_COMMENT_REGEX = /^\s*\*/u;
  function isConstructor(name2) {
    const match = CTOR_PREFIX_REGEX.exec(name2);
    if (!match) {
      return false;
    }
    const firstChar = name2.charAt(match.index);
    return firstChar === firstChar.toUpperCase();
  }
  function canHaveShorthand(property) {
    return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadElement" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
  }
  function isStringLiteral(node2) {
    return node2.type === "Literal" && typeof node2.value === "string";
  }
  function isShorthand(property) {
    return property.shorthand || property.method;
  }
  function isRedundant(property) {
    const value = property.value;
    if (value.type === "FunctionExpression") {
      return !value.id;
    }
    if (value.type === "Identifier") {
      return astUtils2.getStaticPropertyName(property) === value.name;
    }
    return false;
  }
  objectShorthand = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require or disallow method and property shorthand syntax for object literals",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/object-shorthand"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: [
                  "always",
                  "methods",
                  "properties",
                  "never",
                  "consistent",
                  "consistent-as-needed"
                ]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods", "properties"]
              },
              {
                type: "object",
                properties: {
                  avoidQuotes: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods"]
              },
              {
                type: "object",
                properties: {
                  ignoreConstructors: {
                    type: "boolean"
                  },
                  methodsIgnorePattern: {
                    type: "string"
                  },
                  avoidQuotes: {
                    type: "boolean"
                  },
                  avoidExplicitReturnArrows: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        expectedAllPropertiesShorthanded: "Expected shorthand for all properties.",
        expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.",
        expectedPropertyShorthand: "Expected property shorthand.",
        expectedPropertyLongform: "Expected longform property syntax.",
        expectedMethodShorthand: "Expected method shorthand.",
        expectedMethodLongform: "Expected longform method syntax.",
        unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties."
      }
    },
    create(context) {
      const APPLY = context.options[0] || OPTIONS.always;
      const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
      const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
      const APPLY_NEVER = APPLY === OPTIONS.never;
      const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
      const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
      const PARAMS = context.options[1] || {};
      const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
      const METHODS_IGNORE_PATTERN = PARAMS.methodsIgnorePattern ? new RegExp(PARAMS.methodsIgnorePattern, "u") : null;
      const AVOID_QUOTES = PARAMS.avoidQuotes;
      const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
      const sourceCode2 = context.sourceCode;
      function checkConsistency(node2, checkRedundancy) {
        const properties2 = node2.properties.filter(canHaveShorthand);
        if (properties2.length > 0) {
          const shorthandProperties = properties2.filter(isShorthand);
          if (shorthandProperties.length !== properties2.length) {
            if (shorthandProperties.length > 0) {
              context.report({ node: node2, messageId: "unexpectedMix" });
            } else if (checkRedundancy) {
              const canAlwaysUseShorthand = properties2.every(isRedundant);
              if (canAlwaysUseShorthand) {
                context.report({
                  node: node2,
                  messageId: "expectedAllPropertiesShorthanded"
                });
              }
            }
          }
        }
      }
      function makeFunctionShorthand(fixer, node2) {
        const firstKeyToken = node2.computed ? sourceCode2.getFirstToken(node2, astUtils2.isOpeningBracketToken) : sourceCode2.getFirstToken(node2.key);
        const lastKeyToken = node2.computed ? sourceCode2.getFirstTokenBetween(
          node2.key,
          node2.value,
          astUtils2.isClosingBracketToken
        ) : sourceCode2.getLastToken(node2.key);
        const keyText = sourceCode2.text.slice(
          firstKeyToken.range[0],
          lastKeyToken.range[1]
        );
        let keyPrefix = "";
        if (sourceCode2.commentsExistBetween(lastKeyToken, node2.value)) {
          return null;
        }
        if (node2.value.async) {
          keyPrefix += "async ";
        }
        if (node2.value.generator) {
          keyPrefix += "*";
        }
        const fixRange = [firstKeyToken.range[0], node2.range[1]];
        const methodPrefix = keyPrefix + keyText;
        if (node2.value.type === "FunctionExpression") {
          const functionToken = sourceCode2.getTokens(node2.value).find(
            (token) => token.type === "Keyword" && token.value === "function"
          );
          const tokenBeforeParams = node2.value.generator ? sourceCode2.getTokenAfter(functionToken) : functionToken;
          return fixer.replaceTextRange(
            fixRange,
            methodPrefix + sourceCode2.text.slice(
              tokenBeforeParams.range[1],
              node2.value.range[1]
            )
          );
        }
        const arrowToken = sourceCode2.getTokenBefore(
          node2.value.body,
          astUtils2.isArrowToken
        );
        const fnBody = sourceCode2.text.slice(
          arrowToken.range[1],
          node2.value.range[1]
        );
        const firstValueToken = sourceCode2.getFirstToken(node2.value, {
          skip: node2.value.async ? 1 : 0
        });
        const sliceStart = firstValueToken.range[0];
        const sliceEnd = sourceCode2.getTokenBefore(arrowToken).range[1];
        const shouldAddParens = node2.value.params.length === 1 && node2.value.params[0].range[0] === sliceStart;
        const oldParamText = sourceCode2.text.slice(sliceStart, sliceEnd);
        const newParamText = shouldAddParens ? `(${oldParamText})` : oldParamText;
        return fixer.replaceTextRange(
          fixRange,
          methodPrefix + newParamText + fnBody
        );
      }
      function makeFunctionLongform(fixer, node2) {
        const firstKeyToken = node2.computed ? sourceCode2.getTokens(node2).find((token) => token.value === "[") : sourceCode2.getFirstToken(node2.key);
        const lastKeyToken = node2.computed ? sourceCode2.getTokensBetween(node2.key, node2.value).find((token) => token.value === "]") : sourceCode2.getLastToken(node2.key);
        const keyText = sourceCode2.text.slice(
          firstKeyToken.range[0],
          lastKeyToken.range[1]
        );
        let functionHeader = "function";
        if (node2.value.async) {
          functionHeader = `async ${functionHeader}`;
        }
        if (node2.value.generator) {
          functionHeader = `${functionHeader}*`;
        }
        return fixer.replaceTextRange(
          [node2.range[0], lastKeyToken.range[1]],
          `${keyText}: ${functionHeader}`
        );
      }
      const lexicalScopeStack = [];
      const arrowsWithLexicalIdentifiers = /* @__PURE__ */ new WeakSet();
      const argumentsIdentifiers = /* @__PURE__ */ new WeakSet();
      function enterFunction(node2) {
        lexicalScopeStack.unshift(/* @__PURE__ */ new Set());
        sourceCode2.getScope(node2).variables.filter((variable) => variable.name === "arguments").forEach((variable) => {
          variable.references.map((ref2) => ref2.identifier).forEach(
            (identifier) => argumentsIdentifiers.add(identifier)
          );
        });
      }
      function exitFunction() {
        lexicalScopeStack.shift();
      }
      function reportLexicalIdentifier() {
        lexicalScopeStack[0].forEach(
          (arrowFunction) => arrowsWithLexicalIdentifiers.add(arrowFunction)
        );
      }
      return {
        Program: enterFunction,
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        "Program:exit": exitFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression:exit": exitFunction,
        ArrowFunctionExpression(node2) {
          lexicalScopeStack[0].add(node2);
        },
        "ArrowFunctionExpression:exit"(node2) {
          lexicalScopeStack[0].delete(node2);
        },
        ThisExpression: reportLexicalIdentifier,
        Super: reportLexicalIdentifier,
        MetaProperty(node2) {
          if (node2.meta.name === "new" && node2.property.name === "target") {
            reportLexicalIdentifier();
          }
        },
        Identifier(node2) {
          if (argumentsIdentifiers.has(node2)) {
            reportLexicalIdentifier();
          }
        },
        ObjectExpression(node2) {
          if (APPLY_CONSISTENT) {
            checkConsistency(node2, false);
          } else if (APPLY_CONSISTENT_AS_NEEDED) {
            checkConsistency(node2, true);
          }
        },
        "Property:exit"(node2) {
          const isConciseProperty = node2.method || node2.shorthand;
          if (node2.parent.type === "ObjectPattern") {
            return;
          }
          if (node2.kind === "get" || node2.kind === "set") {
            return;
          }
          if (node2.computed && node2.value.type !== "FunctionExpression" && node2.value.type !== "ArrowFunctionExpression") {
            return;
          }
          if (isConciseProperty) {
            if (node2.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node2.key))) {
              const messageId = APPLY_NEVER ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
              context.report({
                node: node2,
                messageId,
                fix: (fixer) => makeFunctionLongform(fixer, node2)
              });
            } else if (APPLY_NEVER) {
              context.report({
                node: node2,
                messageId: "expectedPropertyLongform",
                fix: (fixer) => fixer.insertTextAfter(
                  node2.key,
                  `: ${node2.key.name}`
                )
              });
            }
          } else if (APPLY_TO_METHODS && !node2.value.id && (node2.value.type === "FunctionExpression" || node2.value.type === "ArrowFunctionExpression")) {
            if (IGNORE_CONSTRUCTORS && node2.key.type === "Identifier" && isConstructor(node2.key.name)) {
              return;
            }
            if (METHODS_IGNORE_PATTERN) {
              const propertyName2 = astUtils2.getStaticPropertyName(node2);
              if (propertyName2 !== null && METHODS_IGNORE_PATTERN.test(propertyName2)) {
                return;
              }
            }
            if (AVOID_QUOTES && isStringLiteral(node2.key)) {
              return;
            }
            if (node2.value.type === "FunctionExpression" || node2.value.type === "ArrowFunctionExpression" && node2.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node2.value)) {
              context.report({
                node: node2,
                messageId: "expectedMethodShorthand",
                fix: (fixer) => makeFunctionShorthand(fixer, node2)
              });
            }
          } else if (node2.value.type === "Identifier" && node2.key.name === node2.value.name && APPLY_TO_PROPS) {
            const comments = sourceCode2.getCommentsInside(node2);
            if (comments.some(
              (comment2) => comment2.type === "Block" && JSDOC_COMMENT_REGEX.test(comment2.value) && comment2.value.includes("@type")
            )) {
              return;
            }
            context.report({
              node: node2,
              messageId: "expectedPropertyShorthand",
              fix(fixer) {
                if (sourceCode2.getCommentsInside(node2).length > 0) {
                  return null;
                }
                return fixer.replaceText(node2, node2.value.name);
              }
            });
          } else if (node2.value.type === "Identifier" && node2.key.type === "Literal" && node2.key.value === node2.value.name && APPLY_TO_PROPS) {
            if (AVOID_QUOTES) {
              return;
            }
            const comments = sourceCode2.getCommentsInside(node2);
            if (comments.some(
              (comment2) => comment2.type === "Block" && comment2.value.startsWith("*") && comment2.value.includes("@type")
            )) {
              return;
            }
            context.report({
              node: node2,
              messageId: "expectedPropertyShorthand",
              fix(fixer) {
                if (sourceCode2.getCommentsInside(node2).length > 0) {
                  return null;
                }
                return fixer.replaceText(node2, node2.value.name);
              }
            });
          }
        }
      };
    }
  };
  return objectShorthand;
}
var oneVar;
var hasRequiredOneVar;
function requireOneVar() {
  if (hasRequiredOneVar) return oneVar;
  hasRequiredOneVar = 1;
  const astUtils2 = requireAstUtils();
  function isInStatementList(node2) {
    return astUtils2.STATEMENT_LIST_PARENTS.has(node2.parent.type);
  }
  oneVar = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce variables to be declared either together or separately in functions",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/one-var"
      },
      fixable: "code",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consecutive"]
            },
            {
              type: "object",
              properties: {
                separateRequires: {
                  type: "boolean"
                },
                var: {
                  enum: ["always", "never", "consecutive"]
                },
                let: {
                  enum: ["always", "never", "consecutive"]
                },
                const: {
                  enum: ["always", "never", "consecutive"]
                },
                using: {
                  enum: ["always", "never", "consecutive"]
                },
                awaitUsing: {
                  enum: ["always", "never", "consecutive"]
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                initialized: {
                  enum: ["always", "never", "consecutive"]
                },
                uninitialized: {
                  enum: ["always", "never", "consecutive"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
        combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.",
        splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.",
        splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.",
        splitRequires: "Split requires to be separated into a single block.",
        combine: "Combine this with the previous '{{type}}' statement.",
        split: "Split '{{type}}' declarations into multiple statements."
      }
    },
    create(context) {
      const MODE_ALWAYS = "always";
      const MODE_NEVER = "never";
      const MODE_CONSECUTIVE = "consecutive";
      const mode = context.options[0] || MODE_ALWAYS;
      const options = {};
      if (typeof mode === "string") {
        options.var = { uninitialized: mode, initialized: mode };
        options.let = { uninitialized: mode, initialized: mode };
        options.const = { uninitialized: mode, initialized: mode };
        options.using = { uninitialized: mode, initialized: mode };
        options.awaitUsing = { uninitialized: mode, initialized: mode };
      } else if (typeof mode === "object") {
        options.separateRequires = !!mode.separateRequires;
        options.var = { uninitialized: mode.var, initialized: mode.var };
        options.let = { uninitialized: mode.let, initialized: mode.let };
        options.const = {
          uninitialized: mode.const,
          initialized: mode.const
        };
        options.using = {
          uninitialized: mode.using,
          initialized: mode.using
        };
        options.awaitUsing = {
          uninitialized: mode.awaitUsing,
          initialized: mode.awaitUsing
        };
        if (Object.hasOwn(mode, "uninitialized")) {
          options.var.uninitialized = mode.uninitialized;
          options.let.uninitialized = mode.uninitialized;
          options.const.uninitialized = mode.uninitialized;
          options.using.uninitialized = mode.uninitialized;
          options.awaitUsing.uninitialized = mode.uninitialized;
        }
        if (Object.hasOwn(mode, "initialized")) {
          options.var.initialized = mode.initialized;
          options.let.initialized = mode.initialized;
          options.const.initialized = mode.initialized;
          options.using.initialized = mode.initialized;
          options.awaitUsing.initialized = mode.initialized;
        }
      }
      const sourceCode2 = context.sourceCode;
      const functionStack = [];
      const blockStack = [];
      function startBlock() {
        blockStack.push({
          let: { initialized: false, uninitialized: false },
          const: { initialized: false, uninitialized: false },
          using: { initialized: false, uninitialized: false },
          awaitUsing: { initialized: false, uninitialized: false }
        });
      }
      function startFunction() {
        functionStack.push({ initialized: false, uninitialized: false });
        startBlock();
      }
      function endBlock() {
        blockStack.pop();
      }
      function endFunction() {
        functionStack.pop();
        endBlock();
      }
      function isRequire(decl) {
        return decl.init && decl.init.type === "CallExpression" && decl.init.callee.name === "require";
      }
      function recordTypes(statementType, declarations, currentScope) {
        for (let i2 = 0; i2 < declarations.length; i2++) {
          if (declarations[i2].init === null) {
            if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
              currentScope.uninitialized = true;
            }
          } else {
            if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
              if (options.separateRequires && isRequire(declarations[i2])) {
                currentScope.required = true;
              } else {
                currentScope.initialized = true;
              }
            }
          }
        }
      }
      function getCurrentScope(statementType) {
        let currentScope;
        if (statementType === "var") {
          currentScope = functionStack.at(-1);
        } else if (statementType === "let") {
          currentScope = blockStack.at(-1).let;
        } else if (statementType === "const") {
          currentScope = blockStack.at(-1).const;
        } else if (statementType === "using") {
          currentScope = blockStack.at(-1).using;
        } else if (statementType === "awaitUsing") {
          currentScope = blockStack.at(-1).awaitUsing;
        }
        return currentScope;
      }
      function countDeclarations(declarations) {
        const counts = { uninitialized: 0, initialized: 0 };
        for (let i2 = 0; i2 < declarations.length; i2++) {
          if (declarations[i2].init === null) {
            counts.uninitialized++;
          } else {
            counts.initialized++;
          }
        }
        return counts;
      }
      function hasOnlyOneStatement(statementType, declarations) {
        const declarationCounts = countDeclarations(declarations);
        const currentOptions = options[statementType] || {};
        const currentScope = getCurrentScope(statementType);
        const hasRequires = declarations.some(isRequire);
        if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
          if (currentScope.uninitialized || currentScope.initialized) {
            if (!hasRequires) {
              return false;
            }
          }
        }
        if (declarationCounts.uninitialized > 0) {
          if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
            return false;
          }
        }
        if (declarationCounts.initialized > 0) {
          if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
            if (!hasRequires) {
              return false;
            }
          }
        }
        if (currentScope.required && hasRequires) {
          return false;
        }
        recordTypes(statementType, declarations, currentScope);
        return true;
      }
      function joinDeclarations(declarations) {
        const declaration = declarations[0];
        const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];
        const currentIndex = body.findIndex(
          (node2) => node2.range[0] === declaration.parent.range[0]
        );
        const previousNode = body[currentIndex - 1];
        return function* joinDeclarationsFixer(fixer) {
          const type2 = sourceCode2.getFirstToken(declaration.parent);
          const beforeType = sourceCode2.getTokenBefore(type2);
          if (previousNode && previousNode.kind === declaration.parent.kind) {
            if (beforeType.value === ";") {
              yield fixer.replaceText(beforeType, ",");
            } else {
              yield fixer.insertTextAfter(beforeType, ",");
            }
            if (declaration.parent.kind === "await using") {
              const usingToken = sourceCode2.getTokenAfter(type2);
              yield fixer.remove(usingToken);
            }
            yield fixer.replaceText(type2, "");
          }
        };
      }
      function splitDeclarations(declaration) {
        const { parent } = declaration;
        if (!isInStatementList(
          parent.type === "ExportNamedDeclaration" ? parent : declaration
        )) {
          return null;
        }
        return (fixer) => declaration.declarations.map((declarator) => {
          const tokenAfterDeclarator = sourceCode2.getTokenAfter(declarator);
          if (tokenAfterDeclarator === null) {
            return null;
          }
          const afterComma = sourceCode2.getTokenAfter(
            tokenAfterDeclarator,
            { includeComments: true }
          );
          if (tokenAfterDeclarator.value !== ",") {
            return null;
          }
          const exportPlacement = declaration.parent.type === "ExportNamedDeclaration" ? "export " : "";
          if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {
            return fixer.replaceText(
              tokenAfterDeclarator,
              `; ${exportPlacement}${declaration.kind} `
            );
          }
          if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === "Line" || afterComma.type === "Block") {
            let lastComment = afterComma;
            while (lastComment.type === "Line" || lastComment.type === "Block") {
              lastComment = sourceCode2.getTokenAfter(
                lastComment,
                { includeComments: true }
              );
            }
            return fixer.replaceTextRange(
              [
                tokenAfterDeclarator.range[0],
                lastComment.range[0]
              ],
              `;${sourceCode2.text.slice(
                tokenAfterDeclarator.range[1],
                lastComment.range[0]
              )}${exportPlacement}${declaration.kind} `
            );
          }
          return fixer.replaceText(
            tokenAfterDeclarator,
            `; ${exportPlacement}${declaration.kind}`
          );
        }).filter((x2) => x2);
      }
      function checkVariableDeclaration(node2) {
        const parent = node2.parent;
        const type2 = node2.kind;
        const key = type2 === "await using" ? "awaitUsing" : type2;
        if (!options[key]) {
          return;
        }
        const declarations = node2.declarations;
        const declarationCounts = countDeclarations(declarations);
        const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);
        if (options[key].initialized === MODE_ALWAYS) {
          if (options.separateRequires && mixedRequires) {
            context.report({
              node: node2,
              messageId: "splitRequires"
            });
          }
        }
        const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node2) || 0;
        if (nodeIndex > 0) {
          const previousNode = parent.body[nodeIndex - 1];
          const isPreviousNodeDeclaration = previousNode.type === "VariableDeclaration";
          const declarationsWithPrevious = declarations.concat(
            previousNode.declarations || []
          );
          if (isPreviousNodeDeclaration && previousNode.kind === type2 && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {
            const previousDeclCounts = countDeclarations(
              previousNode.declarations
            );
            if (options[key].initialized === MODE_CONSECUTIVE && options[key].uninitialized === MODE_CONSECUTIVE) {
              context.report({
                node: node2,
                messageId: "combine",
                data: {
                  type: type2
                },
                fix: joinDeclarations(declarations)
              });
            } else if (options[key].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {
              context.report({
                node: node2,
                messageId: "combineInitialized",
                data: {
                  type: type2
                },
                fix: joinDeclarations(declarations)
              });
            } else if (options[key].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {
              context.report({
                node: node2,
                messageId: "combineUninitialized",
                data: {
                  type: type2
                },
                fix: joinDeclarations(declarations)
              });
            }
          }
        }
        if (!hasOnlyOneStatement(key, declarations)) {
          if (options[key].initialized === MODE_ALWAYS && options[key].uninitialized === MODE_ALWAYS) {
            context.report({
              node: node2,
              messageId: "combine",
              data: {
                type: type2
              },
              fix: joinDeclarations(declarations)
            });
          } else {
            if (options[key].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {
              context.report({
                node: node2,
                messageId: "combineInitialized",
                data: {
                  type: type2
                },
                fix: joinDeclarations(declarations)
              });
            }
            if (options[key].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {
              if (node2.parent.left === node2 && (node2.parent.type === "ForInStatement" || node2.parent.type === "ForOfStatement")) {
                return;
              }
              context.report({
                node: node2,
                messageId: "combineUninitialized",
                data: {
                  type: type2
                },
                fix: joinDeclarations(declarations)
              });
            }
          }
        }
        if (parent.type !== "ForStatement" || parent.init !== node2) {
          const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
          if (totalDeclarations > 1) {
            if (options[key].initialized === MODE_NEVER && options[key].uninitialized === MODE_NEVER) {
              context.report({
                node: node2,
                messageId: "split",
                data: {
                  type: type2
                },
                fix: splitDeclarations(node2)
              });
            } else if (options[key].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
              context.report({
                node: node2,
                messageId: "splitInitialized",
                data: {
                  type: type2
                },
                fix: splitDeclarations(node2)
              });
            } else if (options[key].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
              context.report({
                node: node2,
                messageId: "splitUninitialized",
                data: {
                  type: type2
                },
                fix: splitDeclarations(node2)
              });
            }
          }
        }
      }
      return {
        Program: startFunction,
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        StaticBlock: startFunction,
        // StaticBlock creates a new scope for `var` variables
        BlockStatement: startBlock,
        ForStatement: startBlock,
        ForInStatement: startBlock,
        ForOfStatement: startBlock,
        SwitchStatement: startBlock,
        VariableDeclaration: checkVariableDeclaration,
        "ForStatement:exit": endBlock,
        "ForOfStatement:exit": endBlock,
        "ForInStatement:exit": endBlock,
        "SwitchStatement:exit": endBlock,
        "BlockStatement:exit": endBlock,
        "Program:exit": endFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "StaticBlock:exit": endFunction
      };
    }
  };
  return oneVar;
}
var oneVarDeclarationPerLine;
var hasRequiredOneVarDeclarationPerLine;
function requireOneVarDeclarationPerLine() {
  if (hasRequiredOneVarDeclarationPerLine) return oneVarDeclarationPerLine;
  hasRequiredOneVarDeclarationPerLine = 1;
  oneVarDeclarationPerLine = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "one-var-declaration-per-line",
              url: "https://eslint.style/rules/one-var-declaration-per-line"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Require or disallow newlines around variable declarations",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/one-var-declaration-per-line"
      },
      schema: [
        {
          enum: ["always", "initializations"]
        }
      ],
      fixable: "whitespace",
      messages: {
        expectVarOnNewline: "Expected variable declaration to be on a new line."
      }
    },
    create(context) {
      const always = context.options[0] === "always";
      function isForTypeSpecifier(keyword2) {
        return keyword2 === "ForStatement" || keyword2 === "ForInStatement" || keyword2 === "ForOfStatement";
      }
      function checkForNewLine(node2) {
        if (isForTypeSpecifier(node2.parent.type)) {
          return;
        }
        const declarations = node2.declarations;
        let prev;
        declarations.forEach((current) => {
          if (prev && prev.loc.end.line === current.loc.start.line) {
            if (always || prev.init || current.init) {
              context.report({
                node: node2,
                messageId: "expectVarOnNewline",
                loc: current.loc,
                fix: (fixer) => fixer.insertTextBefore(current, "\n")
              });
            }
          }
          prev = current;
        });
      }
      return {
        VariableDeclaration: checkForNewLine
      };
    }
  };
  return oneVarDeclarationPerLine;
}
var operatorAssignment;
var hasRequiredOperatorAssignment;
function requireOperatorAssignment() {
  if (hasRequiredOperatorAssignment) return operatorAssignment;
  hasRequiredOperatorAssignment = 1;
  const astUtils2 = requireAstUtils();
  function isCommutativeOperatorWithShorthand(operator2) {
    return ["*", "&", "^", "|"].includes(operator2);
  }
  function isNonCommutativeOperatorWithShorthand(operator2) {
    return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].includes(operator2);
  }
  function canBeFixed(node2) {
    return node2.type === "Identifier" || node2.type === "MemberExpression" && (node2.object.type === "Identifier" || node2.object.type === "ThisExpression") && (!node2.computed || node2.property.type === "Literal");
  }
  operatorAssignment = {
    meta: {
      type: "suggestion",
      defaultOptions: ["always"],
      docs: {
        description: "Require or disallow assignment operator shorthand where possible",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/operator-assignment"
      },
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      fixable: "code",
      messages: {
        replaced: "Assignment (=) can be replaced with operator assignment ({{operator}}).",
        unexpected: "Unexpected operator assignment ({{operator}}) shorthand."
      }
    },
    create(context) {
      const never = context.options[0] === "never";
      const sourceCode2 = context.sourceCode;
      function getOperatorToken(node2) {
        return sourceCode2.getFirstTokenBetween(
          node2.left,
          node2.right,
          (token) => token.value === node2.operator
        );
      }
      function verify(node2) {
        if (node2.operator !== "=" || node2.right.type !== "BinaryExpression") {
          return;
        }
        const left = node2.left;
        const expr = node2.right;
        const operator2 = expr.operator;
        if (isCommutativeOperatorWithShorthand(operator2) || isNonCommutativeOperatorWithShorthand(operator2)) {
          const replacementOperator = `${operator2}=`;
          if (astUtils2.isSameReference(left, expr.left, true)) {
            context.report({
              node: node2,
              messageId: "replaced",
              data: { operator: replacementOperator },
              fix(fixer) {
                if (canBeFixed(left) && canBeFixed(expr.left)) {
                  const equalsToken = getOperatorToken(node2);
                  const operatorToken2 = getOperatorToken(expr);
                  const leftText = sourceCode2.getText().slice(node2.range[0], equalsToken.range[0]);
                  const rightText = sourceCode2.getText().slice(
                    operatorToken2.range[1],
                    node2.right.range[1]
                  );
                  if (sourceCode2.commentsExistBetween(
                    equalsToken,
                    operatorToken2
                  )) {
                    return null;
                  }
                  return fixer.replaceText(
                    node2,
                    `${leftText}${replacementOperator}${rightText}`
                  );
                }
                return null;
              }
            });
          } else if (astUtils2.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator2)) {
            context.report({
              node: node2,
              messageId: "replaced",
              data: { operator: replacementOperator }
            });
          }
        }
      }
      function prohibit(node2) {
        if (node2.operator !== "=" && !astUtils2.isLogicalAssignmentOperator(node2.operator)) {
          context.report({
            node: node2,
            messageId: "unexpected",
            data: { operator: node2.operator },
            fix(fixer) {
              if (canBeFixed(node2.left)) {
                const firstToken = sourceCode2.getFirstToken(node2);
                const operatorToken2 = getOperatorToken(node2);
                const leftText = sourceCode2.getText().slice(node2.range[0], operatorToken2.range[0]);
                const newOperator = node2.operator.slice(0, -1);
                let rightText;
                if (sourceCode2.commentsExistBetween(
                  firstToken,
                  operatorToken2
                )) {
                  return null;
                }
                if (astUtils2.getPrecedence(node2.right) <= astUtils2.getPrecedence({
                  type: "BinaryExpression",
                  operator: newOperator
                }) && !astUtils2.isParenthesised(
                  sourceCode2,
                  node2.right
                )) {
                  rightText = `${sourceCode2.text.slice(operatorToken2.range[1], node2.right.range[0])}(${sourceCode2.getText(node2.right)})`;
                } else {
                  const tokenAfterOperator = sourceCode2.getTokenAfter(operatorToken2, {
                    includeComments: true
                  });
                  let rightTextPrefix = "";
                  if (operatorToken2.range[1] === tokenAfterOperator.range[0] && !astUtils2.canTokensBeAdjacent(
                    {
                      type: "Punctuator",
                      value: newOperator
                    },
                    tokenAfterOperator
                  )) {
                    rightTextPrefix = " ";
                  }
                  rightText = `${rightTextPrefix}${sourceCode2.text.slice(operatorToken2.range[1], node2.range[1])}`;
                }
                return fixer.replaceText(
                  node2,
                  `${leftText}= ${leftText}${newOperator}${rightText}`
                );
              }
              return null;
            }
          });
        }
      }
      return {
        AssignmentExpression: !never ? verify : prohibit
      };
    }
  };
  return operatorAssignment;
}
var operatorLinebreak;
var hasRequiredOperatorLinebreak;
function requireOperatorLinebreak() {
  if (hasRequiredOperatorLinebreak) return operatorLinebreak;
  hasRequiredOperatorLinebreak = 1;
  const astUtils2 = requireAstUtils();
  operatorLinebreak = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "operator-linebreak",
              url: "https://eslint.style/rules/operator-linebreak"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent linebreak style for operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/operator-linebreak"
      },
      schema: [
        {
          enum: ["after", "before", "none", null]
        },
        {
          type: "object",
          properties: {
            overrides: {
              type: "object",
              additionalProperties: {
                enum: ["after", "before", "none", "ignore"]
              }
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
        operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
        badLinebreak: "Bad line breaking before and after '{{operator}}'.",
        noLinebreak: "There should be no line break before or after '{{operator}}'."
      }
    },
    create(context) {
      const usedDefaultGlobal = !context.options[0];
      const globalStyle = context.options[0] || "after";
      const options = context.options[1] || {};
      const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
      if (usedDefaultGlobal && !styleOverrides["?"]) {
        styleOverrides["?"] = "before";
      }
      if (usedDefaultGlobal && !styleOverrides[":"]) {
        styleOverrides[":"] = "before";
      }
      const sourceCode2 = context.sourceCode;
      function getFixer(operatorToken2, desiredStyle) {
        return (fixer) => {
          const tokenBefore = sourceCode2.getTokenBefore(operatorToken2);
          const tokenAfter = sourceCode2.getTokenAfter(operatorToken2);
          const textBefore = sourceCode2.text.slice(
            tokenBefore.range[1],
            operatorToken2.range[0]
          );
          const textAfter = sourceCode2.text.slice(
            operatorToken2.range[1],
            tokenAfter.range[0]
          );
          const hasLinebreakBefore = !astUtils2.isTokenOnSameLine(
            tokenBefore,
            operatorToken2
          );
          const hasLinebreakAfter = !astUtils2.isTokenOnSameLine(
            operatorToken2,
            tokenAfter
          );
          let newTextBefore, newTextAfter;
          if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
            if (sourceCode2.getTokenBefore(operatorToken2, {
              includeComments: true
            }) !== tokenBefore && sourceCode2.getTokenAfter(operatorToken2, {
              includeComments: true
            }) !== tokenAfter) {
              return null;
            }
            newTextBefore = textAfter;
            newTextAfter = textBefore;
          } else {
            const LINEBREAK_REGEX = astUtils2.createGlobalLinebreakMatcher();
            newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
            newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
            if (newTextBefore === textBefore && newTextAfter === textAfter) {
              return null;
            }
          }
          if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken2.value) && tokenAfter.value === operatorToken2.value) {
            newTextAfter += " ";
          }
          return fixer.replaceTextRange(
            [tokenBefore.range[1], tokenAfter.range[0]],
            newTextBefore + operatorToken2.value + newTextAfter
          );
        };
      }
      function validateNode(node2, rightSide, operator2) {
        const operatorToken2 = sourceCode2.getTokenBefore(
          rightSide,
          (token) => token.value === operator2
        );
        const leftToken = sourceCode2.getTokenBefore(operatorToken2);
        const rightToken = sourceCode2.getTokenAfter(operatorToken2);
        const operatorStyleOverride = styleOverrides[operator2];
        const style = operatorStyleOverride || globalStyle;
        const fix = getFixer(operatorToken2, style);
        if (astUtils2.isTokenOnSameLine(leftToken, operatorToken2) && astUtils2.isTokenOnSameLine(operatorToken2, rightToken)) ;
        else if (operatorStyleOverride !== "ignore" && !astUtils2.isTokenOnSameLine(leftToken, operatorToken2) && !astUtils2.isTokenOnSameLine(operatorToken2, rightToken)) {
          context.report({
            node: node2,
            loc: operatorToken2.loc,
            messageId: "badLinebreak",
            data: {
              operator: operator2
            },
            fix
          });
        } else if (style === "before" && astUtils2.isTokenOnSameLine(leftToken, operatorToken2)) {
          context.report({
            node: node2,
            loc: operatorToken2.loc,
            messageId: "operatorAtBeginning",
            data: {
              operator: operator2
            },
            fix
          });
        } else if (style === "after" && astUtils2.isTokenOnSameLine(operatorToken2, rightToken)) {
          context.report({
            node: node2,
            loc: operatorToken2.loc,
            messageId: "operatorAtEnd",
            data: {
              operator: operator2
            },
            fix
          });
        } else if (style === "none") {
          context.report({
            node: node2,
            loc: operatorToken2.loc,
            messageId: "noLinebreak",
            data: {
              operator: operator2
            },
            fix
          });
        }
      }
      function validateBinaryExpression(node2) {
        validateNode(node2, node2.right, node2.operator);
      }
      return {
        BinaryExpression: validateBinaryExpression,
        LogicalExpression: validateBinaryExpression,
        AssignmentExpression: validateBinaryExpression,
        VariableDeclarator(node2) {
          if (node2.init) {
            validateNode(node2, node2.init, "=");
          }
        },
        PropertyDefinition(node2) {
          if (node2.value) {
            validateNode(node2, node2.value, "=");
          }
        },
        ConditionalExpression(node2) {
          validateNode(node2, node2.consequent, "?");
          validateNode(node2, node2.alternate, ":");
        }
      };
    }
  };
  return operatorLinebreak;
}
var paddedBlocks;
var hasRequiredPaddedBlocks;
function requirePaddedBlocks() {
  if (hasRequiredPaddedBlocks) return paddedBlocks;
  hasRequiredPaddedBlocks = 1;
  const astUtils2 = requireAstUtils();
  paddedBlocks = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "padded-blocks",
              url: "https://eslint.style/rules/padded-blocks"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow padding within blocks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/padded-blocks"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                blocks: {
                  enum: ["always", "never"]
                },
                switches: {
                  enum: ["always", "never"]
                },
                classes: {
                  enum: ["always", "never"]
                }
              },
              additionalProperties: false,
              minProperties: 1
            }
          ]
        },
        {
          type: "object",
          properties: {
            allowSingleLineBlocks: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        alwaysPadBlock: "Block must be padded by blank lines.",
        neverPadBlock: "Block must not be padded by blank lines."
      }
    },
    create(context) {
      const options = {};
      const typeOptions = context.options[0] || "always";
      const exceptOptions = context.options[1] || {};
      if (typeof typeOptions === "string") {
        const shouldHavePadding = typeOptions === "always";
        options.blocks = shouldHavePadding;
        options.switches = shouldHavePadding;
        options.classes = shouldHavePadding;
      } else {
        if (Object.hasOwn(typeOptions, "blocks")) {
          options.blocks = typeOptions.blocks === "always";
        }
        if (Object.hasOwn(typeOptions, "switches")) {
          options.switches = typeOptions.switches === "always";
        }
        if (Object.hasOwn(typeOptions, "classes")) {
          options.classes = typeOptions.classes === "always";
        }
      }
      if (Object.hasOwn(exceptOptions, "allowSingleLineBlocks")) {
        options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
      }
      const sourceCode2 = context.sourceCode;
      function getOpenBrace(node2) {
        if (node2.type === "SwitchStatement") {
          return sourceCode2.getTokenBefore(node2.cases[0]);
        }
        if (node2.type === "StaticBlock") {
          return sourceCode2.getFirstToken(node2, { skip: 1 });
        }
        return sourceCode2.getFirstToken(node2);
      }
      function isComment(node2) {
        return node2.type === "Line" || node2.type === "Block";
      }
      function isPaddingBetweenTokens(first, second) {
        return second.loc.start.line - first.loc.end.line >= 2;
      }
      function getFirstBlockToken(token) {
        let prev, first = token;
        do {
          prev = first;
          first = sourceCode2.getTokenAfter(first, {
            includeComments: true
          });
        } while (isComment(first) && first.loc.start.line === prev.loc.end.line);
        return first;
      }
      function getLastBlockToken(token) {
        let last = token, next;
        do {
          next = last;
          last = sourceCode2.getTokenBefore(last, {
            includeComments: true
          });
        } while (isComment(last) && last.loc.end.line === next.loc.start.line);
        return last;
      }
      function requirePaddingFor(node2) {
        switch (node2.type) {
          case "BlockStatement":
          case "StaticBlock":
            return options.blocks;
          case "SwitchStatement":
            return options.switches;
          case "ClassBody":
            return options.classes;
          default:
            throw new Error("unreachable");
        }
      }
      function checkPadding(node2) {
        const openBrace = getOpenBrace(node2), firstBlockToken = getFirstBlockToken(openBrace), tokenBeforeFirst = sourceCode2.getTokenBefore(firstBlockToken, {
          includeComments: true
        }), closeBrace = sourceCode2.getLastToken(node2), lastBlockToken = getLastBlockToken(closeBrace), tokenAfterLast = sourceCode2.getTokenAfter(lastBlockToken, {
          includeComments: true
        }), blockHasTopPadding = isPaddingBetweenTokens(
          tokenBeforeFirst,
          firstBlockToken
        ), blockHasBottomPadding = isPaddingBetweenTokens(
          lastBlockToken,
          tokenAfterLast
        );
        if (options.allowSingleLineBlocks && astUtils2.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {
          return;
        }
        if (requirePaddingFor(node2)) {
          if (!blockHasTopPadding) {
            context.report({
              node: node2,
              loc: {
                start: tokenBeforeFirst.loc.start,
                end: firstBlockToken.loc.start
              },
              fix(fixer) {
                return fixer.insertTextAfter(
                  tokenBeforeFirst,
                  "\n"
                );
              },
              messageId: "alwaysPadBlock"
            });
          }
          if (!blockHasBottomPadding) {
            context.report({
              node: node2,
              loc: {
                end: tokenAfterLast.loc.start,
                start: lastBlockToken.loc.end
              },
              fix(fixer) {
                return fixer.insertTextBefore(tokenAfterLast, "\n");
              },
              messageId: "alwaysPadBlock"
            });
          }
        } else {
          if (blockHasTopPadding) {
            context.report({
              node: node2,
              loc: {
                start: tokenBeforeFirst.loc.start,
                end: firstBlockToken.loc.start
              },
              fix(fixer) {
                return fixer.replaceTextRange(
                  [
                    tokenBeforeFirst.range[1],
                    firstBlockToken.range[0] - firstBlockToken.loc.start.column
                  ],
                  "\n"
                );
              },
              messageId: "neverPadBlock"
            });
          }
          if (blockHasBottomPadding) {
            context.report({
              node: node2,
              loc: {
                end: tokenAfterLast.loc.start,
                start: lastBlockToken.loc.end
              },
              messageId: "neverPadBlock",
              fix(fixer) {
                return fixer.replaceTextRange(
                  [
                    lastBlockToken.range[1],
                    tokenAfterLast.range[0] - tokenAfterLast.loc.start.column
                  ],
                  "\n"
                );
              }
            });
          }
        }
      }
      const rule = {};
      if (Object.hasOwn(options, "switches")) {
        rule.SwitchStatement = function(node2) {
          if (node2.cases.length === 0) {
            return;
          }
          checkPadding(node2);
        };
      }
      if (Object.hasOwn(options, "blocks")) {
        rule.BlockStatement = function(node2) {
          if (node2.body.length === 0) {
            return;
          }
          checkPadding(node2);
        };
        rule.StaticBlock = rule.BlockStatement;
      }
      if (Object.hasOwn(options, "classes")) {
        rule.ClassBody = function(node2) {
          if (node2.body.length === 0) {
            return;
          }
          checkPadding(node2);
        };
      }
      return rule;
    }
  };
  return paddedBlocks;
}
var paddingLineBetweenStatements;
var hasRequiredPaddingLineBetweenStatements;
function requirePaddingLineBetweenStatements() {
  if (hasRequiredPaddingLineBetweenStatements) return paddingLineBetweenStatements;
  hasRequiredPaddingLineBetweenStatements = 1;
  const astUtils2 = requireAstUtils();
  const LT = `[${Array.from(astUtils2.LINEBREAKS).join("")}]`;
  const PADDING_LINE_SEQUENCE = new RegExp(
    String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`,
    "u"
  );
  const CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
  const CJS_IMPORT = /^require\(/u;
  function newKeywordTester(keyword2) {
    return {
      test: (node2, sourceCode2) => sourceCode2.getFirstToken(node2).value === keyword2
    };
  }
  function newSinglelineKeywordTester(keyword2) {
    return {
      test: (node2, sourceCode2) => node2.loc.start.line === node2.loc.end.line && sourceCode2.getFirstToken(node2).value === keyword2
    };
  }
  function newMultilineKeywordTester(keyword2) {
    return {
      test: (node2, sourceCode2) => node2.loc.start.line !== node2.loc.end.line && sourceCode2.getFirstToken(node2).value === keyword2
    };
  }
  function newNodeTypeTester(type2) {
    return {
      test: (node2) => node2.type === type2
    };
  }
  function isIIFEStatement(node2) {
    if (node2.type === "ExpressionStatement") {
      let call = astUtils2.skipChainExpression(node2.expression);
      if (call.type === "UnaryExpression") {
        call = astUtils2.skipChainExpression(call.argument);
      }
      return call.type === "CallExpression" && astUtils2.isFunction(call.callee);
    }
    return false;
  }
  function isBlockLikeStatement(sourceCode2, node2) {
    if (node2.type === "DoWhileStatement" && node2.body.type === "BlockStatement") {
      return true;
    }
    if (isIIFEStatement(node2)) {
      return true;
    }
    const lastToken = sourceCode2.getLastToken(
      node2,
      astUtils2.isNotSemicolonToken
    );
    const belongingNode = lastToken && astUtils2.isClosingBraceToken(lastToken) ? sourceCode2.getNodeByRangeIndex(lastToken.range[0]) : null;
    return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
  }
  function getActualLastToken(sourceCode2, node2) {
    const semiToken = sourceCode2.getLastToken(node2);
    const prevToken = sourceCode2.getTokenBefore(semiToken);
    const nextToken = sourceCode2.getTokenAfter(semiToken);
    const isSemicolonLessStyle = Boolean(
      prevToken && nextToken && prevToken.range[0] >= node2.range[0] && astUtils2.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line
    );
    return isSemicolonLessStyle ? prevToken : semiToken;
  }
  function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
    return trailingSpaces + indentSpaces;
  }
  function verifyForAny() {
  }
  function verifyForNever(context, _, nextNode, paddingLines) {
    if (paddingLines.length === 0) {
      return;
    }
    context.report({
      node: nextNode,
      messageId: "unexpectedBlankLine",
      fix(fixer) {
        if (paddingLines.length >= 2) {
          return null;
        }
        const prevToken = paddingLines[0][0];
        const nextToken = paddingLines[0][1];
        const start = prevToken.range[1];
        const end = nextToken.range[0];
        const text = context.sourceCode.text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
        return fixer.replaceTextRange([start, end], text);
      }
    });
  }
  function verifyForAlways(context, prevNode, nextNode, paddingLines) {
    if (paddingLines.length > 0) {
      return;
    }
    context.report({
      node: nextNode,
      messageId: "expectedBlankLine",
      fix(fixer) {
        const sourceCode2 = context.sourceCode;
        let prevToken = getActualLastToken(sourceCode2, prevNode);
        const nextToken = sourceCode2.getFirstTokenBetween(prevToken, nextNode, {
          includeComments: true,
          /**
           * Skip the trailing comments of the previous node.
           * This inserts a blank line after the last trailing comment.
           *
           * For example:
           *
           *     foo(); // trailing comment.
           *     // comment.
           *     bar();
           *
           * Get fixed to:
           *
           *     foo(); // trailing comment.
           *
           *     // comment.
           *     bar();
           * @param {Token} token The token to check.
           * @returns {boolean} `true` if the token is not a trailing comment.
           * @private
           */
          filter(token) {
            if (astUtils2.isTokenOnSameLine(prevToken, token)) {
              prevToken = token;
              return false;
            }
            return true;
          }
        }) || nextNode;
        const insertText = astUtils2.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";
        return fixer.insertTextAfter(prevToken, insertText);
      }
    });
  }
  const PaddingTypes = {
    any: { verify: verifyForAny },
    never: { verify: verifyForNever },
    always: { verify: verifyForAlways }
  };
  const StatementTypes = {
    "*": { test: () => true },
    "block-like": {
      test: (node2, sourceCode2) => isBlockLikeStatement(sourceCode2, node2)
    },
    "cjs-export": {
      test: (node2, sourceCode2) => node2.type === "ExpressionStatement" && node2.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode2.getText(node2.expression.left))
    },
    "cjs-import": {
      test: (node2, sourceCode2) => node2.type === "VariableDeclaration" && node2.declarations.length > 0 && Boolean(node2.declarations[0].init) && CJS_IMPORT.test(sourceCode2.getText(node2.declarations[0].init))
    },
    directive: {
      test: astUtils2.isDirective
    },
    expression: {
      test: (node2) => node2.type === "ExpressionStatement" && !astUtils2.isDirective(node2)
    },
    iife: {
      test: isIIFEStatement
    },
    "multiline-block-like": {
      test: (node2, sourceCode2) => node2.loc.start.line !== node2.loc.end.line && isBlockLikeStatement(sourceCode2, node2)
    },
    "multiline-expression": {
      test: (node2) => node2.loc.start.line !== node2.loc.end.line && node2.type === "ExpressionStatement" && !astUtils2.isDirective(node2)
    },
    "multiline-const": newMultilineKeywordTester("const"),
    "multiline-let": newMultilineKeywordTester("let"),
    "multiline-var": newMultilineKeywordTester("var"),
    "singleline-const": newSinglelineKeywordTester("const"),
    "singleline-let": newSinglelineKeywordTester("let"),
    "singleline-var": newSinglelineKeywordTester("var"),
    block: newNodeTypeTester("BlockStatement"),
    empty: newNodeTypeTester("EmptyStatement"),
    function: newNodeTypeTester("FunctionDeclaration"),
    break: newKeywordTester("break"),
    case: newKeywordTester("case"),
    class: newKeywordTester("class"),
    const: newKeywordTester("const"),
    continue: newKeywordTester("continue"),
    debugger: newKeywordTester("debugger"),
    default: newKeywordTester("default"),
    do: newKeywordTester("do"),
    export: newKeywordTester("export"),
    for: newKeywordTester("for"),
    if: newKeywordTester("if"),
    import: newKeywordTester("import"),
    let: newKeywordTester("let"),
    return: newKeywordTester("return"),
    switch: newKeywordTester("switch"),
    throw: newKeywordTester("throw"),
    try: newKeywordTester("try"),
    var: newKeywordTester("var"),
    while: newKeywordTester("while"),
    with: newKeywordTester("with")
  };
  paddingLineBetweenStatements = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "padding-line-between-statements",
              url: "https://eslint.style/rules/padding-line-between-statements"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow padding lines between statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/padding-line-between-statements"
      },
      fixable: "whitespace",
      schema: {
        definitions: {
          paddingType: {
            enum: Object.keys(PaddingTypes)
          },
          statementType: {
            anyOf: [
              { enum: Object.keys(StatementTypes) },
              {
                type: "array",
                items: { enum: Object.keys(StatementTypes) },
                minItems: 1,
                uniqueItems: true
              }
            ]
          }
        },
        type: "array",
        items: {
          type: "object",
          properties: {
            blankLine: { $ref: "#/definitions/paddingType" },
            prev: { $ref: "#/definitions/statementType" },
            next: { $ref: "#/definitions/statementType" }
          },
          additionalProperties: false,
          required: ["blankLine", "prev", "next"]
        }
      },
      messages: {
        unexpectedBlankLine: "Unexpected blank line before this statement.",
        expectedBlankLine: "Expected blank line before this statement."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const configureList = context.options || [];
      let scopeInfo = null;
      function enterScope() {
        scopeInfo = {
          upper: scopeInfo,
          prevNode: null
        };
      }
      function exitScope() {
        scopeInfo = scopeInfo.upper;
      }
      function match(node2, type2) {
        let innerStatementNode = node2;
        while (innerStatementNode.type === "LabeledStatement") {
          innerStatementNode = innerStatementNode.body;
        }
        if (Array.isArray(type2)) {
          return type2.some(match.bind(null, innerStatementNode));
        }
        return StatementTypes[type2].test(innerStatementNode, sourceCode2);
      }
      function getPaddingType(prevNode, nextNode) {
        for (let i2 = configureList.length - 1; i2 >= 0; --i2) {
          const configure = configureList[i2];
          const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);
          if (matched) {
            return PaddingTypes[configure.blankLine];
          }
        }
        return PaddingTypes.any;
      }
      function getPaddingLineSequences(prevNode, nextNode) {
        const pairs = [];
        let prevToken = getActualLastToken(sourceCode2, prevNode);
        if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
          do {
            const token = sourceCode2.getTokenAfter(prevToken, {
              includeComments: true
            });
            if (token.loc.start.line - prevToken.loc.end.line >= 2) {
              pairs.push([prevToken, token]);
            }
            prevToken = token;
          } while (prevToken.range[0] < nextNode.range[0]);
        }
        return pairs;
      }
      function verify(node2) {
        const parentType = node2.parent.type;
        const validParent = astUtils2.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";
        if (!validParent) {
          return;
        }
        const prevNode = scopeInfo.prevNode;
        if (prevNode) {
          const type2 = getPaddingType(prevNode, node2);
          const paddingLines = getPaddingLineSequences(prevNode, node2);
          type2.verify(context, prevNode, node2, paddingLines);
        }
        scopeInfo.prevNode = node2;
      }
      function verifyThenEnterScope(node2) {
        verify(node2);
        enterScope();
      }
      return {
        Program: enterScope,
        BlockStatement: enterScope,
        SwitchStatement: enterScope,
        StaticBlock: enterScope,
        "Program:exit": exitScope,
        "BlockStatement:exit": exitScope,
        "SwitchStatement:exit": exitScope,
        "StaticBlock:exit": exitScope,
        ":statement": verify,
        SwitchCase: verifyThenEnterScope,
        "SwitchCase:exit": exitScope
      };
    }
  };
  return paddingLineBetweenStatements;
}
var preferArrowCallback;
var hasRequiredPreferArrowCallback;
function requirePreferArrowCallback() {
  if (hasRequiredPreferArrowCallback) return preferArrowCallback;
  hasRequiredPreferArrowCallback = 1;
  const astUtils2 = requireAstUtils();
  function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
  }
  function checkMetaProperty(node2, metaName, propertyName2) {
    return node2.meta.name === metaName && node2.property.name === propertyName2;
  }
  function getVariableOfArguments(scope) {
    const variables = scope.variables;
    for (let i2 = 0; i2 < variables.length; ++i2) {
      const variable = variables[i2];
      if (variable.name === "arguments") {
        return variable.identifiers.length === 0 ? variable : null;
      }
    }
    return null;
  }
  function getCallbackInfo(node2) {
    const retv = { isCallback: false, isLexicalThis: false };
    let currentNode = node2;
    let parent = node2.parent;
    let bound = false;
    while (currentNode) {
      switch (parent.type) {
        case "LogicalExpression":
        case "ChainExpression":
        case "ConditionalExpression":
          break;
        case "MemberExpression":
          if (parent.object === currentNode && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind") {
            const maybeCallee = parent.parent.type === "ChainExpression" ? parent.parent : parent;
            if (astUtils2.isCallee(maybeCallee)) {
              if (!bound) {
                bound = true;
                retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === "ThisExpression";
              }
              parent = maybeCallee.parent;
            } else {
              return retv;
            }
          } else {
            return retv;
          }
          break;
        case "CallExpression":
        case "NewExpression":
          if (parent.callee !== currentNode) {
            retv.isCallback = true;
          }
          return retv;
        default:
          return retv;
      }
      currentNode = parent;
      parent = parent.parent;
    }
    throw new Error("unreachable");
  }
  function hasDuplicateParams(paramsList) {
    return paramsList.every((param) => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map((param) => param.name)).size;
  }
  preferArrowCallback = {
    meta: {
      type: "suggestion",
      dialects: ["javascript", "typescript"],
      language: "javascript",
      defaultOptions: [
        { allowNamedFunctions: false, allowUnboundThis: true }
      ],
      docs: {
        description: "Require using arrow functions for callbacks",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowNamedFunctions: {
              type: "boolean"
            },
            allowUnboundThis: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        preferArrowCallback: "Unexpected function expression."
      }
    },
    create(context) {
      const [{ allowNamedFunctions, allowUnboundThis }] = context.options;
      const sourceCode2 = context.sourceCode;
      let stack = [];
      function enterScope() {
        stack.push({ this: false, super: false, meta: false });
      }
      function exitScope() {
        return stack.pop();
      }
      return {
        // Reset internal state.
        Program() {
          stack = [];
        },
        // If there are below, it cannot replace with arrow functions merely.
        ThisExpression() {
          const info = stack.at(-1);
          if (info) {
            info.this = true;
          }
        },
        Super() {
          const info = stack.at(-1);
          if (info) {
            info.super = true;
          }
        },
        MetaProperty(node2) {
          const info = stack.at(-1);
          if (info && checkMetaProperty(node2, "new", "target")) {
            info.meta = true;
          }
        },
        // To skip nested scopes.
        FunctionDeclaration: enterScope,
        "FunctionDeclaration:exit": exitScope,
        // Main.
        FunctionExpression: enterScope,
        "FunctionExpression:exit"(node2) {
          const scopeInfo = exitScope();
          if (allowNamedFunctions && node2.id && node2.id.name) {
            return;
          }
          if (node2.generator) {
            return;
          }
          const nameVar = sourceCode2.getDeclaredVariables(node2)[0];
          if (isFunctionName(nameVar) && nameVar.references.length > 0) {
            return;
          }
          const variable = getVariableOfArguments(
            sourceCode2.getScope(node2)
          );
          if (variable && variable.references.length > 0) {
            return;
          }
          const callbackInfo = getCallbackInfo(node2);
          if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
            context.report({
              node: node2,
              messageId: "preferArrowCallback",
              *fix(fixer) {
                if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node2.params)) {
                  return;
                }
                if (node2.params.length && node2.params[0].name === "this") {
                  return;
                }
                if (callbackInfo.isLexicalThis) {
                  const memberNode = node2.parent;
                  if (memberNode.type !== "MemberExpression") {
                    return;
                  }
                  const callNode = memberNode.parent;
                  const firstTokenToRemove = sourceCode2.getTokenAfter(
                    memberNode.object,
                    astUtils2.isNotClosingParenToken
                  );
                  const lastTokenToRemove = sourceCode2.getLastToken(callNode);
                  if (astUtils2.isParenthesised(
                    sourceCode2,
                    memberNode
                  )) {
                    return;
                  }
                  if (sourceCode2.commentsExistBetween(
                    firstTokenToRemove,
                    lastTokenToRemove
                  )) {
                    return;
                  }
                  yield fixer.removeRange([
                    firstTokenToRemove.range[0],
                    lastTokenToRemove.range[1]
                  ]);
                }
                const functionToken = sourceCode2.getFirstToken(
                  node2,
                  node2.async ? 1 : 0
                );
                const leftParenToken = sourceCode2.getTokenAfter(
                  functionToken,
                  astUtils2.isOpeningParenToken
                );
                const tokenBeforeBody = sourceCode2.getTokenBefore(
                  node2.body
                );
                if (sourceCode2.commentsExistBetween(
                  functionToken,
                  leftParenToken
                )) {
                  yield fixer.remove(functionToken);
                  if (node2.id) {
                    yield fixer.remove(node2.id);
                  }
                } else {
                  yield fixer.removeRange([
                    functionToken.range[0],
                    leftParenToken.range[0]
                  ]);
                }
                yield fixer.insertTextAfter(tokenBeforeBody, " =>");
                let replacedNode = callbackInfo.isLexicalThis ? node2.parent.parent : node2;
                if (replacedNode.type === "ChainExpression") {
                  replacedNode = replacedNode.parent;
                }
                if (replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression" && !astUtils2.isParenthesised(
                  sourceCode2,
                  replacedNode
                ) && !astUtils2.isParenthesised(sourceCode2, node2)) {
                  yield fixer.insertTextBefore(replacedNode, "(");
                  yield fixer.insertTextAfter(replacedNode, ")");
                }
              }
            });
          }
        }
      };
    }
  };
  return preferArrowCallback;
}
var preferConst;
var hasRequiredPreferConst;
function requirePreferConst() {
  if (hasRequiredPreferConst) return preferConst;
  hasRequiredPreferConst = 1;
  const FixTracker = requireFixTracker();
  const astUtils2 = requireAstUtils();
  const PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
  const DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u;
  const DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;
  function isInitOfForStatement(node2) {
    return node2.parent.type === "ForStatement" && node2.parent.init === node2;
  }
  function canBecomeVariableDeclaration(identifier) {
    let node2 = identifier.parent;
    while (PATTERN_TYPE.test(node2.type)) {
      node2 = node2.parent;
    }
    return node2.type === "VariableDeclarator" || node2.type === "AssignmentExpression" && node2.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node2.parent.parent.type);
  }
  function isOuterVariableInDestructing(name2, initScope) {
    if (initScope.through.some(
      (ref2) => ref2.resolved && ref2.resolved.name === name2
    )) {
      return true;
    }
    const variable = astUtils2.getVariableByName(initScope, name2);
    if (variable !== null) {
      return variable.defs.some((def) => def.type === "Parameter");
    }
    return false;
  }
  function getDestructuringHost(reference) {
    if (!reference.isWrite()) {
      return null;
    }
    let node2 = reference.identifier.parent;
    while (PATTERN_TYPE.test(node2.type)) {
      node2 = node2.parent;
    }
    if (!DESTRUCTURING_HOST_TYPE.test(node2.type)) {
      return null;
    }
    return node2;
  }
  function hasMemberExpressionAssignment(node2) {
    switch (node2.type) {
      case "ObjectPattern":
        return node2.properties.some((prop) => {
          if (prop) {
            return hasMemberExpressionAssignment(
              prop.argument || prop.value
            );
          }
          return false;
        });
      case "ArrayPattern":
        return node2.elements.some((element) => {
          if (element) {
            return hasMemberExpressionAssignment(element);
          }
          return false;
        });
      case "AssignmentPattern":
        return hasMemberExpressionAssignment(node2.left);
      case "MemberExpression":
        return true;
    }
    return false;
  }
  function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
    if (variable.eslintUsed && variable.scope.type === "global") {
      return null;
    }
    let writer = null;
    let isReadBeforeInit = false;
    const references = variable.references;
    for (let i2 = 0; i2 < references.length; ++i2) {
      const reference = references[i2];
      if (reference.isWrite()) {
        const isReassigned = writer !== null && writer.identifier !== reference.identifier;
        if (isReassigned) {
          return null;
        }
        const destructuringHost = getDestructuringHost(reference);
        if (destructuringHost !== null && destructuringHost.left !== void 0) {
          const leftNode = destructuringHost.left;
          let hasOuterVariables = false, hasNonIdentifiers = false;
          if (leftNode.type === "ObjectPattern") {
            const properties2 = leftNode.properties;
            hasOuterVariables = properties2.filter((prop) => prop.value).map((prop) => prop.value.name).some(
              (name2) => isOuterVariableInDestructing(name2, variable.scope)
            );
            hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
          } else if (leftNode.type === "ArrayPattern") {
            const elements = leftNode.elements;
            hasOuterVariables = elements.map((element) => element && element.name).some(
              (name2) => isOuterVariableInDestructing(name2, variable.scope)
            );
            hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
          }
          if (hasOuterVariables || hasNonIdentifiers) {
            return null;
          }
        }
        writer = reference;
      } else if (reference.isRead() && writer === null) {
        if (ignoreReadBeforeAssign) {
          return null;
        }
        isReadBeforeInit = true;
      }
    }
    const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);
    if (!shouldBeConst) {
      return null;
    }
    if (isReadBeforeInit) {
      return variable.defs[0].name;
    }
    return writer.identifier;
  }
  function groupByDestructuring(variables, ignoreReadBeforeAssign) {
    const identifierMap = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < variables.length; ++i2) {
      const variable = variables[i2];
      const references = variable.references;
      const identifier = getIdentifierIfShouldBeConst(
        variable,
        ignoreReadBeforeAssign
      );
      let prevId = null;
      for (let j = 0; j < references.length; ++j) {
        const reference = references[j];
        const id2 = reference.identifier;
        if (id2 === prevId) {
          continue;
        }
        prevId = id2;
        const group = getDestructuringHost(reference);
        if (group) {
          if (identifierMap.has(group)) {
            identifierMap.get(group).push(identifier);
          } else {
            identifierMap.set(group, [identifier]);
          }
        }
      }
    }
    return identifierMap;
  }
  function findUp(node2, type2, shouldStop) {
    if (!node2 || shouldStop(node2)) {
      return null;
    }
    if (node2.type === type2) {
      return node2;
    }
    return findUp(node2.parent, type2, shouldStop);
  }
  preferConst = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          destructuring: "any",
          ignoreReadBeforeAssign: false
        }
      ],
      docs: {
        description: "Require `const` declarations for variables that are never reassigned after declared",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-const"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            destructuring: { enum: ["any", "all"] },
            ignoreReadBeforeAssign: { type: "boolean" }
          },
          additionalProperties: false
        }
      ],
      messages: {
        useConst: "'{{name}}' is never reassigned. Use 'const' instead."
      }
    },
    create(context) {
      const [{ destructuring, ignoreReadBeforeAssign }] = context.options;
      const shouldMatchAnyDestructuredVariable = destructuring !== "all";
      const sourceCode2 = context.sourceCode;
      const variables = [];
      let reportCount = 0;
      let checkedId = null;
      let checkedName = "";
      function checkGroup(nodes) {
        const nodesToReport = nodes.filter(Boolean);
        if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {
          const varDeclParent = findUp(
            nodes[0],
            "VariableDeclaration",
            (parentNode) => parentNode.type.endsWith("Statement")
          );
          const isVarDecParentNull = varDeclParent === null;
          if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {
            const firstDeclaration = varDeclParent.declarations[0];
            if (firstDeclaration.init) {
              const firstDecParent = firstDeclaration.init.parent;
              if (firstDecParent.type === "VariableDeclarator") {
                if (firstDecParent.id.name !== checkedName) {
                  checkedName = firstDecParent.id.name;
                  reportCount = 0;
                }
                if (firstDecParent.id.type === "ObjectPattern") {
                  if (firstDecParent.init.name !== checkedName) {
                    checkedName = firstDecParent.init.name;
                    reportCount = 0;
                  }
                }
                if (firstDecParent.id !== checkedId) {
                  checkedId = firstDecParent.id;
                  reportCount = 0;
                }
              }
            }
          }
          let shouldFix = varDeclParent && // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)
          (varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations.every(
            (declaration) => declaration.init
          )) && /*
           * If options.destructuring is "all", then this warning will not occur unless
           * every assignment in the destructuring should be const. In that case, it's safe
           * to apply the fix.
           */
          nodesToReport.length === nodes.length;
          if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {
            if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {
              reportCount += nodesToReport.length;
              let totalDeclarationsCount = 0;
              varDeclParent.declarations.forEach((declaration) => {
                if (declaration.id.type === "ObjectPattern") {
                  totalDeclarationsCount += declaration.id.properties.length;
                } else if (declaration.id.type === "ArrayPattern") {
                  totalDeclarationsCount += declaration.id.elements.length;
                } else {
                  totalDeclarationsCount += 1;
                }
              });
              shouldFix = shouldFix && reportCount === totalDeclarationsCount;
            }
          }
          nodesToReport.forEach((node2) => {
            context.report({
              node: node2,
              messageId: "useConst",
              data: node2,
              fix: shouldFix ? (fixer) => {
                const letKeywordToken = sourceCode2.getFirstToken(
                  varDeclParent,
                  (t2) => t2.value === varDeclParent.kind
                );
                return new FixTracker(fixer, sourceCode2).retainRange(varDeclParent.range).replaceTextRange(
                  letKeywordToken.range,
                  "const"
                );
              } : null
            });
          });
        }
      }
      return {
        "Program:exit"() {
          groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(
            checkGroup
          );
        },
        VariableDeclaration(node2) {
          if (node2.kind === "let" && !isInitOfForStatement(node2)) {
            variables.push(...sourceCode2.getDeclaredVariables(node2));
          }
        }
      };
    }
  };
  return preferConst;
}
var preferDestructuring;
var hasRequiredPreferDestructuring;
function requirePreferDestructuring() {
  if (hasRequiredPreferDestructuring) return preferDestructuring;
  hasRequiredPreferDestructuring = 1;
  const astUtils2 = requireAstUtils();
  const PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils2.getPrecedence({
    type: "AssignmentExpression"
  });
  preferDestructuring = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require destructuring from arrays and/or objects",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-destructuring"
      },
      fixable: "code",
      schema: [
        {
          /*
           * old support {array: Boolean, object: Boolean}
           * new support {VariableDeclarator: {}, AssignmentExpression: {}}
           */
          oneOf: [
            {
              type: "object",
              properties: {
                VariableDeclarator: {
                  type: "object",
                  properties: {
                    array: {
                      type: "boolean"
                    },
                    object: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                AssignmentExpression: {
                  type: "object",
                  properties: {
                    array: {
                      type: "boolean"
                    },
                    object: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                array: {
                  type: "boolean"
                },
                object: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        },
        {
          type: "object",
          properties: {
            enforceForRenamedProperties: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        preferDestructuring: "Use {{type}} destructuring."
      }
    },
    create(context) {
      const enabledTypes = context.options[0];
      const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
      let normalizedOptions = {
        VariableDeclarator: { array: true, object: true },
        AssignmentExpression: { array: true, object: true }
      };
      if (enabledTypes) {
        normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? {
          VariableDeclarator: enabledTypes,
          AssignmentExpression: enabledTypes
        } : enabledTypes;
      }
      function shouldCheck(nodeType, destructuringType) {
        return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
      }
      function isArrayIndexAccess(node2) {
        return Number.isInteger(node2.property.value);
      }
      function report(reportNode, type2, fix) {
        context.report({
          node: reportNode,
          messageId: "preferDestructuring",
          data: { type: type2 },
          fix
        });
      }
      function shouldFix(node2) {
        return node2.type === "VariableDeclarator" && node2.id.type === "Identifier" && node2.init.type === "MemberExpression" && !node2.init.computed && node2.init.property.type === "Identifier" && node2.id.name === node2.init.property.name;
      }
      function fixIntoObjectDestructuring(fixer, node2) {
        const rightNode = node2.init;
        const sourceCode2 = context.sourceCode;
        if (sourceCode2.getCommentsInside(node2).length > sourceCode2.getCommentsInside(rightNode.object).length) {
          return null;
        }
        let objectText = sourceCode2.getText(rightNode.object);
        if (astUtils2.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {
          objectText = `(${objectText})`;
        }
        return fixer.replaceText(
          node2,
          `{${rightNode.property.name}} = ${objectText}`
        );
      }
      function performCheck(leftNode, rightNode, reportNode) {
        if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super" || rightNode.property.type === "PrivateIdentifier") {
          return;
        }
        if (isArrayIndexAccess(rightNode)) {
          if (shouldCheck(reportNode.type, "array")) {
            report(reportNode, "array", null);
          }
          return;
        }
        const fix = shouldFix(reportNode) ? (fixer) => fixIntoObjectDestructuring(fixer, reportNode) : null;
        if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
          report(reportNode, "object", fix);
          return;
        }
        if (shouldCheck(reportNode.type, "object")) {
          const property = rightNode.property;
          if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name && !rightNode.computed) {
            report(reportNode, "object", fix);
          }
        }
      }
      function checkVariableDeclarator(node2) {
        if (!node2.init) {
          return;
        }
        if (node2.parent.kind === "using" || node2.parent.kind === "await using") {
          return;
        }
        if (node2.init.type !== "MemberExpression") {
          return;
        }
        performCheck(node2.id, node2.init, node2);
      }
      function checkAssignmentExpression(node2) {
        if (node2.operator === "=") {
          performCheck(node2.left, node2.right, node2);
        }
      }
      return {
        VariableDeclarator: checkVariableDeclarator,
        AssignmentExpression: checkAssignmentExpression
      };
    }
  };
  return preferDestructuring;
}
var preferExponentiationOperator;
var hasRequiredPreferExponentiationOperator;
function requirePreferExponentiationOperator() {
  if (hasRequiredPreferExponentiationOperator) return preferExponentiationOperator;
  hasRequiredPreferExponentiationOperator = 1;
  const astUtils2 = requireAstUtils();
  const { CALL, ReferenceTracker } = /* @__PURE__ */ requireEslintUtils();
  const PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils2.getPrecedence({
    type: "BinaryExpression",
    operator: "**"
  });
  function doesBaseNeedParens(base2) {
    return (
      // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c
      astUtils2.getPrecedence(base2) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || // An unary operator cannot be used immediately before an exponentiation expression
      base2.type === "AwaitExpression" || base2.type === "UnaryExpression"
    );
  }
  function doesExponentNeedParens(exponent) {
    return astUtils2.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;
  }
  function doesExponentiationExpressionNeedParens(node2, sourceCode2) {
    const parent = node2.parent.type === "ChainExpression" ? node2.parent.parent : node2.parent;
    const parentPrecedence = astUtils2.getPrecedence(parent);
    const needsParens = parent.type === "ClassDeclaration" || parent.type.endsWith("Expression") && (parentPrecedence === -1 || parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) && !(parent.type === "BinaryExpression" && parent.operator === "**" && parent.right === node2) && !((parent.type === "CallExpression" || parent.type === "NewExpression") && parent.arguments.includes(node2)) && !(parent.type === "MemberExpression" && parent.computed && parent.property === node2) && !(parent.type === "ArrayExpression");
    return needsParens && !astUtils2.isParenthesised(sourceCode2, node2);
  }
  function parenthesizeIfShould(text, shouldParenthesize) {
    return shouldParenthesize ? `(${text})` : text;
  }
  preferExponentiationOperator = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow the use of `Math.pow` in favor of the `**` operator",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-exponentiation-operator"
      },
      schema: [],
      fixable: "code",
      messages: {
        useExponentiation: "Use the '**' operator instead of 'Math.pow'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function report(node2) {
        context.report({
          node: node2,
          messageId: "useExponentiation",
          fix(fixer) {
            if (node2.arguments.length !== 2 || node2.arguments.some(
              (arg) => arg.type === "SpreadElement"
            ) || sourceCode2.getCommentsInside(node2).length > 0) {
              return null;
            }
            const base2 = node2.arguments[0], exponent = node2.arguments[1], baseText = sourceCode2.getText(base2), exponentText = sourceCode2.getText(exponent), shouldParenthesizeBase = doesBaseNeedParens(base2), shouldParenthesizeExponent = doesExponentNeedParens(exponent), shouldParenthesizeAll = doesExponentiationExpressionNeedParens(
              node2,
              sourceCode2
            );
            let prefix = "", suffix = "";
            if (!shouldParenthesizeAll) {
              if (!shouldParenthesizeBase) {
                const firstReplacementToken = sourceCode2.getFirstToken(base2), tokenBefore = sourceCode2.getTokenBefore(node2);
                if (tokenBefore && tokenBefore.range[1] === node2.range[0] && !astUtils2.canTokensBeAdjacent(
                  tokenBefore,
                  firstReplacementToken
                )) {
                  prefix = " ";
                }
              }
              if (!shouldParenthesizeExponent) {
                const lastReplacementToken = sourceCode2.getLastToken(exponent), tokenAfter = sourceCode2.getTokenAfter(node2);
                if (tokenAfter && node2.range[1] === tokenAfter.range[0] && !astUtils2.canTokensBeAdjacent(
                  lastReplacementToken,
                  tokenAfter
                )) {
                  suffix = " ";
                }
              }
            }
            const baseReplacement = parenthesizeIfShould(
              baseText,
              shouldParenthesizeBase
            ), exponentReplacement = parenthesizeIfShould(
              exponentText,
              shouldParenthesizeExponent
            ), replacement = parenthesizeIfShould(
              `${baseReplacement}**${exponentReplacement}`,
              shouldParenthesizeAll
            );
            return fixer.replaceText(
              node2,
              `${prefix}${replacement}${suffix}`
            );
          }
        });
      }
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          const trackMap = {
            Math: {
              pow: { [CALL]: true }
            }
          };
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            trackMap
          )) {
            report(refNode);
          }
        }
      };
    }
  };
  return preferExponentiationOperator;
}
var preferNamedCaptureGroup;
var hasRequiredPreferNamedCaptureGroup;
function requirePreferNamedCaptureGroup() {
  if (hasRequiredPreferNamedCaptureGroup) return preferNamedCaptureGroup;
  hasRequiredPreferNamedCaptureGroup = 1;
  const {
    CALL,
    CONSTRUCT,
    ReferenceTracker,
    getStringIfConstant
  } = /* @__PURE__ */ requireEslintUtils();
  const regexpp2 = requireRegexpp();
  const parser2 = new regexpp2.RegExpParser();
  function suggestIfPossible(groupStart, pattern2, rawText, regexNode) {
    switch (regexNode.type) {
      case "Literal":
        if (typeof regexNode.value === "string" && rawText.includes("\\")) {
          return null;
        }
        break;
      case "TemplateLiteral":
        if (regexNode.expressions.length || rawText.slice(1, -1) !== pattern2) {
          return null;
        }
        break;
      default:
        return null;
    }
    const start = regexNode.range[0] + groupStart + 2;
    return [
      {
        fix(fixer) {
          const existingTemps = pattern2.match(/temp\d+/gu) || [];
          const highestTempCount = existingTemps.reduce(
            (previous, next) => Math.max(previous, Number(next.slice("temp".length))),
            0
          );
          return fixer.insertTextBeforeRange(
            [start, start],
            `?<temp${highestTempCount + 1}>`
          );
        },
        messageId: "addGroupName"
      },
      {
        fix(fixer) {
          return fixer.insertTextBeforeRange([start, start], "?:");
        },
        messageId: "addNonCapture"
      }
    ];
  }
  preferNamedCaptureGroup = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Enforce using named capture group in regular expression",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-named-capture-group"
      },
      hasSuggestions: true,
      schema: [],
      messages: {
        addGroupName: "Add name to capture group.",
        addNonCapture: "Convert group to non-capturing.",
        required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkRegex(pattern2, node2, regexNode, flags2) {
        let ast2;
        try {
          ast2 = parser2.parsePattern(pattern2, 0, pattern2.length, {
            unicode: Boolean(flags2 && flags2.includes("u")),
            unicodeSets: Boolean(flags2 && flags2.includes("v"))
          });
        } catch {
          return;
        }
        regexpp2.visitRegExpAST(ast2, {
          onCapturingGroupEnter(group) {
            if (!group.name) {
              const rawText = sourceCode2.getText(regexNode);
              const suggest = suggestIfPossible(
                group.start,
                pattern2,
                rawText,
                regexNode
              );
              context.report({
                node: node2,
                messageId: "required",
                data: {
                  group: group.raw
                },
                suggest
              });
            }
          }
        });
      }
      return {
        Literal(node2) {
          if (node2.regex) {
            checkRegex(
              node2.regex.pattern,
              node2,
              node2,
              node2.regex.flags
            );
          }
        },
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          const traceMap = {
            RegExp: {
              [CALL]: true,
              [CONSTRUCT]: true
            }
          };
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            traceMap
          )) {
            const regex = getStringIfConstant(refNode.arguments[0]);
            const flags2 = getStringIfConstant(refNode.arguments[1]);
            if (regex) {
              checkRegex(regex, refNode, refNode.arguments[0], flags2);
            }
          }
        }
      };
    }
  };
  return preferNamedCaptureGroup;
}
var preferNumericLiterals;
var hasRequiredPreferNumericLiterals;
function requirePreferNumericLiterals() {
  if (hasRequiredPreferNumericLiterals) return preferNumericLiterals;
  hasRequiredPreferNumericLiterals = 1;
  const astUtils2 = requireAstUtils();
  const radixMap = /* @__PURE__ */ new Map([
    [2, { system: "binary", literalPrefix: "0b" }],
    [8, { system: "octal", literalPrefix: "0o" }],
    [16, { system: "hexadecimal", literalPrefix: "0x" }]
  ]);
  function isParseInt(calleeNode) {
    return astUtils2.isSpecificId(calleeNode, "parseInt") || astUtils2.isSpecificMemberAccess(calleeNode, "Number", "parseInt");
  }
  preferNumericLiterals = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-numeric-literals"
      },
      schema: [],
      messages: {
        useLiteral: "Use {{system}} literals instead of {{functionName}}()."
      },
      fixable: "code"
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        "CallExpression[arguments.length=2]"(node2) {
          const [strNode, radixNode] = node2.arguments, str = astUtils2.getStaticStringValue(strNode), radix2 = radixNode.value;
          if (str !== null && astUtils2.isStringLiteral(strNode) && radixNode.type === "Literal" && typeof radix2 === "number" && radixMap.has(radix2) && isParseInt(node2.callee)) {
            const { system, literalPrefix } = radixMap.get(radix2);
            context.report({
              node: node2,
              messageId: "useLiteral",
              data: {
                system,
                functionName: sourceCode2.getText(node2.callee)
              },
              fix(fixer) {
                if (sourceCode2.getCommentsInside(node2).length) {
                  return null;
                }
                const replacement = `${literalPrefix}${str}`;
                if (+replacement !== parseInt(str, radix2)) {
                  return null;
                }
                const tokenBefore = sourceCode2.getTokenBefore(node2), tokenAfter = sourceCode2.getTokenAfter(node2);
                let prefix = "", suffix = "";
                if (tokenBefore && tokenBefore.range[1] === node2.range[0] && !astUtils2.canTokensBeAdjacent(
                  tokenBefore,
                  replacement
                )) {
                  prefix = " ";
                }
                if (tokenAfter && node2.range[1] === tokenAfter.range[0] && !astUtils2.canTokensBeAdjacent(
                  replacement,
                  tokenAfter
                )) {
                  suffix = " ";
                }
                return fixer.replaceText(
                  node2,
                  `${prefix}${replacement}${suffix}`
                );
              }
            });
          }
        }
      };
    }
  };
  return preferNumericLiterals;
}
var preferObjectHasOwn;
var hasRequiredPreferObjectHasOwn;
function requirePreferObjectHasOwn() {
  if (hasRequiredPreferObjectHasOwn) return preferObjectHasOwn;
  hasRequiredPreferObjectHasOwn = 1;
  const astUtils2 = requireAstUtils();
  function hasLeftHandObject(node2) {
    if (node2.object.type === "ObjectExpression" && node2.object.properties.length === 0) {
      return true;
    }
    const objectNodeToCheck = node2.object.type === "MemberExpression" && astUtils2.getStaticPropertyName(node2.object) === "prototype" ? node2.object.object : node2.object;
    if (objectNodeToCheck.type === "Identifier" && objectNodeToCheck.name === "Object") {
      return true;
    }
    return false;
  }
  preferObjectHasOwn = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow use of `Object.prototype.hasOwnProperty.call()` and prefer use of `Object.hasOwn()`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-object-has-own"
      },
      schema: [],
      messages: {
        useHasOwn: "Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'."
      },
      fixable: "code"
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        CallExpression(node2) {
          if (!(node2.callee.type === "MemberExpression" && node2.callee.object.type === "MemberExpression")) {
            return;
          }
          const calleePropertyName = astUtils2.getStaticPropertyName(
            node2.callee
          );
          const objectPropertyName = astUtils2.getStaticPropertyName(
            node2.callee.object
          );
          const isObject = hasLeftHandObject(node2.callee.object);
          const scope = sourceCode2.getScope(node2);
          const variable = astUtils2.getVariableByName(scope, "Object");
          if (calleePropertyName === "call" && objectPropertyName === "hasOwnProperty" && isObject && variable && variable.scope.type === "global") {
            context.report({
              node: node2,
              messageId: "useHasOwn",
              fix(fixer) {
                if (sourceCode2.getCommentsInside(node2.callee).length > 0) {
                  return null;
                }
                const tokenJustBeforeNode = sourceCode2.getTokenBefore(node2.callee, {
                  includeComments: true
                });
                if (tokenJustBeforeNode && tokenJustBeforeNode.range[1] === node2.callee.range[0] && !astUtils2.canTokensBeAdjacent(
                  tokenJustBeforeNode,
                  "Object.hasOwn"
                )) {
                  return fixer.replaceText(
                    node2.callee,
                    " Object.hasOwn"
                  );
                }
                return fixer.replaceText(
                  node2.callee,
                  "Object.hasOwn"
                );
              }
            });
          }
        }
      };
    }
  };
  return preferObjectHasOwn;
}
var preferObjectSpread;
var hasRequiredPreferObjectSpread;
function requirePreferObjectSpread() {
  if (hasRequiredPreferObjectSpread) return preferObjectSpread;
  hasRequiredPreferObjectSpread = 1;
  const { CALL, ReferenceTracker } = /* @__PURE__ */ requireEslintUtils();
  const {
    isCommaToken,
    isOpeningParenToken,
    isClosingParenToken,
    isParenthesised
  } = requireAstUtils();
  const ANY_SPACE = /\s/u;
  function hasArraySpread(node2) {
    return node2.arguments.some((arg) => arg.type === "SpreadElement");
  }
  function isAccessorProperty(node2) {
    return node2.type === "Property" && (node2.kind === "get" || node2.kind === "set");
  }
  function hasAccessors(node2) {
    return node2.properties.some(isAccessorProperty);
  }
  function hasArgumentsWithAccessors(node2) {
    return node2.arguments.filter((arg) => arg.type === "ObjectExpression").some(hasAccessors);
  }
  function needsParens(node2, sourceCode2) {
    const parent = node2.parent;
    switch (parent.type) {
      case "VariableDeclarator":
      case "ArrayExpression":
      case "ReturnStatement":
      case "CallExpression":
      case "Property":
        return false;
      case "AssignmentExpression":
        return parent.left === node2 && !isParenthesised(sourceCode2, node2);
      default:
        return !isParenthesised(sourceCode2, node2);
    }
  }
  function argNeedsParens(node2, sourceCode2) {
    switch (node2.type) {
      case "AssignmentExpression":
      case "ArrowFunctionExpression":
      case "ConditionalExpression":
        return !isParenthesised(sourceCode2, node2);
      default:
        return false;
    }
  }
  function getParenTokens(node2, leftArgumentListParen, sourceCode2) {
    const parens = [
      sourceCode2.getFirstToken(node2),
      sourceCode2.getLastToken(node2)
    ];
    let leftNext = sourceCode2.getTokenBefore(node2);
    let rightNext = sourceCode2.getTokenAfter(node2);
    while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {
      parens.push(leftNext, rightNext);
      leftNext = sourceCode2.getTokenBefore(leftNext);
      rightNext = sourceCode2.getTokenAfter(rightNext);
    }
    return parens.sort((a2, b) => a2.range[0] - b.range[0]);
  }
  function getStartWithSpaces(token, sourceCode2) {
    const text = sourceCode2.text;
    let start = token.range[0];
    {
      const prevToken = sourceCode2.getTokenBefore(token, {
        includeComments: true
      });
      if (prevToken && prevToken.type === "Line") {
        return start;
      }
    }
    while (ANY_SPACE.test(text[start - 1] || "")) {
      start -= 1;
    }
    return start;
  }
  function getEndWithSpaces(token, sourceCode2) {
    const text = sourceCode2.text;
    let end = token.range[1];
    while (ANY_SPACE.test(text[end] || "")) {
      end += 1;
    }
    return end;
  }
  function defineFixer(node2, sourceCode2) {
    return function* (fixer) {
      const leftParen = sourceCode2.getTokenAfter(
        node2.callee,
        isOpeningParenToken
      );
      const rightParen = sourceCode2.getLastToken(node2);
      yield fixer.removeRange([node2.range[0], leftParen.range[0]]);
      if (needsParens(node2, sourceCode2)) {
        yield fixer.replaceText(leftParen, "({");
        yield fixer.replaceText(rightParen, "})");
      } else {
        yield fixer.replaceText(leftParen, "{");
        yield fixer.replaceText(rightParen, "}");
      }
      for (const argNode of node2.arguments) {
        const innerParens = getParenTokens(argNode, leftParen, sourceCode2);
        const left = innerParens.shift();
        const right = innerParens.pop();
        if (argNode.type === "ObjectExpression") {
          const maybeTrailingComma = sourceCode2.getLastToken(argNode, 1);
          const maybeArgumentComma = sourceCode2.getTokenAfter(right);
          for (const innerParen of innerParens) {
            yield fixer.remove(innerParen);
          }
          const leftRange = [
            left.range[0],
            getEndWithSpaces(left, sourceCode2)
          ];
          const rightRange = [
            Math.max(
              getStartWithSpaces(right, sourceCode2),
              leftRange[1]
            ),
            // Ensure ranges don't overlap
            right.range[1]
          ];
          yield fixer.removeRange(leftRange);
          yield fixer.removeRange(rightRange);
          if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {
            yield fixer.remove(maybeArgumentComma);
          }
        } else {
          if (argNeedsParens(argNode, sourceCode2)) {
            yield fixer.insertTextBefore(left, "...(");
            yield fixer.insertTextAfter(right, ")");
          } else {
            yield fixer.insertTextBefore(left, "...");
          }
        }
      }
    };
  }
  preferObjectSpread = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-object-spread"
      },
      schema: [],
      fixable: "code",
      messages: {
        useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
        useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          const trackMap = {
            Object: {
              assign: { [CALL]: true }
            }
          };
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            trackMap
          )) {
            if (refNode.arguments.length >= 1 && refNode.arguments[0].type === "ObjectExpression" && !hasArraySpread(refNode) && !(refNode.arguments.length > 1 && hasArgumentsWithAccessors(refNode))) {
              const messageId = refNode.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage";
              const fix = defineFixer(refNode, sourceCode2);
              context.report({ node: refNode, messageId, fix });
            }
          }
        }
      };
    }
  };
  return preferObjectSpread;
}
var preferPromiseRejectErrors;
var hasRequiredPreferPromiseRejectErrors;
function requirePreferPromiseRejectErrors() {
  if (hasRequiredPreferPromiseRejectErrors) return preferPromiseRejectErrors;
  hasRequiredPreferPromiseRejectErrors = 1;
  const astUtils2 = requireAstUtils();
  preferPromiseRejectErrors = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowEmptyReject: false
        }
      ],
      docs: {
        description: "Require using Error objects as Promise rejection reasons",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-promise-reject-errors"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowEmptyReject: { type: "boolean" }
          },
          additionalProperties: false
        }
      ],
      messages: {
        rejectAnError: "Expected the Promise rejection reason to be an Error."
      }
    },
    create(context) {
      const [{ allowEmptyReject }] = context.options;
      const sourceCode2 = context.sourceCode;
      function checkRejectCall(callExpression) {
        if (!callExpression.arguments.length && allowEmptyReject) {
          return;
        }
        if (!callExpression.arguments.length || !astUtils2.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
          context.report({
            node: callExpression,
            messageId: "rejectAnError"
          });
        }
      }
      function isPromiseRejectCall(node2) {
        return astUtils2.isSpecificMemberAccess(
          node2.callee,
          "Promise",
          "reject"
        );
      }
      return {
        // Check `Promise.reject(value)` calls.
        CallExpression(node2) {
          if (isPromiseRejectCall(node2)) {
            checkRejectCall(node2);
          }
        },
        /*
         * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.
         * This function is run on "NewExpression:exit" instead of "NewExpression" to ensure that
         * the nodes in the expression already have the `parent` property.
         */
        "NewExpression:exit"(node2) {
          if (node2.callee.type === "Identifier" && node2.callee.name === "Promise" && node2.arguments.length && astUtils2.isFunction(node2.arguments[0]) && node2.arguments[0].params.length > 1 && node2.arguments[0].params[1].type === "Identifier") {
            sourceCode2.getDeclaredVariables(node2.arguments[0]).find(
              (variable) => variable.name === node2.arguments[0].params[1].name
            ).references.filter((ref2) => ref2.isRead()).filter(
              (ref2) => ref2.identifier.parent.type === "CallExpression" && ref2.identifier === ref2.identifier.parent.callee
            ).forEach((ref2) => checkRejectCall(ref2.identifier.parent));
          }
        }
      };
    }
  };
  return preferPromiseRejectErrors;
}
var preferReflect;
var hasRequiredPreferReflect;
function requirePreferReflect() {
  if (hasRequiredPreferReflect) return preferReflect;
  hasRequiredPreferReflect = 1;
  preferReflect = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `Reflect` methods where applicable",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-reflect"
      },
      deprecated: {
        message: "The original intention of this rule was misguided.",
        deprecatedSince: "3.9.0",
        availableUntil: null,
        replacedBy: []
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                enum: [
                  "apply",
                  "call",
                  "delete",
                  "defineProperty",
                  "getOwnPropertyDescriptor",
                  "getPrototypeOf",
                  "setPrototypeOf",
                  "isExtensible",
                  "getOwnPropertyNames",
                  "preventExtensions"
                ]
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        preferReflect: "Avoid using {{existing}}, instead use {{substitute}}."
      }
    },
    create(context) {
      const existingNames = {
        apply: "Function.prototype.apply",
        call: "Function.prototype.call",
        defineProperty: "Object.defineProperty",
        getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
        getPrototypeOf: "Object.getPrototypeOf",
        setPrototypeOf: "Object.setPrototypeOf",
        isExtensible: "Object.isExtensible",
        getOwnPropertyNames: "Object.getOwnPropertyNames",
        preventExtensions: "Object.preventExtensions"
      };
      const reflectSubstitutes = {
        apply: "Reflect.apply",
        call: "Reflect.apply",
        defineProperty: "Reflect.defineProperty",
        getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
        getPrototypeOf: "Reflect.getPrototypeOf",
        setPrototypeOf: "Reflect.setPrototypeOf",
        isExtensible: "Reflect.isExtensible",
        getOwnPropertyNames: "Reflect.getOwnPropertyNames",
        preventExtensions: "Reflect.preventExtensions"
      };
      const exceptions = (context.options[0] || {}).exceptions || [];
      function report(node2, existing, substitute) {
        context.report({
          node: node2,
          messageId: "preferReflect",
          data: {
            existing,
            substitute
          }
        });
      }
      return {
        CallExpression(node2) {
          const methodName = (node2.callee.property || {}).name;
          const isReflectCall = (node2.callee.object || {}).name === "Reflect";
          const hasReflectSubstitute = Object.hasOwn(
            reflectSubstitutes,
            methodName
          );
          const userConfiguredException = exceptions.includes(methodName);
          if (hasReflectSubstitute && !isReflectCall && !userConfiguredException) {
            report(
              node2,
              existingNames[methodName],
              reflectSubstitutes[methodName]
            );
          }
        },
        UnaryExpression(node2) {
          const isDeleteOperator = node2.operator === "delete";
          const targetsIdentifier = node2.argument.type === "Identifier";
          const userConfiguredException = exceptions.includes("delete");
          if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
            report(
              node2,
              "the delete keyword",
              "Reflect.deleteProperty"
            );
          }
        }
      };
    }
  };
  return preferReflect;
}
var preferRegexLiterals;
var hasRequiredPreferRegexLiterals;
function requirePreferRegexLiterals() {
  if (hasRequiredPreferRegexLiterals) return preferRegexLiterals;
  hasRequiredPreferRegexLiterals = 1;
  const astUtils2 = requireAstUtils();
  const {
    CALL,
    CONSTRUCT,
    ReferenceTracker
  } = /* @__PURE__ */ requireEslintUtils();
  const {
    RegExpValidator,
    visitRegExpAST,
    RegExpParser
  } = requireRegexpp();
  const { canTokensBeAdjacent } = requireAstUtils();
  const { REGEXPP_LATEST_ECMA_VERSION } = requireRegularExpressions();
  function isStringLiteral(node2) {
    return node2.type === "Literal" && typeof node2.value === "string";
  }
  function isRegexLiteral(node2) {
    return node2.type === "Literal" && Object.hasOwn(node2, "regex");
  }
  const validPrecedingTokens = /* @__PURE__ */ new Set([
    "(",
    ";",
    "[",
    ",",
    "=",
    "+",
    "*",
    "-",
    "?",
    "~",
    "%",
    "**",
    "!",
    "typeof",
    "instanceof",
    "&&",
    "||",
    "??",
    "return",
    "...",
    "delete",
    "void",
    "in",
    "<",
    ">",
    "<=",
    ">=",
    "==",
    "===",
    "!=",
    "!==",
    "<<",
    ">>",
    ">>>",
    "&",
    "|",
    "^",
    ":",
    "{",
    "=>",
    "*=",
    "<<=",
    ">>=",
    ">>>=",
    "^=",
    "|=",
    "&=",
    "??=",
    "||=",
    "&&=",
    "**=",
    "+=",
    "-=",
    "/=",
    "%=",
    "/",
    "do",
    "break",
    "continue",
    "debugger",
    "case",
    "throw"
  ]);
  preferRegexLiterals = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          disallowRedundantWrapping: false
        }
      ],
      docs: {
        description: "Disallow use of the `RegExp` constructor in favor of regular expression literals",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-regex-literals"
      },
      hasSuggestions: true,
      schema: [
        {
          type: "object",
          properties: {
            disallowRedundantWrapping: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.",
        replaceWithLiteral: "Replace with an equivalent regular expression literal.",
        replaceWithLiteralAndFlags: "Replace with an equivalent regular expression literal with flags '{{ flags }}'.",
        replaceWithIntendedLiteralAndFlags: "Replace with a regular expression literal with flags '{{ flags }}'.",
        unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",
        unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor."
      }
    },
    create(context) {
      const [{ disallowRedundantWrapping }] = context.options;
      const sourceCode2 = context.sourceCode;
      function isStringRawTaggedStaticTemplateLiteral(node2) {
        return node2.type === "TaggedTemplateExpression" && astUtils2.isSpecificMemberAccess(node2.tag, "String", "raw") && sourceCode2.isGlobalReference(
          astUtils2.skipChainExpression(node2.tag).object
        ) && astUtils2.isStaticTemplateLiteral(node2.quasi);
      }
      function getStringValue(node2) {
        if (isStringLiteral(node2)) {
          return node2.value;
        }
        if (astUtils2.isStaticTemplateLiteral(node2)) {
          return node2.quasis[0].value.cooked;
        }
        if (isStringRawTaggedStaticTemplateLiteral(node2)) {
          return node2.quasi.quasis[0].value.raw;
        }
        return null;
      }
      function isStaticString(node2) {
        return isStringLiteral(node2) || astUtils2.isStaticTemplateLiteral(node2) || isStringRawTaggedStaticTemplateLiteral(node2);
      }
      function hasOnlyStaticStringArguments(node2) {
        const args = node2.arguments;
        if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {
          return true;
        }
        return false;
      }
      function isUnnecessarilyWrappedRegexLiteral(node2) {
        const args = node2.arguments;
        if (args.length === 1 && isRegexLiteral(args[0])) {
          return true;
        }
        if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {
          return true;
        }
        return false;
      }
      function getRegexppEcmaVersion(ecmaVersion2) {
        if (ecmaVersion2 <= 5) {
          return 5;
        }
        return Math.min(ecmaVersion2, REGEXPP_LATEST_ECMA_VERSION);
      }
      const regexppEcmaVersion = getRegexppEcmaVersion(
        context.languageOptions.ecmaVersion
      );
      function resolveEscapes(character) {
        switch (character) {
          case "\n":
          case "\\\n":
            return "\\n";
          case "\r":
          case "\\\r":
            return "\\r";
          case "	":
          case "\\	":
            return "\\t";
          case "\v":
          case "\\\v":
            return "\\v";
          case "\f":
          case "\\\f":
            return "\\f";
          case "/":
            return "\\/";
          default:
            return null;
        }
      }
      function isValidRegexForEcmaVersion(pattern2, flags2) {
        const validator = new RegExpValidator({
          ecmaVersion: regexppEcmaVersion
        });
        try {
          validator.validatePattern(pattern2, 0, pattern2.length, {
            unicode: flags2 ? flags2.includes("u") : false,
            unicodeSets: flags2 ? flags2.includes("v") : false
          });
          if (flags2) {
            validator.validateFlags(flags2);
          }
          return true;
        } catch {
          return false;
        }
      }
      function areFlagsEqual(flagsA, flagsB) {
        return [...flagsA].sort().join("") === [...flagsB].sort().join("");
      }
      function mergeRegexFlags(flagsA, flagsB) {
        const flagsSet = /* @__PURE__ */ new Set([...flagsA, ...flagsB]);
        return [...flagsSet].join("");
      }
      function canFixTo(node2, pattern2, flags2) {
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        return sourceCode2.getCommentsInside(node2).length === 0 && (!tokenBefore || validPrecedingTokens.has(tokenBefore.value)) && isValidRegexForEcmaVersion(pattern2, flags2);
      }
      function getSafeOutput(node2, newRegExpValue) {
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        const tokenAfter = sourceCode2.getTokenAfter(node2);
        return (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node2.range[0] ? " " : "") + newRegExpValue + (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node2.range[1] === tokenAfter.range[0] ? " " : "");
      }
      return {
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          const traceMap = {
            RegExp: {
              [CALL]: true,
              [CONSTRUCT]: true
            }
          };
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            traceMap
          )) {
            if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(refNode)) {
              const regexNode = refNode.arguments[0];
              if (refNode.arguments.length === 2) {
                const suggests = [];
                const argFlags = getStringValue(refNode.arguments[1]) || "";
                if (canFixTo(
                  refNode,
                  regexNode.regex.pattern,
                  argFlags
                )) {
                  suggests.push({
                    messageId: "replaceWithLiteralAndFlags",
                    pattern: regexNode.regex.pattern,
                    flags: argFlags
                  });
                }
                const literalFlags = regexNode.regex.flags || "";
                const mergedFlags = mergeRegexFlags(
                  literalFlags,
                  argFlags
                );
                if (!areFlagsEqual(mergedFlags, argFlags) && canFixTo(
                  refNode,
                  regexNode.regex.pattern,
                  mergedFlags
                )) {
                  suggests.push({
                    messageId: "replaceWithIntendedLiteralAndFlags",
                    pattern: regexNode.regex.pattern,
                    flags: mergedFlags
                  });
                }
                context.report({
                  node: refNode,
                  messageId: "unexpectedRedundantRegExpWithFlags",
                  suggest: suggests.map(
                    ({ flags: flags2, pattern: pattern2, messageId }) => ({
                      messageId,
                      data: {
                        flags: flags2
                      },
                      fix(fixer) {
                        return fixer.replaceText(
                          refNode,
                          getSafeOutput(
                            refNode,
                            `/${pattern2}/${flags2}`
                          )
                        );
                      }
                    })
                  )
                });
              } else {
                const outputs = [];
                if (canFixTo(
                  refNode,
                  regexNode.regex.pattern,
                  regexNode.regex.flags
                )) {
                  outputs.push(sourceCode2.getText(regexNode));
                }
                context.report({
                  node: refNode,
                  messageId: "unexpectedRedundantRegExp",
                  suggest: outputs.map((output) => ({
                    messageId: "replaceWithLiteral",
                    fix(fixer) {
                      return fixer.replaceText(
                        refNode,
                        getSafeOutput(refNode, output)
                      );
                    }
                  }))
                });
              }
            } else if (hasOnlyStaticStringArguments(refNode)) {
              let regexContent = getStringValue(refNode.arguments[0]);
              let noFix = false;
              let flags2;
              if (refNode.arguments[1]) {
                flags2 = getStringValue(refNode.arguments[1]);
              }
              if (!canFixTo(refNode, regexContent, flags2)) {
                noFix = true;
              }
              if (!/^[-\w\\[\](){} \t\r\n\v\f!@#$%^&*+=/~`.><?,'"|:;]*$/u.test(
                regexContent
              )) {
                noFix = true;
              }
              if (regexContent && !noFix) {
                let charIncrease = 0;
                const ast2 = new RegExpParser({
                  ecmaVersion: regexppEcmaVersion
                }).parsePattern(
                  regexContent,
                  0,
                  regexContent.length,
                  {
                    unicode: flags2 ? flags2.includes("u") : false,
                    unicodeSets: flags2 ? flags2.includes("v") : false
                  }
                );
                visitRegExpAST(ast2, {
                  onCharacterEnter(characterNode) {
                    const escaped = resolveEscapes(
                      characterNode.raw
                    );
                    if (escaped) {
                      regexContent = regexContent.slice(
                        0,
                        characterNode.start + charIncrease
                      ) + escaped + regexContent.slice(
                        characterNode.end + charIncrease
                      );
                      if (characterNode.raw.length === 1) {
                        charIncrease += 1;
                      }
                    }
                  }
                });
              }
              const newRegExpValue = `/${regexContent || "(?:)"}/${flags2 || ""}`;
              context.report({
                node: refNode,
                messageId: "unexpectedRegExp",
                suggest: noFix ? [] : [
                  {
                    messageId: "replaceWithLiteral",
                    fix(fixer) {
                      return fixer.replaceText(
                        refNode,
                        getSafeOutput(
                          refNode,
                          newRegExpValue
                        )
                      );
                    }
                  }
                ]
              });
            }
          }
        }
      };
    }
  };
  return preferRegexLiterals;
}
var preferRestParams;
var hasRequiredPreferRestParams;
function requirePreferRestParams() {
  if (hasRequiredPreferRestParams) return preferRestParams;
  hasRequiredPreferRestParams = 1;
  function getVariableOfArguments(scope) {
    const variables = scope.variables;
    for (let i2 = 0; i2 < variables.length; ++i2) {
      const variable = variables[i2];
      if (variable.name === "arguments") {
        return variable.identifiers.length === 0 ? variable : null;
      }
    }
    return null;
  }
  function isNotNormalMemberAccess(reference) {
    const id2 = reference.identifier;
    const parent = id2.parent;
    return !(parent.type === "MemberExpression" && parent.object === id2 && !parent.computed);
  }
  preferRestParams = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require rest parameters instead of `arguments`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/prefer-rest-params"
      },
      schema: [],
      messages: {
        preferRestParams: "Use the rest parameters instead of 'arguments'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function report(reference) {
        context.report({
          node: reference.identifier,
          loc: reference.identifier.loc,
          messageId: "preferRestParams"
        });
      }
      function checkForArguments(node2) {
        const argumentsVar = getVariableOfArguments(
          sourceCode2.getScope(node2)
        );
        if (argumentsVar) {
          argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
        }
      }
      return {
        "FunctionDeclaration:exit": checkForArguments,
        "FunctionExpression:exit": checkForArguments
      };
    }
  };
  return preferRestParams;
}
var preferSpread;
var hasRequiredPreferSpread;
function requirePreferSpread() {
  if (hasRequiredPreferSpread) return preferSpread;
  hasRequiredPreferSpread = 1;
  const astUtils2 = requireAstUtils();
  function isVariadicApplyCalling(node2) {
    return astUtils2.isSpecificMemberAccess(node2.callee, null, "apply") && node2.arguments.length === 2 && node2.arguments[1].type !== "ArrayExpression" && node2.arguments[1].type !== "SpreadElement";
  }
  function isValidThisArg(expectedThis, thisArg, context) {
    if (!expectedThis) {
      return astUtils2.isNullOrUndefined(thisArg);
    }
    return astUtils2.equalTokens(expectedThis, thisArg, context);
  }
  preferSpread = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require spread operators instead of `.apply()`",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-spread"
      },
      schema: [],
      fixable: null,
      messages: {
        preferSpread: "Use the spread operator instead of '.apply()'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        CallExpression(node2) {
          if (!isVariadicApplyCalling(node2)) {
            return;
          }
          const applied = astUtils2.skipChainExpression(
            astUtils2.skipChainExpression(node2.callee).object
          );
          const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
          const thisArg = node2.arguments[0];
          if (isValidThisArg(expectedThis, thisArg, sourceCode2)) {
            context.report({
              node: node2,
              messageId: "preferSpread"
            });
          }
        }
      };
    }
  };
  return preferSpread;
}
var preferTemplate;
var hasRequiredPreferTemplate;
function requirePreferTemplate() {
  if (hasRequiredPreferTemplate) return preferTemplate;
  hasRequiredPreferTemplate = 1;
  const astUtils2 = requireAstUtils();
  function isConcatenation(node2) {
    return node2.type === "BinaryExpression" && node2.operator === "+";
  }
  function getTopConcatBinaryExpression(node2) {
    let currentNode = node2;
    while (isConcatenation(currentNode.parent)) {
      currentNode = currentNode.parent;
    }
    return currentNode;
  }
  function hasOctalOrNonOctalDecimalEscapeSequence(node2) {
    if (isConcatenation(node2)) {
      return hasOctalOrNonOctalDecimalEscapeSequence(node2.left) || hasOctalOrNonOctalDecimalEscapeSequence(node2.right);
    }
    if (node2.type === "Literal" && typeof node2.value === "string") {
      return astUtils2.hasOctalOrNonOctalDecimalEscapeSequence(node2.raw);
    }
    return false;
  }
  function hasStringLiteral(node2) {
    if (isConcatenation(node2)) {
      return hasStringLiteral(node2.right) || hasStringLiteral(node2.left);
    }
    return astUtils2.isStringLiteral(node2);
  }
  function hasNonStringLiteral(node2) {
    if (isConcatenation(node2)) {
      return hasNonStringLiteral(node2.right) || hasNonStringLiteral(node2.left);
    }
    return !astUtils2.isStringLiteral(node2);
  }
  function startsWithTemplateCurly(node2) {
    if (node2.type === "BinaryExpression") {
      return startsWithTemplateCurly(node2.left);
    }
    if (node2.type === "TemplateLiteral") {
      return node2.expressions.length && node2.quasis.length && node2.quasis[0].range[0] === node2.quasis[0].range[1];
    }
    return node2.type !== "Literal" || typeof node2.value !== "string";
  }
  function endsWithTemplateCurly(node2) {
    if (node2.type === "BinaryExpression") {
      return startsWithTemplateCurly(node2.right);
    }
    if (node2.type === "TemplateLiteral") {
      return node2.expressions.length && node2.quasis.length && node2.quasis.at(-1).range[0] === node2.quasis.at(-1).range[1];
    }
    return node2.type !== "Literal" || typeof node2.value !== "string";
  }
  preferTemplate = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require template literals instead of string concatenation",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/prefer-template"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedStringConcatenation: "Unexpected string concatenation."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let done = /* @__PURE__ */ Object.create(null);
      function getTextBetween(node1, node2) {
        const allTokens = [node1].concat(sourceCode2.getTokensBetween(node1, node2)).concat(node2);
        const sourceText = sourceCode2.getText();
        return allTokens.slice(0, -1).reduce(
          (accumulator, token, index) => accumulator + sourceText.slice(
            token.range[1],
            allTokens[index + 1].range[0]
          ),
          ""
        );
      }
      function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
        if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
          return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, (matched) => {
            if (matched.lastIndexOf("\\") % 2) {
              return `\\${matched}`;
            }
            return matched;
          }).replace(
            new RegExp(`\\\\${currentNode.raw[0]}`, "gu"),
            currentNode.raw[0]
          )}\``;
        }
        if (currentNode.type === "TemplateLiteral") {
          return sourceCode2.getText(currentNode);
        }
        if (isConcatenation(currentNode) && hasStringLiteral(currentNode)) {
          const plusSign = sourceCode2.getFirstTokenBetween(
            currentNode.left,
            currentNode.right,
            (token) => token.value === "+"
          );
          const textBeforePlus = getTextBetween(
            currentNode.left,
            plusSign
          );
          const textAfterPlus = getTextBetween(
            plusSign,
            currentNode.right
          );
          const leftEndsWithCurly = endsWithTemplateCurly(
            currentNode.left
          );
          const rightStartsWithCurly = startsWithTemplateCurly(
            currentNode.right
          );
          if (leftEndsWithCurly) {
            return getTemplateLiteral(
              currentNode.left,
              textBeforeNode,
              textBeforePlus + textAfterPlus
            ).slice(0, -1) + getTemplateLiteral(
              currentNode.right,
              null,
              textAfterNode
            ).slice(1);
          }
          if (rightStartsWithCurly) {
            return getTemplateLiteral(
              currentNode.left,
              textBeforeNode,
              null
            ).slice(0, -1) + getTemplateLiteral(
              currentNode.right,
              textBeforePlus + textAfterPlus,
              textAfterNode
            ).slice(1);
          }
          return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
        }
        return `\`\${${textBeforeNode || ""}${sourceCode2.getText(currentNode)}${textAfterNode || ""}}\``;
      }
      function fixNonStringBinaryExpression(fixer, node2) {
        const topBinaryExpr = getTopConcatBinaryExpression(node2.parent);
        if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {
          return null;
        }
        return fixer.replaceText(
          topBinaryExpr,
          getTemplateLiteral(topBinaryExpr, null, null)
        );
      }
      function checkForStringConcat(node2) {
        if (!astUtils2.isStringLiteral(node2) || !isConcatenation(node2.parent)) {
          return;
        }
        const topBinaryExpr = getTopConcatBinaryExpression(node2.parent);
        if (done[topBinaryExpr.range[0]]) {
          return;
        }
        done[topBinaryExpr.range[0]] = true;
        if (hasNonStringLiteral(topBinaryExpr)) {
          context.report({
            node: topBinaryExpr,
            messageId: "unexpectedStringConcatenation",
            fix: (fixer) => fixNonStringBinaryExpression(fixer, node2)
          });
        }
      }
      return {
        Program() {
          done = /* @__PURE__ */ Object.create(null);
        },
        Literal: checkForStringConcat,
        TemplateLiteral: checkForStringConcat
      };
    }
  };
  return preferTemplate;
}
var preserveCaughtError;
var hasRequiredPreserveCaughtError;
function requirePreserveCaughtError() {
  if (hasRequiredPreserveCaughtError) return preserveCaughtError;
  hasRequiredPreserveCaughtError = 1;
  const astUtils2 = requireAstUtils();
  const UNKNOWN_CAUSE = Symbol("unknown_cause");
  const BUILT_IN_ERROR_TYPES = /* @__PURE__ */ new Set([
    "Error",
    "EvalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError",
    "AggregateError"
  ]);
  function getErrorCause(throwStatement) {
    const throwExpression = throwStatement.argument;
    const optionsIndex = throwExpression.callee.name === "AggregateError" ? 2 : 1;
    const spreadExpressionIndex = throwExpression.arguments.findIndex(
      (arg) => arg.type === "SpreadElement"
    );
    if (spreadExpressionIndex >= 0 && spreadExpressionIndex <= optionsIndex) {
      return UNKNOWN_CAUSE;
    }
    const errorOptions = throwExpression.arguments[optionsIndex];
    if (errorOptions) {
      if (errorOptions.type === "ObjectExpression") {
        if (errorOptions.properties.some(
          (prop) => prop.type === "SpreadElement"
        )) {
          return UNKNOWN_CAUSE;
        }
        const causeProperties = errorOptions.properties.filter(
          (prop) => astUtils2.getStaticPropertyName(prop) === "cause"
        );
        const causeProperty = causeProperties.at(-1);
        return causeProperty ? {
          value: causeProperty.value,
          multipleDefinitions: causeProperties.length > 1
        } : null;
      }
      return UNKNOWN_CAUSE;
    }
    return null;
  }
  function findParentCatch(node2) {
    let currentNode = node2;
    while (currentNode && currentNode.type !== "CatchClause") {
      if ([
        "FunctionDeclaration",
        "FunctionExpression",
        "ArrowFunctionExpression",
        "StaticBlock"
      ].includes(currentNode.type)) {
        return null;
      }
      currentNode = currentNode.parent;
    }
    return currentNode;
  }
  preserveCaughtError = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          requireCatchParameter: false
        }
      ],
      docs: {
        description: "Disallow losing originally caught error when re-throwing custom errors",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/preserve-caught-error"
        // URL to the documentation page for this rule
      },
      /*
       * TODO: We should allow passing `customErrorTypes` option once something like `typescript-eslint`'s
       * 		`TypeOrValueSpecifier` is implemented in core Eslint.
       *      See:
       * 		1. https://typescript-eslint.io/packages/type-utils/type-or-value-specifier/
       *      2. https://github.com/eslint/eslint/pull/19913#discussion_r2192608593
       *      3. https://github.com/eslint/eslint/discussions/16540
       */
      schema: [
        {
          type: "object",
          properties: {
            requireCatchParameter: {
              type: "boolean",
              description: "Requires the catch blocks to always have the caught error parameter so it is not discarded."
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingCause: "There is no `cause` attached to the symptom error being thrown.",
        incorrectCause: "The symptom error is being thrown with an incorrect `cause`.",
        includeCause: "Include the original caught error as the `cause` of the symptom error.",
        missingCatchErrorParam: "The caught error is not accessible because the catch clause lacks the error parameter. Start referencing the caught error using the catch parameter.",
        partiallyLostError: "Re-throws cannot preserve the caught error as a part of it is being lost due to destructuring.",
        caughtErrorShadowed: "The caught error is being attached as `cause`, but is shadowed by a closer scoped redeclaration."
      },
      hasSuggestions: true
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ requireCatchParameter }] = context.options;
      function isThrowingNewError(throwStatement) {
        return (throwStatement.argument.type === "NewExpression" || throwStatement.argument.type === "CallExpression") && throwStatement.argument.callee.type === "Identifier" && BUILT_IN_ERROR_TYPES.has(throwStatement.argument.callee.name) && /*
         * Make sure the thrown Error is instance is one of the built-in global error types.
         * Custom imports could shadow this, which would lead to false positives.
         * e.g. import { Error } from "./my-custom-error.js";
         *      throw Error("Failed to perform error prone operations");
         */
        sourceCode2.isGlobalReference(throwStatement.argument.callee);
      }
      function insertCauseIntoOptions(fixer, optionsNode, caughtErrorName) {
        const properties2 = optionsNode.properties;
        if (properties2.length === 0) {
          return fixer.insertTextAfter(
            sourceCode2.getFirstToken(optionsNode),
            `cause: ${caughtErrorName}`
          );
        }
        const lastProp = properties2.at(-1);
        return fixer.insertTextAfter(
          lastProp,
          `, cause: ${caughtErrorName}`
        );
      }
      return {
        ThrowStatement(node2) {
          var _a2;
          const parentCatch = findParentCatch(node2);
          const throwStatement = node2;
          if (parentCatch && isThrowingNewError(throwStatement)) {
            if (parentCatch.param && parentCatch.param.type !== "Identifier") {
              context.report({
                messageId: "partiallyLostError",
                node: parentCatch
              });
              return;
            }
            const caughtError = ((_a2 = parentCatch.param) == null ? void 0 : _a2.type) === "Identifier" ? parentCatch.param : null;
            if (!caughtError) {
              if (requireCatchParameter) {
                context.report({
                  node: throwStatement,
                  messageId: "missingCatchErrorParam"
                });
                return;
              }
              return;
            }
            const errorCauseInfo = getErrorCause(throwStatement);
            if (errorCauseInfo === UNKNOWN_CAUSE) {
              return;
            }
            if (errorCauseInfo === null) {
              context.report({
                messageId: "missingCause",
                node: throwStatement,
                suggest: [
                  {
                    messageId: "includeCause",
                    fix(fixer) {
                      const throwExpression = throwStatement.argument;
                      const args = throwExpression.arguments;
                      const errorType = throwExpression.callee.name;
                      if (errorType === "AggregateError") {
                        const errorsArg = args[0];
                        const messageArg2 = args[1];
                        const optionsArg2 = args[2];
                        if (!errorsArg) {
                          const lastToken = sourceCode2.getLastToken(
                            throwExpression
                          );
                          const lastCalleeToken = sourceCode2.getLastToken(
                            throwExpression.callee
                          );
                          const parenToken = sourceCode2.getFirstTokenBetween(
                            lastCalleeToken,
                            lastToken,
                            astUtils2.isOpeningParenToken
                          );
                          if (parenToken) {
                            return fixer.insertTextAfter(
                              parenToken,
                              `[], "", { cause: ${caughtError.name} }`
                            );
                          }
                          return fixer.insertTextAfter(
                            throwExpression.callee,
                            `([], "", { cause: ${caughtError.name} })`
                          );
                        }
                        if (!messageArg2) {
                          return fixer.insertTextAfter(
                            errorsArg,
                            `, "", { cause: ${caughtError.name} }`
                          );
                        }
                        if (!optionsArg2) {
                          return fixer.insertTextAfter(
                            messageArg2,
                            `, { cause: ${caughtError.name} }`
                          );
                        }
                        if (optionsArg2.type === "ObjectExpression") {
                          return insertCauseIntoOptions(
                            fixer,
                            optionsArg2,
                            caughtError.name
                          );
                        }
                        return null;
                      }
                      const messageArg = args[0];
                      const optionsArg = args[1];
                      if (!messageArg) {
                        const lastToken = sourceCode2.getLastToken(
                          throwExpression
                        );
                        const lastCalleeToken = sourceCode2.getLastToken(
                          throwExpression.callee
                        );
                        const parenToken = sourceCode2.getFirstTokenBetween(
                          lastCalleeToken,
                          lastToken,
                          astUtils2.isOpeningParenToken
                        );
                        if (parenToken) {
                          return fixer.insertTextAfter(
                            parenToken,
                            `"", { cause: ${caughtError.name} }`
                          );
                        }
                        return fixer.insertTextAfter(
                          throwExpression.callee,
                          `("", { cause: ${caughtError.name} })`
                        );
                      }
                      if (!optionsArg) {
                        return fixer.insertTextAfter(
                          messageArg,
                          `, { cause: ${caughtError.name} }`
                        );
                      }
                      if (optionsArg.type === "ObjectExpression") {
                        return insertCauseIntoOptions(
                          fixer,
                          optionsArg,
                          caughtError.name
                        );
                      }
                      return null;
                    }
                  }
                ]
              });
              return;
            }
            const { value: thrownErrorCause } = errorCauseInfo;
            if (!(thrownErrorCause.type === "Identifier" && thrownErrorCause.name === caughtError.name)) {
              const suggest = errorCauseInfo.multipleDefinitions ? null : [
                {
                  messageId: "includeCause",
                  fix(fixer) {
                    if (thrownErrorCause.parent.method || thrownErrorCause.parent.shorthand || thrownErrorCause.parent.kind !== "init") {
                      return fixer.replaceText(
                        thrownErrorCause.parent,
                        `cause: ${caughtError.name}`
                      );
                    }
                    return fixer.replaceText(
                      thrownErrorCause,
                      caughtError.name
                    );
                  }
                }
              ];
              context.report({
                messageId: "incorrectCause",
                node: thrownErrorCause,
                suggest
              });
              return;
            }
            let scope = sourceCode2.getScope(throwStatement);
            do {
              const variable = scope.set.get(caughtError.name);
              if (variable) {
                break;
              }
              scope = scope.upper;
            } while (scope);
            if ((scope == null ? void 0 : scope.block) !== parentCatch) {
              context.report({
                messageId: "caughtErrorShadowed",
                node: throwStatement
              });
            }
          }
        }
      };
    }
  };
  return preserveCaughtError;
}
var quoteProps;
var hasRequiredQuoteProps;
function requireQuoteProps() {
  if (hasRequiredQuoteProps) return quoteProps;
  hasRequiredQuoteProps = 1;
  const espree2 = requireEspree();
  const astUtils2 = requireAstUtils();
  const keywords2 = requireKeywords();
  quoteProps = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "quote-props",
              url: "https://eslint.style/rules/quote-props"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Require quotes around object literal property names",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/quote-props"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: [
                  "always",
                  "as-needed",
                  "consistent",
                  "consistent-as-needed"
                ]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: [
                  "always",
                  "as-needed",
                  "consistent",
                  "consistent-as-needed"
                ]
              },
              {
                type: "object",
                properties: {
                  keywords: {
                    type: "boolean"
                  },
                  unnecessary: {
                    type: "boolean"
                  },
                  numbers: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
        inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
        unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
        unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
        unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
        unquotedPropertyFound: "Unquoted property '{{property}}' found.",
        redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
      }
    },
    create(context) {
      const MODE = context.options[0], KEYWORDS = context.options[1] && context.options[1].keywords, CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false, NUMBERS = context.options[1] && context.options[1].numbers, sourceCode2 = context.sourceCode;
      function isKeyword(tokenStr) {
        return keywords2.includes(tokenStr);
      }
      function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
        return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].includes(
          tokens[0].type
        ) || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
      }
      function getUnquotedKey(key) {
        return key.type === "Identifier" ? key.name : key.value;
      }
      function getQuotedKey(key) {
        if (key.type === "Literal" && typeof key.value === "string") {
          return sourceCode2.getText(key);
        }
        return `"${key.type === "Identifier" ? key.name : key.value}"`;
      }
      function checkUnnecessaryQuotes(node2) {
        const key = node2.key;
        if (node2.method || node2.computed || node2.shorthand) {
          return;
        }
        if (key.type === "Literal" && typeof key.value === "string") {
          let tokens;
          try {
            tokens = espree2.tokenize(key.value);
          } catch {
            return;
          }
          if (tokens.length !== 1) {
            return;
          }
          const isKeywordToken = isKeyword(tokens[0].value);
          if (isKeywordToken && KEYWORDS) {
            return;
          }
          if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
            context.report({
              node: node2,
              messageId: "unnecessarilyQuotedProperty",
              data: { property: key.value },
              fix: (fixer) => fixer.replaceText(key, getUnquotedKey(key))
            });
          }
        } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
          context.report({
            node: node2,
            messageId: "unquotedReservedProperty",
            data: { property: key.name },
            fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
          });
        } else if (NUMBERS && key.type === "Literal" && astUtils2.isNumericLiteral(key)) {
          context.report({
            node: node2,
            messageId: "unquotedNumericProperty",
            data: { property: key.value },
            fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
          });
        }
      }
      function checkOmittedQuotes(node2) {
        const key = node2.key;
        if (!node2.method && !node2.computed && !node2.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
          context.report({
            node: node2,
            messageId: "unquotedPropertyFound",
            data: { property: key.name || key.value },
            fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
          });
        }
      }
      function checkConsistency(node2, checkQuotesRedundancy) {
        const quotedProps = [], unquotedProps = [];
        let keywordKeyName = null, necessaryQuotes = false;
        node2.properties.forEach((property) => {
          const key = property.key;
          if (!key || property.method || property.computed || property.shorthand) {
            return;
          }
          if (key.type === "Literal" && typeof key.value === "string") {
            quotedProps.push(property);
            if (checkQuotesRedundancy) {
              let tokens;
              try {
                tokens = espree2.tokenize(key.value);
              } catch {
                necessaryQuotes = true;
                return;
              }
              necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
            }
          } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
            unquotedProps.push(property);
            necessaryQuotes = true;
            keywordKeyName = key.name;
          } else {
            unquotedProps.push(property);
          }
        });
        if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
          quotedProps.forEach((property) => {
            context.report({
              node: property,
              messageId: "redundantQuoting",
              fix: (fixer) => fixer.replaceText(
                property.key,
                getUnquotedKey(property.key)
              )
            });
          });
        } else if (unquotedProps.length && keywordKeyName) {
          unquotedProps.forEach((property) => {
            context.report({
              node: property,
              messageId: "requireQuotesDueToReservedWord",
              data: { property: keywordKeyName },
              fix: (fixer) => fixer.replaceText(
                property.key,
                getQuotedKey(property.key)
              )
            });
          });
        } else if (quotedProps.length && unquotedProps.length) {
          unquotedProps.forEach((property) => {
            context.report({
              node: property,
              messageId: "inconsistentlyQuotedProperty",
              data: { key: property.key.name || property.key.value },
              fix: (fixer) => fixer.replaceText(
                property.key,
                getQuotedKey(property.key)
              )
            });
          });
        }
      }
      return {
        Property(node2) {
          if (MODE === "always" || !MODE) {
            checkOmittedQuotes(node2);
          }
          if (MODE === "as-needed") {
            checkUnnecessaryQuotes(node2);
          }
        },
        ObjectExpression(node2) {
          if (MODE === "consistent") {
            checkConsistency(node2, false);
          }
          if (MODE === "consistent-as-needed") {
            checkConsistency(node2, true);
          }
        }
      };
    }
  };
  return quoteProps;
}
var quotes;
var hasRequiredQuotes;
function requireQuotes() {
  if (hasRequiredQuotes) return quotes;
  hasRequiredQuotes = 1;
  const astUtils2 = requireAstUtils();
  const QUOTE_SETTINGS = {
    double: {
      quote: '"',
      alternateQuote: "'",
      description: "doublequote"
    },
    single: {
      quote: "'",
      alternateQuote: '"',
      description: "singlequote"
    },
    backtick: {
      quote: "`",
      alternateQuote: '"',
      description: "backtick"
    }
  };
  const UNESCAPED_LINEBREAK_PATTERN = new RegExp(
    String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils2.LINEBREAKS).join("")}]`,
    "u"
  );
  QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function(str) {
    const newQuote = this.quote;
    const oldQuote = str[0];
    if (newQuote === oldQuote) {
      return str;
    }
    return newQuote + str.slice(1, -1).replace(
      /\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu,
      (match, escaped, newline2) => {
        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
          return escaped;
        }
        if (match === newQuote || newQuote === "`" && match === "${") {
          return `\\${match}`;
        }
        if (newline2 && oldQuote === "`") {
          return "\\n";
        }
        return match;
      }
    ) + newQuote;
  };
  const AVOID_ESCAPE = "avoid-escape";
  quotes = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "quotes",
              url: "https://eslint.style/rules/quotes"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce the consistent use of either backticks, double, or single quotes",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/quotes"
      },
      fixable: "code",
      schema: [
        {
          enum: ["single", "double", "backtick"]
        },
        {
          anyOf: [
            {
              enum: ["avoid-escape"]
            },
            {
              type: "object",
              properties: {
                avoidEscape: {
                  type: "boolean"
                },
                allowTemplateLiterals: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        wrongQuotes: "Strings must use {{description}}."
      }
    },
    create(context) {
      const quoteOption = context.options[0], settings = QUOTE_SETTINGS[quoteOption || "double"], options = context.options[1], allowTemplateLiterals = options && options.allowTemplateLiterals === true, sourceCode2 = context.sourceCode;
      let avoidEscape = options && options.avoidEscape === true;
      if (options === AVOID_ESCAPE) {
        avoidEscape = true;
      }
      function isJSXLiteral(node2) {
        return node2.parent.type === "JSXAttribute" || node2.parent.type === "JSXElement" || node2.parent.type === "JSXFragment";
      }
      function isDirective(node2) {
        return node2.type === "ExpressionStatement" && node2.expression.type === "Literal" && typeof node2.expression.value === "string" && !astUtils2.isParenthesised(sourceCode2, node2.expression);
      }
      function isExpressionInOrJustAfterDirectivePrologue(node2) {
        if (!astUtils2.isTopLevelExpressionStatement(node2.parent)) {
          return false;
        }
        const block = node2.parent.parent;
        for (let i2 = 0; i2 < block.body.length; ++i2) {
          const statement = block.body[i2];
          if (statement === node2.parent) {
            return true;
          }
          if (!isDirective(statement)) {
            break;
          }
        }
        return false;
      }
      function isAllowedAsNonBacktick(node2) {
        const parent = node2.parent;
        switch (parent.type) {
          case "ExpressionStatement":
            return !astUtils2.isParenthesised(sourceCode2, node2) && isExpressionInOrJustAfterDirectivePrologue(node2);
          case "Property":
          case "PropertyDefinition":
          case "MethodDefinition":
            return parent.key === node2 && !parent.computed;
          case "ImportDeclaration":
          case "ExportNamedDeclaration":
            return parent.source === node2;
          case "ExportAllDeclaration":
            return parent.exported === node2 || parent.source === node2;
          case "ImportSpecifier":
            return parent.imported === node2;
          case "ExportSpecifier":
            return parent.local === node2 || parent.exported === node2;
          default:
            return false;
        }
      }
      function isUsingFeatureOfTemplateLiteral(node2) {
        const hasTag = node2.parent.type === "TaggedTemplateExpression" && node2 === node2.parent.quasi;
        if (hasTag) {
          return true;
        }
        const hasStringInterpolation = node2.expressions.length > 0;
        if (hasStringInterpolation) {
          return true;
        }
        const isMultilineString = node2.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node2.quasis[0].value.raw);
        if (isMultilineString) {
          return true;
        }
        return false;
      }
      return {
        Literal(node2) {
          const val = node2.value, rawVal = node2.raw;
          if (settings && typeof val === "string") {
            let isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node2) || isJSXLiteral(node2) || astUtils2.isSurroundedBy(rawVal, settings.quote);
            if (!isValid && avoidEscape) {
              isValid = astUtils2.isSurroundedBy(
                rawVal,
                settings.alternateQuote
              ) && rawVal.includes(settings.quote);
            }
            if (!isValid) {
              context.report({
                node: node2,
                messageId: "wrongQuotes",
                data: {
                  description: settings.description
                },
                fix(fixer) {
                  if (quoteOption === "backtick" && astUtils2.hasOctalOrNonOctalDecimalEscapeSequence(
                    rawVal
                  )) {
                    return null;
                  }
                  return fixer.replaceText(
                    node2,
                    settings.convert(node2.raw)
                  );
                }
              });
            }
          }
        },
        TemplateLiteral(node2) {
          if (allowTemplateLiterals || quoteOption === "backtick" || isUsingFeatureOfTemplateLiteral(node2)) {
            return;
          }
          context.report({
            node: node2,
            messageId: "wrongQuotes",
            data: {
              description: settings.description
            },
            fix(fixer) {
              if (astUtils2.isTopLevelExpressionStatement(
                node2.parent
              ) && !astUtils2.isParenthesised(sourceCode2, node2)) {
                return null;
              }
              return fixer.replaceText(
                node2,
                settings.convert(sourceCode2.getText(node2))
              );
            }
          });
        }
      };
    }
  };
  return quotes;
}
var radix;
var hasRequiredRadix;
function requireRadix() {
  if (hasRequiredRadix) return radix;
  hasRequiredRadix = 1;
  const astUtils2 = requireAstUtils();
  const MODE_ALWAYS = "always", MODE_AS_NEEDED = "as-needed";
  const validRadixValues = new Set(
    Array.from({ length: 37 - 2 }, (_, index) => index + 2)
  );
  function isShadowed(variable) {
    return variable.defs.length >= 1;
  }
  function isParseIntMethod(node2) {
    return node2.type === "MemberExpression" && !node2.computed && node2.property.type === "Identifier" && node2.property.name === "parseInt";
  }
  function isValidRadix(radix2) {
    return !(radix2.type === "Literal" && !validRadixValues.has(radix2.value) || radix2.type === "Identifier" && radix2.name === "undefined");
  }
  function isDefaultRadix(radix2) {
    return radix2.type === "Literal" && radix2.value === 10;
  }
  radix = {
    meta: {
      type: "suggestion",
      defaultOptions: [MODE_ALWAYS],
      docs: {
        description: "Enforce the consistent use of the radix argument when using `parseInt()`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/radix"
      },
      hasSuggestions: true,
      schema: [
        {
          enum: ["always", "as-needed"]
        }
      ],
      messages: {
        missingParameters: "Missing parameters.",
        redundantRadix: "Redundant radix parameter.",
        missingRadix: "Missing radix parameter.",
        invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36.",
        addRadixParameter10: "Add radix parameter `10` for parsing decimal numbers."
      }
    },
    create(context) {
      const [mode] = context.options;
      const sourceCode2 = context.sourceCode;
      function checkArguments(node2) {
        const args = node2.arguments;
        switch (args.length) {
          case 0:
            context.report({
              node: node2,
              messageId: "missingParameters"
            });
            break;
          case 1:
            if (mode === MODE_ALWAYS) {
              context.report({
                node: node2,
                messageId: "missingRadix",
                suggest: [
                  {
                    messageId: "addRadixParameter10",
                    fix(fixer) {
                      const tokens = sourceCode2.getTokens(node2);
                      const lastToken = tokens.at(-1);
                      const secondToLastToken = tokens.at(-2);
                      const hasTrailingComma = secondToLastToken.type === "Punctuator" && secondToLastToken.value === ",";
                      return fixer.insertTextBefore(
                        lastToken,
                        hasTrailingComma ? " 10," : ", 10"
                      );
                    }
                  }
                ]
              });
            }
            break;
          default:
            if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
              context.report({
                node: node2,
                messageId: "redundantRadix"
              });
            } else if (!isValidRadix(args[1])) {
              context.report({
                node: node2,
                messageId: "invalidRadix"
              });
            }
            break;
        }
      }
      return {
        "Program:exit"(node2) {
          const scope = sourceCode2.getScope(node2);
          let variable;
          variable = astUtils2.getVariableByName(scope, "parseInt");
          if (variable && !isShadowed(variable)) {
            variable.references.forEach((reference) => {
              const idNode = reference.identifier;
              if (astUtils2.isCallee(idNode)) {
                checkArguments(idNode.parent);
              }
            });
          }
          variable = astUtils2.getVariableByName(scope, "Number");
          if (variable && !isShadowed(variable)) {
            variable.references.forEach((reference) => {
              const parentNode = reference.identifier.parent;
              const maybeCallee = parentNode.parent.type === "ChainExpression" ? parentNode.parent : parentNode;
              if (isParseIntMethod(parentNode) && astUtils2.isCallee(maybeCallee)) {
                checkArguments(maybeCallee.parent);
              }
            });
          }
        }
      };
    }
  };
  return radix;
}
var requireAtomicUpdates;
var hasRequiredRequireAtomicUpdates;
function requireRequireAtomicUpdates() {
  if (hasRequiredRequireAtomicUpdates) return requireAtomicUpdates;
  hasRequiredRequireAtomicUpdates = 1;
  function createReferenceMap(scope, outReferenceMap = /* @__PURE__ */ new Map()) {
    for (const reference of scope.references) {
      if (reference.resolved === null) {
        continue;
      }
      outReferenceMap.set(reference.identifier, reference);
    }
    for (const childScope of scope.childScopes) {
      if (childScope.type !== "function") {
        createReferenceMap(childScope, outReferenceMap);
      }
    }
    return outReferenceMap;
  }
  function getWriteExpr(reference) {
    if (reference.writeExpr) {
      return reference.writeExpr;
    }
    let node2 = reference.identifier;
    while (node2) {
      const t2 = node2.parent.type;
      if (t2 === "AssignmentExpression" && node2.parent.left === node2) {
        return node2.parent.right;
      }
      if (t2 === "MemberExpression" && node2.parent.object === node2) {
        node2 = node2.parent;
        continue;
      }
      break;
    }
    return null;
  }
  function isLocalVariableWithoutEscape(variable, isMemberAccess) {
    if (!variable) {
      return false;
    }
    if (isMemberAccess && variable.defs.some((d2) => d2.type === "Parameter")) {
      return false;
    }
    const functionScope = variable.scope.variableScope;
    return variable.references.every(
      (reference) => reference.from.variableScope === functionScope
    );
  }
  class SegmentInfo {
    constructor() {
      this.info = /* @__PURE__ */ new WeakMap();
    }
    /**
     * Initialize the segment information.
     * @param {PathSegment} segment The segment to initialize.
     * @returns {void}
     */
    initialize(segment) {
      const outdatedReadVariables = /* @__PURE__ */ new Set();
      const freshReadVariables = /* @__PURE__ */ new Set();
      for (const prevSegment of segment.prevSegments) {
        const info = this.info.get(prevSegment);
        if (info) {
          info.outdatedReadVariables.forEach(
            Set.prototype.add,
            outdatedReadVariables
          );
          info.freshReadVariables.forEach(
            Set.prototype.add,
            freshReadVariables
          );
        }
      }
      this.info.set(segment, { outdatedReadVariables, freshReadVariables });
    }
    /**
     * Mark a given variable as read on given segments.
     * @param {PathSegment[]} segments The segments that it read the variable on.
     * @param {Variable} variable The variable to be read.
     * @returns {void}
     */
    markAsRead(segments, variable) {
      for (const segment of segments) {
        const info = this.info.get(segment);
        if (info) {
          info.freshReadVariables.add(variable);
          info.outdatedReadVariables.delete(variable);
        }
      }
    }
    /**
     * Move `freshReadVariables` to `outdatedReadVariables`.
     * @param {PathSegment[]} segments The segments to process.
     * @returns {void}
     */
    makeOutdated(segments) {
      for (const segment of segments) {
        const info = this.info.get(segment);
        if (info) {
          info.freshReadVariables.forEach(
            Set.prototype.add,
            info.outdatedReadVariables
          );
          info.freshReadVariables.clear();
        }
      }
    }
    /**
     * Check if a given variable is outdated on the current segments.
     * @param {PathSegment[]} segments The current segments.
     * @param {Variable} variable The variable to check.
     * @returns {boolean} `true` if the variable is outdated on the segments.
     */
    isOutdated(segments, variable) {
      for (const segment of segments) {
        const info = this.info.get(segment);
        if (info && info.outdatedReadVariables.has(variable)) {
          return true;
        }
      }
      return false;
    }
  }
  requireAtomicUpdates = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          allowProperties: false
        }
      ],
      docs: {
        description: "Disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/require-atomic-updates"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowProperties: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.",
        nonAtomicObjectUpdate: "Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`."
      }
    },
    create(context) {
      const [{ allowProperties }] = context.options;
      const sourceCode2 = context.sourceCode;
      const assignmentReferences = /* @__PURE__ */ new Map();
      const segmentInfo = new SegmentInfo();
      let stack = null;
      return {
        onCodePathStart(codePath2, node2) {
          const scope = sourceCode2.getScope(node2);
          const shouldVerify = scope.type === "function" && (scope.block.async || scope.block.generator);
          stack = {
            upper: stack,
            codePath: codePath2,
            referenceMap: shouldVerify ? createReferenceMap(scope) : null,
            currentSegments: /* @__PURE__ */ new Set()
          };
        },
        onCodePathEnd() {
          stack = stack.upper;
        },
        // Initialize the segment information.
        onCodePathSegmentStart(segment) {
          segmentInfo.initialize(segment);
          stack.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentStart(segment) {
          stack.currentSegments.add(segment);
        },
        onUnreachableCodePathSegmentEnd(segment) {
          stack.currentSegments.delete(segment);
        },
        onCodePathSegmentEnd(segment) {
          stack.currentSegments.delete(segment);
        },
        // Handle references to prepare verification.
        Identifier(node2) {
          const { referenceMap } = stack;
          const reference = referenceMap && referenceMap.get(node2);
          if (!reference) {
            return;
          }
          const variable = reference.resolved;
          const writeExpr = getWriteExpr(reference);
          const isMemberAccess = reference.identifier.parent.type === "MemberExpression";
          if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
            segmentInfo.markAsRead(stack.currentSegments, variable);
          }
          if (writeExpr && writeExpr.parent.right === writeExpr && // ← exclude variable declarations.
          !isLocalVariableWithoutEscape(variable, isMemberAccess)) {
            let refs = assignmentReferences.get(writeExpr);
            if (!refs) {
              refs = [];
              assignmentReferences.set(writeExpr, refs);
            }
            refs.push(reference);
          }
        },
        /*
         * Verify assignments.
         * If the reference exists in `outdatedReadVariables` list, report it.
         */
        ":expression:exit"(node2) {
          if (!stack.referenceMap) {
            return;
          }
          if (node2.type === "AwaitExpression" || node2.type === "YieldExpression") {
            segmentInfo.makeOutdated(stack.currentSegments);
          }
          const references = assignmentReferences.get(node2);
          if (references) {
            assignmentReferences.delete(node2);
            for (const reference of references) {
              const variable = reference.resolved;
              if (segmentInfo.isOutdated(
                stack.currentSegments,
                variable
              )) {
                if (node2.parent.left === reference.identifier) {
                  context.report({
                    node: node2.parent,
                    messageId: "nonAtomicUpdate",
                    data: {
                      value: variable.name
                    }
                  });
                } else if (!allowProperties) {
                  context.report({
                    node: node2.parent,
                    messageId: "nonAtomicObjectUpdate",
                    data: {
                      value: sourceCode2.getText(
                        node2.parent.left
                      ),
                      object: variable.name
                    }
                  });
                }
              }
            }
          }
        }
      };
    }
  };
  return requireAtomicUpdates;
}
var requireAwait;
var hasRequiredRequireAwait;
function requireRequireAwait() {
  if (hasRequiredRequireAwait) return requireAwait;
  hasRequiredRequireAwait = 1;
  const astUtils2 = requireAstUtils();
  function capitalizeFirstLetter(text) {
    return text[0].toUpperCase() + text.slice(1);
  }
  requireAwait = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Disallow async functions which have no `await` expression",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/require-await"
      },
      schema: [],
      messages: {
        missingAwait: "{{name}} has no 'await' expression.",
        removeAsync: "Remove 'async'."
      },
      hasSuggestions: true
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      let scopeInfo = null;
      function enterFunction() {
        scopeInfo = {
          upper: scopeInfo,
          hasAwait: false
        };
      }
      function exitFunction(node2) {
        if (!node2.generator && node2.async && !scopeInfo.hasAwait && !astUtils2.isEmptyFunction(node2)) {
          const nodeWithAsyncKeyword = node2.parent.type === "MethodDefinition" && node2.parent.value === node2 || node2.parent.type === "Property" && node2.parent.method && node2.parent.value === node2 ? node2.parent : node2;
          const asyncToken = sourceCode2.getFirstToken(
            nodeWithAsyncKeyword,
            (token) => token.value === "async"
          );
          const asyncRange = [
            asyncToken.range[0],
            sourceCode2.getTokenAfter(asyncToken, {
              includeComments: true
            }).range[0]
          ];
          const nextToken = sourceCode2.getTokenAfter(asyncToken);
          const addSemiColon = nextToken.type === "Punctuator" && (nextToken.value === "[" || nextToken.value === "(") && (nodeWithAsyncKeyword.type === "MethodDefinition" || astUtils2.isStartOfExpressionStatement(
            nodeWithAsyncKeyword
          )) && astUtils2.needsPrecedingSemicolon(
            sourceCode2,
            nodeWithAsyncKeyword
          );
          context.report({
            node: node2,
            loc: astUtils2.getFunctionHeadLoc(node2, sourceCode2),
            messageId: "missingAwait",
            data: {
              name: capitalizeFirstLetter(
                astUtils2.getFunctionNameWithKind(node2)
              )
            },
            suggest: [
              {
                messageId: "removeAsync",
                fix: (fixer) => fixer.replaceTextRange(
                  asyncRange,
                  addSemiColon ? ";" : ""
                )
              }
            ]
          });
        }
        scopeInfo = scopeInfo.upper;
      }
      return {
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        ArrowFunctionExpression: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression:exit": exitFunction,
        "ArrowFunctionExpression:exit": exitFunction,
        AwaitExpression() {
          if (!scopeInfo) {
            return;
          }
          scopeInfo.hasAwait = true;
        },
        ForOfStatement(node2) {
          if (!scopeInfo) {
            return;
          }
          if (node2.await) {
            scopeInfo.hasAwait = true;
          }
        },
        VariableDeclaration(node2) {
          if (!scopeInfo) {
            return;
          }
          if (node2.kind === "await using") {
            scopeInfo.hasAwait = true;
          }
        }
      };
    }
  };
  return requireAwait;
}
var requireUnicodeRegexp;
var hasRequiredRequireUnicodeRegexp;
function requireRequireUnicodeRegexp() {
  if (hasRequiredRequireUnicodeRegexp) return requireUnicodeRegexp;
  hasRequiredRequireUnicodeRegexp = 1;
  const {
    CALL,
    CONSTRUCT,
    ReferenceTracker,
    getStringIfConstant
  } = /* @__PURE__ */ requireEslintUtils();
  const astUtils2 = requireAstUtils();
  const { isValidWithUnicodeFlag } = requireRegularExpressions();
  function checkFlags(requireFlag, flags2) {
    let missingFlag;
    if (requireFlag === "v") {
      missingFlag = !flags2.includes("v");
    } else if (requireFlag === "u") {
      missingFlag = !flags2.includes("u");
    } else {
      missingFlag = !flags2.includes("u") && !flags2.includes("v");
    }
    return missingFlag;
  }
  requireUnicodeRegexp = {
    meta: {
      type: "suggestion",
      defaultOptions: [{}],
      docs: {
        description: "Enforce the use of `u` or `v` flag on regular expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/require-unicode-regexp"
      },
      hasSuggestions: true,
      messages: {
        addUFlag: "Add the 'u' flag.",
        addVFlag: "Add the 'v' flag.",
        requireUFlag: "Use the 'u' flag.",
        requireVFlag: "Use the 'v' flag."
      },
      schema: [
        {
          type: "object",
          properties: {
            requireFlag: {
              enum: ["u", "v"]
            }
          },
          additionalProperties: false
        }
      ]
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const [{ requireFlag }] = context.options;
      return {
        "Literal[regex]"(node2) {
          const flags2 = node2.regex.flags || "";
          const missingFlag = checkFlags(requireFlag, flags2);
          if (missingFlag) {
            context.report({
              messageId: requireFlag === "v" ? "requireVFlag" : "requireUFlag",
              node: node2,
              suggest: isValidWithUnicodeFlag(
                context.languageOptions.ecmaVersion,
                node2.regex.pattern,
                requireFlag
              ) ? [
                {
                  fix(fixer) {
                    const replaceFlag = requireFlag ?? "u";
                    const regex = sourceCode2.getText(node2);
                    const slashPos = regex.lastIndexOf("/");
                    if (requireFlag) {
                      const flag = requireFlag === "u" ? "v" : "u";
                      if (regex.includes(
                        flag,
                        slashPos
                      )) {
                        return fixer.replaceText(
                          node2,
                          regex.slice(
                            0,
                            slashPos
                          ) + regex.slice(slashPos).replace(
                            flag,
                            requireFlag
                          )
                        );
                      }
                    }
                    return fixer.insertTextAfter(
                      node2,
                      replaceFlag
                    );
                  },
                  messageId: requireFlag === "v" ? "addVFlag" : "addUFlag"
                }
              ] : null
            });
          }
        },
        Program(node2) {
          const scope = sourceCode2.getScope(node2);
          const tracker = new ReferenceTracker(scope);
          const trackMap = {
            RegExp: { [CALL]: true, [CONSTRUCT]: true }
          };
          for (const { node: refNode } of tracker.iterateGlobalReferences(
            trackMap
          )) {
            const [patternNode, flagsNode] = refNode.arguments;
            if (patternNode && patternNode.type === "SpreadElement") {
              continue;
            }
            const pattern2 = getStringIfConstant(patternNode, scope);
            const flags2 = getStringIfConstant(flagsNode, scope);
            let missingFlag = !flagsNode;
            if (typeof flags2 === "string") {
              missingFlag = checkFlags(requireFlag, flags2);
            }
            if (missingFlag) {
              context.report({
                messageId: requireFlag === "v" ? "requireVFlag" : "requireUFlag",
                node: refNode,
                suggest: typeof pattern2 === "string" && isValidWithUnicodeFlag(
                  context.languageOptions.ecmaVersion,
                  pattern2,
                  requireFlag
                ) ? [
                  {
                    fix(fixer) {
                      const replaceFlag = requireFlag ?? "u";
                      if (flagsNode) {
                        if (flagsNode.type === "Literal" && typeof flagsNode.value === "string" || flagsNode.type === "TemplateLiteral") {
                          const flagsNodeText = sourceCode2.getText(
                            flagsNode
                          );
                          const flag = requireFlag === "u" ? "v" : "u";
                          if (flags2.includes(
                            flag
                          )) {
                            if (flagsNode.type === "Literal" && flagsNode.raw.includes(
                              "\\"
                            )) {
                              return null;
                            }
                            if (flagsNode.type === "TemplateLiteral" && (flagsNode.expressions.length || flagsNode.quasis.some(
                              ({
                                value: {
                                  raw
                                }
                              }) => raw.includes(
                                "\\"
                              )
                            ))) {
                              return null;
                            }
                            return fixer.replaceText(
                              flagsNode,
                              flagsNodeText.replace(
                                flag,
                                replaceFlag
                              )
                            );
                          }
                          return fixer.replaceText(
                            flagsNode,
                            [
                              flagsNodeText.slice(
                                0,
                                flagsNodeText.length - 1
                              ),
                              flagsNodeText.slice(
                                flagsNodeText.length - 1
                              )
                            ].join(
                              replaceFlag
                            )
                          );
                        }
                        return null;
                      }
                      const penultimateToken = sourceCode2.getLastToken(
                        refNode,
                        { skip: 1 }
                      );
                      return fixer.insertTextAfter(
                        penultimateToken,
                        astUtils2.isCommaToken(
                          penultimateToken
                        ) ? ` "${replaceFlag}",` : `, "${replaceFlag}"`
                      );
                    },
                    messageId: requireFlag === "v" ? "addVFlag" : "addUFlag"
                  }
                ] : null
              });
            }
          }
        }
      };
    }
  };
  return requireUnicodeRegexp;
}
var requireYield;
var hasRequiredRequireYield;
function requireRequireYield() {
  if (hasRequiredRequireYield) return requireYield;
  hasRequiredRequireYield = 1;
  requireYield = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require generator functions to contain `yield`",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/require-yield"
      },
      schema: [],
      messages: {
        missingYield: "This generator function does not have 'yield'."
      }
    },
    create(context) {
      const stack = [];
      function beginChecking(node2) {
        if (node2.generator) {
          stack.push(0);
        }
      }
      function endChecking(node2) {
        if (!node2.generator) {
          return;
        }
        const countYield = stack.pop();
        if (countYield === 0 && node2.body.body.length > 0) {
          context.report({ node: node2, messageId: "missingYield" });
        }
      }
      return {
        FunctionDeclaration: beginChecking,
        "FunctionDeclaration:exit": endChecking,
        FunctionExpression: beginChecking,
        "FunctionExpression:exit": endChecking,
        // Increases the count of `yield` keyword.
        YieldExpression() {
          if (stack.length > 0) {
            stack[stack.length - 1] += 1;
          }
        }
      };
    }
  };
  return requireYield;
}
var restSpreadSpacing;
var hasRequiredRestSpreadSpacing;
function requireRestSpreadSpacing() {
  if (hasRequiredRestSpreadSpacing) return restSpreadSpacing;
  hasRequiredRestSpreadSpacing = 1;
  restSpreadSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "rest-spread-spacing",
              url: "https://eslint.style/rules/rest-spread-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce spacing between rest and spread operators and their expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/rest-spread-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
        expectedWhitespace: "Expected whitespace after {{type}} operator."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode, alwaysSpace = context.options[0] === "always";
      function checkWhiteSpace(node2) {
        const operator2 = sourceCode2.getFirstToken(node2), nextToken = sourceCode2.getTokenAfter(operator2), hasWhitespace = sourceCode2.isSpaceBetweenTokens(
          operator2,
          nextToken
        );
        let type2;
        switch (node2.type) {
          case "SpreadElement":
            type2 = "spread";
            if (node2.parent.type === "ObjectExpression") {
              type2 += " property";
            }
            break;
          case "RestElement":
            type2 = "rest";
            if (node2.parent.type === "ObjectPattern") {
              type2 += " property";
            }
            break;
          case "ExperimentalSpreadProperty":
            type2 = "spread property";
            break;
          case "ExperimentalRestProperty":
            type2 = "rest property";
            break;
          default:
            return;
        }
        if (alwaysSpace && !hasWhitespace) {
          context.report({
            node: node2,
            loc: operator2.loc,
            messageId: "expectedWhitespace",
            data: {
              type: type2
            },
            fix(fixer) {
              return fixer.replaceTextRange(
                [operator2.range[1], nextToken.range[0]],
                " "
              );
            }
          });
        } else if (!alwaysSpace && hasWhitespace) {
          context.report({
            node: node2,
            loc: {
              start: operator2.loc.end,
              end: nextToken.loc.start
            },
            messageId: "unexpectedWhitespace",
            data: {
              type: type2
            },
            fix(fixer) {
              return fixer.removeRange([
                operator2.range[1],
                nextToken.range[0]
              ]);
            }
          });
        }
      }
      return {
        SpreadElement: checkWhiteSpace,
        RestElement: checkWhiteSpace,
        ExperimentalSpreadProperty: checkWhiteSpace,
        ExperimentalRestProperty: checkWhiteSpace
      };
    }
  };
  return restSpreadSpacing;
}
var semi;
var hasRequiredSemi;
function requireSemi() {
  if (hasRequiredSemi) return semi;
  hasRequiredSemi = 1;
  const FixTracker = requireFixTracker();
  const astUtils2 = requireAstUtils();
  semi = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "semi",
              url: "https://eslint.style/rules/semi"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow semicolons instead of ASI",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/semi"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              },
              {
                type: "object",
                properties: {
                  beforeStatementContinuationChars: {
                    enum: ["always", "any", "never"]
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          },
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  omitLastInOneLineBlock: { type: "boolean" },
                  omitLastInOneLineClassBody: { type: "boolean" }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        missingSemi: "Missing semicolon.",
        extraSemi: "Extra semicolon."
      }
    },
    create(context) {
      const OPT_OUT_PATTERN = /^[-[(/+`]/u;
      const unsafeClassFieldNames = /* @__PURE__ */ new Set(["get", "set", "static"]);
      const unsafeClassFieldFollowers = /* @__PURE__ */ new Set(["*", "in", "instanceof"]);
      const options = context.options[1];
      const never = context.options[0] === "never";
      const exceptOneLine = Boolean(
        options && options.omitLastInOneLineBlock
      );
      const exceptOneLineClassBody = Boolean(
        options && options.omitLastInOneLineClassBody
      );
      const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
      const sourceCode2 = context.sourceCode;
      function report(node2, missing) {
        const lastToken = sourceCode2.getLastToken(node2);
        let messageId, fix, loc;
        if (!missing) {
          messageId = "missingSemi";
          loc = {
            start: lastToken.loc.end,
            end: astUtils2.getNextLocation(
              sourceCode2,
              lastToken.loc.end
            )
          };
          fix = function(fixer) {
            return fixer.insertTextAfter(lastToken, ";");
          };
        } else {
          messageId = "extraSemi";
          loc = lastToken.loc;
          fix = function(fixer) {
            return new FixTracker(fixer, sourceCode2).retainSurroundingTokens(lastToken).remove(lastToken);
          };
        }
        context.report({
          node: node2,
          loc,
          messageId,
          fix
        });
      }
      function isRedundantSemi(semiToken) {
        const nextToken = sourceCode2.getTokenAfter(semiToken);
        return !nextToken || astUtils2.isClosingBraceToken(nextToken) || astUtils2.isSemicolonToken(nextToken);
      }
      function isEndOfArrowBlock(lastToken) {
        if (!astUtils2.isClosingBraceToken(lastToken)) {
          return false;
        }
        const node2 = sourceCode2.getNodeByRangeIndex(lastToken.range[0]);
        return node2.type === "BlockStatement" && node2.parent.type === "ArrowFunctionExpression";
      }
      function maybeClassFieldAsiHazard(node2) {
        if (node2.type !== "PropertyDefinition") {
          return false;
        }
        const needsNameCheck = !node2.computed && node2.key.type === "Identifier";
        if (needsNameCheck && unsafeClassFieldNames.has(node2.key.name)) {
          const isStaticStatic = node2.static && node2.key.name === "static";
          if (!isStaticStatic && !node2.value) {
            return true;
          }
        }
        const followingToken = sourceCode2.getTokenAfter(node2);
        return unsafeClassFieldFollowers.has(followingToken.value);
      }
      function isOnSameLineWithNextToken(node2) {
        const prevToken = sourceCode2.getLastToken(node2, 1);
        const nextToken = sourceCode2.getTokenAfter(node2);
        return !!nextToken && astUtils2.isTokenOnSameLine(prevToken, nextToken);
      }
      function maybeAsiHazardAfter(node2) {
        const t2 = node2.type;
        if (t2 === "DoWhileStatement" || t2 === "BreakStatement" || t2 === "ContinueStatement" || t2 === "DebuggerStatement" || t2 === "ImportDeclaration" || t2 === "ExportAllDeclaration") {
          return false;
        }
        if (t2 === "ReturnStatement") {
          return Boolean(node2.argument);
        }
        if (t2 === "ExportNamedDeclaration") {
          return Boolean(node2.declaration);
        }
        if (isEndOfArrowBlock(sourceCode2.getLastToken(node2, 1))) {
          return false;
        }
        return true;
      }
      function maybeAsiHazardBefore(token) {
        return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
      }
      function canRemoveSemicolon(node2) {
        if (isRedundantSemi(sourceCode2.getLastToken(node2))) {
          return true;
        }
        if (maybeClassFieldAsiHazard(node2)) {
          return false;
        }
        if (isOnSameLineWithNextToken(node2)) {
          return false;
        }
        if (node2.type !== "PropertyDefinition" && beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node2)) {
          return true;
        }
        if (!maybeAsiHazardBefore(sourceCode2.getTokenAfter(node2))) {
          return true;
        }
        return false;
      }
      function isLastInOneLinerBlock(node2) {
        const parent = node2.parent;
        const nextToken = sourceCode2.getTokenAfter(node2);
        if (!nextToken || nextToken.value !== "}") {
          return false;
        }
        if (parent.type === "BlockStatement") {
          return parent.loc.start.line === parent.loc.end.line;
        }
        if (parent.type === "StaticBlock") {
          const openingBrace = sourceCode2.getFirstToken(parent, {
            skip: 1
          });
          return openingBrace.loc.start.line === parent.loc.end.line;
        }
        return false;
      }
      function isLastInOneLinerClassBody(node2) {
        const parent = node2.parent;
        const nextToken = sourceCode2.getTokenAfter(node2);
        if (!nextToken || nextToken.value !== "}") {
          return false;
        }
        if (parent.type === "ClassBody") {
          return parent.loc.start.line === parent.loc.end.line;
        }
        return false;
      }
      function checkForSemicolon(node2) {
        const isSemi = astUtils2.isSemicolonToken(
          sourceCode2.getLastToken(node2)
        );
        if (never) {
          if (isSemi && canRemoveSemicolon(node2)) {
            report(node2, true);
          } else if (!isSemi && beforeStatementContinuationChars === "always" && node2.type !== "PropertyDefinition" && maybeAsiHazardBefore(sourceCode2.getTokenAfter(node2))) {
            report(node2);
          }
        } else {
          const oneLinerBlock = exceptOneLine && isLastInOneLinerBlock(node2);
          const oneLinerClassBody = exceptOneLineClassBody && isLastInOneLinerClassBody(node2);
          const oneLinerBlockOrClassBody = oneLinerBlock || oneLinerClassBody;
          if (isSemi && oneLinerBlockOrClassBody) {
            report(node2, true);
          } else if (!isSemi && !oneLinerBlockOrClassBody) {
            report(node2);
          }
        }
      }
      function checkForSemicolonForVariableDeclaration(node2) {
        const parent = node2.parent;
        if ((parent.type !== "ForStatement" || parent.init !== node2) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node2)) {
          checkForSemicolon(node2);
        }
      }
      return {
        VariableDeclaration: checkForSemicolonForVariableDeclaration,
        ExpressionStatement: checkForSemicolon,
        ReturnStatement: checkForSemicolon,
        ThrowStatement: checkForSemicolon,
        DoWhileStatement: checkForSemicolon,
        DebuggerStatement: checkForSemicolon,
        BreakStatement: checkForSemicolon,
        ContinueStatement: checkForSemicolon,
        ImportDeclaration: checkForSemicolon,
        ExportAllDeclaration: checkForSemicolon,
        ExportNamedDeclaration(node2) {
          if (!node2.declaration) {
            checkForSemicolon(node2);
          }
        },
        ExportDefaultDeclaration(node2) {
          if (!/(?:Class|Function)Declaration/u.test(
            node2.declaration.type
          )) {
            checkForSemicolon(node2);
          }
        },
        PropertyDefinition: checkForSemicolon
      };
    }
  };
  return semi;
}
var semiSpacing;
var hasRequiredSemiSpacing;
function requireSemiSpacing() {
  if (hasRequiredSemiSpacing) return semiSpacing;
  hasRequiredSemiSpacing = 1;
  const astUtils2 = requireAstUtils();
  semiSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "semi-spacing",
              url: "https://eslint.style/rules/semi-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before and after semicolons",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/semi-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: false
            },
            after: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
        unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
        missingWhitespaceBefore: "Missing whitespace before semicolon.",
        missingWhitespaceAfter: "Missing whitespace after semicolon."
      }
    },
    create(context) {
      const config2 = context.options[0], sourceCode2 = context.sourceCode;
      let requireSpaceBefore = false, requireSpaceAfter = true;
      if (typeof config2 === "object") {
        requireSpaceBefore = config2.before;
        requireSpaceAfter = config2.after;
      }
      function hasLeadingSpace(token) {
        const tokenBefore = sourceCode2.getTokenBefore(token);
        return tokenBefore && astUtils2.isTokenOnSameLine(tokenBefore, token) && sourceCode2.isSpaceBetweenTokens(tokenBefore, token);
      }
      function hasTrailingSpace(token) {
        const tokenAfter = sourceCode2.getTokenAfter(token);
        return tokenAfter && astUtils2.isTokenOnSameLine(token, tokenAfter) && sourceCode2.isSpaceBetweenTokens(token, tokenAfter);
      }
      function isLastTokenInCurrentLine(token) {
        const tokenAfter = sourceCode2.getTokenAfter(token);
        return !(tokenAfter && astUtils2.isTokenOnSameLine(token, tokenAfter));
      }
      function isFirstTokenInCurrentLine(token) {
        const tokenBefore = sourceCode2.getTokenBefore(token);
        return !(tokenBefore && astUtils2.isTokenOnSameLine(token, tokenBefore));
      }
      function isBeforeClosingParen(token) {
        const nextToken = sourceCode2.getTokenAfter(token);
        return nextToken && astUtils2.isClosingBraceToken(nextToken) || astUtils2.isClosingParenToken(nextToken);
      }
      function checkSemicolonSpacing(token, node2) {
        if (astUtils2.isSemicolonToken(token)) {
          if (hasLeadingSpace(token)) {
            if (!requireSpaceBefore) {
              const tokenBefore = sourceCode2.getTokenBefore(token);
              const loc = {
                start: tokenBefore.loc.end,
                end: token.loc.start
              };
              context.report({
                node: node2,
                loc,
                messageId: "unexpectedWhitespaceBefore",
                fix(fixer) {
                  return fixer.removeRange([
                    tokenBefore.range[1],
                    token.range[0]
                  ]);
                }
              });
            }
          } else {
            if (requireSpaceBefore) {
              const loc = token.loc;
              context.report({
                node: node2,
                loc,
                messageId: "missingWhitespaceBefore",
                fix(fixer) {
                  return fixer.insertTextBefore(token, " ");
                }
              });
            }
          }
          if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
            if (hasTrailingSpace(token)) {
              if (!requireSpaceAfter) {
                const tokenAfter = sourceCode2.getTokenAfter(token);
                const loc = {
                  start: token.loc.end,
                  end: tokenAfter.loc.start
                };
                context.report({
                  node: node2,
                  loc,
                  messageId: "unexpectedWhitespaceAfter",
                  fix(fixer) {
                    return fixer.removeRange([
                      token.range[1],
                      tokenAfter.range[0]
                    ]);
                  }
                });
              }
            } else {
              if (requireSpaceAfter) {
                const loc = token.loc;
                context.report({
                  node: node2,
                  loc,
                  messageId: "missingWhitespaceAfter",
                  fix(fixer) {
                    return fixer.insertTextAfter(token, " ");
                  }
                });
              }
            }
          }
        }
      }
      function checkNode(node2) {
        const token = sourceCode2.getLastToken(node2);
        checkSemicolonSpacing(token, node2);
      }
      return {
        VariableDeclaration: checkNode,
        ExpressionStatement: checkNode,
        BreakStatement: checkNode,
        ContinueStatement: checkNode,
        DebuggerStatement: checkNode,
        DoWhileStatement: checkNode,
        ReturnStatement: checkNode,
        ThrowStatement: checkNode,
        ImportDeclaration: checkNode,
        ExportNamedDeclaration: checkNode,
        ExportAllDeclaration: checkNode,
        ExportDefaultDeclaration: checkNode,
        ForStatement(node2) {
          if (node2.init) {
            checkSemicolonSpacing(
              sourceCode2.getTokenAfter(node2.init),
              node2
            );
          }
          if (node2.test) {
            checkSemicolonSpacing(
              sourceCode2.getTokenAfter(node2.test),
              node2
            );
          }
        },
        PropertyDefinition: checkNode
      };
    }
  };
  return semiSpacing;
}
var semiStyle;
var hasRequiredSemiStyle;
function requireSemiStyle() {
  if (hasRequiredSemiStyle) return semiStyle;
  hasRequiredSemiStyle = 1;
  const astUtils2 = requireAstUtils();
  const SELECTOR = [
    "BreakStatement",
    "ContinueStatement",
    "DebuggerStatement",
    "DoWhileStatement",
    "ExportAllDeclaration",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExpressionStatement",
    "ImportDeclaration",
    "ReturnStatement",
    "ThrowStatement",
    "VariableDeclaration",
    "PropertyDefinition"
  ].join(",");
  function getChildren2(node2) {
    const t2 = node2.type;
    if (t2 === "BlockStatement" || t2 === "StaticBlock" || t2 === "Program" || t2 === "ClassBody") {
      return node2.body;
    }
    if (t2 === "SwitchCase") {
      return node2.consequent;
    }
    return null;
  }
  function isLastChild(node2) {
    const t2 = node2.parent.type;
    if (t2 === "IfStatement" && node2.parent.consequent === node2 && node2.parent.alternate) {
      return true;
    }
    if (t2 === "DoWhileStatement") {
      return true;
    }
    const nodeList = getChildren2(node2.parent);
    return nodeList !== null && nodeList.at(-1) === node2;
  }
  semiStyle = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "semi-style",
              url: "https://eslint.style/rules/semi-style"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce location of semicolons",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/semi-style"
      },
      schema: [{ enum: ["last", "first"] }],
      fixable: "whitespace",
      messages: {
        expectedSemiColon: "Expected this semicolon to be at {{pos}}."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const option = context.options[0] || "last";
      function check2(semiToken, expected) {
        const prevToken = sourceCode2.getTokenBefore(semiToken);
        const nextToken = sourceCode2.getTokenAfter(semiToken);
        const prevIsSameLine = !prevToken || astUtils2.isTokenOnSameLine(prevToken, semiToken);
        const nextIsSameLine = !nextToken || astUtils2.isTokenOnSameLine(semiToken, nextToken);
        if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
          context.report({
            loc: semiToken.loc,
            messageId: "expectedSemiColon",
            data: {
              pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
            },
            fix(fixer) {
              if (prevToken && nextToken && sourceCode2.commentsExistBetween(
                prevToken,
                nextToken
              )) {
                return null;
              }
              const start = prevToken ? prevToken.range[1] : semiToken.range[0];
              const end = nextToken ? nextToken.range[0] : semiToken.range[1];
              const text = expected === "last" ? ";\n" : "\n;";
              return fixer.replaceTextRange([start, end], text);
            }
          });
        }
      }
      return {
        [SELECTOR](node2) {
          if (option === "first" && isLastChild(node2)) {
            return;
          }
          const lastToken = sourceCode2.getLastToken(node2);
          if (astUtils2.isSemicolonToken(lastToken)) {
            check2(lastToken, option);
          }
        },
        ForStatement(node2) {
          const firstSemi = node2.init && sourceCode2.getTokenAfter(
            node2.init,
            astUtils2.isSemicolonToken
          );
          const secondSemi = node2.test && sourceCode2.getTokenAfter(
            node2.test,
            astUtils2.isSemicolonToken
          );
          if (firstSemi) {
            check2(firstSemi, "last");
          }
          if (secondSemi) {
            check2(secondSemi, "last");
          }
        }
      };
    }
  };
  return semiStyle;
}
var sortImports;
var hasRequiredSortImports;
function requireSortImports() {
  if (hasRequiredSortImports) return sortImports;
  hasRequiredSortImports = 1;
  sortImports = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          allowSeparatedGroups: false,
          ignoreCase: false,
          ignoreDeclarationSort: false,
          ignoreMemberSort: false,
          memberSyntaxSortOrder: ["none", "all", "multiple", "single"]
        }
      ],
      docs: {
        description: "Enforce sorted `import` declarations within modules",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/sort-imports"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean"
            },
            memberSyntaxSortOrder: {
              type: "array",
              items: {
                enum: ["none", "all", "multiple", "single"]
              },
              uniqueItems: true,
              minItems: 4,
              maxItems: 4
            },
            ignoreDeclarationSort: {
              type: "boolean"
            },
            ignoreMemberSort: {
              type: "boolean"
            },
            allowSeparatedGroups: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        sortImportsAlphabetically: "Imports should be sorted alphabetically.",
        sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
        unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."
      }
    },
    create(context) {
      const [
        {
          ignoreCase,
          ignoreDeclarationSort,
          ignoreMemberSort,
          memberSyntaxSortOrder,
          allowSeparatedGroups
        }
      ] = context.options;
      const sourceCode2 = context.sourceCode;
      let previousDeclaration = null;
      function usedMemberSyntax(node2) {
        if (node2.specifiers.length === 0) {
          return "none";
        }
        if (node2.specifiers[0].type === "ImportNamespaceSpecifier") {
          return "all";
        }
        if (node2.specifiers.length === 1) {
          return "single";
        }
        return "multiple";
      }
      function getMemberParameterGroupIndex(node2) {
        return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node2));
      }
      function getFirstLocalMemberName(node2) {
        if (node2.specifiers[0]) {
          return node2.specifiers[0].local.name;
        }
        return null;
      }
      function getNumberOfLinesBetween(left, right) {
        return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);
      }
      return {
        ImportDeclaration(node2) {
          if (!ignoreDeclarationSort) {
            if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node2) > 0) {
              previousDeclaration = null;
            }
            if (previousDeclaration) {
              const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node2), previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(
                previousDeclaration
              );
              let currentLocalMemberName = getFirstLocalMemberName(node2), previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);
              if (ignoreCase) {
                previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
                currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
              }
              if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
                if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                  context.report({
                    node: node2,
                    messageId: "unexpectedSyntaxOrder",
                    data: {
                      syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                      syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                    }
                  });
                }
              } else {
                if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
                  context.report({
                    node: node2,
                    messageId: "sortImportsAlphabetically"
                  });
                }
              }
            }
            previousDeclaration = node2;
          }
          if (!ignoreMemberSort) {
            const importSpecifiers = node2.specifiers.filter(
              (specifier) => specifier.type === "ImportSpecifier"
            );
            const getSortableName = ignoreCase ? (specifier) => specifier.local.name.toLowerCase() : (specifier) => specifier.local.name;
            const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex(
              (name2, index, array) => array[index - 1] > name2
            );
            if (firstUnsortedIndex !== -1) {
              context.report({
                node: importSpecifiers[firstUnsortedIndex],
                messageId: "sortMembersAlphabetically",
                data: {
                  memberName: importSpecifiers[firstUnsortedIndex].local.name
                },
                fix(fixer) {
                  if (importSpecifiers.some(
                    (specifier) => sourceCode2.getCommentsBefore(
                      specifier
                    ).length || sourceCode2.getCommentsAfter(
                      specifier
                    ).length
                  )) {
                    return null;
                  }
                  return fixer.replaceTextRange(
                    [
                      importSpecifiers[0].range[0],
                      importSpecifiers.at(-1).range[1]
                    ],
                    importSpecifiers.slice().sort((specifierA, specifierB) => {
                      const aName = getSortableName(specifierA);
                      const bName = getSortableName(specifierB);
                      return aName > bName ? 1 : -1;
                    }).reduce(
                      (sourceText, specifier, index) => {
                        const textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode2.getText().slice(
                          importSpecifiers[index].range[1],
                          importSpecifiers[index + 1].range[0]
                        );
                        return sourceText + sourceCode2.getText(
                          specifier
                        ) + textAfterSpecifier;
                      },
                      ""
                    )
                  );
                }
              });
            }
          }
        }
      };
    }
  };
  return sortImports;
}
var naturalCompare = { exports: {} };
var hasRequiredNaturalCompare;
function requireNaturalCompare() {
  if (hasRequiredNaturalCompare) return naturalCompare.exports;
  hasRequiredNaturalCompare = 1;
  /*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   */
  var naturalCompare$1 = function(a2, b) {
    var i2, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
    function getCode(str, pos, code2) {
      if (code2) {
        for (i2 = pos; code2 = getCode(str, i2), code2 < 76 && code2 > 65; ) ++i2;
        return +str.slice(pos - 1, i2);
      }
      code2 = alphabet && alphabet.indexOf(str.charAt(pos));
      return code2 > -1 ? code2 + 76 : (code2 = str.charCodeAt(pos) || 0, code2 < 45 || code2 > 127) ? code2 : code2 < 46 ? 65 : code2 < 48 ? code2 - 1 : code2 < 58 ? code2 + 18 : code2 < 65 ? code2 - 11 : code2 < 91 ? code2 + 11 : code2 < 97 ? code2 - 37 : code2 < 123 ? code2 + 5 : code2 - 63;
    }
    if ((a2 += "") != (b += "")) for (; codeB; ) {
      codeA = getCode(a2, posA++);
      codeB = getCode(b, posB++);
      if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
        codeA = getCode(a2, posA, posA);
        codeB = getCode(b, posB, posA = i2);
        posB = i2;
      }
      if (codeA != codeB) return codeA < codeB ? -1 : 1;
    }
    return 0;
  };
  try {
    naturalCompare.exports = naturalCompare$1;
  } catch (e2) {
    String.naturalCompare = naturalCompare$1;
  }
  return naturalCompare.exports;
}
var sortKeys;
var hasRequiredSortKeys;
function requireSortKeys() {
  if (hasRequiredSortKeys) return sortKeys;
  hasRequiredSortKeys = 1;
  const astUtils2 = requireAstUtils(), naturalCompare2 = requireNaturalCompare();
  function getPropertyName(node2) {
    const staticName = astUtils2.getStaticPropertyName(node2);
    if (staticName !== null) {
      return staticName;
    }
    return node2.key.name || null;
  }
  const isValidOrders = {
    asc(a2, b) {
      return a2 <= b;
    },
    ascI(a2, b) {
      return a2.toLowerCase() <= b.toLowerCase();
    },
    ascN(a2, b) {
      return naturalCompare2(a2, b) <= 0;
    },
    ascIN(a2, b) {
      return naturalCompare2(a2.toLowerCase(), b.toLowerCase()) <= 0;
    },
    desc(a2, b) {
      return isValidOrders.asc(b, a2);
    },
    descI(a2, b) {
      return isValidOrders.ascI(b, a2);
    },
    descN(a2, b) {
      return isValidOrders.ascN(b, a2);
    },
    descIN(a2, b) {
      return isValidOrders.ascIN(b, a2);
    }
  };
  sortKeys = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        "asc",
        {
          allowLineSeparatedGroups: false,
          caseSensitive: true,
          ignoreComputedKeys: false,
          minKeys: 2,
          natural: false
        }
      ],
      docs: {
        description: "Require object keys to be sorted",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/sort-keys"
      },
      schema: [
        {
          enum: ["asc", "desc"]
        },
        {
          type: "object",
          properties: {
            caseSensitive: {
              type: "boolean"
            },
            natural: {
              type: "boolean"
            },
            minKeys: {
              type: "integer",
              minimum: 2
            },
            allowLineSeparatedGroups: {
              type: "boolean"
            },
            ignoreComputedKeys: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."
      }
    },
    create(context) {
      const [
        order,
        {
          caseSensitive,
          natural,
          minKeys,
          allowLineSeparatedGroups,
          ignoreComputedKeys
        }
      ] = context.options;
      const insensitive = !caseSensitive;
      const isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natural ? "N" : "")];
      let stack = null;
      const sourceCode2 = context.sourceCode;
      return {
        ObjectExpression(node2) {
          stack = {
            upper: stack,
            prevNode: null,
            prevBlankLine: false,
            prevName: null,
            numKeys: node2.properties.length
          };
        },
        "ObjectExpression:exit"() {
          stack = stack.upper;
        },
        SpreadElement(node2) {
          if (node2.parent.type === "ObjectExpression") {
            stack.prevName = null;
          }
        },
        Property(node2) {
          if (node2.parent.type === "ObjectPattern") {
            return;
          }
          if (ignoreComputedKeys && node2.computed) {
            stack.prevName = null;
            return;
          }
          const prevName = stack.prevName;
          const numKeys = stack.numKeys;
          const thisName = getPropertyName(node2);
          const tokens = stack.prevNode && sourceCode2.getTokensBetween(stack.prevNode, node2, {
            includeComments: true
          });
          let isBlankLineBetweenNodes = stack.prevBlankLine;
          if (tokens) {
            tokens.forEach((token, index) => {
              const previousToken = tokens[index - 1];
              if (previousToken && token.loc.start.line - previousToken.loc.end.line > 1) {
                isBlankLineBetweenNodes = true;
              }
            });
            if (!isBlankLineBetweenNodes && node2.loc.start.line - tokens.at(-1).loc.end.line > 1) {
              isBlankLineBetweenNodes = true;
            }
            if (!isBlankLineBetweenNodes && tokens[0].loc.start.line - stack.prevNode.loc.end.line > 1) {
              isBlankLineBetweenNodes = true;
            }
          }
          stack.prevNode = node2;
          if (thisName !== null) {
            stack.prevName = thisName;
          }
          if (allowLineSeparatedGroups && isBlankLineBetweenNodes) {
            stack.prevBlankLine = thisName === null;
            return;
          }
          if (prevName === null || thisName === null || numKeys < minKeys) {
            return;
          }
          if (!isValidOrder(prevName, thisName)) {
            context.report({
              node: node2,
              loc: node2.key.loc,
              messageId: "sortKeys",
              data: {
                thisName,
                prevName,
                order,
                insensitive: insensitive ? "insensitive " : "",
                natural: natural ? "natural " : ""
              }
            });
          }
        }
      };
    }
  };
  return sortKeys;
}
var sortVars;
var hasRequiredSortVars;
function requireSortVars() {
  if (hasRequiredSortVars) return sortVars;
  hasRequiredSortVars = 1;
  sortVars = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        {
          ignoreCase: false
        }
      ],
      docs: {
        description: "Require variables within the same declaration block to be sorted",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/sort-vars"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        sortVars: "Variables within the same declaration block should be sorted alphabetically."
      }
    },
    create(context) {
      const [{ ignoreCase }] = context.options;
      const sourceCode2 = context.sourceCode;
      return {
        VariableDeclaration(node2) {
          const idDeclarations = node2.declarations.filter(
            (decl) => decl.id.type === "Identifier"
          );
          const getSortableName = ignoreCase ? (decl) => decl.id.name.toLowerCase() : (decl) => decl.id.name;
          const unfixable = idDeclarations.some(
            (decl) => decl.init !== null && decl.init.type !== "Literal"
          );
          let fixed = false;
          idDeclarations.slice(1).reduce((memo, decl) => {
            const lastVariableName = getSortableName(memo), currentVariableName = getSortableName(decl);
            if (currentVariableName < lastVariableName) {
              context.report({
                node: decl,
                messageId: "sortVars",
                fix(fixer) {
                  if (unfixable || fixed) {
                    return null;
                  }
                  return fixer.replaceTextRange(
                    [
                      idDeclarations[0].range[0],
                      idDeclarations.at(-1).range[1]
                    ],
                    idDeclarations.slice().sort((declA, declB) => {
                      const aName = getSortableName(declA);
                      const bName = getSortableName(declB);
                      return aName > bName ? 1 : -1;
                    }).reduce(
                      (sourceText, identifier, index) => {
                        const textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode2.getText().slice(
                          idDeclarations[index].range[1],
                          idDeclarations[index + 1].range[0]
                        );
                        return sourceText + sourceCode2.getText(
                          identifier
                        ) + textAfterIdentifier;
                      },
                      ""
                    )
                  );
                }
              });
              fixed = true;
              return memo;
            }
            return decl;
          }, idDeclarations[0]);
        }
      };
    }
  };
  return sortVars;
}
var spaceBeforeBlocks;
var hasRequiredSpaceBeforeBlocks;
function requireSpaceBeforeBlocks() {
  if (hasRequiredSpaceBeforeBlocks) return spaceBeforeBlocks;
  hasRequiredSpaceBeforeBlocks = 1;
  const astUtils2 = requireAstUtils();
  function isFunctionBody(node2) {
    const parent = node2.parent;
    return node2.type === "BlockStatement" && astUtils2.isFunction(parent) && parent.body === node2;
  }
  spaceBeforeBlocks = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "space-before-blocks",
              url: "https://eslint.style/rules/space-before-blocks"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before blocks",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/space-before-blocks"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                keywords: {
                  enum: ["always", "never", "off"]
                },
                functions: {
                  enum: ["always", "never", "off"]
                },
                classes: {
                  enum: ["always", "never", "off"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedSpace: "Unexpected space before opening brace.",
        missingSpace: "Missing space before opening brace."
      }
    },
    create(context) {
      const config2 = context.options[0], sourceCode2 = context.sourceCode;
      let alwaysFunctions = true, alwaysKeywords = true, alwaysClasses = true, neverFunctions = false, neverKeywords = false, neverClasses = false;
      if (typeof config2 === "object") {
        alwaysFunctions = config2.functions === "always";
        alwaysKeywords = config2.keywords === "always";
        alwaysClasses = config2.classes === "always";
        neverFunctions = config2.functions === "never";
        neverKeywords = config2.keywords === "never";
        neverClasses = config2.classes === "never";
      } else if (config2 === "never") {
        alwaysFunctions = false;
        alwaysKeywords = false;
        alwaysClasses = false;
        neverFunctions = true;
        neverKeywords = true;
        neverClasses = true;
      }
      function isConflicted(precedingToken, node2) {
        return astUtils2.isArrowToken(precedingToken) || astUtils2.isKeywordToken(precedingToken) && !isFunctionBody(node2) || astUtils2.isColonToken(precedingToken) && node2.parent && node2.parent.type === "SwitchCase" && precedingToken === astUtils2.getSwitchCaseColonToken(
          node2.parent,
          sourceCode2
        );
      }
      function checkPrecedingSpace(node2) {
        const precedingToken = sourceCode2.getTokenBefore(node2);
        if (precedingToken && !isConflicted(precedingToken, node2) && astUtils2.isTokenOnSameLine(precedingToken, node2)) {
          const hasSpace = sourceCode2.isSpaceBetweenTokens(
            precedingToken,
            node2
          );
          let requireSpace;
          let requireNoSpace;
          if (isFunctionBody(node2)) {
            requireSpace = alwaysFunctions;
            requireNoSpace = neverFunctions;
          } else if (node2.type === "ClassBody") {
            requireSpace = alwaysClasses;
            requireNoSpace = neverClasses;
          } else {
            requireSpace = alwaysKeywords;
            requireNoSpace = neverKeywords;
          }
          if (requireSpace && !hasSpace) {
            context.report({
              node: node2,
              messageId: "missingSpace",
              fix(fixer) {
                return fixer.insertTextBefore(node2, " ");
              }
            });
          } else if (requireNoSpace && hasSpace) {
            context.report({
              node: node2,
              messageId: "unexpectedSpace",
              fix(fixer) {
                return fixer.removeRange([
                  precedingToken.range[1],
                  node2.range[0]
                ]);
              }
            });
          }
        }
      }
      function checkSpaceBeforeCaseBlock(node2) {
        const cases = node2.cases;
        let openingBrace;
        if (cases.length > 0) {
          openingBrace = sourceCode2.getTokenBefore(cases[0]);
        } else {
          openingBrace = sourceCode2.getLastToken(node2, 1);
        }
        checkPrecedingSpace(openingBrace);
      }
      return {
        BlockStatement: checkPrecedingSpace,
        ClassBody: checkPrecedingSpace,
        SwitchStatement: checkSpaceBeforeCaseBlock
      };
    }
  };
  return spaceBeforeBlocks;
}
var spaceBeforeFunctionParen;
var hasRequiredSpaceBeforeFunctionParen;
function requireSpaceBeforeFunctionParen() {
  if (hasRequiredSpaceBeforeFunctionParen) return spaceBeforeFunctionParen;
  hasRequiredSpaceBeforeFunctionParen = 1;
  const astUtils2 = requireAstUtils();
  spaceBeforeFunctionParen = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "space-before-function-paren",
              url: "https://eslint.style/rules/space-before-function-paren"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before `function` definition opening parenthesis",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/space-before-function-paren"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                anonymous: {
                  enum: ["always", "never", "ignore"]
                },
                named: {
                  enum: ["always", "never", "ignore"]
                },
                asyncArrow: {
                  enum: ["always", "never", "ignore"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedSpace: "Unexpected space before function parentheses.",
        missingSpace: "Missing space before function parentheses."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
      const overrideConfig = typeof context.options[0] === "object" ? context.options[0] : {};
      function isNamedFunction(node2) {
        if (node2.id) {
          return true;
        }
        const parent = node2.parent;
        return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
      }
      function getConfigForFunction(node2) {
        if (node2.type === "ArrowFunctionExpression") {
          if (node2.async && astUtils2.isOpeningParenToken(
            sourceCode2.getFirstToken(node2, { skip: 1 })
          )) {
            return overrideConfig.asyncArrow || baseConfig;
          }
        } else if (isNamedFunction(node2)) {
          return overrideConfig.named || baseConfig;
        } else if (!node2.generator) {
          return overrideConfig.anonymous || baseConfig;
        }
        return "ignore";
      }
      function checkFunction(node2) {
        const functionConfig = getConfigForFunction(node2);
        if (functionConfig === "ignore") {
          return;
        }
        const rightToken = sourceCode2.getFirstToken(
          node2,
          astUtils2.isOpeningParenToken
        );
        const leftToken = sourceCode2.getTokenBefore(rightToken);
        const hasSpacing = sourceCode2.isSpaceBetweenTokens(
          leftToken,
          rightToken
        );
        if (hasSpacing && functionConfig === "never") {
          context.report({
            node: node2,
            loc: {
              start: leftToken.loc.end,
              end: rightToken.loc.start
            },
            messageId: "unexpectedSpace",
            fix(fixer) {
              const comments = sourceCode2.getCommentsBefore(rightToken);
              if (comments.some((comment2) => comment2.type === "Line")) {
                return null;
              }
              return fixer.replaceTextRange(
                [leftToken.range[1], rightToken.range[0]],
                comments.reduce(
                  (text, comment2) => text + sourceCode2.getText(comment2),
                  ""
                )
              );
            }
          });
        } else if (!hasSpacing && functionConfig === "always") {
          context.report({
            node: node2,
            loc: rightToken.loc,
            messageId: "missingSpace",
            fix: (fixer) => fixer.insertTextAfter(leftToken, " ")
          });
        }
      }
      return {
        ArrowFunctionExpression: checkFunction,
        FunctionDeclaration: checkFunction,
        FunctionExpression: checkFunction
      };
    }
  };
  return spaceBeforeFunctionParen;
}
var spaceInParens;
var hasRequiredSpaceInParens;
function requireSpaceInParens() {
  if (hasRequiredSpaceInParens) return spaceInParens;
  hasRequiredSpaceInParens = 1;
  const astUtils2 = requireAstUtils();
  spaceInParens = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "space-in-parens",
              url: "https://eslint.style/rules/space-in-parens"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing inside parentheses",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/space-in-parens"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                enum: ["{}", "[]", "()", "empty"]
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingOpeningSpace: "There must be a space after this paren.",
        missingClosingSpace: "There must be a space before this paren.",
        rejectedOpeningSpace: "There should be no space after this paren.",
        rejectedClosingSpace: "There should be no space before this paren."
      }
    },
    create(context) {
      const ALWAYS = context.options[0] === "always", exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [], options = {};
      let exceptions;
      if (exceptionsArrayOptions.length) {
        options.braceException = exceptionsArrayOptions.includes("{}");
        options.bracketException = exceptionsArrayOptions.includes("[]");
        options.parenException = exceptionsArrayOptions.includes("()");
        options.empty = exceptionsArrayOptions.includes("empty");
      }
      function getExceptions() {
        const openers = [], closers = [];
        if (options.braceException) {
          openers.push("{");
          closers.push("}");
        }
        if (options.bracketException) {
          openers.push("[");
          closers.push("]");
        }
        if (options.parenException) {
          openers.push("(");
          closers.push(")");
        }
        if (options.empty) {
          openers.push(")");
          closers.push("(");
        }
        return {
          openers,
          closers
        };
      }
      const sourceCode2 = context.sourceCode;
      function isOpenerException(token) {
        return exceptions.openers.includes(token.value);
      }
      function isCloserException(token) {
        return exceptions.closers.includes(token.value);
      }
      function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {
        if (sourceCode2.isSpaceBetweenTokens(
          openingParenToken,
          tokenAfterOpeningParen
        )) {
          return false;
        }
        if (!options.empty && astUtils2.isClosingParenToken(tokenAfterOpeningParen)) {
          return false;
        }
        if (ALWAYS) {
          return !isOpenerException(tokenAfterOpeningParen);
        }
        return isOpenerException(tokenAfterOpeningParen);
      }
      function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {
        if (!astUtils2.isTokenOnSameLine(
          openingParenToken,
          tokenAfterOpeningParen
        )) {
          return false;
        }
        if (tokenAfterOpeningParen.type === "Line") {
          return false;
        }
        if (!sourceCode2.isSpaceBetweenTokens(
          openingParenToken,
          tokenAfterOpeningParen
        )) {
          return false;
        }
        if (ALWAYS) {
          return isOpenerException(tokenAfterOpeningParen);
        }
        return !isOpenerException(tokenAfterOpeningParen);
      }
      function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {
        if (sourceCode2.isSpaceBetweenTokens(
          tokenBeforeClosingParen,
          closingParenToken
        )) {
          return false;
        }
        if (!options.empty && astUtils2.isOpeningParenToken(tokenBeforeClosingParen)) {
          return false;
        }
        if (ALWAYS) {
          return !isCloserException(tokenBeforeClosingParen);
        }
        return isCloserException(tokenBeforeClosingParen);
      }
      function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {
        if (!astUtils2.isTokenOnSameLine(
          tokenBeforeClosingParen,
          closingParenToken
        )) {
          return false;
        }
        if (!sourceCode2.isSpaceBetweenTokens(
          tokenBeforeClosingParen,
          closingParenToken
        )) {
          return false;
        }
        if (ALWAYS) {
          return isCloserException(tokenBeforeClosingParen);
        }
        return !isCloserException(tokenBeforeClosingParen);
      }
      return {
        Program: function checkParenSpaces(node2) {
          exceptions = getExceptions();
          const tokens = sourceCode2.tokensAndComments;
          tokens.forEach((token, i2) => {
            const prevToken = tokens[i2 - 1];
            const nextToken = tokens[i2 + 1];
            if (!astUtils2.isOpeningParenToken(token) && !astUtils2.isClosingParenToken(token)) {
              return;
            }
            if (token.value === "(" && openerMissingSpace(token, nextToken)) {
              context.report({
                node: node2,
                loc: token.loc,
                messageId: "missingOpeningSpace",
                fix(fixer) {
                  return fixer.insertTextAfter(token, " ");
                }
              });
            }
            if (token.value === "(" && openerRejectsSpace(token, nextToken)) {
              context.report({
                node: node2,
                loc: {
                  start: token.loc.end,
                  end: nextToken.loc.start
                },
                messageId: "rejectedOpeningSpace",
                fix(fixer) {
                  return fixer.removeRange([
                    token.range[1],
                    nextToken.range[0]
                  ]);
                }
              });
            }
            if (token.value === ")" && closerMissingSpace(prevToken, token)) {
              context.report({
                node: node2,
                loc: token.loc,
                messageId: "missingClosingSpace",
                fix(fixer) {
                  return fixer.insertTextBefore(token, " ");
                }
              });
            }
            if (token.value === ")" && closerRejectsSpace(prevToken, token)) {
              context.report({
                node: node2,
                loc: {
                  start: prevToken.loc.end,
                  end: token.loc.start
                },
                messageId: "rejectedClosingSpace",
                fix(fixer) {
                  return fixer.removeRange([
                    prevToken.range[1],
                    token.range[0]
                  ]);
                }
              });
            }
          });
        }
      };
    }
  };
  return spaceInParens;
}
var spaceInfixOps;
var hasRequiredSpaceInfixOps;
function requireSpaceInfixOps() {
  if (hasRequiredSpaceInfixOps) return spaceInfixOps;
  hasRequiredSpaceInfixOps = 1;
  const { isEqToken } = requireAstUtils();
  spaceInfixOps = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "space-infix-ops",
              url: "https://eslint.style/rules/space-infix-ops"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require spacing around infix operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/space-infix-ops"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            int32Hint: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingSpace: "Operator '{{operator}}' must be spaced."
      }
    },
    create(context) {
      const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
      const sourceCode2 = context.sourceCode;
      function getFirstNonSpacedToken(left, right, op) {
        const operator2 = sourceCode2.getFirstTokenBetween(
          left,
          right,
          (token) => token.value === op
        );
        const prev = sourceCode2.getTokenBefore(operator2);
        const next = sourceCode2.getTokenAfter(operator2);
        if (!sourceCode2.isSpaceBetweenTokens(prev, operator2) || !sourceCode2.isSpaceBetweenTokens(operator2, next)) {
          return operator2;
        }
        return null;
      }
      function report(mainNode, culpritToken) {
        context.report({
          node: mainNode,
          loc: culpritToken.loc,
          messageId: "missingSpace",
          data: {
            operator: culpritToken.value
          },
          fix(fixer) {
            const previousToken = sourceCode2.getTokenBefore(culpritToken);
            const afterToken = sourceCode2.getTokenAfter(culpritToken);
            let fixString = "";
            if (culpritToken.range[0] - previousToken.range[1] === 0) {
              fixString = " ";
            }
            fixString += culpritToken.value;
            if (afterToken.range[0] - culpritToken.range[1] === 0) {
              fixString += " ";
            }
            return fixer.replaceText(culpritToken, fixString);
          }
        });
      }
      function checkBinary(node2) {
        const leftNode = node2.left.typeAnnotation ? node2.left.typeAnnotation : node2.left;
        const rightNode = node2.right;
        const operator2 = node2.operator || "=";
        const nonSpacedNode = getFirstNonSpacedToken(
          leftNode,
          rightNode,
          operator2
        );
        if (nonSpacedNode) {
          if (!(int32Hint && sourceCode2.getText(node2).endsWith("|0"))) {
            report(node2, nonSpacedNode);
          }
        }
      }
      function checkConditional(node2) {
        const nonSpacedConsequentNode = getFirstNonSpacedToken(
          node2.test,
          node2.consequent,
          "?"
        );
        const nonSpacedAlternateNode = getFirstNonSpacedToken(
          node2.consequent,
          node2.alternate,
          ":"
        );
        if (nonSpacedConsequentNode) {
          report(node2, nonSpacedConsequentNode);
        }
        if (nonSpacedAlternateNode) {
          report(node2, nonSpacedAlternateNode);
        }
      }
      function checkVar(node2) {
        const leftNode = node2.id.typeAnnotation ? node2.id.typeAnnotation : node2.id;
        const rightNode = node2.init;
        if (rightNode) {
          const nonSpacedNode = getFirstNonSpacedToken(
            leftNode,
            rightNode,
            "="
          );
          if (nonSpacedNode) {
            report(node2, nonSpacedNode);
          }
        }
      }
      return {
        AssignmentExpression: checkBinary,
        AssignmentPattern: checkBinary,
        BinaryExpression: checkBinary,
        LogicalExpression: checkBinary,
        ConditionalExpression: checkConditional,
        VariableDeclarator: checkVar,
        PropertyDefinition(node2) {
          if (!node2.value) {
            return;
          }
          const operatorToken2 = sourceCode2.getTokenBefore(
            node2.value,
            isEqToken
          );
          const leftToken = sourceCode2.getTokenBefore(operatorToken2);
          const rightToken = sourceCode2.getTokenAfter(operatorToken2);
          if (!sourceCode2.isSpaceBetweenTokens(
            leftToken,
            operatorToken2
          ) || !sourceCode2.isSpaceBetweenTokens(operatorToken2, rightToken)) {
            report(node2, operatorToken2);
          }
        }
      };
    }
  };
  return spaceInfixOps;
}
var spaceUnaryOps;
var hasRequiredSpaceUnaryOps;
function requireSpaceUnaryOps() {
  if (hasRequiredSpaceUnaryOps) return spaceUnaryOps;
  hasRequiredSpaceUnaryOps = 1;
  const astUtils2 = requireAstUtils();
  spaceUnaryOps = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "space-unary-ops",
              url: "https://eslint.style/rules/space-unary-ops"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce consistent spacing before or after unary operators",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/space-unary-ops"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            words: {
              type: "boolean",
              default: true
            },
            nonwords: {
              type: "boolean",
              default: false
            },
            overrides: {
              type: "object",
              additionalProperties: {
                type: "boolean"
              }
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
        unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
        unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
        wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
        operator: "Unary operator '{{operator}}' must be followed by whitespace.",
        beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
      }
    },
    create(context) {
      const options = context.options[0] || { words: true, nonwords: false };
      const sourceCode2 = context.sourceCode;
      function isFirstBangInBangBangExpression(node2) {
        return node2 && node2.type === "UnaryExpression" && node2.argument.operator === "!" && node2.argument && node2.argument.type === "UnaryExpression" && node2.argument.operator === "!";
      }
      function overrideExistsForOperator(operator2) {
        return options.overrides && Object.hasOwn(options.overrides, operator2);
      }
      function overrideEnforcesSpaces(operator2) {
        return options.overrides[operator2];
      }
      function verifyWordHasSpaces(node2, firstToken, secondToken, word) {
        if (secondToken.range[0] === firstToken.range[1]) {
          context.report({
            node: node2,
            messageId: "wordOperator",
            data: {
              word
            },
            fix(fixer) {
              return fixer.insertTextAfter(firstToken, " ");
            }
          });
        }
      }
      function verifyWordDoesntHaveSpaces(node2, firstToken, secondToken, word) {
        if (astUtils2.canTokensBeAdjacent(firstToken, secondToken)) {
          if (secondToken.range[0] > firstToken.range[1]) {
            context.report({
              node: node2,
              messageId: "unexpectedAfterWord",
              data: {
                word
              },
              fix(fixer) {
                return fixer.removeRange([
                  firstToken.range[1],
                  secondToken.range[0]
                ]);
              }
            });
          }
        }
      }
      function checkUnaryWordOperatorForSpaces(node2, firstToken, secondToken, word) {
        if (overrideExistsForOperator(word)) {
          if (overrideEnforcesSpaces(word)) {
            verifyWordHasSpaces(node2, firstToken, secondToken, word);
          } else {
            verifyWordDoesntHaveSpaces(
              node2,
              firstToken,
              secondToken,
              word
            );
          }
        } else if (options.words) {
          verifyWordHasSpaces(node2, firstToken, secondToken, word);
        } else {
          verifyWordDoesntHaveSpaces(node2, firstToken, secondToken, word);
        }
      }
      function checkForSpacesAfterYield(node2) {
        const tokens = sourceCode2.getFirstTokens(node2, 3), word = "yield";
        if (!node2.argument || node2.delegate) {
          return;
        }
        checkUnaryWordOperatorForSpaces(node2, tokens[0], tokens[1], word);
      }
      function checkForSpacesAfterAwait(node2) {
        const tokens = sourceCode2.getFirstTokens(node2, 3);
        checkUnaryWordOperatorForSpaces(
          node2,
          tokens[0],
          tokens[1],
          "await"
        );
      }
      function verifyNonWordsHaveSpaces(node2, firstToken, secondToken) {
        if (node2.prefix) {
          if (isFirstBangInBangBangExpression(node2)) {
            return;
          }
          if (firstToken.range[1] === secondToken.range[0]) {
            context.report({
              node: node2,
              messageId: "operator",
              data: {
                operator: firstToken.value
              },
              fix(fixer) {
                return fixer.insertTextAfter(firstToken, " ");
              }
            });
          }
        } else {
          if (firstToken.range[1] === secondToken.range[0]) {
            context.report({
              node: node2,
              messageId: "beforeUnaryExpressions",
              data: {
                token: secondToken.value
              },
              fix(fixer) {
                return fixer.insertTextBefore(secondToken, " ");
              }
            });
          }
        }
      }
      function verifyNonWordsDontHaveSpaces(node2, firstToken, secondToken) {
        if (node2.prefix) {
          if (secondToken.range[0] > firstToken.range[1]) {
            context.report({
              node: node2,
              messageId: "unexpectedAfter",
              data: {
                operator: firstToken.value
              },
              fix(fixer) {
                if (astUtils2.canTokensBeAdjacent(
                  firstToken,
                  secondToken
                )) {
                  return fixer.removeRange([
                    firstToken.range[1],
                    secondToken.range[0]
                  ]);
                }
                return null;
              }
            });
          }
        } else {
          if (secondToken.range[0] > firstToken.range[1]) {
            context.report({
              node: node2,
              messageId: "unexpectedBefore",
              data: {
                operator: secondToken.value
              },
              fix(fixer) {
                return fixer.removeRange([
                  firstToken.range[1],
                  secondToken.range[0]
                ]);
              }
            });
          }
        }
      }
      function checkForSpaces(node2) {
        const tokens = node2.type === "UpdateExpression" && !node2.prefix ? sourceCode2.getLastTokens(node2, 2) : sourceCode2.getFirstTokens(node2, 2);
        const firstToken = tokens[0];
        const secondToken = tokens[1];
        if ((node2.type === "NewExpression" || node2.prefix) && firstToken.type === "Keyword") {
          checkUnaryWordOperatorForSpaces(
            node2,
            firstToken,
            secondToken,
            firstToken.value
          );
          return;
        }
        const operator2 = node2.prefix ? tokens[0].value : tokens[1].value;
        if (overrideExistsForOperator(operator2)) {
          if (overrideEnforcesSpaces(operator2)) {
            verifyNonWordsHaveSpaces(node2, firstToken, secondToken);
          } else {
            verifyNonWordsDontHaveSpaces(node2, firstToken, secondToken);
          }
        } else if (options.nonwords) {
          verifyNonWordsHaveSpaces(node2, firstToken, secondToken);
        } else {
          verifyNonWordsDontHaveSpaces(node2, firstToken, secondToken);
        }
      }
      return {
        UnaryExpression: checkForSpaces,
        UpdateExpression: checkForSpaces,
        NewExpression: checkForSpaces,
        YieldExpression: checkForSpacesAfterYield,
        AwaitExpression: checkForSpacesAfterAwait
      };
    }
  };
  return spaceUnaryOps;
}
var spacedComment;
var hasRequiredSpacedComment;
function requireSpacedComment() {
  if (hasRequiredSpacedComment) return spacedComment;
  hasRequiredSpacedComment = 1;
  const escapeRegExp = requireEscapeStringRegexp();
  const astUtils2 = requireAstUtils();
  function escape2(s2) {
    return `(?:${escapeRegExp(s2)})`;
  }
  function escapeAndRepeat(s2) {
    return `${escape2(s2)}+`;
  }
  function parseMarkersOption(markers) {
    if (!markers.includes("*")) {
      return markers.concat("*");
    }
    return markers;
  }
  function createExceptionsPattern(exceptions) {
    let pattern2 = "";
    if (exceptions.length === 0) {
      pattern2 += "\\s";
    } else {
      pattern2 += "(?:\\s|";
      if (exceptions.length === 1) {
        pattern2 += escapeAndRepeat(exceptions[0]);
      } else {
        pattern2 += "(?:";
        pattern2 += exceptions.map(escapeAndRepeat).join("|");
        pattern2 += ")";
      }
      pattern2 += `(?:$|[${Array.from(astUtils2.LINEBREAKS).join("")}]))`;
    }
    return pattern2;
  }
  function createAlwaysStylePattern(markers, exceptions) {
    let pattern2 = "^";
    if (markers.length === 1) {
      pattern2 += escape2(markers[0]);
    } else {
      pattern2 += "(?:";
      pattern2 += markers.map(escape2).join("|");
      pattern2 += ")";
    }
    pattern2 += "?";
    pattern2 += createExceptionsPattern(exceptions);
    return new RegExp(pattern2, "u");
  }
  function createNeverStylePattern(markers) {
    const pattern2 = `^(${markers.map(escape2).join("|")})?[ 	]+`;
    return new RegExp(pattern2, "u");
  }
  spacedComment = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "spaced-comment",
              url: "https://eslint.style/rules/spaced-comment"
            }
          }
        ]
      },
      type: "suggestion",
      docs: {
        description: "Enforce consistent spacing after the `//` or `/*` in a comment",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/spaced-comment"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            },
            line: {
              type: "object",
              properties: {
                exceptions: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                markers: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              },
              additionalProperties: false
            },
            block: {
              type: "object",
              properties: {
                exceptions: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                markers: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                balanced: {
                  type: "boolean",
                  default: false
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
        expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
        unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
        unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
        expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
        expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const requireSpace = context.options[0] !== "never";
      const config2 = context.options[1] || {};
      const balanced = config2.block && config2.block.balanced;
      const styleRules = ["block", "line"].reduce((rule, type2) => {
        const markers = parseMarkersOption(
          config2[type2] && config2[type2].markers || config2.markers || []
        );
        const exceptions = config2[type2] && config2[type2].exceptions || config2.exceptions || [];
        const endNeverPattern = "[ 	]+$";
        rule[type2] = {
          beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
          endRegex: balanced && requireSpace ? new RegExp(
            `${createExceptionsPattern(exceptions)}$`,
            "u"
          ) : new RegExp(endNeverPattern, "u"),
          hasExceptions: exceptions.length > 0,
          captureMarker: new RegExp(
            `^(${markers.map(escape2).join("|")})`,
            "u"
          ),
          markers: new Set(markers)
        };
        return rule;
      }, {});
      function reportBegin(node2, messageId, match, refChar) {
        const type2 = node2.type.toLowerCase(), commentIdentifier = type2 === "block" ? "/*" : "//";
        context.report({
          node: node2,
          fix(fixer) {
            const start = node2.range[0];
            let end = start + 2;
            if (requireSpace) {
              if (match) {
                end += match[0].length;
              }
              return fixer.insertTextAfterRange([start, end], " ");
            }
            end += match[0].length;
            return fixer.replaceTextRange(
              [start, end],
              commentIdentifier + (match[1] ? match[1] : "")
            );
          },
          messageId,
          data: { refChar }
        });
      }
      function reportEnd(node2, messageId, match) {
        context.report({
          node: node2,
          fix(fixer) {
            if (requireSpace) {
              return fixer.insertTextAfterRange(
                [node2.range[0], node2.range[1] - 2],
                " "
              );
            }
            const end = node2.range[1] - 2, start = end - match[0].length;
            return fixer.replaceTextRange([start, end], "");
          },
          messageId
        });
      }
      function checkCommentForSpace(node2) {
        const type2 = node2.type.toLowerCase(), rule = styleRules[type2], commentIdentifier = type2 === "block" ? "/*" : "//";
        if (node2.value.length === 0 || rule.markers.has(node2.value)) {
          return;
        }
        const beginMatch = rule.beginRegex.exec(node2.value);
        const endMatch = rule.endRegex.exec(node2.value);
        if (requireSpace) {
          if (!beginMatch) {
            const hasMarker = rule.captureMarker.exec(node2.value);
            const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
            if (rule.hasExceptions) {
              reportBegin(
                node2,
                "expectedExceptionAfter",
                hasMarker,
                marker
              );
            } else {
              reportBegin(
                node2,
                "expectedSpaceAfter",
                hasMarker,
                marker
              );
            }
          }
          if (balanced && type2 === "block" && !endMatch) {
            reportEnd(node2, "expectedSpaceBefore");
          }
        } else {
          if (beginMatch) {
            if (!beginMatch[1]) {
              reportBegin(
                node2,
                "unexpectedSpaceAfter",
                beginMatch,
                commentIdentifier
              );
            } else {
              reportBegin(
                node2,
                "unexpectedSpaceAfterMarker",
                beginMatch,
                beginMatch[1]
              );
            }
          }
          if (balanced && type2 === "block" && endMatch) {
            reportEnd(node2, "unexpectedSpaceBefore", endMatch);
          }
        }
      }
      return {
        Program() {
          const comments = sourceCode2.getAllComments();
          comments.filter((token) => token.type !== "Shebang").forEach(checkCommentForSpace);
        }
      };
    }
  };
  return spacedComment;
}
var strict;
var hasRequiredStrict;
function requireStrict() {
  if (hasRequiredStrict) return strict;
  hasRequiredStrict = 1;
  const astUtils2 = requireAstUtils();
  function getUseStrictDirectives(statements) {
    const directives2 = [];
    for (let i2 = 0; i2 < statements.length; i2++) {
      const statement = statements[i2];
      if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
        directives2[i2] = statement;
      } else {
        break;
      }
    }
    return directives2;
  }
  function isSimpleParameter(node2) {
    return node2.type === "Identifier";
  }
  function isSimpleParameterList(params) {
    return params.every(isSimpleParameter);
  }
  strict = {
    meta: {
      type: "suggestion",
      defaultOptions: ["safe"],
      docs: {
        description: "Require or disallow strict mode directives",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/strict"
      },
      schema: [
        {
          enum: ["never", "global", "function", "safe"]
        }
      ],
      fixable: "code",
      messages: {
        function: "Use the function form of 'use strict'.",
        global: "Use the global form of 'use strict'.",
        multiple: "Multiple 'use strict' directives.",
        never: "Strict mode is not permitted.",
        unnecessary: "Unnecessary 'use strict' directive.",
        module: "'use strict' is unnecessary inside of modules.",
        implied: "'use strict' is unnecessary when implied strict mode is enabled.",
        unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
        nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
        wrap: "Wrap {{name}} in a function with 'use strict' directive."
      }
    },
    create(context) {
      const ecmaFeatures = context.languageOptions.parserOptions.ecmaFeatures || {}, scopes = [], classScopes = [];
      let [mode] = context.options;
      if (ecmaFeatures.impliedStrict) {
        mode = "implied";
      } else if (mode === "safe") {
        mode = ecmaFeatures.globalReturn || context.languageOptions.sourceType === "commonjs" ? "global" : "function";
      }
      function shouldFix(errorType) {
        return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
      }
      function getFixFunction(node2) {
        return (fixer) => fixer.remove(node2);
      }
      function reportSlice(nodes, start, end, messageId, fix) {
        nodes.slice(start, end).forEach((node2) => {
          context.report({
            node: node2,
            messageId,
            fix: fix ? getFixFunction(node2) : null
          });
        });
      }
      function reportAll(nodes, messageId, fix) {
        reportSlice(nodes, 0, nodes.length, messageId, fix);
      }
      function reportAllExceptFirst(nodes, messageId, fix) {
        reportSlice(nodes, 1, nodes.length, messageId, fix);
      }
      function enterFunctionInFunctionMode(node2, useStrictDirectives) {
        const isInClass = classScopes.length > 0, isParentGlobal = scopes.length === 0 && classScopes.length === 0, isParentStrict = scopes.length > 0 && scopes.at(-1), isStrict = useStrictDirectives.length > 0;
        if (isStrict) {
          if (!isSimpleParameterList(node2.params)) {
            context.report({
              node: useStrictDirectives[0],
              messageId: "nonSimpleParameterList"
            });
          } else if (isParentStrict) {
            context.report({
              node: useStrictDirectives[0],
              messageId: "unnecessary",
              fix: getFixFunction(useStrictDirectives[0])
            });
          } else if (isInClass) {
            context.report({
              node: useStrictDirectives[0],
              messageId: "unnecessaryInClasses",
              fix: getFixFunction(useStrictDirectives[0])
            });
          }
          reportAllExceptFirst(useStrictDirectives, "multiple", true);
        } else if (isParentGlobal) {
          if (isSimpleParameterList(node2.params)) {
            context.report({ node: node2, messageId: "function" });
          } else {
            context.report({
              node: node2,
              messageId: "wrap",
              data: { name: astUtils2.getFunctionNameWithKind(node2) }
            });
          }
        }
        scopes.push(isParentStrict || isStrict);
      }
      function exitFunctionInFunctionMode() {
        scopes.pop();
      }
      function enterFunction(node2) {
        const isBlock = node2.body.type === "BlockStatement", useStrictDirectives = isBlock ? getUseStrictDirectives(node2.body.body) : [];
        if (mode === "function") {
          enterFunctionInFunctionMode(node2, useStrictDirectives);
        } else if (useStrictDirectives.length > 0) {
          if (isSimpleParameterList(node2.params)) {
            reportAll(useStrictDirectives, mode, shouldFix(mode));
          } else {
            context.report({
              node: useStrictDirectives[0],
              messageId: "nonSimpleParameterList"
            });
            reportAllExceptFirst(useStrictDirectives, "multiple", true);
          }
        }
      }
      const rule = {
        Program(node2) {
          const useStrictDirectives = getUseStrictDirectives(node2.body);
          if (node2.sourceType === "module") {
            mode = "module";
          }
          if (mode === "global") {
            if (node2.body.length > 0 && useStrictDirectives.length === 0) {
              context.report({ node: node2, messageId: "global" });
            }
            reportAllExceptFirst(useStrictDirectives, "multiple", true);
          } else {
            reportAll(useStrictDirectives, mode, shouldFix(mode));
          }
        },
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        ArrowFunctionExpression: enterFunction
      };
      if (mode === "function") {
        Object.assign(rule, {
          // Inside of class bodies are always strict mode.
          ClassBody() {
            classScopes.push(true);
          },
          "ClassBody:exit"() {
            classScopes.pop();
          },
          "FunctionDeclaration:exit": exitFunctionInFunctionMode,
          "FunctionExpression:exit": exitFunctionInFunctionMode,
          "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
        });
      }
      return rule;
    }
  };
  return strict;
}
var switchColonSpacing;
var hasRequiredSwitchColonSpacing;
function requireSwitchColonSpacing() {
  if (hasRequiredSwitchColonSpacing) return switchColonSpacing;
  hasRequiredSwitchColonSpacing = 1;
  const astUtils2 = requireAstUtils();
  switchColonSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "switch-colon-spacing",
              url: "https://eslint.style/rules/switch-colon-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Enforce spacing around colons of switch statements",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/switch-colon-spacing"
      },
      schema: [
        {
          type: "object",
          properties: {
            before: { type: "boolean", default: false },
            after: { type: "boolean", default: true }
          },
          additionalProperties: false
        }
      ],
      fixable: "whitespace",
      messages: {
        expectedBefore: "Expected space(s) before this colon.",
        expectedAfter: "Expected space(s) after this colon.",
        unexpectedBefore: "Unexpected space(s) before this colon.",
        unexpectedAfter: "Unexpected space(s) after this colon."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const options = context.options[0] || {};
      const beforeSpacing = options.before === true;
      const afterSpacing = options.after !== false;
      function isValidSpacing(left, right, expected) {
        return astUtils2.isClosingBraceToken(right) || !astUtils2.isTokenOnSameLine(left, right) || sourceCode2.isSpaceBetweenTokens(left, right) === expected;
      }
      function commentsExistBetween(left, right) {
        return sourceCode2.getFirstTokenBetween(left, right, {
          includeComments: true,
          filter: astUtils2.isCommentToken
        }) !== null;
      }
      function fix(fixer, left, right, spacing) {
        if (commentsExistBetween(left, right)) {
          return null;
        }
        if (spacing) {
          return fixer.insertTextAfter(left, " ");
        }
        return fixer.removeRange([left.range[1], right.range[0]]);
      }
      return {
        SwitchCase(node2) {
          const colonToken = astUtils2.getSwitchCaseColonToken(
            node2,
            sourceCode2
          );
          const beforeToken = sourceCode2.getTokenBefore(colonToken);
          const afterToken = sourceCode2.getTokenAfter(colonToken);
          if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
            context.report({
              node: node2,
              loc: colonToken.loc,
              messageId: beforeSpacing ? "expectedBefore" : "unexpectedBefore",
              fix: (fixer) => fix(fixer, beforeToken, colonToken, beforeSpacing)
            });
          }
          if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
            context.report({
              node: node2,
              loc: colonToken.loc,
              messageId: afterSpacing ? "expectedAfter" : "unexpectedAfter",
              fix: (fixer) => fix(fixer, colonToken, afterToken, afterSpacing)
            });
          }
        }
      };
    }
  };
  return switchColonSpacing;
}
var symbolDescription;
var hasRequiredSymbolDescription;
function requireSymbolDescription() {
  if (hasRequiredSymbolDescription) return symbolDescription;
  hasRequiredSymbolDescription = 1;
  const astUtils2 = requireAstUtils();
  symbolDescription = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require symbol descriptions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/symbol-description"
      },
      fixable: null,
      schema: [],
      messages: {
        expected: "Expected Symbol to have a description."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      function checkArgument(node2) {
        if (node2.arguments.length === 0) {
          context.report({
            node: node2,
            messageId: "expected"
          });
        }
      }
      return {
        "Program:exit"(node2) {
          const scope = sourceCode2.getScope(node2);
          const variable = astUtils2.getVariableByName(scope, "Symbol");
          if (variable && variable.defs.length === 0) {
            variable.references.forEach((reference) => {
              const idNode = reference.identifier;
              if (astUtils2.isCallee(idNode)) {
                checkArgument(idNode.parent);
              }
            });
          }
        }
      };
    }
  };
  return symbolDescription;
}
var templateCurlySpacing;
var hasRequiredTemplateCurlySpacing;
function requireTemplateCurlySpacing() {
  if (hasRequiredTemplateCurlySpacing) return templateCurlySpacing;
  hasRequiredTemplateCurlySpacing = 1;
  const astUtils2 = requireAstUtils();
  templateCurlySpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "template-curly-spacing",
              url: "https://eslint.style/rules/template-curly-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow spacing around embedded expressions of template strings",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/template-curly-spacing"
      },
      fixable: "whitespace",
      schema: [{ enum: ["always", "never"] }],
      messages: {
        expectedBefore: "Expected space(s) before '}'.",
        expectedAfter: "Expected space(s) after '${'.",
        unexpectedBefore: "Unexpected space(s) before '}'.",
        unexpectedAfter: "Unexpected space(s) after '${'."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const always = context.options[0] === "always";
      function checkSpacingBefore(token) {
        if (!token.value.startsWith("}")) {
          return;
        }
        const prevToken = sourceCode2.getTokenBefore(token, {
          includeComments: true
        }), hasSpace = sourceCode2.isSpaceBetween(prevToken, token);
        if (!astUtils2.isTokenOnSameLine(prevToken, token)) {
          return;
        }
        if (always && !hasSpace) {
          context.report({
            loc: {
              start: token.loc.start,
              end: {
                line: token.loc.start.line,
                column: token.loc.start.column + 1
              }
            },
            messageId: "expectedBefore",
            fix: (fixer) => fixer.insertTextBefore(token, " ")
          });
        }
        if (!always && hasSpace) {
          context.report({
            loc: {
              start: prevToken.loc.end,
              end: token.loc.start
            },
            messageId: "unexpectedBefore",
            fix: (fixer) => fixer.removeRange([prevToken.range[1], token.range[0]])
          });
        }
      }
      function checkSpacingAfter(token) {
        if (!token.value.endsWith("${")) {
          return;
        }
        const nextToken = sourceCode2.getTokenAfter(token, {
          includeComments: true
        }), hasSpace = sourceCode2.isSpaceBetween(token, nextToken);
        if (!astUtils2.isTokenOnSameLine(token, nextToken)) {
          return;
        }
        if (always && !hasSpace) {
          context.report({
            loc: {
              start: {
                line: token.loc.end.line,
                column: token.loc.end.column - 2
              },
              end: token.loc.end
            },
            messageId: "expectedAfter",
            fix: (fixer) => fixer.insertTextAfter(token, " ")
          });
        }
        if (!always && hasSpace) {
          context.report({
            loc: {
              start: token.loc.end,
              end: nextToken.loc.start
            },
            messageId: "unexpectedAfter",
            fix: (fixer) => fixer.removeRange([token.range[1], nextToken.range[0]])
          });
        }
      }
      return {
        TemplateElement(node2) {
          const token = sourceCode2.getFirstToken(node2);
          checkSpacingBefore(token);
          checkSpacingAfter(token);
        }
      };
    }
  };
  return templateCurlySpacing;
}
var templateTagSpacing;
var hasRequiredTemplateTagSpacing;
function requireTemplateTagSpacing() {
  if (hasRequiredTemplateTagSpacing) return templateTagSpacing;
  hasRequiredTemplateTagSpacing = 1;
  templateTagSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "template-tag-spacing",
              url: "https://eslint.style/rules/template-tag-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow spacing between template tags and their literals",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/template-tag-spacing"
      },
      fixable: "whitespace",
      schema: [{ enum: ["always", "never"] }],
      messages: {
        unexpected: "Unexpected space between template tag and template literal.",
        missing: "Missing space between template tag and template literal."
      }
    },
    create(context) {
      const never = context.options[0] !== "always";
      const sourceCode2 = context.sourceCode;
      function checkSpacing(node2) {
        const tagToken = sourceCode2.getTokenBefore(node2.quasi);
        const literalToken = sourceCode2.getFirstToken(node2.quasi);
        const hasWhitespace = sourceCode2.isSpaceBetweenTokens(
          tagToken,
          literalToken
        );
        if (never && hasWhitespace) {
          context.report({
            node: node2,
            loc: {
              start: tagToken.loc.end,
              end: literalToken.loc.start
            },
            messageId: "unexpected",
            fix(fixer) {
              const comments = sourceCode2.getCommentsBefore(
                node2.quasi
              );
              if (comments.some((comment2) => comment2.type === "Line")) {
                return null;
              }
              return fixer.replaceTextRange(
                [tagToken.range[1], literalToken.range[0]],
                comments.reduce(
                  (text, comment2) => text + sourceCode2.getText(comment2),
                  ""
                )
              );
            }
          });
        } else if (!never && !hasWhitespace) {
          context.report({
            node: node2,
            loc: {
              start: node2.loc.start,
              end: literalToken.loc.start
            },
            messageId: "missing",
            fix(fixer) {
              return fixer.insertTextAfter(tagToken, " ");
            }
          });
        }
      }
      return {
        TaggedTemplateExpression: checkSpacing
      };
    }
  };
  return templateTagSpacing;
}
var unicodeBom;
var hasRequiredUnicodeBom;
function requireUnicodeBom() {
  if (hasRequiredUnicodeBom) return unicodeBom;
  hasRequiredUnicodeBom = 1;
  unicodeBom = {
    meta: {
      type: "layout",
      defaultOptions: ["never"],
      docs: {
        description: "Require or disallow Unicode byte order mark (BOM)",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/unicode-bom"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        expected: "Expected Unicode BOM (Byte Order Mark).",
        unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
      }
    },
    create(context) {
      return {
        Program: function checkUnicodeBOM(node2) {
          const sourceCode2 = context.sourceCode, location = { column: 0, line: 1 };
          const [requireBOM] = context.options;
          if (!sourceCode2.hasBOM && requireBOM === "always") {
            context.report({
              node: node2,
              loc: location,
              messageId: "expected",
              fix(fixer) {
                return fixer.insertTextBeforeRange(
                  [0, 1],
                  "\uFEFF"
                );
              }
            });
          } else if (sourceCode2.hasBOM && requireBOM === "never") {
            context.report({
              node: node2,
              loc: location,
              messageId: "unexpected",
              fix(fixer) {
                return fixer.removeRange([-1, 0]);
              }
            });
          }
        }
      };
    }
  };
  return unicodeBom;
}
var useIsnan;
var hasRequiredUseIsnan;
function requireUseIsnan() {
  if (hasRequiredUseIsnan) return useIsnan;
  hasRequiredUseIsnan = 1;
  const astUtils2 = requireAstUtils();
  function isNaNIdentifier(node2) {
    if (!node2) {
      return false;
    }
    const nodeToCheck = node2.type === "SequenceExpression" ? node2.expressions.at(-1) : node2;
    return astUtils2.isSpecificId(nodeToCheck, "NaN") || astUtils2.isSpecificMemberAccess(nodeToCheck, "Number", "NaN");
  }
  useIsnan = {
    meta: {
      hasSuggestions: true,
      type: "problem",
      docs: {
        description: "Require calls to `isNaN()` when checking for `NaN`",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/use-isnan"
      },
      schema: [
        {
          type: "object",
          properties: {
            enforceForSwitchCase: {
              type: "boolean"
            },
            enforceForIndexOf: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      defaultOptions: [
        {
          enforceForIndexOf: false,
          enforceForSwitchCase: true
        }
      ],
      messages: {
        comparisonWithNaN: "Use the isNaN function to compare with NaN.",
        switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
        caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.",
        indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN.",
        replaceWithIsNaN: "Replace with Number.isNaN.",
        replaceWithCastingAndIsNaN: "Replace with Number.isNaN and cast to a Number.",
        replaceWithFindIndex: "Replace with Array.prototype.{{ methodName }}."
      }
    },
    create(context) {
      const [{ enforceForIndexOf, enforceForSwitchCase }] = context.options;
      const sourceCode2 = context.sourceCode;
      const fixableOperators = /* @__PURE__ */ new Set(["==", "===", "!=", "!=="]);
      const castableOperators = /* @__PURE__ */ new Set(["==", "!="]);
      function getBinaryExpressionFixer(node2, wrapValue) {
        return (fixer) => {
          const comparedValue = isNaNIdentifier(node2.left) ? node2.right : node2.left;
          const shouldWrap = comparedValue.type === "SequenceExpression";
          const shouldNegate = node2.operator[0] === "!";
          const negation = shouldNegate ? "!" : "";
          let comparedValueText = sourceCode2.getText(comparedValue);
          if (shouldWrap) {
            comparedValueText = `(${comparedValueText})`;
          }
          const fixedValue = wrapValue(comparedValueText);
          return fixer.replaceText(node2, `${negation}${fixedValue}`);
        };
      }
      function checkBinaryExpression(node2) {
        if (/^(?:[<>]|[!=]=)=?$/u.test(node2.operator) && (isNaNIdentifier(node2.left) || isNaNIdentifier(node2.right))) {
          const suggestedFixes = [];
          const NaNNode = isNaNIdentifier(node2.left) ? node2.left : node2.right;
          const isSequenceExpression = NaNNode.type === "SequenceExpression";
          const isSuggestable = fixableOperators.has(node2.operator) && !isSequenceExpression;
          const isCastable = castableOperators.has(node2.operator);
          if (isSuggestable) {
            suggestedFixes.push({
              messageId: "replaceWithIsNaN",
              fix: getBinaryExpressionFixer(
                node2,
                (value) => `Number.isNaN(${value})`
              )
            });
            if (isCastable) {
              suggestedFixes.push({
                messageId: "replaceWithCastingAndIsNaN",
                fix: getBinaryExpressionFixer(
                  node2,
                  (value) => `Number.isNaN(Number(${value}))`
                )
              });
            }
          }
          context.report({
            node: node2,
            messageId: "comparisonWithNaN",
            suggest: suggestedFixes
          });
        }
      }
      function checkSwitchStatement(node2) {
        if (isNaNIdentifier(node2.discriminant)) {
          context.report({ node: node2, messageId: "switchNaN" });
        }
        for (const switchCase of node2.cases) {
          if (isNaNIdentifier(switchCase.test)) {
            context.report({ node: switchCase, messageId: "caseNaN" });
          }
        }
      }
      function checkCallExpression(node2) {
        const callee = astUtils2.skipChainExpression(node2.callee);
        if (callee.type === "MemberExpression") {
          const methodName = astUtils2.getStaticPropertyName(callee);
          if ((methodName === "indexOf" || methodName === "lastIndexOf") && node2.arguments.length <= 2 && isNaNIdentifier(node2.arguments[0])) {
            const isSuggestable = node2.arguments[0].type !== "SequenceExpression" && !node2.arguments[1];
            const suggestedFixes = [];
            if (isSuggestable) {
              const shouldWrap = callee.computed;
              const findIndexMethod = methodName === "indexOf" ? "findIndex" : "findLastIndex";
              const propertyName2 = shouldWrap ? `"${findIndexMethod}"` : findIndexMethod;
              suggestedFixes.push({
                messageId: "replaceWithFindIndex",
                data: { methodName: findIndexMethod },
                fix: (fixer) => [
                  fixer.replaceText(
                    callee.property,
                    propertyName2
                  ),
                  fixer.replaceText(
                    node2.arguments[0],
                    "Number.isNaN"
                  )
                ]
              });
            }
            context.report({
              node: node2,
              messageId: "indexOfNaN",
              data: { methodName },
              suggest: suggestedFixes
            });
          }
        }
      }
      const listeners = {
        BinaryExpression: checkBinaryExpression
      };
      if (enforceForSwitchCase) {
        listeners.SwitchStatement = checkSwitchStatement;
      }
      if (enforceForIndexOf) {
        listeners.CallExpression = checkCallExpression;
      }
      return listeners;
    }
  };
  return useIsnan;
}
var validTypeof;
var hasRequiredValidTypeof;
function requireValidTypeof() {
  if (hasRequiredValidTypeof) return validTypeof;
  hasRequiredValidTypeof = 1;
  const astUtils2 = requireAstUtils();
  validTypeof = {
    meta: {
      type: "problem",
      defaultOptions: [
        {
          requireStringLiterals: false
        }
      ],
      docs: {
        description: "Enforce comparing `typeof` expressions against valid strings",
        recommended: true,
        url: "https://eslint.org/docs/latest/rules/valid-typeof"
      },
      hasSuggestions: true,
      schema: [
        {
          type: "object",
          properties: {
            requireStringLiterals: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        invalidValue: "Invalid typeof comparison value.",
        notString: "Typeof comparisons should be to string literals.",
        suggestString: 'Use `"{{type}}"` instead of `{{type}}`.'
      }
    },
    create(context) {
      const VALID_TYPES = /* @__PURE__ */ new Set([
        "symbol",
        "undefined",
        "object",
        "boolean",
        "number",
        "string",
        "function",
        "bigint"
      ]), OPERATORS = /* @__PURE__ */ new Set(["==", "===", "!=", "!=="]);
      const sourceCode2 = context.sourceCode;
      const [{ requireStringLiterals }] = context.options;
      let globalScope;
      function isReferenceToGlobalVariable(node2) {
        const variable = globalScope.set.get(node2.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref2) => ref2.identifier === node2);
      }
      function isTypeofExpression(node2) {
        return node2.type === "UnaryExpression" && node2.operator === "typeof";
      }
      return {
        Program(node2) {
          globalScope = sourceCode2.getScope(node2);
        },
        UnaryExpression(node2) {
          if (isTypeofExpression(node2)) {
            const { parent } = node2;
            if (parent.type === "BinaryExpression" && OPERATORS.has(parent.operator)) {
              const sibling = parent.left === node2 ? parent.right : parent.left;
              if (sibling.type === "Literal" || astUtils2.isStaticTemplateLiteral(sibling)) {
                const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
                if (!VALID_TYPES.has(value)) {
                  context.report({
                    node: sibling,
                    messageId: "invalidValue"
                  });
                }
              } else if (sibling.type === "Identifier" && sibling.name === "undefined" && isReferenceToGlobalVariable(sibling)) {
                context.report({
                  node: sibling,
                  messageId: requireStringLiterals ? "notString" : "invalidValue",
                  suggest: [
                    {
                      messageId: "suggestString",
                      data: { type: "undefined" },
                      fix(fixer) {
                        return fixer.replaceText(
                          sibling,
                          '"undefined"'
                        );
                      }
                    }
                  ]
                });
              } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
                context.report({
                  node: sibling,
                  messageId: "notString"
                });
              }
            }
          }
        }
      };
    }
  };
  return validTypeof;
}
var varsOnTop;
var hasRequiredVarsOnTop;
function requireVarsOnTop() {
  if (hasRequiredVarsOnTop) return varsOnTop;
  hasRequiredVarsOnTop = 1;
  varsOnTop = {
    meta: {
      type: "suggestion",
      docs: {
        description: "Require `var` declarations be placed at the top of their containing scope",
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/vars-on-top"
      },
      schema: [],
      messages: {
        top: "All 'var' declarations must be at the top of the function scope."
      }
    },
    create(context) {
      function looksLikeDirective(node2) {
        return node2.type === "ExpressionStatement" && node2.expression.type === "Literal" && typeof node2.expression.value === "string";
      }
      function looksLikeImport(node2) {
        return node2.type === "ImportDeclaration" || node2.type === "ImportSpecifier" || node2.type === "ImportDefaultSpecifier" || node2.type === "ImportNamespaceSpecifier";
      }
      function isVariableDeclaration(node2) {
        return node2.type === "VariableDeclaration" || node2.type === "ExportNamedDeclaration" && node2.declaration && node2.declaration.type === "VariableDeclaration";
      }
      function isVarOnTop(node2, statements) {
        const l2 = statements.length;
        let i2 = 0;
        if (node2.parent.type !== "StaticBlock") {
          for (; i2 < l2; ++i2) {
            if (!looksLikeDirective(statements[i2]) && !looksLikeImport(statements[i2])) {
              break;
            }
          }
        }
        for (; i2 < l2; ++i2) {
          if (!isVariableDeclaration(statements[i2])) {
            return false;
          }
          if (statements[i2] === node2) {
            return true;
          }
        }
        return false;
      }
      function globalVarCheck(node2, parent) {
        if (!isVarOnTop(node2, parent.body)) {
          context.report({ node: node2, messageId: "top" });
        }
      }
      function blockScopeVarCheck(node2) {
        const { parent } = node2;
        if (parent.type === "BlockStatement" && /Function/u.test(parent.parent.type) && isVarOnTop(node2, parent.body)) {
          return;
        }
        if (parent.type === "StaticBlock" && isVarOnTop(node2, parent.body)) {
          return;
        }
        context.report({ node: node2, messageId: "top" });
      }
      return {
        "VariableDeclaration[kind='var']"(node2) {
          if (node2.parent.type === "ExportNamedDeclaration") {
            globalVarCheck(node2.parent, node2.parent.parent);
          } else if (node2.parent.type === "Program") {
            globalVarCheck(node2, node2.parent);
          } else {
            blockScopeVarCheck(node2);
          }
        }
      };
    }
  };
  return varsOnTop;
}
var wrapIife;
var hasRequiredWrapIife;
function requireWrapIife() {
  if (hasRequiredWrapIife) return wrapIife;
  hasRequiredWrapIife = 1;
  const astUtils2 = requireAstUtils();
  const eslintUtils2 = /* @__PURE__ */ requireEslintUtils();
  function isCalleeOfNewExpression(node2) {
    const maybeCallee = node2.parent.type === "ChainExpression" ? node2.parent : node2;
    return maybeCallee.parent.type === "NewExpression" && maybeCallee.parent.callee === maybeCallee;
  }
  wrapIife = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "wrap-iife",
              url: "https://eslint.style/rules/wrap-iife"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require parentheses around immediate `function` invocations",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/wrap-iife"
      },
      schema: [
        {
          enum: ["outside", "inside", "any"]
        },
        {
          type: "object",
          properties: {
            functionPrototypeMethods: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        wrapInvocation: "Wrap an immediate function invocation in parentheses.",
        wrapExpression: "Wrap only the function expression in parens.",
        moveInvocation: "Move the invocation into the parens that contain the function."
      }
    },
    create(context) {
      const style = context.options[0] || "outside";
      const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;
      const sourceCode2 = context.sourceCode;
      function isWrappedInAnyParens(node2) {
        return astUtils2.isParenthesised(sourceCode2, node2);
      }
      function isWrappedInGroupingParens(node2) {
        return eslintUtils2.isParenthesized(1, node2, sourceCode2);
      }
      function getFunctionNodeFromIIFE(node2) {
        const callee = astUtils2.skipChainExpression(node2.callee);
        if (callee.type === "FunctionExpression") {
          return callee;
        }
        if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils2.getStaticPropertyName(callee) === "call" || astUtils2.getStaticPropertyName(callee) === "apply")) {
          return callee.object;
        }
        return null;
      }
      return {
        CallExpression(node2) {
          const innerNode = getFunctionNodeFromIIFE(node2);
          if (!innerNode) {
            return;
          }
          const isCallExpressionWrapped = isWrappedInAnyParens(node2), isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);
          if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {
            context.report({
              node: node2,
              messageId: "wrapInvocation",
              fix(fixer) {
                const nodeToSurround = style === "inside" ? innerNode : node2;
                return fixer.replaceText(
                  nodeToSurround,
                  `(${sourceCode2.getText(nodeToSurround)})`
                );
              }
            });
          } else if (style === "inside" && !isFunctionExpressionWrapped) {
            context.report({
              node: node2,
              messageId: "wrapExpression",
              fix(fixer) {
                if (isWrappedInGroupingParens(node2) && !isCalleeOfNewExpression(node2)) {
                  const parenAfter = sourceCode2.getTokenAfter(node2);
                  return fixer.replaceTextRange(
                    [innerNode.range[1], parenAfter.range[1]],
                    `)${sourceCode2.getText().slice(innerNode.range[1], parenAfter.range[0])}`
                  );
                }
                return fixer.replaceText(
                  innerNode,
                  `(${sourceCode2.getText(innerNode)})`
                );
              }
            });
          } else if (style === "outside" && !isCallExpressionWrapped) {
            context.report({
              node: node2,
              messageId: "moveInvocation",
              fix(fixer) {
                const parenAfter = sourceCode2.getTokenAfter(innerNode);
                return fixer.replaceTextRange(
                  [parenAfter.range[0], node2.range[1]],
                  `${sourceCode2.getText().slice(parenAfter.range[1], node2.range[1])})`
                );
              }
            });
          }
        }
      };
    }
  };
  return wrapIife;
}
var wrapRegex;
var hasRequiredWrapRegex;
function requireWrapRegex() {
  if (hasRequiredWrapRegex) return wrapRegex;
  hasRequiredWrapRegex = 1;
  wrapRegex = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "wrap-regex",
              url: "https://eslint.style/rules/wrap-regex"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require parenthesis around regex literals",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/wrap-regex"
      },
      schema: [],
      fixable: "code",
      messages: {
        requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      return {
        Literal(node2) {
          const token = sourceCode2.getFirstToken(node2), nodeType = token.type;
          if (nodeType === "RegularExpression") {
            const beforeToken = sourceCode2.getTokenBefore(node2);
            const afterToken = sourceCode2.getTokenAfter(node2);
            const { parent } = node2;
            if (parent.type === "MemberExpression" && parent.object === node2 && !(beforeToken && beforeToken.value === "(" && afterToken && afterToken.value === ")")) {
              context.report({
                node: node2,
                messageId: "requireParens",
                fix: (fixer) => fixer.replaceText(
                  node2,
                  `(${sourceCode2.getText(node2)})`
                )
              });
            }
          }
        }
      };
    }
  };
  return wrapRegex;
}
var yieldStarSpacing;
var hasRequiredYieldStarSpacing;
function requireYieldStarSpacing() {
  if (hasRequiredYieldStarSpacing) return yieldStarSpacing;
  hasRequiredYieldStarSpacing = 1;
  yieldStarSpacing = {
    meta: {
      deprecated: {
        message: "Formatting rules are being moved out of ESLint core.",
        url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
        deprecatedSince: "8.53.0",
        availableUntil: "11.0.0",
        replacedBy: [
          {
            message: "ESLint Stylistic now maintains deprecated stylistic core rules.",
            url: "https://eslint.style/guide/migration",
            plugin: {
              name: "@stylistic/eslint-plugin",
              url: "https://eslint.style"
            },
            rule: {
              name: "yield-star-spacing",
              url: "https://eslint.style/rules/yield-star-spacing"
            }
          }
        ]
      },
      type: "layout",
      docs: {
        description: "Require or disallow spacing around the `*` in `yield*` expressions",
        recommended: false,
        url: "https://eslint.org/docs/latest/rules/yield-star-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["before", "after", "both", "neither"]
            },
            {
              type: "object",
              properties: {
                before: { type: "boolean" },
                after: { type: "boolean" }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        missingBefore: "Missing space before *.",
        missingAfter: "Missing space after *.",
        unexpectedBefore: "Unexpected space before *.",
        unexpectedAfter: "Unexpected space after *."
      }
    },
    create(context) {
      const sourceCode2 = context.sourceCode;
      const mode = function(option) {
        if (!option || typeof option === "string") {
          return {
            before: { before: true, after: false },
            after: { before: false, after: true },
            both: { before: true, after: true },
            neither: { before: false, after: false }
          }[option || "after"];
        }
        return option;
      }(context.options[0]);
      function checkSpacing(side, leftToken, rightToken) {
        if (sourceCode2.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
          const after = leftToken.value === "*";
          const spaceRequired = mode[side];
          const node2 = after ? leftToken : rightToken;
          let messageId;
          if (spaceRequired) {
            messageId = side === "before" ? "missingBefore" : "missingAfter";
          } else {
            messageId = side === "before" ? "unexpectedBefore" : "unexpectedAfter";
          }
          context.report({
            node: node2,
            messageId,
            fix(fixer) {
              if (spaceRequired) {
                if (after) {
                  return fixer.insertTextAfter(node2, " ");
                }
                return fixer.insertTextBefore(node2, " ");
              }
              return fixer.removeRange([
                leftToken.range[1],
                rightToken.range[0]
              ]);
            }
          });
        }
      }
      function checkExpression(node2) {
        if (!node2.delegate) {
          return;
        }
        const tokens = sourceCode2.getFirstTokens(node2, 3);
        const yieldToken = tokens[0];
        const starToken = tokens[1];
        const nextToken = tokens[2];
        checkSpacing("before", yieldToken, starToken);
        checkSpacing("after", starToken, nextToken);
      }
      return {
        YieldExpression: checkExpression
      };
    }
  };
  return yieldStarSpacing;
}
var yoda;
var hasRequiredYoda;
function requireYoda() {
  if (hasRequiredYoda) return yoda;
  hasRequiredYoda = 1;
  const astUtils2 = requireAstUtils();
  function isComparisonOperator(operator2) {
    return /^(?:==|===|!=|!==|<|>|<=|>=)$/u.test(operator2);
  }
  function isEqualityOperator(operator2) {
    return /^(?:==|===)$/u.test(operator2);
  }
  function isRangeTestOperator(operator2) {
    return ["<", "<="].includes(operator2);
  }
  function isNegativeNumericLiteral(node2) {
    return node2.type === "UnaryExpression" && node2.operator === "-" && node2.prefix && astUtils2.isNumericLiteral(node2.argument);
  }
  function looksLikeLiteral(node2) {
    return isNegativeNumericLiteral(node2) || astUtils2.isStaticTemplateLiteral(node2);
  }
  function getNormalizedLiteral(node2) {
    if (node2.type === "Literal") {
      return node2;
    }
    if (isNegativeNumericLiteral(node2)) {
      return {
        type: "Literal",
        value: -node2.argument.value,
        raw: `-${node2.argument.value}`
      };
    }
    if (astUtils2.isStaticTemplateLiteral(node2)) {
      return {
        type: "Literal",
        value: node2.quasis[0].value.cooked,
        raw: node2.quasis[0].value.raw
      };
    }
    return null;
  }
  yoda = {
    meta: {
      type: "suggestion",
      defaultOptions: [
        "never",
        {
          exceptRange: false,
          onlyEquality: false
        }
      ],
      docs: {
        description: 'Require or disallow "Yoda" conditions',
        recommended: false,
        frozen: true,
        url: "https://eslint.org/docs/latest/rules/yoda"
      },
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptRange: {
              type: "boolean"
            },
            onlyEquality: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
      }
    },
    create(context) {
      const [when, { exceptRange, onlyEquality }] = context.options;
      const always = when === "always";
      const sourceCode2 = context.sourceCode;
      function isRangeTest(node2) {
        const left = node2.left, right = node2.right;
        function isBetweenTest() {
          if (node2.operator === "&&" && astUtils2.isSameReference(left.right, right.left)) {
            const leftLiteral = getNormalizedLiteral(left.left);
            const rightLiteral = getNormalizedLiteral(right.right);
            if (leftLiteral === null && rightLiteral === null) {
              return false;
            }
            if (rightLiteral === null || leftLiteral === null) {
              return true;
            }
            if (leftLiteral.value <= rightLiteral.value) {
              return true;
            }
          }
          return false;
        }
        function isOutsideTest() {
          if (node2.operator === "||" && astUtils2.isSameReference(left.left, right.right)) {
            const leftLiteral = getNormalizedLiteral(left.right);
            const rightLiteral = getNormalizedLiteral(right.left);
            if (leftLiteral === null && rightLiteral === null) {
              return false;
            }
            if (rightLiteral === null || leftLiteral === null) {
              return true;
            }
            if (leftLiteral.value <= rightLiteral.value) {
              return true;
            }
          }
          return false;
        }
        function isParenWrapped() {
          return astUtils2.isParenthesised(sourceCode2, node2);
        }
        return node2.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();
      }
      const OPERATOR_FLIP_MAP = {
        "===": "===",
        "!==": "!==",
        "==": "==",
        "!=": "!=",
        "<": ">",
        ">": "<",
        "<=": ">=",
        ">=": "<="
      };
      function getFlippedString(node2) {
        const operatorToken2 = sourceCode2.getFirstTokenBetween(
          node2.left,
          node2.right,
          (token) => token.value === node2.operator
        );
        const lastLeftToken = sourceCode2.getTokenBefore(operatorToken2);
        const firstRightToken = sourceCode2.getTokenAfter(operatorToken2);
        const source = sourceCode2.getText();
        const leftText = source.slice(
          node2.range[0],
          lastLeftToken.range[1]
        );
        const textBeforeOperator = source.slice(
          lastLeftToken.range[1],
          operatorToken2.range[0]
        );
        const textAfterOperator = source.slice(
          operatorToken2.range[1],
          firstRightToken.range[0]
        );
        const rightText = source.slice(
          firstRightToken.range[0],
          node2.range[1]
        );
        const tokenBefore = sourceCode2.getTokenBefore(node2);
        const tokenAfter = sourceCode2.getTokenAfter(node2);
        let prefix = "";
        let suffix = "";
        if (tokenBefore && tokenBefore.range[1] === node2.range[0] && !astUtils2.canTokensBeAdjacent(tokenBefore, firstRightToken)) {
          prefix = " ";
        }
        if (tokenAfter && node2.range[1] === tokenAfter.range[0] && !astUtils2.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {
          suffix = " ";
        }
        return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken2.value] + textAfterOperator + leftText + suffix;
      }
      return {
        BinaryExpression(node2) {
          const expectedLiteral = always ? node2.left : node2.right;
          const expectedNonLiteral = always ? node2.right : node2.left;
          if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node2.operator) && onlyEquality) && isComparisonOperator(node2.operator) && !(exceptRange && isRangeTest(node2.parent))) {
            context.report({
              node: node2,
              messageId: "expected",
              data: {
                operator: node2.operator,
                expectedSide: always ? "left" : "right"
              },
              fix: (fixer) => fixer.replaceText(node2, getFlippedString(node2))
            });
          }
        }
      };
    }
  };
  return yoda;
}
var rules$1;
var hasRequiredRules$1;
function requireRules$1() {
  if (hasRequiredRules$1) return rules$1;
  hasRequiredRules$1 = 1;
  const { LazyLoadingRuleMap } = requireLazyLoadingRuleMap();
  rules$1 = new LazyLoadingRuleMap(
    Object.entries({
      "accessor-pairs": () => requireAccessorPairs(),
      "array-bracket-newline": () => requireArrayBracketNewline(),
      "array-bracket-spacing": () => requireArrayBracketSpacing(),
      "array-callback-return": () => requireArrayCallbackReturn(),
      "array-element-newline": () => requireArrayElementNewline(),
      "arrow-body-style": () => requireArrowBodyStyle(),
      "arrow-parens": () => requireArrowParens(),
      "arrow-spacing": () => requireArrowSpacing(),
      "block-scoped-var": () => requireBlockScopedVar(),
      "block-spacing": () => requireBlockSpacing(),
      "brace-style": () => requireBraceStyle(),
      "callback-return": () => requireCallbackReturn(),
      camelcase: () => requireCamelcase(),
      "capitalized-comments": () => requireCapitalizedComments(),
      "class-methods-use-this": () => requireClassMethodsUseThis(),
      "comma-dangle": () => requireCommaDangle(),
      "comma-spacing": () => requireCommaSpacing(),
      "comma-style": () => requireCommaStyle(),
      complexity: () => requireComplexity(),
      "computed-property-spacing": () => requireComputedPropertySpacing(),
      "consistent-return": () => requireConsistentReturn(),
      "consistent-this": () => requireConsistentThis(),
      "constructor-super": () => requireConstructorSuper(),
      curly: () => requireCurly(),
      "default-case": () => requireDefaultCase(),
      "default-case-last": () => requireDefaultCaseLast(),
      "default-param-last": () => requireDefaultParamLast(),
      "dot-location": () => requireDotLocation(),
      "dot-notation": () => requireDotNotation(),
      "eol-last": () => requireEolLast(),
      eqeqeq: () => requireEqeqeq(),
      "for-direction": () => requireForDirection(),
      "func-call-spacing": () => requireFuncCallSpacing(),
      "func-name-matching": () => requireFuncNameMatching(),
      "func-names": () => requireFuncNames(),
      "func-style": () => requireFuncStyle(),
      "function-call-argument-newline": () => requireFunctionCallArgumentNewline(),
      "function-paren-newline": () => requireFunctionParenNewline(),
      "generator-star-spacing": () => requireGeneratorStarSpacing(),
      "getter-return": () => requireGetterReturn(),
      "global-require": () => requireGlobalRequire(),
      "grouped-accessor-pairs": () => requireGroupedAccessorPairs(),
      "guard-for-in": () => requireGuardForIn(),
      "handle-callback-err": () => requireHandleCallbackErr(),
      "id-blacklist": () => requireIdBlacklist(),
      "id-denylist": () => requireIdDenylist(),
      "id-length": () => requireIdLength(),
      "id-match": () => requireIdMatch(),
      "implicit-arrow-linebreak": () => requireImplicitArrowLinebreak(),
      indent: () => requireIndent(),
      "indent-legacy": () => requireIndentLegacy(),
      "init-declarations": () => requireInitDeclarations(),
      "jsx-quotes": () => requireJsxQuotes(),
      "key-spacing": () => requireKeySpacing(),
      "keyword-spacing": () => requireKeywordSpacing(),
      "line-comment-position": () => requireLineCommentPosition(),
      "linebreak-style": () => requireLinebreakStyle(),
      "lines-around-comment": () => requireLinesAroundComment(),
      "lines-around-directive": () => requireLinesAroundDirective(),
      "lines-between-class-members": () => requireLinesBetweenClassMembers(),
      "logical-assignment-operators": () => requireLogicalAssignmentOperators(),
      "max-classes-per-file": () => requireMaxClassesPerFile(),
      "max-depth": () => requireMaxDepth(),
      "max-len": () => requireMaxLen(),
      "max-lines": () => requireMaxLines(),
      "max-lines-per-function": () => requireMaxLinesPerFunction(),
      "max-nested-callbacks": () => requireMaxNestedCallbacks(),
      "max-params": () => requireMaxParams(),
      "max-statements": () => requireMaxStatements(),
      "max-statements-per-line": () => requireMaxStatementsPerLine(),
      "multiline-comment-style": () => requireMultilineCommentStyle(),
      "multiline-ternary": () => requireMultilineTernary(),
      "new-cap": () => requireNewCap(),
      "new-parens": () => requireNewParens(),
      "newline-after-var": () => requireNewlineAfterVar(),
      "newline-before-return": () => requireNewlineBeforeReturn(),
      "newline-per-chained-call": () => requireNewlinePerChainedCall(),
      "no-alert": () => requireNoAlert(),
      "no-array-constructor": () => requireNoArrayConstructor(),
      "no-async-promise-executor": () => requireNoAsyncPromiseExecutor(),
      "no-await-in-loop": () => requireNoAwaitInLoop(),
      "no-bitwise": () => requireNoBitwise(),
      "no-buffer-constructor": () => requireNoBufferConstructor(),
      "no-caller": () => requireNoCaller(),
      "no-case-declarations": () => requireNoCaseDeclarations(),
      "no-catch-shadow": () => requireNoCatchShadow(),
      "no-class-assign": () => requireNoClassAssign(),
      "no-compare-neg-zero": () => requireNoCompareNegZero(),
      "no-cond-assign": () => requireNoCondAssign(),
      "no-confusing-arrow": () => requireNoConfusingArrow(),
      "no-console": () => requireNoConsole(),
      "no-const-assign": () => requireNoConstAssign(),
      "no-constant-binary-expression": () => requireNoConstantBinaryExpression(),
      "no-constant-condition": () => requireNoConstantCondition(),
      "no-constructor-return": () => requireNoConstructorReturn(),
      "no-continue": () => requireNoContinue(),
      "no-control-regex": () => requireNoControlRegex(),
      "no-debugger": () => requireNoDebugger(),
      "no-delete-var": () => requireNoDeleteVar(),
      "no-div-regex": () => requireNoDivRegex(),
      "no-dupe-args": () => requireNoDupeArgs(),
      "no-dupe-class-members": () => requireNoDupeClassMembers(),
      "no-dupe-else-if": () => requireNoDupeElseIf(),
      "no-dupe-keys": () => requireNoDupeKeys(),
      "no-duplicate-case": () => requireNoDuplicateCase(),
      "no-duplicate-imports": () => requireNoDuplicateImports(),
      "no-else-return": () => requireNoElseReturn(),
      "no-empty": () => requireNoEmpty(),
      "no-empty-character-class": () => requireNoEmptyCharacterClass(),
      "no-empty-function": () => requireNoEmptyFunction(),
      "no-empty-pattern": () => requireNoEmptyPattern(),
      "no-empty-static-block": () => requireNoEmptyStaticBlock(),
      "no-eq-null": () => requireNoEqNull(),
      "no-eval": () => requireNoEval(),
      "no-ex-assign": () => requireNoExAssign(),
      "no-extend-native": () => requireNoExtendNative(),
      "no-extra-bind": () => requireNoExtraBind(),
      "no-extra-boolean-cast": () => requireNoExtraBooleanCast(),
      "no-extra-label": () => requireNoExtraLabel(),
      "no-extra-parens": () => requireNoExtraParens(),
      "no-extra-semi": () => requireNoExtraSemi(),
      "no-fallthrough": () => requireNoFallthrough(),
      "no-floating-decimal": () => requireNoFloatingDecimal(),
      "no-func-assign": () => requireNoFuncAssign(),
      "no-global-assign": () => requireNoGlobalAssign(),
      "no-implicit-coercion": () => requireNoImplicitCoercion(),
      "no-implicit-globals": () => requireNoImplicitGlobals(),
      "no-implied-eval": () => requireNoImpliedEval(),
      "no-import-assign": () => requireNoImportAssign(),
      "no-inline-comments": () => requireNoInlineComments(),
      "no-inner-declarations": () => requireNoInnerDeclarations(),
      "no-invalid-regexp": () => requireNoInvalidRegexp(),
      "no-invalid-this": () => requireNoInvalidThis(),
      "no-irregular-whitespace": () => requireNoIrregularWhitespace(),
      "no-iterator": () => requireNoIterator(),
      "no-label-var": () => requireNoLabelVar(),
      "no-labels": () => requireNoLabels(),
      "no-lone-blocks": () => requireNoLoneBlocks(),
      "no-lonely-if": () => requireNoLonelyIf(),
      "no-loop-func": () => requireNoLoopFunc(),
      "no-loss-of-precision": () => requireNoLossOfPrecision(),
      "no-magic-numbers": () => requireNoMagicNumbers(),
      "no-misleading-character-class": () => requireNoMisleadingCharacterClass(),
      "no-mixed-operators": () => requireNoMixedOperators(),
      "no-mixed-requires": () => requireNoMixedRequires(),
      "no-mixed-spaces-and-tabs": () => requireNoMixedSpacesAndTabs(),
      "no-multi-assign": () => requireNoMultiAssign(),
      "no-multi-spaces": () => requireNoMultiSpaces(),
      "no-multi-str": () => requireNoMultiStr(),
      "no-multiple-empty-lines": () => requireNoMultipleEmptyLines(),
      "no-native-reassign": () => requireNoNativeReassign(),
      "no-negated-condition": () => requireNoNegatedCondition(),
      "no-negated-in-lhs": () => requireNoNegatedInLhs(),
      "no-nested-ternary": () => requireNoNestedTernary(),
      "no-new": () => requireNoNew(),
      "no-new-func": () => requireNoNewFunc(),
      "no-new-native-nonconstructor": () => requireNoNewNativeNonconstructor(),
      "no-new-object": () => requireNoNewObject(),
      "no-new-require": () => requireNoNewRequire(),
      "no-new-symbol": () => requireNoNewSymbol(),
      "no-new-wrappers": () => requireNoNewWrappers(),
      "no-nonoctal-decimal-escape": () => requireNoNonoctalDecimalEscape(),
      "no-obj-calls": () => requireNoObjCalls(),
      "no-object-constructor": () => requireNoObjectConstructor(),
      "no-octal": () => requireNoOctal(),
      "no-octal-escape": () => requireNoOctalEscape(),
      "no-param-reassign": () => requireNoParamReassign(),
      "no-path-concat": () => requireNoPathConcat(),
      "no-plusplus": () => requireNoPlusplus(),
      "no-process-env": () => requireNoProcessEnv(),
      "no-process-exit": () => requireNoProcessExit(),
      "no-promise-executor-return": () => requireNoPromiseExecutorReturn(),
      "no-proto": () => requireNoProto(),
      "no-prototype-builtins": () => requireNoPrototypeBuiltins(),
      "no-redeclare": () => requireNoRedeclare(),
      "no-regex-spaces": () => requireNoRegexSpaces(),
      "no-restricted-exports": () => requireNoRestrictedExports(),
      "no-restricted-globals": () => requireNoRestrictedGlobals(),
      "no-restricted-imports": () => requireNoRestrictedImports(),
      "no-restricted-modules": () => requireNoRestrictedModules(),
      "no-restricted-properties": () => requireNoRestrictedProperties(),
      "no-restricted-syntax": () => requireNoRestrictedSyntax(),
      "no-return-assign": () => requireNoReturnAssign(),
      "no-return-await": () => requireNoReturnAwait(),
      "no-script-url": () => requireNoScriptUrl(),
      "no-self-assign": () => requireNoSelfAssign(),
      "no-self-compare": () => requireNoSelfCompare(),
      "no-sequences": () => requireNoSequences(),
      "no-setter-return": () => requireNoSetterReturn(),
      "no-shadow": () => requireNoShadow(),
      "no-shadow-restricted-names": () => requireNoShadowRestrictedNames(),
      "no-spaced-func": () => requireNoSpacedFunc(),
      "no-sparse-arrays": () => requireNoSparseArrays(),
      "no-sync": () => requireNoSync(),
      "no-tabs": () => requireNoTabs(),
      "no-template-curly-in-string": () => requireNoTemplateCurlyInString(),
      "no-ternary": () => requireNoTernary(),
      "no-this-before-super": () => requireNoThisBeforeSuper(),
      "no-throw-literal": () => requireNoThrowLiteral(),
      "no-trailing-spaces": () => requireNoTrailingSpaces(),
      "no-unassigned-vars": () => requireNoUnassignedVars(),
      "no-undef": () => requireNoUndef(),
      "no-undef-init": () => requireNoUndefInit(),
      "no-undefined": () => requireNoUndefined(),
      "no-underscore-dangle": () => requireNoUnderscoreDangle(),
      "no-unexpected-multiline": () => requireNoUnexpectedMultiline(),
      "no-unmodified-loop-condition": () => requireNoUnmodifiedLoopCondition(),
      "no-unneeded-ternary": () => requireNoUnneededTernary(),
      "no-unreachable": () => requireNoUnreachable(),
      "no-unreachable-loop": () => requireNoUnreachableLoop(),
      "no-unsafe-finally": () => requireNoUnsafeFinally(),
      "no-unsafe-negation": () => requireNoUnsafeNegation(),
      "no-unsafe-optional-chaining": () => requireNoUnsafeOptionalChaining(),
      "no-unused-expressions": () => requireNoUnusedExpressions(),
      "no-unused-labels": () => requireNoUnusedLabels(),
      "no-unused-private-class-members": () => requireNoUnusedPrivateClassMembers(),
      "no-unused-vars": () => requireNoUnusedVars(),
      "no-use-before-define": () => requireNoUseBeforeDefine(),
      "no-useless-assignment": () => requireNoUselessAssignment(),
      "no-useless-backreference": () => requireNoUselessBackreference(),
      "no-useless-call": () => requireNoUselessCall(),
      "no-useless-catch": () => requireNoUselessCatch(),
      "no-useless-computed-key": () => requireNoUselessComputedKey(),
      "no-useless-concat": () => requireNoUselessConcat(),
      "no-useless-constructor": () => requireNoUselessConstructor(),
      "no-useless-escape": () => requireNoUselessEscape(),
      "no-useless-rename": () => requireNoUselessRename(),
      "no-useless-return": () => requireNoUselessReturn(),
      "no-var": () => requireNoVar(),
      "no-void": () => requireNoVoid(),
      "no-warning-comments": () => requireNoWarningComments(),
      "no-whitespace-before-property": () => requireNoWhitespaceBeforeProperty(),
      "no-with": () => requireNoWith(),
      "nonblock-statement-body-position": () => requireNonblockStatementBodyPosition(),
      "object-curly-newline": () => requireObjectCurlyNewline(),
      "object-curly-spacing": () => requireObjectCurlySpacing(),
      "object-property-newline": () => requireObjectPropertyNewline(),
      "object-shorthand": () => requireObjectShorthand(),
      "one-var": () => requireOneVar(),
      "one-var-declaration-per-line": () => requireOneVarDeclarationPerLine(),
      "operator-assignment": () => requireOperatorAssignment(),
      "operator-linebreak": () => requireOperatorLinebreak(),
      "padded-blocks": () => requirePaddedBlocks(),
      "padding-line-between-statements": () => requirePaddingLineBetweenStatements(),
      "prefer-arrow-callback": () => requirePreferArrowCallback(),
      "prefer-const": () => requirePreferConst(),
      "prefer-destructuring": () => requirePreferDestructuring(),
      "prefer-exponentiation-operator": () => requirePreferExponentiationOperator(),
      "prefer-named-capture-group": () => requirePreferNamedCaptureGroup(),
      "prefer-numeric-literals": () => requirePreferNumericLiterals(),
      "prefer-object-has-own": () => requirePreferObjectHasOwn(),
      "prefer-object-spread": () => requirePreferObjectSpread(),
      "prefer-promise-reject-errors": () => requirePreferPromiseRejectErrors(),
      "prefer-reflect": () => requirePreferReflect(),
      "prefer-regex-literals": () => requirePreferRegexLiterals(),
      "prefer-rest-params": () => requirePreferRestParams(),
      "prefer-spread": () => requirePreferSpread(),
      "prefer-template": () => requirePreferTemplate(),
      "preserve-caught-error": () => requirePreserveCaughtError(),
      "quote-props": () => requireQuoteProps(),
      quotes: () => requireQuotes(),
      radix: () => requireRadix(),
      "require-atomic-updates": () => requireRequireAtomicUpdates(),
      "require-await": () => requireRequireAwait(),
      "require-unicode-regexp": () => requireRequireUnicodeRegexp(),
      "require-yield": () => requireRequireYield(),
      "rest-spread-spacing": () => requireRestSpreadSpacing(),
      semi: () => requireSemi(),
      "semi-spacing": () => requireSemiSpacing(),
      "semi-style": () => requireSemiStyle(),
      "sort-imports": () => requireSortImports(),
      "sort-keys": () => requireSortKeys(),
      "sort-vars": () => requireSortVars(),
      "space-before-blocks": () => requireSpaceBeforeBlocks(),
      "space-before-function-paren": () => requireSpaceBeforeFunctionParen(),
      "space-in-parens": () => requireSpaceInParens(),
      "space-infix-ops": () => requireSpaceInfixOps(),
      "space-unary-ops": () => requireSpaceUnaryOps(),
      "spaced-comment": () => requireSpacedComment(),
      strict: () => requireStrict(),
      "switch-colon-spacing": () => requireSwitchColonSpacing(),
      "symbol-description": () => requireSymbolDescription(),
      "template-curly-spacing": () => requireTemplateCurlySpacing(),
      "template-tag-spacing": () => requireTemplateTagSpacing(),
      "unicode-bom": () => requireUnicodeBom(),
      "use-isnan": () => requireUseIsnan(),
      "valid-typeof": () => requireValidTypeof(),
      "vars-on-top": () => requireVarsOnTop(),
      "wrap-iife": () => requireWrapIife(),
      "wrap-regex": () => requireWrapRegex(),
      "yield-star-spacing": () => requireYieldStarSpacing(),
      yoda: () => requireYoda()
    })
  );
  return rules$1;
}
var rules;
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  const builtInRules = requireRules$1();
  class Rules {
    constructor() {
      this._rules = /* @__PURE__ */ Object.create(null);
    }
    /**
     * Registers a rule module for rule id in storage.
     * @param {string} ruleId Rule id (file name).
     * @param {Rule} rule Rule object.
     * @returns {void}
     */
    define(ruleId, rule) {
      this._rules[ruleId] = rule;
    }
    /**
     * Access rule handler by id (file name).
     * @param {string} ruleId Rule id (file name).
     * @returns {Rule} Rule object.
     */
    get(ruleId) {
      if (typeof this._rules[ruleId] === "string") {
        this.define(ruleId, commonjsRequire(this._rules[ruleId]));
      }
      if (this._rules[ruleId]) {
        return this._rules[ruleId];
      }
      if (builtInRules.has(ruleId)) {
        return builtInRules.get(ruleId);
      }
      return null;
    }
    *[Symbol.iterator]() {
      yield* builtInRules;
      for (const ruleId of Object.keys(this._rules)) {
        yield [ruleId, this.get(ruleId)];
      }
    }
  }
  rules = Rules;
  return rules;
}
var sourceCodeFixer;
var hasRequiredSourceCodeFixer;
function requireSourceCodeFixer() {
  if (hasRequiredSourceCodeFixer) return sourceCodeFixer;
  hasRequiredSourceCodeFixer = 1;
  const debug = requireSrc()("eslint:source-code-fixer");
  const BOM = "\uFEFF";
  function compareMessagesByFixRange(a2, b) {
    return a2.fix.range[0] - b.fix.range[0] || a2.fix.range[1] - b.fix.range[1];
  }
  function compareMessagesByLocation(a2, b) {
    return a2.line - b.line || a2.column - b.column;
  }
  function SourceCodeFixer() {
    Object.freeze(this);
  }
  SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {
    debug("Applying fixes");
    if (shouldFix === false) {
      debug("shouldFix parameter was false, not attempting fixes");
      return {
        fixed: false,
        messages,
        output: sourceText
      };
    }
    const remainingMessages = [], fixes = [], bom = sourceText.startsWith(BOM) ? BOM : "", text = bom ? sourceText.slice(1) : sourceText;
    let lastPos = Number.NEGATIVE_INFINITY, output = bom;
    function attemptFix(problem) {
      const fix = problem.fix;
      const start = fix.range[0];
      const end = fix.range[1];
      if (lastPos >= start || start > end) {
        remainingMessages.push(problem);
        return false;
      }
      if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
        output = "";
      }
      output += text.slice(Math.max(0, lastPos), Math.max(0, start));
      output += fix.text;
      lastPos = end;
      return true;
    }
    messages.forEach((problem) => {
      if (Object.hasOwn(problem, "fix") && problem.fix) {
        fixes.push(problem);
      } else {
        remainingMessages.push(problem);
      }
    });
    if (fixes.length) {
      debug("Found fixes to apply");
      let fixesWereApplied = false;
      for (const problem of fixes.sort(compareMessagesByFixRange)) {
        if (typeof shouldFix !== "function" || shouldFix(problem)) {
          attemptFix(problem);
          fixesWereApplied = true;
        } else {
          remainingMessages.push(problem);
        }
      }
      output += text.slice(Math.max(0, lastPos));
      return {
        fixed: fixesWereApplied,
        messages: remainingMessages.sort(compareMessagesByLocation),
        output
      };
    }
    debug("No fixes to apply");
    return {
      fixed: false,
      messages,
      output: bom + text
    };
  };
  sourceCodeFixer = SourceCodeFixer;
  return sourceCodeFixer;
}
var sourceCodeVisitor;
var hasRequiredSourceCodeVisitor;
function requireSourceCodeVisitor() {
  var _functions;
  if (hasRequiredSourceCodeVisitor) return sourceCodeVisitor;
  hasRequiredSourceCodeVisitor = 1;
  const emptyArray = Object.freeze([]);
  class SourceCodeVisitor {
    constructor() {
      /**
       * The functions to call for a given name.
       * @type {Map<string, Function[]>}
       */
      __privateAdd(this, _functions, /* @__PURE__ */ new Map());
    }
    /**
     * Adds a function to the list of functions to call for a given name.
     * @param {string} name The name of the function to call.
     * @param {Function} func The function to call.
     * @returns {void}
     */
    add(name2, func) {
      if (__privateGet(this, _functions).has(name2)) {
        __privateGet(this, _functions).get(name2).push(func);
      } else {
        __privateGet(this, _functions).set(name2, [func]);
      }
    }
    /**
     * Gets the list of functions to call for a given name.
     * @param {string} name The name of the function to call.
     * @returns {Function[]} The list of functions to call.
     */
    get(name2) {
      if (__privateGet(this, _functions).has(name2)) {
        return __privateGet(this, _functions).get(name2);
      }
      return emptyArray;
    }
    /**
     * Iterates over all names and calls the callback with the name.
     * @param {(name:string) => void} callback The callback to call for each name.
     * @returns {void}
     */
    forEachName(callback) {
      __privateGet(this, _functions).forEach((funcs, name2) => {
        callback(name2);
      });
    }
    /**
     * Calls the functions for a given name with the given arguments.
     * @param {string} name The name of the function to call.
     * @param {any[]} args The arguments to pass to the function.
     * @returns {void}
     */
    callSync(name2, ...args) {
      if (__privateGet(this, _functions).has(name2)) {
        __privateGet(this, _functions).get(name2).forEach((func) => func(...args));
      }
    }
  }
  _functions = new WeakMap();
  sourceCodeVisitor = { SourceCodeVisitor };
  return sourceCodeVisitor;
}
var stats;
var hasRequiredStats;
function requireStats() {
  if (hasRequiredStats) return stats;
  hasRequiredStats = 1;
  function startTime2() {
    return browser$1$1.hrtime();
  }
  function endTime(t2) {
    const time = browser$1$1.hrtime(t2);
    return time[0] * 1e3 + time[1] / 1e6;
  }
  stats = {
    startTime: startTime2,
    endTime
  };
  return stats;
}
var timing;
var hasRequiredTiming;
function requireTiming() {
  if (hasRequiredTiming) return timing;
  hasRequiredTiming = 1;
  const { startTime: startTime2, endTime } = requireStats();
  const enabled = !!browser$1$1.env.TIMING;
  function getListSize() {
    const MINIMUM_SIZE = 10;
    if (typeof browser$1$1.env.TIMING !== "string") {
      return MINIMUM_SIZE;
    }
    if (browser$1$1.env.TIMING.toLowerCase() === "all") {
      return Number.POSITIVE_INFINITY;
    }
    const TIMING_ENV_VAR_AS_INTEGER = Number.parseInt(browser$1$1.env.TIMING, 10);
    return TIMING_ENV_VAR_AS_INTEGER > 10 ? TIMING_ENV_VAR_AS_INTEGER : MINIMUM_SIZE;
  }
  timing = /* @__PURE__ */ function() {
    const data2 = /* @__PURE__ */ Object.create(null);
    function time(key, fn, stats2) {
      return function(...args) {
        const t2 = startTime2();
        const result = fn(...args);
        const tdiff = endTime(t2);
        if (enabled) {
          if (typeof data2[key] === "undefined") {
            data2[key] = 0;
          }
          data2[key] += tdiff;
        }
        return stats2 ? { result, tdiff } : result;
      };
    }
    function getData() {
      return { ...data2 };
    }
    function mergeData(dataToMerge) {
      for (const [key, value] of Object.entries(dataToMerge)) {
        if (typeof data2[key] === "undefined") {
          data2[key] = 0;
        }
        data2[key] += value;
      }
    }
    function disableDisplay() {
    }
    return {
      time,
      enabled,
      getListSize,
      getData,
      mergeData,
      disableDisplay
    };
  }();
  return timing;
}
var flatConfigArray = {};
var defaultConfig = {};
var validateLanguageOptions_1;
var hasRequiredValidateLanguageOptions;
function requireValidateLanguageOptions() {
  if (hasRequiredValidateLanguageOptions) return validateLanguageOptions_1;
  hasRequiredValidateLanguageOptions = 1;
  const globalVariablesValues = /* @__PURE__ */ new Set([
    true,
    "true",
    "writable",
    "writeable",
    false,
    "false",
    "readonly",
    "readable",
    null,
    "off"
  ]);
  function isNonNullObject(value) {
    return typeof value === "object" && value !== null;
  }
  function isNonArrayObject(value) {
    return isNonNullObject(value) && !Array.isArray(value);
  }
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  function validateEcmaVersion(ecmaVersion2) {
    if (isUndefined(ecmaVersion2)) {
      throw new TypeError(
        'Key "ecmaVersion": Expected an "ecmaVersion" property.'
      );
    }
    if (typeof ecmaVersion2 !== "number" && ecmaVersion2 !== "latest") {
      throw new TypeError(
        'Key "ecmaVersion": Expected a number or "latest".'
      );
    }
  }
  function validateSourceType(sourceType) {
    if (typeof sourceType !== "string" || !/^(?:script|module|commonjs)$/u.test(sourceType)) {
      throw new TypeError(
        'Key "sourceType": Expected "script", "module", or "commonjs".'
      );
    }
  }
  function validateGlobals(globals2) {
    if (!isNonArrayObject(globals2)) {
      throw new TypeError('Key "globals": Expected an object.');
    }
    for (const key of Object.keys(globals2)) {
      if (key === "__proto__") {
        continue;
      }
      if (key !== key.trim()) {
        throw new TypeError(
          `Key "globals": Global "${key}" has leading or trailing whitespace.`
        );
      }
      if (!globalVariablesValues.has(globals2[key])) {
        throw new TypeError(
          `Key "globals": Key "${key}": Expected "readonly", "writable", or "off".`
        );
      }
    }
  }
  function validateParser(parser2) {
    if (!parser2 || typeof parser2 !== "object" || typeof parser2.parse !== "function" && typeof parser2.parseForESLint !== "function") {
      throw new TypeError(
        'Key "parser": Expected object with parse() or parseForESLint() method.'
      );
    }
  }
  function validateLanguageOptions(languageOptions) {
    if (!isNonArrayObject(languageOptions)) {
      throw new TypeError("Expected an object.");
    }
    const {
      ecmaVersion: ecmaVersion2,
      sourceType,
      globals: globals2,
      parser: parser2,
      parserOptions,
      ...otherOptions
    } = languageOptions;
    if ("ecmaVersion" in languageOptions) {
      validateEcmaVersion(ecmaVersion2);
    }
    if ("sourceType" in languageOptions) {
      validateSourceType(sourceType);
    }
    if ("globals" in languageOptions) {
      validateGlobals(globals2);
    }
    if ("parser" in languageOptions) {
      validateParser(parser2);
    }
    if ("parserOptions" in languageOptions) {
      if (!isNonArrayObject(parserOptions)) {
        throw new TypeError('Key "parserOptions": Expected an object.');
      }
    }
    const otherOptionKeys = Object.keys(otherOptions);
    if (otherOptionKeys.length > 0) {
      throw new TypeError(`Unexpected key "${otherOptionKeys[0]}" found.`);
    }
  }
  validateLanguageOptions_1 = { validateLanguageOptions };
  return validateLanguageOptions_1;
}
var js;
var hasRequiredJs;
function requireJs() {
  if (hasRequiredJs) return js;
  hasRequiredJs = 1;
  const { SourceCode } = requireSourceCode();
  const createDebug = requireSrc();
  const astUtils2 = requireAstUtils$1();
  const espree2 = requireEspree();
  const eslintScope2 = requireEslintScope();
  const evk = requireEslintVisitorKeys$2();
  const { validateLanguageOptions } = requireValidateLanguageOptions();
  const { LATEST_ECMA_VERSION } = requireEcmaVersion();
  const debug = createDebug("eslint:languages:js");
  const DEFAULT_ECMA_VERSION = 5;
  const parserSymbol = Symbol.for("eslint.RuleTester.parser");
  function analyzeScope(ast2, languageOptions, visitorKeys) {
    const parserOptions = languageOptions.parserOptions;
    const ecmaFeatures = parserOptions.ecmaFeatures || {};
    const ecmaVersion2 = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;
    return eslintScope2.analyze(ast2, {
      ignoreEval: true,
      nodejsScope: ecmaFeatures.globalReturn,
      impliedStrict: ecmaFeatures.impliedStrict,
      ecmaVersion: typeof ecmaVersion2 === "number" ? ecmaVersion2 : 6,
      sourceType: languageOptions.sourceType || "script",
      childVisitorKeys: visitorKeys || evk.KEYS,
      fallback: evk.getKeys
    });
  }
  function isEspree(parser2) {
    return !!(parser2 === espree2 || parser2[parserSymbol] === espree2);
  }
  function normalizeEcmaVersionForLanguageOptions(ecmaVersion2) {
    switch (ecmaVersion2) {
      case 3:
        return 3;
      case 5:
      case void 0:
        return 5;
      default:
        if (typeof ecmaVersion2 === "number") {
          return ecmaVersion2 >= 2015 ? ecmaVersion2 : ecmaVersion2 + 2009;
        }
    }
    return LATEST_ECMA_VERSION;
  }
  js = {
    fileType: "text",
    lineStart: 1,
    columnStart: 0,
    nodeTypeKey: "type",
    visitorKeys: evk.KEYS,
    defaultLanguageOptions: {
      sourceType: "module",
      ecmaVersion: "latest",
      parser: espree2,
      parserOptions: {}
    },
    validateLanguageOptions,
    /**
     * Normalizes the language options.
     * @param {Object} languageOptions The language options to normalize.
     * @returns {Object} The normalized language options.
     */
    normalizeLanguageOptions(languageOptions) {
      languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(
        languageOptions.ecmaVersion
      );
      if (isEspree(languageOptions.parser)) {
        const parserOptions = languageOptions.parserOptions;
        if (languageOptions.sourceType) {
          parserOptions.sourceType = languageOptions.sourceType;
          if (parserOptions.sourceType === "module" && parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) {
            parserOptions.ecmaFeatures.globalReturn = false;
          }
        }
      }
      return languageOptions;
    },
    /**
     * Determines if a given node matches a given selector class.
     * @param {string} className The class name to check.
     * @param {ASTNode} node The node to check.
     * @param {Array<ASTNode>} ancestry The ancestry of the node.
     * @returns {boolean} True if there's a match, false if not.
     * @throws {Error} When an unknown class name is passed.
     */
    matchesSelectorClass(className, node2, ancestry) {
      switch (className.toLowerCase()) {
        case "statement":
          if (node2.type.slice(-9) === "Statement") {
            return true;
          }
        case "declaration":
          return node2.type.slice(-11) === "Declaration";
        case "pattern":
          if (node2.type.slice(-7) === "Pattern") {
            return true;
          }
        case "expression":
          return node2.type.slice(-10) === "Expression" || node2.type.slice(-7) === "Literal" || node2.type === "Identifier" && (ancestry.length === 0 || ancestry[0].type !== "MetaProperty") || node2.type === "MetaProperty";
        case "function":
          return node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression" || node2.type === "ArrowFunctionExpression";
        default:
          throw new Error(`Unknown class name: ${className}`);
      }
    },
    /**
     * Parses the given file into an AST.
     * @param {File} file The virtual file to parse.
     * @param {Object} options Additional options passed from ESLint.
     * @param {JSLanguageOptions} options.languageOptions The language options.
     * @returns {Object} The result of parsing.
     */
    parse(file, { languageOptions }) {
      const { body: text, path: filePath } = file;
      const textToParse = text.replace(
        astUtils2.shebangPattern,
        (match, captured) => `//${captured}`
      );
      const { ecmaVersion: ecmaVersion2, sourceType, parser: parser2 } = languageOptions;
      const parserOptions = Object.assign(
        { ecmaVersion: ecmaVersion2, sourceType },
        languageOptions.parserOptions,
        {
          loc: true,
          range: true,
          raw: true,
          tokens: true,
          comment: true,
          eslintVisitorKeys: true,
          eslintScopeManager: true,
          filePath
        }
      );
      try {
        debug("Parsing:", filePath);
        const parseResult = typeof parser2.parseForESLint === "function" ? parser2.parseForESLint(textToParse, parserOptions) : { ast: parser2.parse(textToParse, parserOptions) };
        debug("Parsing successful:", filePath);
        const {
          ast: ast2,
          services: parserServices = {},
          visitorKeys = evk.KEYS,
          scopeManager
        } = parseResult;
        return {
          ok: true,
          ast: ast2,
          parserServices,
          visitorKeys,
          scopeManager
        };
      } catch (ex) {
        const message = ex.message.replace(/^line \d+:/iu, "").trim();
        debug("%s\n%s", message, ex.stack);
        return {
          ok: false,
          errors: [
            {
              message,
              line: ex.lineNumber,
              column: ex.column
            }
          ]
        };
      }
    },
    /**
     * Creates a new `SourceCode` object from the given information.
     * @param {File} file The virtual file to create a `SourceCode` object from.
     * @param {OkParseResult} parseResult The result returned from `parse()`.
     * @param {Object} options Additional options passed from ESLint.
     * @param {JSLanguageOptions} options.languageOptions The language options.
     * @returns {SourceCode} The new `SourceCode` object.
     */
    createSourceCode(file, parseResult, { languageOptions }) {
      const { body: text, path: filePath, bom: hasBOM } = file;
      const { ast: ast2, parserServices, visitorKeys } = parseResult;
      debug("Scope analysis:", filePath);
      const scopeManager = parseResult.scopeManager || analyzeScope(ast2, languageOptions, visitorKeys);
      debug("Scope analysis successful:", filePath);
      return new SourceCode({
        text,
        ast: ast2,
        hasBOM,
        parserServices,
        scopeManager,
        visitorKeys
      });
    }
  };
  return js;
}
var hasRequiredDefaultConfig;
function requireDefaultConfig() {
  if (hasRequiredDefaultConfig) return defaultConfig;
  hasRequiredDefaultConfig = 1;
  const Rules = requireRules$1();
  const sharedDefaultConfig = [
    // intentionally empty config to ensure these files are globbed by default
    {
      files: ["**/*.js", "**/*.mjs"]
    },
    {
      files: ["**/*.cjs"],
      languageOptions: {
        sourceType: "commonjs",
        ecmaVersion: "latest"
      }
    }
  ];
  defaultConfig.defaultConfig = Object.freeze([
    {
      plugins: {
        "@": {
          languages: {
            js: requireJs()
          },
          /*
           * Because we try to delay loading rules until absolutely
           * necessary, a proxy allows us to hook into the lazy-loading
           * aspect of the rules map while still keeping all of the
           * relevant configuration inside of the config array.
           */
          rules: new Proxy(
            {},
            {
              get(target, property) {
                return Rules.get(property);
              },
              has(target, property) {
                return Rules.has(property);
              }
            }
          )
        }
      },
      language: "@/js",
      linterOptions: {
        reportUnusedDisableDirectives: 1
      }
    },
    // default ignores are listed here
    {
      ignores: ["**/node_modules/", ".git/"]
    },
    ...sharedDefaultConfig
  ]);
  defaultConfig.defaultRuleTesterConfig = Object.freeze([
    { files: ["**"] },
    // Make sure the default config matches for all files
    ...sharedDefaultConfig
  ]);
  return defaultConfig;
}
var hasRequiredFlatConfigArray;
function requireFlatConfigArray() {
  if (hasRequiredFlatConfigArray) return flatConfigArray;
  hasRequiredFlatConfigArray = 1;
  const { ConfigArray, ConfigArraySymbol } = requireCjs();
  const { flatConfigSchema } = requireFlatConfigSchema();
  const { defaultConfig: defaultConfig2 } = requireDefaultConfig();
  const { Config } = requireConfig();
  const META_FIELDS = /* @__PURE__ */ new Set(["name", "basePath"]);
  function wrapConfigErrorWithDetails(error, originalLength2, baseLength2) {
    let location = "user-defined";
    let configIndex = error.index;
    if (error.index < baseLength2) {
      location = "base";
    } else if (error.index < originalLength2 + baseLength2) {
      location = "original";
      configIndex = error.index - baseLength2;
    } else {
      configIndex = error.index - originalLength2 - baseLength2;
    }
    return new TypeError(
      `${error.message.slice(0, -1)} at ${location} index ${configIndex}.`,
      { cause: error }
    );
  }
  const originalBaseConfig = Symbol("originalBaseConfig");
  const originalLength = Symbol("originalLength");
  const baseLength = Symbol("baseLength");
  class FlatConfigArray extends ConfigArray {
    /**
     * Creates a new instance.
     * @param {*[]} configs An array of configuration information.
     * @param {{basePath: string, shouldIgnore: boolean, baseConfig: FlatConfig}} options The options
     *      to use for the config array instance.
     */
    constructor(configs, { basePath, shouldIgnore = true, baseConfig = defaultConfig2 } = {}) {
      super(configs, {
        basePath,
        schema: flatConfigSchema
      });
      this[originalLength] = this.length;
      if (baseConfig[Symbol.iterator]) {
        this.unshift(...baseConfig);
      } else {
        this.unshift(baseConfig);
      }
      this[baseLength] = this.length - this[originalLength];
      this[originalBaseConfig] = baseConfig;
      Object.defineProperty(this, originalBaseConfig, { writable: false });
      this.shouldIgnore = shouldIgnore;
      Object.defineProperty(this, "shouldIgnore", { writable: false });
    }
    /**
     * Normalizes the array by calling the superclass method and catching/rethrowing
     * any ConfigError exceptions with additional details.
     * @param {any} [context] The context to use to normalize the array.
     * @returns {Promise<FlatConfigArray>} A promise that resolves when the array is normalized.
     */
    normalize(context) {
      return super.normalize(context).catch((error) => {
        if (error.name === "ConfigError") {
          throw wrapConfigErrorWithDetails(
            error,
            this[originalLength],
            this[baseLength]
          );
        }
        throw error;
      });
    }
    /**
     * Normalizes the array by calling the superclass method and catching/rethrowing
     * any ConfigError exceptions with additional details.
     * @param {any} [context] The context to use to normalize the array.
     * @returns {FlatConfigArray} The current instance.
     * @throws {TypeError} If the config is invalid.
     */
    normalizeSync(context) {
      try {
        return super.normalizeSync(context);
      } catch (error) {
        if (error.name === "ConfigError") {
          throw wrapConfigErrorWithDetails(
            error,
            this[originalLength],
            this[baseLength]
          );
        }
        throw error;
      }
    }
    /* eslint-disable class-methods-use-this -- Desired as instance method */
    /**
     * Replaces a config with another config to allow us to put strings
     * in the config array that will be replaced by objects before
     * normalization.
     * @param {Object} config The config to preprocess.
     * @returns {Object} The preprocessed config.
     */
    [ConfigArraySymbol.preprocessConfig](config2) {
      if (!this.shouldIgnore && !this[originalBaseConfig].includes(config2) && config2.ignores && Object.keys(config2).filter((key) => !META_FIELDS.has(key)).length === 1) {
        const { ignores, ...otherKeys } = config2;
        return otherKeys;
      }
      return config2;
    }
    /**
     * Finalizes the config by replacing plugin references with their objects
     * and validating rule option schemas.
     * @param {Object} config The config to finalize.
     * @returns {Object} The finalized config.
     * @throws {TypeError} If the config is invalid.
     */
    [ConfigArraySymbol.finalizeConfig](config2) {
      return new Config(config2);
    }
    /* eslint-enable class-methods-use-this -- Desired as instance method */
  }
  flatConfigArray.FlatConfigArray = FlatConfigArray;
  return flatConfigArray;
}
var flags;
var hasRequiredFlags;
function requireFlags() {
  if (hasRequiredFlags) return flags;
  hasRequiredFlags = 1;
  const activeFlags = /* @__PURE__ */ new Map([
    ["test_only", "Used only for testing."],
    ["test_only_2", "Used only for testing."],
    [
      "v10_config_lookup_from_file",
      "Look up `eslint.config.js` from the file being linted."
    ],
    [
      "unstable_native_nodejs_ts_config",
      "Use native Node.js to load TypeScript configuration."
    ]
  ]);
  const inactiveFlags = /* @__PURE__ */ new Map([
    [
      "test_only_replaced",
      {
        description: "Used only for testing flags that have been replaced by other flags.",
        replacedBy: "test_only"
      }
    ],
    [
      "test_only_enabled_by_default",
      {
        description: "Used only for testing flags whose features have been enabled by default.",
        replacedBy: null
      }
    ],
    [
      "test_only_abandoned",
      {
        description: "Used only for testing flags whose features have been abandoned."
      }
    ],
    [
      "unstable_ts_config",
      {
        description: "Enable TypeScript configuration files.",
        replacedBy: null
      }
    ],
    [
      "unstable_config_lookup_from_file",
      {
        description: "Look up `eslint.config.js` from the file being linted.",
        replacedBy: "v10_config_lookup_from_file"
      }
    ]
  ]);
  function getInactivityReasonMessage({ replacedBy }) {
    if (typeof replacedBy === "undefined") {
      return "This feature has been abandoned.";
    }
    if (typeof replacedBy === "string") {
      return `This flag has been renamed '${replacedBy}' to reflect its stabilization. Please use '${replacedBy}' instead.`;
    }
    return "This feature is now enabled by default.";
  }
  flags = {
    activeFlags,
    inactiveFlags,
    getInactivityReasonMessage
  };
  return flags;
}
var vfile;
var hasRequiredVfile;
function requireVfile() {
  if (hasRequiredVfile) return vfile;
  hasRequiredVfile = 1;
  function hasUnicodeBOM(value) {
    return typeof value === "string" ? value.charCodeAt(0) === 65279 : value[0] === 239 && value[1] === 187 && value[2] === 191;
  }
  function stripUnicodeBOM(value) {
    if (!hasUnicodeBOM(value)) {
      return value;
    }
    if (typeof value === "string") {
      return value.slice(1);
    }
    return value.slice(3);
  }
  class VFile {
    /**
     * Creates a new instance.
     * @param {string} path The file path.
     * @param {string|Uint8Array} body The file contents.
     * @param {Object} [options] Additional options.
     * @param {string} [options.physicalPath] The file path on disk.
     */
    constructor(path, body, { physicalPath } = {}) {
      /**
       * The file path including any processor-created virtual path.
       * @type {string}
       * @readonly
       */
      __publicField(this, "path");
      /**
       * The file path on disk.
       * @type {string}
       * @readonly
       */
      __publicField(this, "physicalPath");
      /**
       * The file contents.
       * @type {string|Uint8Array}
       * @readonly
       */
      __publicField(this, "body");
      /**
       * The raw body of the file, including a BOM if present.
       * @type {string|Uint8Array}
       * @readonly
       */
      __publicField(this, "rawBody");
      /**
       * Indicates whether the file has a byte order mark (BOM).
       * @type {boolean}
       * @readonly
       */
      __publicField(this, "bom");
      this.path = path;
      this.physicalPath = physicalPath ?? path;
      this.bom = hasUnicodeBOM(body);
      this.body = stripUnicodeBOM(body);
      this.rawBody = body;
    }
  }
  vfile = { VFile };
  return vfile;
}
var parserService;
var hasRequiredParserService;
function requireParserService() {
  if (hasRequiredParserService) return parserService;
  hasRequiredParserService = 1;
  class ParserService {
    /**
     * Parses the given file synchronously.
     * @param {VFile} file The file to parse.
     * @param {{language:Language,languageOptions:LanguageOptions}} config The configuration to use.
     * @returns {Object} An object with the parsed source code or errors.
     * @throws {Error} If the parser returns a promise.
     */
    parseSync(file, config2) {
      const { language: language2, languageOptions } = config2;
      const result = language2.parse(file, { languageOptions });
      if (typeof result.then === "function") {
        throw new Error("Unsupported: Language parser returned a promise.");
      }
      if (result.ok) {
        return {
          ok: true,
          sourceCode: language2.createSourceCode(file, result, {
            languageOptions
          })
        };
      }
      return {
        ok: false,
        errors: result.errors.map((error) => ({
          ruleId: null,
          nodeType: null,
          fatal: true,
          severity: 2,
          message: `Parsing error: ${error.message}`,
          line: error.line,
          column: error.column
        }))
      };
    }
  }
  parserService = { ParserService };
  return parserService;
}
var fileContext = {};
var hasRequiredFileContext;
function requireFileContext() {
  if (hasRequiredFileContext) return fileContext;
  hasRequiredFileContext = 1;
  class FileContext {
    /**
     * Creates a new instance.
     * @param {Object} config The configuration object for the file context.
     * @param {string} config.cwd The current working directory.
     * @param {string} config.filename The filename of the file being linted.
     * @param {string} config.physicalFilename The physical filename of the file being linted.
     * @param {SourceCode} config.sourceCode The source code of the file being linted.
     * @param {Record<string, unknown>} config.parserOptions The parser options for the file being linted.
     * @param {string} config.parserPath The path to the parser used to parse this file.
     * @param {Record<string, unknown>} config.languageOptions The language options used when parsing this file.
     * @param {Record<string, unknown>} config.settings The settings for the file being linted.
     */
    constructor({
      cwd: cwd2,
      filename,
      physicalFilename,
      sourceCode: sourceCode2,
      parserOptions,
      parserPath,
      languageOptions,
      settings
    }) {
      /**
       * The current working directory.
       * @type {string}
       */
      __publicField(this, "cwd");
      /**
       * The filename of the file being linted.
       * @type {string}
       */
      __publicField(this, "filename");
      /**
       * The physical filename of the file being linted.
       * @type {string}
       */
      __publicField(this, "physicalFilename");
      /**
       * The source code of the file being linted.
       * @type {SourceCode}
       */
      __publicField(this, "sourceCode");
      /**
       * The parser options for the file being linted.
       * @type {Record<string, unknown>}
       * @deprecated Use `languageOptions` instead.
       */
      __publicField(this, "parserOptions");
      /**
       * The path to the parser used to parse this file.
       * @type {string}
       * @deprecated No longer supported.
       */
      __publicField(this, "parserPath");
      /**
       * The language options used when parsing this file.
       * @type {Record<string, unknown>}
       */
      __publicField(this, "languageOptions");
      /**
       * The settings for the file being linted.
       * @type {Record<string, unknown>}
       */
      __publicField(this, "settings");
      this.cwd = cwd2;
      this.filename = filename;
      this.physicalFilename = physicalFilename;
      this.sourceCode = sourceCode2;
      this.parserOptions = parserOptions;
      this.parserPath = parserPath;
      this.languageOptions = languageOptions;
      this.settings = settings;
      Object.freeze(this);
    }
    /**
     * Gets the current working directory.
     * @returns {string} The current working directory.
     * @deprecated Use `cwd` instead.
     */
    getCwd() {
      return this.cwd;
    }
    /**
     * Gets the filename of the file being linted.
     * @returns {string} The filename of the file being linted.
     * @deprecated Use `filename` instead.
     */
    getFilename() {
      return this.filename;
    }
    /**
     * Gets the physical filename of the file being linted.
     * @returns {string} The physical filename of the file being linted.
     * @deprecated Use `physicalFilename` instead.
     */
    getPhysicalFilename() {
      return this.physicalFilename;
    }
    /**
     * Gets the source code of the file being linted.
     * @returns {SourceCode} The source code of the file being linted.
     * @deprecated Use `sourceCode` instead.
     */
    getSourceCode() {
      return this.sourceCode;
    }
    /**
     * Creates a new object with the current object as the prototype and
     * the specified properties as its own properties.
     * @param {Object} extension The properties to add to the new object.
     * @returns {FileContext} A new object with the current object as the prototype
     * and the specified properties as its own properties.
     */
    extend(extension) {
      return Object.freeze(Object.assign(Object.create(this), extension));
    }
  }
  fileContext.FileContext = FileContext;
  return fileContext;
}
var processorService;
var hasRequiredProcessorService;
function requireProcessorService() {
  if (hasRequiredProcessorService) return processorService;
  hasRequiredProcessorService = 1;
  const path = require$$0$3;
  const { VFile } = requireVfile();
  class ProcessorService {
    /**
     * Preprocesses the given file synchronously.
     * @param {VFile} file The file to preprocess.
     * @param {{processor:Processor}} config The configuration to use.
     * @returns {{ok:boolean, files?: Array<VFile>, errors?: Array<LintMessage>}} An array of preprocessed files or errors.
     * @throws {Error} If the preprocessor returns a promise.
     */
    preprocessSync(file, config2) {
      const { processor } = config2;
      let blocks;
      try {
        blocks = processor.preprocess(file.rawBody, file.path);
      } catch (ex) {
        const message = `Preprocessing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
        return {
          ok: false,
          errors: [
            {
              ruleId: null,
              fatal: true,
              severity: 2,
              message,
              line: ex.lineNumber,
              column: ex.column,
              nodeType: null
            }
          ]
        };
      }
      if (typeof blocks.then === "function") {
        throw new Error("Unsupported: Preprocessor returned a promise.");
      }
      return {
        ok: true,
        files: blocks.map((block, i2) => {
          if (typeof block === "string") {
            return block;
          }
          const filePath = path.join(file.path, `${i2}_${block.filename}`);
          return new VFile(filePath, block.text, {
            physicalPath: file.physicalPath
          });
        })
      };
    }
    /**
     * Postprocesses the given messages synchronously.
     * @param {VFile} file The file to postprocess.
     * @param {LintMessage[][]} messages The messages to postprocess.
     * @param {{processor:Processor}} config The configuration to use.
     * @returns {LintMessage[]} The postprocessed messages.
     */
    postprocessSync(file, messages, config2) {
      const { processor } = config2;
      return processor.postprocess(messages, file.path);
    }
  }
  processorService = { ProcessorService };
  return processorService;
}
var optionUtils;
var hasRequiredOptionUtils;
function requireOptionUtils() {
  if (hasRequiredOptionUtils) return optionUtils;
  hasRequiredOptionUtils = 1;
  function containsDifferentProperty(input, original) {
    if (input === original) {
      return false;
    }
    if (typeof input !== typeof original || Array.isArray(input) !== Array.isArray(original)) {
      return true;
    }
    if (Array.isArray(input)) {
      return input.length !== original.length || input.some(
        (value, i2) => containsDifferentProperty(value, original[i2])
      );
    }
    if (typeof input === "object") {
      if (input === null || original === null) {
        return true;
      }
      const inputKeys = Object.keys(input);
      const originalKeys = Object.keys(original);
      return inputKeys.length !== originalKeys.length || inputKeys.some(
        (inputKey) => !Object.hasOwn(original, inputKey) || containsDifferentProperty(
          input[inputKey],
          original[inputKey]
        )
      );
    }
    return true;
  }
  optionUtils = {
    containsDifferentProperty
  };
  return optionUtils;
}
var warningService;
var hasRequiredWarningService;
function requireWarningService() {
  if (hasRequiredWarningService) return warningService;
  hasRequiredWarningService = 1;
  class WarningService {
    /**
     * Creates a new instance of the service.
     * @param {{ emitWarning?: ((warning: string, type: string) => void) | undefined }} [options] A function called internally to emit warnings using API provided by the runtime.
     */
    constructor({
      emitWarning = ((_a2) => (_a2 = globalThis.process) == null ? void 0 : _a2.emitWarning)() ?? (() => {
      })
    } = {}) {
      this.emitWarning = emitWarning;
    }
    /**
     * Emits a warning when circular fixes are detected while fixing a file.
     * This method is used by the Linter and is safe to call outside Node.js.
     * @param {string} filename The name of the file being fixed.
     * @returns {void}
     */
    emitCircularFixesWarning(filename) {
      this.emitWarning(
        `Circular fixes detected while fixing ${filename}. It is likely that you have conflicting rules in your configuration.`,
        "ESLintCircularFixesWarning"
      );
    }
    /**
     * Emits a warning when an empty config file has been loaded.
     * @param {string} configFilePath The path to the config file.
     * @returns {void}
     */
    emitEmptyConfigWarning(configFilePath) {
      this.emitWarning(
        `Running ESLint with an empty config (from ${configFilePath}). Please double-check that this is what you want. If you want to run ESLint with an empty config, export [{}] to remove this warning.`,
        "ESLintEmptyConfigWarning"
      );
    }
    /**
     * Emits a warning when an ".eslintignore" file is found.
     * @returns {void}
     */
    emitESLintIgnoreWarning() {
      this.emitWarning(
        'The ".eslintignore" file is no longer supported. Switch to using the "ignores" property in "eslint.config.js": https://eslint.org/docs/latest/use/configure/migration-guide#ignoring-files',
        "ESLintIgnoreWarning"
      );
    }
    /**
     * Emits a warning when the ESLINT_USE_FLAT_CONFIG environment variable is set to "false".
     * @returns {void}
     */
    emitESLintRCWarning() {
      this.emitWarning(
        "You are using an eslintrc configuration file, which is deprecated and support will be removed in v10.0.0. Please migrate to an eslint.config.js file. See https://eslint.org/docs/latest/use/configure/migration-guide for details. An eslintrc configuration file is used because you have the ESLINT_USE_FLAT_CONFIG environment variable set to false. If you want to use an eslint.config.js file, remove the environment variable. If you want to find the location of the eslintrc configuration file, use the --debug flag.",
        "ESLintRCWarning"
      );
    }
    /**
     * Emits a warning when an inactive flag is used.
     * This method is used by the Linter and is safe to call outside Node.js.
     * @param {string} flag The name of the flag.
     * @param {string} message The warning message.
     * @returns {void}
     */
    emitInactiveFlagWarning(flag, message) {
      this.emitWarning(message, `ESLintInactiveFlag_${flag}`);
    }
    /**
     * Emits a warning when a suboptimal concurrency setting is detected.
     * Currently, this is only used to warn when the net linting ratio is low.
     * @param {string} notice A notice about how to improve performance.
     * @returns {void}
     */
    emitPoorConcurrencyWarning(notice) {
      this.emitWarning(
        `You may ${notice} to improve performance.`,
        "ESLintPoorConcurrencyWarning"
      );
    }
  }
  warningService = { WarningService };
  return warningService;
}
function e(t2) {
  return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
    return typeof e2;
  } : function(e2) {
    return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
  })(t2);
}
function t(e2, t2) {
  return function(e3) {
    if (Array.isArray(e3)) return e3;
  }(e2) || function(e3, t3) {
    var r2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
    if (null != r2) {
      var n2, a2, o2, i2, s2 = [], u2 = true, l2 = false;
      try {
        if (o2 = (r2 = r2.call(e3)).next, 0 === t3) ;
        else for (; !(u2 = (n2 = o2.call(r2)).done) && (s2.push(n2.value), s2.length !== t3); u2 = true) ;
      } catch (e4) {
        l2 = true, a2 = e4;
      } finally {
        try {
          if (!u2 && null != r2.return && (i2 = r2.return(), Object(i2) !== i2)) return;
        } finally {
          if (l2) throw a2;
        }
      }
      return s2;
    }
  }(e2, t2) || n(e2, t2) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function r(e2) {
  return function(e3) {
    if (Array.isArray(e3)) return a(e3);
  }(e2) || function(e3) {
    if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"]) return Array.from(e3);
  }(e2) || n(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function n(e2, t2) {
  if (e2) {
    if ("string" == typeof e2) return a(e2, t2);
    var r2 = Object.prototype.toString.call(e2).slice(8, -1);
    return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? a(e2, t2) : void 0;
  }
}
function a(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++) n2[r2] = e2[r2];
  return n2;
}
function o(e2, t2) {
  return e2(t2 = { exports: {} }, t2.exports), t2.exports;
}
var i = o(function(e2, t2) {
  !function e3(t3) {
    var r2, n2, a2, o2, i2, s2;
    function u2(e4) {
      var t4, r3, n3 = {};
      for (t4 in e4) e4.hasOwnProperty(t4) && (r3 = e4[t4], n3[t4] = "object" == typeof r3 && null !== r3 ? u2(r3) : r3);
      return n3;
    }
    function l2(e4, t4) {
      this.parent = e4, this.key = t4;
    }
    function c2(e4, t4, r3, n3) {
      this.node = e4, this.path = t4, this.wrap = r3, this.ref = n3;
    }
    function f2() {
    }
    function p2(e4) {
      return null != e4 && ("object" == typeof e4 && "string" == typeof e4.type);
    }
    function h2(e4, t4) {
      return (e4 === r2.ObjectExpression || e4 === r2.ObjectPattern) && "properties" === t4;
    }
    function y2(e4, t4) {
      for (var r3 = e4.length - 1; r3 >= 0; --r3) if (e4[r3].node === t4) return true;
      return false;
    }
    function d2(e4, t4) {
      return new f2().traverse(e4, t4);
    }
    function m2(e4, t4) {
      var r3;
      return r3 = function(e5, t5) {
        var r4, n3, a3, o3;
        for (n3 = e5.length, a3 = 0; n3; ) t5(e5[o3 = a3 + (r4 = n3 >>> 1)]) ? n3 = r4 : (a3 = o3 + 1, n3 -= r4 + 1);
        return a3;
      }(t4, function(t5) {
        return t5.range[0] > e4.range[0];
      }), e4.extendedRange = [e4.range[0], e4.range[1]], r3 !== t4.length && (e4.extendedRange[1] = t4[r3].range[0]), (r3 -= 1) >= 0 && (e4.extendedRange[0] = t4[r3].range[1]), e4;
    }
    return r2 = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ChainExpression: "ChainExpression", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ComprehensionBlock: "ComprehensionBlock", ComprehensionExpression: "ComprehensionExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DebuggerStatement: "DebuggerStatement", DirectiveStatement: "DirectiveStatement", DoWhileStatement: "DoWhileStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", GeneratorExpression: "GeneratorExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportExpression: "ImportExpression", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", ModuleSpecifier: "ModuleSpecifier", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", PrivateIdentifier: "PrivateIdentifier", Program: "Program", Property: "Property", PropertyDefinition: "PropertyDefinition", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchStatement: "SwitchStatement", SwitchCase: "SwitchCase", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" }, a2 = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ComprehensionBlock: ["left", "right"], ComprehensionExpression: ["blocks", "filter", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], GeneratorExpression: ["blocks", "filter", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportExpression: ["source"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], PrivateIdentifier: [], Program: ["body"], Property: ["key", "value"], PropertyDefinition: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] }, n2 = { Break: o2 = {}, Skip: i2 = {}, Remove: s2 = {} }, l2.prototype.replace = function(e4) {
      this.parent[this.key] = e4;
    }, l2.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), true) : (this.replace(null), false);
    }, f2.prototype.path = function() {
      var e4, t4, r3, n3, a3;
      function o3(e5, t5) {
        if (Array.isArray(t5)) for (r3 = 0, n3 = t5.length; r3 < n3; ++r3) e5.push(t5[r3]);
        else e5.push(t5);
      }
      if (!this.__current.path) return null;
      for (a3 = [], e4 = 2, t4 = this.__leavelist.length; e4 < t4; ++e4) o3(a3, this.__leavelist[e4].path);
      return o3(a3, this.__current.path), a3;
    }, f2.prototype.type = function() {
      return this.current().type || this.__current.wrap;
    }, f2.prototype.parents = function() {
      var e4, t4, r3;
      for (r3 = [], e4 = 1, t4 = this.__leavelist.length; e4 < t4; ++e4) r3.push(this.__leavelist[e4].node);
      return r3;
    }, f2.prototype.current = function() {
      return this.__current.node;
    }, f2.prototype.__execute = function(e4, t4) {
      var r3, n3;
      return n3 = void 0, r3 = this.__current, this.__current = t4, this.__state = null, e4 && (n3 = e4.call(this, t4.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r3, n3;
    }, f2.prototype.notify = function(e4) {
      this.__state = e4;
    }, f2.prototype.skip = function() {
      this.notify(i2);
    }, f2.prototype.break = function() {
      this.notify(o2);
    }, f2.prototype.remove = function() {
      this.notify(s2);
    }, f2.prototype.__initialize = function(e4, t4) {
      this.visitor = t4, this.root = e4, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, "iteration" === t4.fallback ? this.__fallback = Object.keys : "function" == typeof t4.fallback && (this.__fallback = t4.fallback), this.__keys = a2, t4.keys && (this.__keys = Object.assign(Object.create(this.__keys), t4.keys));
    }, f2.prototype.traverse = function(e4, t4) {
      var r3, n3, a3, s3, u3, l3, f3, d3, m3, x2, v2, g2;
      for (this.__initialize(e4, t4), g2 = {}, r3 = this.__worklist, n3 = this.__leavelist, r3.push(new c2(e4, null, null, null)), n3.push(new c2(null, null, null, null)); r3.length; ) if ((a3 = r3.pop()) !== g2) {
        if (a3.node) {
          if (l3 = this.__execute(t4.enter, a3), this.__state === o2 || l3 === o2) return;
          if (r3.push(g2), n3.push(a3), this.__state === i2 || l3 === i2) continue;
          if (u3 = (s3 = a3.node).type || a3.wrap, !(x2 = this.__keys[u3])) {
            if (!this.__fallback) throw new Error("Unknown node type " + u3 + ".");
            x2 = this.__fallback(s3);
          }
          for (d3 = x2.length; (d3 -= 1) >= 0; ) if (v2 = s3[f3 = x2[d3]]) {
            if (Array.isArray(v2)) {
              for (m3 = v2.length; (m3 -= 1) >= 0; ) if (v2[m3] && !y2(n3, v2[m3])) {
                if (h2(u3, x2[d3])) a3 = new c2(v2[m3], [f3, m3], "Property", null);
                else {
                  if (!p2(v2[m3])) continue;
                  a3 = new c2(v2[m3], [f3, m3], null, null);
                }
                r3.push(a3);
              }
            } else if (p2(v2)) {
              if (y2(n3, v2)) continue;
              r3.push(new c2(v2, f3, null, null));
            }
          }
        }
      } else if (a3 = n3.pop(), l3 = this.__execute(t4.leave, a3), this.__state === o2 || l3 === o2) return;
    }, f2.prototype.replace = function(e4, t4) {
      var r3, n3, a3, u3, f3, y3, d3, m3, x2, v2, g2, A2, E;
      function b(e5) {
        var t5, n4, a4, o3;
        if (e5.ref.remove()) {
          for (n4 = e5.ref.key, o3 = e5.ref.parent, t5 = r3.length; t5--; ) if ((a4 = r3[t5]).ref && a4.ref.parent === o3) {
            if (a4.ref.key < n4) break;
            --a4.ref.key;
          }
        }
      }
      for (this.__initialize(e4, t4), g2 = {}, r3 = this.__worklist, n3 = this.__leavelist, y3 = new c2(e4, null, null, new l2(A2 = { root: e4 }, "root")), r3.push(y3), n3.push(y3); r3.length; ) if ((y3 = r3.pop()) !== g2) {
        if (void 0 !== (f3 = this.__execute(t4.enter, y3)) && f3 !== o2 && f3 !== i2 && f3 !== s2 && (y3.ref.replace(f3), y3.node = f3), this.__state !== s2 && f3 !== s2 || (b(y3), y3.node = null), this.__state === o2 || f3 === o2) return A2.root;
        if ((a3 = y3.node) && (r3.push(g2), n3.push(y3), this.__state !== i2 && f3 !== i2)) {
          if (u3 = a3.type || y3.wrap, !(x2 = this.__keys[u3])) {
            if (!this.__fallback) throw new Error("Unknown node type " + u3 + ".");
            x2 = this.__fallback(a3);
          }
          for (d3 = x2.length; (d3 -= 1) >= 0; ) if (v2 = a3[E = x2[d3]]) if (Array.isArray(v2)) {
            for (m3 = v2.length; (m3 -= 1) >= 0; ) if (v2[m3]) {
              if (h2(u3, x2[d3])) y3 = new c2(v2[m3], [E, m3], "Property", new l2(v2, m3));
              else {
                if (!p2(v2[m3])) continue;
                y3 = new c2(v2[m3], [E, m3], null, new l2(v2, m3));
              }
              r3.push(y3);
            }
          } else p2(v2) && r3.push(new c2(v2, E, null, new l2(a3, E)));
        }
      } else if (y3 = n3.pop(), void 0 !== (f3 = this.__execute(t4.leave, y3)) && f3 !== o2 && f3 !== i2 && f3 !== s2 && y3.ref.replace(f3), this.__state !== s2 && f3 !== s2 || b(y3), this.__state === o2 || f3 === o2) return A2.root;
      return A2.root;
    }, t3.Syntax = r2, t3.traverse = d2, t3.replace = function(e4, t4) {
      return new f2().replace(e4, t4);
    }, t3.attachComments = function(e4, t4, r3) {
      var a3, o3, i3, s3, l3 = [];
      if (!e4.range) throw new Error("attachComments needs range information");
      if (!r3.length) {
        if (t4.length) {
          for (i3 = 0, o3 = t4.length; i3 < o3; i3 += 1) (a3 = u2(t4[i3])).extendedRange = [0, e4.range[0]], l3.push(a3);
          e4.leadingComments = l3;
        }
        return e4;
      }
      for (i3 = 0, o3 = t4.length; i3 < o3; i3 += 1) l3.push(m2(u2(t4[i3]), r3));
      return s3 = 0, d2(e4, { enter: function(e5) {
        for (var t5; s3 < l3.length && !((t5 = l3[s3]).extendedRange[1] > e5.range[0]); ) t5.extendedRange[1] === e5.range[0] ? (e5.leadingComments || (e5.leadingComments = []), e5.leadingComments.push(t5), l3.splice(s3, 1)) : s3 += 1;
        return s3 === l3.length ? n2.Break : l3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0;
      } }), s3 = 0, d2(e4, { leave: function(e5) {
        for (var t5; s3 < l3.length && (t5 = l3[s3], !(e5.range[1] < t5.extendedRange[0])); ) e5.range[1] === t5.extendedRange[0] ? (e5.trailingComments || (e5.trailingComments = []), e5.trailingComments.push(t5), l3.splice(s3, 1)) : s3 += 1;
        return s3 === l3.length ? n2.Break : l3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0;
      } }), e4;
    }, t3.VisitorKeys = a2, t3.VisitorOption = n2, t3.Controller = f2, t3.cloneEnvironment = function() {
      return e3({});
    }, t3;
  }(t2);
}), s = o(function(e2) {
  e2.exports && (e2.exports = function() {
    function e3(t2, r2, n2, a2) {
      this.message = t2, this.expected = r2, this.found = n2, this.location = a2, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, e3);
    }
    return function(e4, t2) {
      function r2() {
        this.constructor = e4;
      }
      r2.prototype = t2.prototype, e4.prototype = new r2();
    }(e3, Error), e3.buildMessage = function(e4, t2) {
      var r2 = { literal: function(e5) {
        return '"' + a2(e5.text) + '"';
      }, class: function(e5) {
        var t3, r3 = "";
        for (t3 = 0; t3 < e5.parts.length; t3++) r3 += e5.parts[t3] instanceof Array ? o2(e5.parts[t3][0]) + "-" + o2(e5.parts[t3][1]) : o2(e5.parts[t3]);
        return "[" + (e5.inverted ? "^" : "") + r3 + "]";
      }, any: function(e5) {
        return "any character";
      }, end: function(e5) {
        return "end of input";
      }, other: function(e5) {
        return e5.description;
      } };
      function n2(e5) {
        return e5.charCodeAt(0).toString(16).toUpperCase();
      }
      function a2(e5) {
        return e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(e6) {
          return "\\x0" + n2(e6);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(e6) {
          return "\\x" + n2(e6);
        });
      }
      function o2(e5) {
        return e5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(e6) {
          return "\\x0" + n2(e6);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(e6) {
          return "\\x" + n2(e6);
        });
      }
      return "Expected " + function(e5) {
        var t3, n3, a3, o3 = new Array(e5.length);
        for (t3 = 0; t3 < e5.length; t3++) o3[t3] = (a3 = e5[t3], r2[a3.type](a3));
        if (o3.sort(), o3.length > 0) {
          for (t3 = 1, n3 = 1; t3 < o3.length; t3++) o3[t3 - 1] !== o3[t3] && (o3[n3] = o3[t3], n3++);
          o3.length = n3;
        }
        switch (o3.length) {
          case 1:
            return o3[0];
          case 2:
            return o3[0] + " or " + o3[1];
          default:
            return o3.slice(0, -1).join(", ") + ", or " + o3[o3.length - 1];
        }
      }(e4) + " but " + function(e5) {
        return e5 ? '"' + a2(e5) + '"' : "end of input";
      }(t2) + " found.";
    }, { SyntaxError: e3, parse: function(t2, r2) {
      r2 = void 0 !== r2 ? r2 : {};
      var n2, a2, o2, i2, s2 = {}, u2 = { start: de }, l2 = de, c2 = ce(" ", false), f2 = /^[^ [\],():#!=><~+.]/, p2 = fe([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false), h2 = ce(">", false), y2 = ce("~", false), d2 = ce("+", false), m2 = ce(",", false), x2 = ce("!", false), v2 = ce("*", false), g2 = ce("#", false), A2 = ce("[", false), E = ce("]", false), b = /^[><!]/, S = fe([">", "<", "!"], false, false), _ = ce("=", false), C2 = function(e4) {
        return (e4 || "") + "=";
      }, w = /^[><]/, P = fe([">", "<"], false, false), k = ce(".", false), D = function(e4, t3, r3) {
        return { type: "attribute", name: e4, operator: t3, value: r3 };
      }, I = ce('"', false), j = /^[^\\"]/, T = fe(["\\", '"'], true, false), F = ce("\\", false), R = { type: "any" }, O = function(e4, t3) {
        return e4 + t3;
      }, L = function(e4) {
        return { type: "literal", value: (t3 = e4.join(""), t3.replace(/\\(.)/g, function(e5, t4) {
          switch (t4) {
            case "b":
              return "\b";
            case "f":
              return "\f";
            case "n":
              return "\n";
            case "r":
              return "\r";
            case "t":
              return "	";
            case "v":
              return "\v";
            default:
              return t4;
          }
        })) };
        var t3;
      }, M = ce("'", false), B = /^[^\\']/, U = fe(["\\", "'"], true, false), K = /^[0-9]/, W = fe([["0", "9"]], false, false), V = ce("type(", false), q = /^[^ )]/, N = fe([" ", ")"], true, false), G = ce(")", false), z = /^[imsu]/, H = fe(["i", "m", "s", "u"], false, false), Y = ce("/", false), $ = /^[^\/]/, J = fe(["/"], true, false), Q = ce(":not(", false), X = ce(":matches(", false), Z = ce(":has(", false), ee = ce(":first-child", false), te = ce(":last-child", false), re = ce(":nth-child(", false), ne = ce(":nth-last-child(", false), ae = ce(":", false), oe = 0, ie2 = [{ line: 1, column: 1 }], se = 0, ue = [], le = {};
      if ("startRule" in r2) {
        if (!(r2.startRule in u2)) throw new Error(`Can't start parsing from rule "` + r2.startRule + '".');
        l2 = u2[r2.startRule];
      }
      function ce(e4, t3) {
        return { type: "literal", text: e4, ignoreCase: t3 };
      }
      function fe(e4, t3, r3) {
        return { type: "class", parts: e4, inverted: t3, ignoreCase: r3 };
      }
      function pe(e4) {
        var r3, n3 = ie2[e4];
        if (n3) return n3;
        for (r3 = e4 - 1; !ie2[r3]; ) r3--;
        for (n3 = { line: (n3 = ie2[r3]).line, column: n3.column }; r3 < e4; ) 10 === t2.charCodeAt(r3) ? (n3.line++, n3.column = 1) : n3.column++, r3++;
        return ie2[e4] = n3, n3;
      }
      function he(e4, t3) {
        var r3 = pe(e4), n3 = pe(t3);
        return { start: { offset: e4, line: r3.line, column: r3.column }, end: { offset: t3, line: n3.line, column: n3.column } };
      }
      function ye(e4) {
        oe < se || (oe > se && (se = oe, ue = []), ue.push(e4));
      }
      function de() {
        var e4, t3, r3, n3, a3 = 30 * oe + 0, o3 = le[a3];
        return o3 ? (oe = o3.nextPos, o3.result) : (e4 = oe, (t3 = me()) !== s2 && (r3 = ge()) !== s2 && me() !== s2 ? e4 = t3 = 1 === (n3 = r3).length ? n3[0] : { type: "matches", selectors: n3 } : (oe = e4, e4 = s2), e4 === s2 && (e4 = oe, (t3 = me()) !== s2 && (t3 = void 0), e4 = t3), le[a3] = { nextPos: oe, result: e4 }, e4);
      }
      function me() {
        var e4, r3, n3 = 30 * oe + 1, a3 = le[n3];
        if (a3) return oe = a3.nextPos, a3.result;
        for (e4 = [], 32 === t2.charCodeAt(oe) ? (r3 = " ", oe++) : (r3 = s2, ye(c2)); r3 !== s2; ) e4.push(r3), 32 === t2.charCodeAt(oe) ? (r3 = " ", oe++) : (r3 = s2, ye(c2));
        return le[n3] = { nextPos: oe, result: e4 }, e4;
      }
      function xe() {
        var e4, r3, n3, a3 = 30 * oe + 2, o3 = le[a3];
        if (o3) return oe = o3.nextPos, o3.result;
        if (r3 = [], f2.test(t2.charAt(oe)) ? (n3 = t2.charAt(oe), oe++) : (n3 = s2, ye(p2)), n3 !== s2) for (; n3 !== s2; ) r3.push(n3), f2.test(t2.charAt(oe)) ? (n3 = t2.charAt(oe), oe++) : (n3 = s2, ye(p2));
        else r3 = s2;
        return r3 !== s2 && (r3 = r3.join("")), e4 = r3, le[a3] = { nextPos: oe, result: e4 }, e4;
      }
      function ve() {
        var e4, r3, n3, a3 = 30 * oe + 3, o3 = le[a3];
        return o3 ? (oe = o3.nextPos, o3.result) : (e4 = oe, (r3 = me()) !== s2 ? (62 === t2.charCodeAt(oe) ? (n3 = ">", oe++) : (n3 = s2, ye(h2)), n3 !== s2 && me() !== s2 ? e4 = r3 = "child" : (oe = e4, e4 = s2)) : (oe = e4, e4 = s2), e4 === s2 && (e4 = oe, (r3 = me()) !== s2 ? (126 === t2.charCodeAt(oe) ? (n3 = "~", oe++) : (n3 = s2, ye(y2)), n3 !== s2 && me() !== s2 ? e4 = r3 = "sibling" : (oe = e4, e4 = s2)) : (oe = e4, e4 = s2), e4 === s2 && (e4 = oe, (r3 = me()) !== s2 ? (43 === t2.charCodeAt(oe) ? (n3 = "+", oe++) : (n3 = s2, ye(d2)), n3 !== s2 && me() !== s2 ? e4 = r3 = "adjacent" : (oe = e4, e4 = s2)) : (oe = e4, e4 = s2), e4 === s2 && (e4 = oe, 32 === t2.charCodeAt(oe) ? (r3 = " ", oe++) : (r3 = s2, ye(c2)), r3 !== s2 && (n3 = me()) !== s2 ? e4 = r3 = "descendant" : (oe = e4, e4 = s2)))), le[a3] = { nextPos: oe, result: e4 }, e4);
      }
      function ge() {
        var e4, r3, n3, a3, o3, i3, u3, l3, c3 = 30 * oe + 4, f3 = le[c3];
        if (f3) return oe = f3.nextPos, f3.result;
        if (e4 = oe, (r3 = Ae()) !== s2) {
          for (n3 = [], a3 = oe, (o3 = me()) !== s2 ? (44 === t2.charCodeAt(oe) ? (i3 = ",", oe++) : (i3 = s2, ye(m2)), i3 !== s2 && (u3 = me()) !== s2 && (l3 = Ae()) !== s2 ? a3 = o3 = [o3, i3, u3, l3] : (oe = a3, a3 = s2)) : (oe = a3, a3 = s2); a3 !== s2; ) n3.push(a3), a3 = oe, (o3 = me()) !== s2 ? (44 === t2.charCodeAt(oe) ? (i3 = ",", oe++) : (i3 = s2, ye(m2)), i3 !== s2 && (u3 = me()) !== s2 && (l3 = Ae()) !== s2 ? a3 = o3 = [o3, i3, u3, l3] : (oe = a3, a3 = s2)) : (oe = a3, a3 = s2);
          n3 !== s2 ? e4 = r3 = [r3].concat(n3.map(function(e5) {
            return e5[3];
          })) : (oe = e4, e4 = s2);
        } else oe = e4, e4 = s2;
        return le[c3] = { nextPos: oe, result: e4 }, e4;
      }
      function Ae() {
        var e4, t3, r3, n3, a3, o3, i3, u3 = 30 * oe + 5, l3 = le[u3];
        if (l3) return oe = l3.nextPos, l3.result;
        if (e4 = oe, (t3 = Ee()) !== s2) {
          for (r3 = [], n3 = oe, (a3 = ve()) !== s2 && (o3 = Ee()) !== s2 ? n3 = a3 = [a3, o3] : (oe = n3, n3 = s2); n3 !== s2; ) r3.push(n3), n3 = oe, (a3 = ve()) !== s2 && (o3 = Ee()) !== s2 ? n3 = a3 = [a3, o3] : (oe = n3, n3 = s2);
          r3 !== s2 ? (i3 = t3, e4 = t3 = r3.reduce(function(e5, t4) {
            return { type: t4[0], left: e5, right: t4[1] };
          }, i3)) : (oe = e4, e4 = s2);
        } else oe = e4, e4 = s2;
        return le[u3] = { nextPos: oe, result: e4 }, e4;
      }
      function Ee() {
        var e4, r3, n3, a3, o3, i3, u3, l3 = 30 * oe + 6, c3 = le[l3];
        if (c3) return oe = c3.nextPos, c3.result;
        if (e4 = oe, 33 === t2.charCodeAt(oe) ? (r3 = "!", oe++) : (r3 = s2, ye(x2)), r3 === s2 && (r3 = null), r3 !== s2) {
          if (n3 = [], (a3 = be()) !== s2) for (; a3 !== s2; ) n3.push(a3), a3 = be();
          else n3 = s2;
          n3 !== s2 ? (o3 = r3, u3 = 1 === (i3 = n3).length ? i3[0] : { type: "compound", selectors: i3 }, o3 && (u3.subject = true), e4 = r3 = u3) : (oe = e4, e4 = s2);
        } else oe = e4, e4 = s2;
        return le[l3] = { nextPos: oe, result: e4 }, e4;
      }
      function be() {
        var e4, r3 = 30 * oe + 7, n3 = le[r3];
        return n3 ? (oe = n3.nextPos, n3.result) : ((e4 = function() {
          var e5, r4, n4 = 30 * oe + 8, a3 = le[n4];
          return a3 ? (oe = a3.nextPos, a3.result) : (42 === t2.charCodeAt(oe) ? (r4 = "*", oe++) : (r4 = s2, ye(v2)), r4 !== s2 && (r4 = { type: "wildcard", value: r4 }), e5 = r4, le[n4] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3 = 30 * oe + 9, o3 = le[a3];
          return o3 ? (oe = o3.nextPos, o3.result) : (e5 = oe, 35 === t2.charCodeAt(oe) ? (r4 = "#", oe++) : (r4 = s2, ye(g2)), r4 === s2 && (r4 = null), r4 !== s2 && (n4 = xe()) !== s2 ? e5 = r4 = { type: "identifier", value: n4 } : (oe = e5, e5 = s2), le[a3] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3 = 30 * oe + 10, i3 = le[o3];
          return i3 ? (oe = i3.nextPos, i3.result) : (e5 = oe, 91 === t2.charCodeAt(oe) ? (r4 = "[", oe++) : (r4 = s2, ye(A2)), r4 !== s2 && me() !== s2 && (n4 = function() {
            var e6, r5, n5, a4, o4 = 30 * oe + 14, i4 = le[o4];
            return i4 ? (oe = i4.nextPos, i4.result) : (e6 = oe, (r5 = Se()) !== s2 && me() !== s2 && (n5 = function() {
              var e7, r6, n6, a5 = 30 * oe + 12, o5 = le[a5];
              return o5 ? (oe = o5.nextPos, o5.result) : (e7 = oe, 33 === t2.charCodeAt(oe) ? (r6 = "!", oe++) : (r6 = s2, ye(x2)), r6 === s2 && (r6 = null), r6 !== s2 ? (61 === t2.charCodeAt(oe) ? (n6 = "=", oe++) : (n6 = s2, ye(_)), n6 !== s2 ? (r6 = C2(r6), e7 = r6) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2), le[a5] = { nextPos: oe, result: e7 }, e7);
            }()) !== s2 && me() !== s2 ? ((a4 = function() {
              var e7, r6, n6, a5, o5, i5 = 30 * oe + 18, u3 = le[i5];
              if (u3) return oe = u3.nextPos, u3.result;
              if (e7 = oe, "type(" === t2.substr(oe, 5) ? (r6 = "type(", oe += 5) : (r6 = s2, ye(V)), r6 !== s2) if (me() !== s2) {
                if (n6 = [], q.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(N)), a5 !== s2) for (; a5 !== s2; ) n6.push(a5), q.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(N));
                else n6 = s2;
                n6 !== s2 && (a5 = me()) !== s2 ? (41 === t2.charCodeAt(oe) ? (o5 = ")", oe++) : (o5 = s2, ye(G)), o5 !== s2 ? (r6 = { type: "type", value: n6.join("") }, e7 = r6) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2);
              } else oe = e7, e7 = s2;
              else oe = e7, e7 = s2;
              return le[i5] = { nextPos: oe, result: e7 }, e7;
            }()) === s2 && (a4 = function() {
              var e7, r6, n6, a5, o5, i5, u3 = 30 * oe + 20, l3 = le[u3];
              if (l3) return oe = l3.nextPos, l3.result;
              if (e7 = oe, 47 === t2.charCodeAt(oe) ? (r6 = "/", oe++) : (r6 = s2, ye(Y)), r6 !== s2) {
                if (n6 = [], $.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(J)), a5 !== s2) for (; a5 !== s2; ) n6.push(a5), $.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(J));
                else n6 = s2;
                n6 !== s2 ? (47 === t2.charCodeAt(oe) ? (a5 = "/", oe++) : (a5 = s2, ye(Y)), a5 !== s2 ? ((o5 = function() {
                  var e8, r7, n7 = 30 * oe + 19, a6 = le[n7];
                  if (a6) return oe = a6.nextPos, a6.result;
                  if (e8 = [], z.test(t2.charAt(oe)) ? (r7 = t2.charAt(oe), oe++) : (r7 = s2, ye(H)), r7 !== s2) for (; r7 !== s2; ) e8.push(r7), z.test(t2.charAt(oe)) ? (r7 = t2.charAt(oe), oe++) : (r7 = s2, ye(H));
                  else e8 = s2;
                  return le[n7] = { nextPos: oe, result: e8 }, e8;
                }()) === s2 && (o5 = null), o5 !== s2 ? (i5 = o5, r6 = { type: "regexp", value: new RegExp(n6.join(""), i5 ? i5.join("") : "") }, e7 = r6) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2);
              } else oe = e7, e7 = s2;
              return le[u3] = { nextPos: oe, result: e7 }, e7;
            }()), a4 !== s2 ? (r5 = D(r5, n5, a4), e6 = r5) : (oe = e6, e6 = s2)) : (oe = e6, e6 = s2), e6 === s2 && (e6 = oe, (r5 = Se()) !== s2 && me() !== s2 && (n5 = function() {
              var e7, r6, n6, a5 = 30 * oe + 11, o5 = le[a5];
              return o5 ? (oe = o5.nextPos, o5.result) : (e7 = oe, b.test(t2.charAt(oe)) ? (r6 = t2.charAt(oe), oe++) : (r6 = s2, ye(S)), r6 === s2 && (r6 = null), r6 !== s2 ? (61 === t2.charCodeAt(oe) ? (n6 = "=", oe++) : (n6 = s2, ye(_)), n6 !== s2 ? (r6 = C2(r6), e7 = r6) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2), e7 === s2 && (w.test(t2.charAt(oe)) ? (e7 = t2.charAt(oe), oe++) : (e7 = s2, ye(P))), le[a5] = { nextPos: oe, result: e7 }, e7);
            }()) !== s2 && me() !== s2 ? ((a4 = function() {
              var e7, r6, n6, a5, o5, i5, u3 = 30 * oe + 15, l3 = le[u3];
              if (l3) return oe = l3.nextPos, l3.result;
              if (e7 = oe, 34 === t2.charCodeAt(oe) ? (r6 = '"', oe++) : (r6 = s2, ye(I)), r6 !== s2) {
                for (n6 = [], j.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(T)), a5 === s2 && (a5 = oe, 92 === t2.charCodeAt(oe) ? (o5 = "\\", oe++) : (o5 = s2, ye(F)), o5 !== s2 ? (t2.length > oe ? (i5 = t2.charAt(oe), oe++) : (i5 = s2, ye(R)), i5 !== s2 ? (o5 = O(o5, i5), a5 = o5) : (oe = a5, a5 = s2)) : (oe = a5, a5 = s2)); a5 !== s2; ) n6.push(a5), j.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(T)), a5 === s2 && (a5 = oe, 92 === t2.charCodeAt(oe) ? (o5 = "\\", oe++) : (o5 = s2, ye(F)), o5 !== s2 ? (t2.length > oe ? (i5 = t2.charAt(oe), oe++) : (i5 = s2, ye(R)), i5 !== s2 ? (o5 = O(o5, i5), a5 = o5) : (oe = a5, a5 = s2)) : (oe = a5, a5 = s2));
                n6 !== s2 ? (34 === t2.charCodeAt(oe) ? (a5 = '"', oe++) : (a5 = s2, ye(I)), a5 !== s2 ? (r6 = L(n6), e7 = r6) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2);
              } else oe = e7, e7 = s2;
              if (e7 === s2) if (e7 = oe, 39 === t2.charCodeAt(oe) ? (r6 = "'", oe++) : (r6 = s2, ye(M)), r6 !== s2) {
                for (n6 = [], B.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(U)), a5 === s2 && (a5 = oe, 92 === t2.charCodeAt(oe) ? (o5 = "\\", oe++) : (o5 = s2, ye(F)), o5 !== s2 ? (t2.length > oe ? (i5 = t2.charAt(oe), oe++) : (i5 = s2, ye(R)), i5 !== s2 ? (o5 = O(o5, i5), a5 = o5) : (oe = a5, a5 = s2)) : (oe = a5, a5 = s2)); a5 !== s2; ) n6.push(a5), B.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(U)), a5 === s2 && (a5 = oe, 92 === t2.charCodeAt(oe) ? (o5 = "\\", oe++) : (o5 = s2, ye(F)), o5 !== s2 ? (t2.length > oe ? (i5 = t2.charAt(oe), oe++) : (i5 = s2, ye(R)), i5 !== s2 ? (o5 = O(o5, i5), a5 = o5) : (oe = a5, a5 = s2)) : (oe = a5, a5 = s2));
                n6 !== s2 ? (39 === t2.charCodeAt(oe) ? (a5 = "'", oe++) : (a5 = s2, ye(M)), a5 !== s2 ? (r6 = L(n6), e7 = r6) : (oe = e7, e7 = s2)) : (oe = e7, e7 = s2);
              } else oe = e7, e7 = s2;
              return le[u3] = { nextPos: oe, result: e7 }, e7;
            }()) === s2 && (a4 = function() {
              var e7, r6, n6, a5, o5, i5, u3, l3 = 30 * oe + 16, c3 = le[l3];
              if (c3) return oe = c3.nextPos, c3.result;
              for (e7 = oe, r6 = oe, n6 = [], K.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(W)); a5 !== s2; ) n6.push(a5), K.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(W));
              if (n6 !== s2 ? (46 === t2.charCodeAt(oe) ? (a5 = ".", oe++) : (a5 = s2, ye(k)), a5 !== s2 ? r6 = n6 = [n6, a5] : (oe = r6, r6 = s2)) : (oe = r6, r6 = s2), r6 === s2 && (r6 = null), r6 !== s2) {
                if (n6 = [], K.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(W)), a5 !== s2) for (; a5 !== s2; ) n6.push(a5), K.test(t2.charAt(oe)) ? (a5 = t2.charAt(oe), oe++) : (a5 = s2, ye(W));
                else n6 = s2;
                n6 !== s2 ? (i5 = n6, u3 = (o5 = r6) ? [].concat.apply([], o5).join("") : "", r6 = { type: "literal", value: parseFloat(u3 + i5.join("")) }, e7 = r6) : (oe = e7, e7 = s2);
              } else oe = e7, e7 = s2;
              return le[l3] = { nextPos: oe, result: e7 }, e7;
            }()) === s2 && (a4 = function() {
              var e7, t3, r6 = 30 * oe + 17, n6 = le[r6];
              return n6 ? (oe = n6.nextPos, n6.result) : ((t3 = xe()) !== s2 && (t3 = { type: "literal", value: t3 }), e7 = t3, le[r6] = { nextPos: oe, result: e7 }, e7);
            }()), a4 !== s2 ? (r5 = D(r5, n5, a4), e6 = r5) : (oe = e6, e6 = s2)) : (oe = e6, e6 = s2), e6 === s2 && (e6 = oe, (r5 = Se()) !== s2 && (r5 = { type: "attribute", name: r5 }), e6 = r5)), le[o4] = { nextPos: oe, result: e6 }, e6);
          }()) !== s2 && me() !== s2 ? (93 === t2.charCodeAt(oe) ? (a3 = "]", oe++) : (a3 = s2, ye(E)), a3 !== s2 ? e5 = r4 = n4 : (oe = e5, e5 = s2)) : (oe = e5, e5 = s2), le[o3] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3, i3, u3, l3, c3 = 30 * oe + 21, f3 = le[c3];
          if (f3) return oe = f3.nextPos, f3.result;
          if (e5 = oe, 46 === t2.charCodeAt(oe) ? (r4 = ".", oe++) : (r4 = s2, ye(k)), r4 !== s2) if ((n4 = xe()) !== s2) {
            for (a3 = [], o3 = oe, 46 === t2.charCodeAt(oe) ? (i3 = ".", oe++) : (i3 = s2, ye(k)), i3 !== s2 && (u3 = xe()) !== s2 ? o3 = i3 = [i3, u3] : (oe = o3, o3 = s2); o3 !== s2; ) a3.push(o3), o3 = oe, 46 === t2.charCodeAt(oe) ? (i3 = ".", oe++) : (i3 = s2, ye(k)), i3 !== s2 && (u3 = xe()) !== s2 ? o3 = i3 = [i3, u3] : (oe = o3, o3 = s2);
            a3 !== s2 ? (l3 = n4, r4 = { type: "field", name: a3.reduce(function(e6, t3) {
              return e6 + t3[0] + t3[1];
            }, l3) }, e5 = r4) : (oe = e5, e5 = s2);
          } else oe = e5, e5 = s2;
          else oe = e5, e5 = s2;
          return le[c3] = { nextPos: oe, result: e5 }, e5;
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3 = 30 * oe + 22, i3 = le[o3];
          return i3 ? (oe = i3.nextPos, i3.result) : (e5 = oe, ":not(" === t2.substr(oe, 5) ? (r4 = ":not(", oe += 5) : (r4 = s2, ye(Q)), r4 !== s2 && me() !== s2 && (n4 = ge()) !== s2 && me() !== s2 ? (41 === t2.charCodeAt(oe) ? (a3 = ")", oe++) : (a3 = s2, ye(G)), a3 !== s2 ? e5 = r4 = { type: "not", selectors: n4 } : (oe = e5, e5 = s2)) : (oe = e5, e5 = s2), le[o3] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3 = 30 * oe + 23, i3 = le[o3];
          return i3 ? (oe = i3.nextPos, i3.result) : (e5 = oe, ":matches(" === t2.substr(oe, 9) ? (r4 = ":matches(", oe += 9) : (r4 = s2, ye(X)), r4 !== s2 && me() !== s2 && (n4 = ge()) !== s2 && me() !== s2 ? (41 === t2.charCodeAt(oe) ? (a3 = ")", oe++) : (a3 = s2, ye(G)), a3 !== s2 ? e5 = r4 = { type: "matches", selectors: n4 } : (oe = e5, e5 = s2)) : (oe = e5, e5 = s2), le[o3] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3 = 30 * oe + 24, i3 = le[o3];
          return i3 ? (oe = i3.nextPos, i3.result) : (e5 = oe, ":has(" === t2.substr(oe, 5) ? (r4 = ":has(", oe += 5) : (r4 = s2, ye(Z)), r4 !== s2 && me() !== s2 && (n4 = ge()) !== s2 && me() !== s2 ? (41 === t2.charCodeAt(oe) ? (a3 = ")", oe++) : (a3 = s2, ye(G)), a3 !== s2 ? e5 = r4 = { type: "has", selectors: n4 } : (oe = e5, e5 = s2)) : (oe = e5, e5 = s2), le[o3] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4 = 30 * oe + 25, a3 = le[n4];
          return a3 ? (oe = a3.nextPos, a3.result) : (":first-child" === t2.substr(oe, 12) ? (r4 = ":first-child", oe += 12) : (r4 = s2, ye(ee)), r4 !== s2 && (r4 = _e(1)), e5 = r4, le[n4] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4 = 30 * oe + 26, a3 = le[n4];
          return a3 ? (oe = a3.nextPos, a3.result) : (":last-child" === t2.substr(oe, 11) ? (r4 = ":last-child", oe += 11) : (r4 = s2, ye(te)), r4 !== s2 && (r4 = Ce(1)), e5 = r4, le[n4] = { nextPos: oe, result: e5 }, e5);
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3, i3 = 30 * oe + 27, u3 = le[i3];
          if (u3) return oe = u3.nextPos, u3.result;
          if (e5 = oe, ":nth-child(" === t2.substr(oe, 11) ? (r4 = ":nth-child(", oe += 11) : (r4 = s2, ye(re)), r4 !== s2) if (me() !== s2) {
            if (n4 = [], K.test(t2.charAt(oe)) ? (a3 = t2.charAt(oe), oe++) : (a3 = s2, ye(W)), a3 !== s2) for (; a3 !== s2; ) n4.push(a3), K.test(t2.charAt(oe)) ? (a3 = t2.charAt(oe), oe++) : (a3 = s2, ye(W));
            else n4 = s2;
            n4 !== s2 && (a3 = me()) !== s2 ? (41 === t2.charCodeAt(oe) ? (o3 = ")", oe++) : (o3 = s2, ye(G)), o3 !== s2 ? (r4 = _e(parseInt(n4.join(""), 10)), e5 = r4) : (oe = e5, e5 = s2)) : (oe = e5, e5 = s2);
          } else oe = e5, e5 = s2;
          else oe = e5, e5 = s2;
          return le[i3] = { nextPos: oe, result: e5 }, e5;
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3, o3, i3 = 30 * oe + 28, u3 = le[i3];
          if (u3) return oe = u3.nextPos, u3.result;
          if (e5 = oe, ":nth-last-child(" === t2.substr(oe, 16) ? (r4 = ":nth-last-child(", oe += 16) : (r4 = s2, ye(ne)), r4 !== s2) if (me() !== s2) {
            if (n4 = [], K.test(t2.charAt(oe)) ? (a3 = t2.charAt(oe), oe++) : (a3 = s2, ye(W)), a3 !== s2) for (; a3 !== s2; ) n4.push(a3), K.test(t2.charAt(oe)) ? (a3 = t2.charAt(oe), oe++) : (a3 = s2, ye(W));
            else n4 = s2;
            n4 !== s2 && (a3 = me()) !== s2 ? (41 === t2.charCodeAt(oe) ? (o3 = ")", oe++) : (o3 = s2, ye(G)), o3 !== s2 ? (r4 = Ce(parseInt(n4.join(""), 10)), e5 = r4) : (oe = e5, e5 = s2)) : (oe = e5, e5 = s2);
          } else oe = e5, e5 = s2;
          else oe = e5, e5 = s2;
          return le[i3] = { nextPos: oe, result: e5 }, e5;
        }()) === s2 && (e4 = function() {
          var e5, r4, n4, a3 = 30 * oe + 29, o3 = le[a3];
          return o3 ? (oe = o3.nextPos, o3.result) : (e5 = oe, 58 === t2.charCodeAt(oe) ? (r4 = ":", oe++) : (r4 = s2, ye(ae)), r4 !== s2 && (n4 = xe()) !== s2 ? e5 = r4 = { type: "class", name: n4 } : (oe = e5, e5 = s2), le[a3] = { nextPos: oe, result: e5 }, e5);
        }()), le[r3] = { nextPos: oe, result: e4 }, e4);
      }
      function Se() {
        var e4, r3, n3, a3, o3, i3, u3, l3, c3 = 30 * oe + 13, f3 = le[c3];
        if (f3) return oe = f3.nextPos, f3.result;
        if (e4 = oe, (r3 = xe()) !== s2) {
          for (n3 = [], a3 = oe, 46 === t2.charCodeAt(oe) ? (o3 = ".", oe++) : (o3 = s2, ye(k)), o3 !== s2 && (i3 = xe()) !== s2 ? a3 = o3 = [o3, i3] : (oe = a3, a3 = s2); a3 !== s2; ) n3.push(a3), a3 = oe, 46 === t2.charCodeAt(oe) ? (o3 = ".", oe++) : (o3 = s2, ye(k)), o3 !== s2 && (i3 = xe()) !== s2 ? a3 = o3 = [o3, i3] : (oe = a3, a3 = s2);
          n3 !== s2 ? (u3 = r3, l3 = n3, e4 = r3 = [].concat.apply([u3], l3).join("")) : (oe = e4, e4 = s2);
        } else oe = e4, e4 = s2;
        return le[c3] = { nextPos: oe, result: e4 }, e4;
      }
      function _e(e4) {
        return { type: "nth-child", index: { type: "literal", value: e4 } };
      }
      function Ce(e4) {
        return { type: "nth-last-child", index: { type: "literal", value: e4 } };
      }
      if ((n2 = l2()) !== s2 && oe === t2.length) return n2;
      throw n2 !== s2 && oe < t2.length && ye({ type: "end" }), a2 = ue, o2 = se < t2.length ? t2.charAt(se) : null, i2 = se < t2.length ? he(se, se + 1) : he(se, se), new e3(e3.buildMessage(a2, o2), a2, o2, i2);
    } };
  }());
});
function u(e2, t2) {
  for (var r2 = 0; r2 < t2.length; ++r2) {
    if (null == e2) return e2;
    e2 = e2[t2[r2]];
  }
  return e2;
}
var l = "function" == typeof WeakMap ? /* @__PURE__ */ new WeakMap() : null;
function c(e2) {
  if (null == e2) return function() {
    return true;
  };
  if (null != l) {
    var t2 = l.get(e2);
    return null != t2 || (t2 = f(e2), l.set(e2, t2)), t2;
  }
  return f(e2);
}
function f(t2) {
  switch (t2.type) {
    case "wildcard":
      return function() {
        return true;
      };
    case "identifier":
      var r2 = t2.value.toLowerCase();
      return function(e2, t3, n3) {
        var a3 = n3 && n3.nodeTypeKey || "type";
        return r2 === e2[a3].toLowerCase();
      };
    case "field":
      var n2 = t2.name.split(".");
      return function(e2, t3) {
        return function e3(t4, r3, n3, a3) {
          for (var o3 = r3, i2 = a3; i2 < n3.length; ++i2) {
            if (null == o3) return false;
            var s3 = o3[n3[i2]];
            if (Array.isArray(s3)) {
              for (var u2 = 0; u2 < s3.length; ++u2) if (e3(t4, s3[u2], n3, i2 + 1)) return true;
              return false;
            }
            o3 = s3;
          }
          return t4 === o3;
        }(e2, t3[n2.length - 1], n2, 0);
      };
    case "matches":
      var a2 = t2.selectors.map(c);
      return function(e2, t3, r3) {
        for (var n3 = 0; n3 < a2.length; ++n3) if (a2[n3](e2, t3, r3)) return true;
        return false;
      };
    case "compound":
      var o2 = t2.selectors.map(c);
      return function(e2, t3, r3) {
        for (var n3 = 0; n3 < o2.length; ++n3) if (!o2[n3](e2, t3, r3)) return false;
        return true;
      };
    case "not":
      var s2 = t2.selectors.map(c);
      return function(e2, t3, r3) {
        for (var n3 = 0; n3 < s2.length; ++n3) if (s2[n3](e2, t3, r3)) return false;
        return true;
      };
    case "has":
      var l2 = t2.selectors.map(c);
      return function(e2, t3, r3) {
        var n3 = false, a3 = [];
        return i.traverse(e2, { enter: function(e3, t4) {
          null != t4 && a3.unshift(t4);
          for (var o3 = 0; o3 < l2.length; ++o3) if (l2[o3](e3, a3, r3)) return n3 = true, void this.break();
        }, leave: function() {
          a3.shift();
        }, keys: r3 && r3.visitorKeys, fallback: r3 && r3.fallback || "iteration" }), n3;
      };
    case "child":
      var f2 = c(t2.left), p2 = c(t2.right);
      return function(e2, t3, r3) {
        return !!(t3.length > 0 && p2(e2, t3, r3)) && f2(t3[0], t3.slice(1), r3);
      };
    case "descendant":
      var h2 = c(t2.left), x2 = c(t2.right);
      return function(e2, t3, r3) {
        if (x2(e2, t3, r3)) {
          for (var n3 = 0, a3 = t3.length; n3 < a3; ++n3) if (h2(t3[n3], t3.slice(n3 + 1), r3)) return true;
        }
        return false;
      };
    case "attribute":
      var v2 = t2.name.split(".");
      switch (t2.operator) {
        case void 0:
          return function(e2) {
            return null != u(e2, v2);
          };
        case "=":
          switch (t2.value.type) {
            case "regexp":
              return function(e2) {
                var r3 = u(e2, v2);
                return "string" == typeof r3 && t2.value.value.test(r3);
              };
            case "literal":
              var g2 = "".concat(t2.value.value);
              return function(e2) {
                return g2 === "".concat(u(e2, v2));
              };
            case "type":
              return function(r3) {
                return t2.value.value === e(u(r3, v2));
              };
          }
          throw new Error("Unknown selector value type: ".concat(t2.value.type));
        case "!=":
          switch (t2.value.type) {
            case "regexp":
              return function(e2) {
                return !t2.value.value.test(u(e2, v2));
              };
            case "literal":
              var A2 = "".concat(t2.value.value);
              return function(e2) {
                return A2 !== "".concat(u(e2, v2));
              };
            case "type":
              return function(r3) {
                return t2.value.value !== e(u(r3, v2));
              };
          }
          throw new Error("Unknown selector value type: ".concat(t2.value.type));
        case "<=":
          return function(e2) {
            return u(e2, v2) <= t2.value.value;
          };
        case "<":
          return function(e2) {
            return u(e2, v2) < t2.value.value;
          };
        case ">":
          return function(e2) {
            return u(e2, v2) > t2.value.value;
          };
        case ">=":
          return function(e2) {
            return u(e2, v2) >= t2.value.value;
          };
      }
      throw new Error("Unknown operator: ".concat(t2.operator));
    case "sibling":
      var E = c(t2.left), b = c(t2.right);
      return function(e2, r3, n3) {
        return b(e2, r3, n3) && y(e2, E, r3, "LEFT_SIDE", n3) || t2.left.subject && E(e2, r3, n3) && y(e2, b, r3, "RIGHT_SIDE", n3);
      };
    case "adjacent":
      var S = c(t2.left), _ = c(t2.right);
      return function(e2, r3, n3) {
        return _(e2, r3, n3) && d(e2, S, r3, "LEFT_SIDE", n3) || t2.right.subject && S(e2, r3, n3) && d(e2, _, r3, "RIGHT_SIDE", n3);
      };
    case "nth-child":
      var C2 = t2.index.value, w = c(t2.right);
      return function(e2, t3, r3) {
        return w(e2, t3, r3) && m(e2, t3, C2, r3);
      };
    case "nth-last-child":
      var P = -t2.index.value, k = c(t2.right);
      return function(e2, t3, r3) {
        return k(e2, t3, r3) && m(e2, t3, P, r3);
      };
    case "class":
      return function(e2, r3, n3) {
        if (n3 && n3.matchClass) return n3.matchClass(t2.name, e2, r3);
        if (n3 && n3.nodeTypeKey) return false;
        switch (t2.name.toLowerCase()) {
          case "statement":
            if ("Statement" === e2.type.slice(-9)) return true;
          case "declaration":
            return "Declaration" === e2.type.slice(-11);
          case "pattern":
            if ("Pattern" === e2.type.slice(-7)) return true;
          case "expression":
            return "Expression" === e2.type.slice(-10) || "Literal" === e2.type.slice(-7) || "Identifier" === e2.type && (0 === r3.length || "MetaProperty" !== r3[0].type) || "MetaProperty" === e2.type;
          case "function":
            return "FunctionDeclaration" === e2.type || "FunctionExpression" === e2.type || "ArrowFunctionExpression" === e2.type;
        }
        throw new Error("Unknown class name: ".concat(t2.name));
      };
  }
  throw new Error("Unknown selector type: ".concat(t2.type));
}
function p(e2, t2) {
  var r2 = t2 && t2.nodeTypeKey || "type", n2 = e2[r2];
  return t2 && t2.visitorKeys && t2.visitorKeys[n2] ? t2.visitorKeys[n2] : i.VisitorKeys[n2] ? i.VisitorKeys[n2] : t2 && "function" == typeof t2.fallback ? t2.fallback(e2) : Object.keys(e2).filter(function(e3) {
    return e3 !== r2;
  });
}
function h(t2, r2) {
  var n2 = r2 && r2.nodeTypeKey || "type";
  return null !== t2 && "object" === e(t2) && "string" == typeof t2[n2];
}
function y(e2, r2, n2, a2, o2) {
  var i2 = t(n2, 1)[0];
  if (!i2) return false;
  for (var s2 = p(i2, o2), u2 = 0; u2 < s2.length; ++u2) {
    var l2 = i2[s2[u2]];
    if (Array.isArray(l2)) {
      var c2 = l2.indexOf(e2);
      if (c2 < 0) continue;
      var f2 = void 0, y2 = void 0;
      "LEFT_SIDE" === a2 ? (f2 = 0, y2 = c2) : (f2 = c2 + 1, y2 = l2.length);
      for (var d2 = f2; d2 < y2; ++d2) if (h(l2[d2], o2) && r2(l2[d2], n2, o2)) return true;
    }
  }
  return false;
}
function d(e2, r2, n2, a2, o2) {
  var i2 = t(n2, 1)[0];
  if (!i2) return false;
  for (var s2 = p(i2, o2), u2 = 0; u2 < s2.length; ++u2) {
    var l2 = i2[s2[u2]];
    if (Array.isArray(l2)) {
      var c2 = l2.indexOf(e2);
      if (c2 < 0) continue;
      if ("LEFT_SIDE" === a2 && c2 > 0 && h(l2[c2 - 1], o2) && r2(l2[c2 - 1], n2, o2)) return true;
      if ("RIGHT_SIDE" === a2 && c2 < l2.length - 1 && h(l2[c2 + 1], o2) && r2(l2[c2 + 1], n2, o2)) return true;
    }
  }
  return false;
}
function m(e2, r2, n2, a2) {
  if (0 === n2) return false;
  var o2 = t(r2, 1)[0];
  if (!o2) return false;
  for (var i2 = p(o2, a2), s2 = 0; s2 < i2.length; ++s2) {
    var u2 = o2[i2[s2]];
    if (Array.isArray(u2)) {
      var l2 = n2 < 0 ? u2.length + n2 : n2 - 1;
      if (l2 >= 0 && l2 < u2.length && u2[l2] === e2) return true;
    }
  }
  return false;
}
function x(t2, n2, a2, o2) {
  if (n2) {
    var s2 = [], u2 = c(n2), l2 = function t3(n3, a3) {
      if (null == n3 || "object" != e(n3)) return [];
      null == a3 && (a3 = n3);
      for (var o3 = n3.subject ? [a3] : [], i2 = Object.keys(n3), s3 = 0; s3 < i2.length; ++s3) {
        var u3 = i2[s3], l3 = n3[u3];
        o3.push.apply(o3, r(t3(l3, "left" === u3 ? l3 : a3)));
      }
      return o3;
    }(n2).map(c);
    i.traverse(t2, { enter: function(e2, t3) {
      if (null != t3 && s2.unshift(t3), u2(e2, s2, o2)) if (l2.length) for (var r2 = 0, n3 = l2.length; r2 < n3; ++r2) {
        l2[r2](e2, s2, o2) && a2(e2, t3, s2);
        for (var i2 = 0, c2 = s2.length; i2 < c2; ++i2) {
          var f2 = s2.slice(i2 + 1);
          l2[r2](s2[i2], f2, o2) && a2(s2[i2], t3, f2);
        }
      }
      else a2(e2, t3, s2);
    }, leave: function() {
      s2.shift();
    }, keys: o2 && o2.visitorKeys, fallback: o2 && o2.fallback || "iteration" });
  }
}
function v(e2, t2, r2) {
  var n2 = [];
  return x(e2, t2, function(e3) {
    n2.push(e3);
  }, r2), n2;
}
function g(e2) {
  return s.parse(e2);
}
function A(e2, t2, r2) {
  return v(e2, g(t2), r2);
}
A.parse = g, A.match = v, A.traverse = x, A.matches = function(e2, t2, r2, n2) {
  return !t2 || !!e2 && (r2 || (r2 = []), c(t2)(e2, r2, n2));
}, A.query = A;
var esquery_1;
var hasRequiredEsquery;
function requireEsquery() {
  if (hasRequiredEsquery) return esquery_1;
  hasRequiredEsquery = 1;
  const esquery = A;
  class ESQueryParsedSelector {
    /**
     * Creates a new parsed selector.
     * @param {string} source The raw selector string that was parsed
     * @param {boolean} isExit Whether this selector is an exit selector
     * @param {ESQuerySelector} root An object (from esquery) describing the matching behavior of the selector
     * @param {string[]|null} nodeTypes The node types that could possibly trigger this selector, or `null` if all node types could trigger it
     * @param {number} attributeCount The number of class, pseudo-class, and attribute queries in this selector
     * @param {number} identifierCount The number of identifier queries in this selector
     */
    constructor(source, isExit, root, nodeTypes, attributeCount, identifierCount) {
      /**
       * The raw selector string that was parsed
       * @type {string}
       */
      __publicField(this, "source");
      /**
       * Whether this selector is an exit selector
       * @type {boolean}
       */
      __publicField(this, "isExit");
      /**
       * An object (from esquery) describing the matching behavior of the selector
       * @type {ESQuerySelector}
       */
      __publicField(this, "root");
      /**
       * The node types that could possibly trigger this selector, or `null` if all node types could trigger it
       * @type {string[]|null}
       */
      __publicField(this, "nodeTypes");
      /**
       * The number of class, pseudo-class, and attribute queries in this selector
       * @type {number}
       */
      __publicField(this, "attributeCount");
      /**
       * The number of identifier queries in this selector
       * @type {number}
       */
      __publicField(this, "identifierCount");
      this.source = source;
      this.isExit = isExit;
      this.root = root;
      this.nodeTypes = nodeTypes;
      this.attributeCount = attributeCount;
      this.identifierCount = identifierCount;
    }
    /**
     * Compares this selector's specificity to another selector for sorting purposes.
     * @param {ESQueryParsedSelector} otherSelector The selector to compare against
     * @returns {number}
     * a value less than 0 if this selector is less specific than otherSelector
     * a value greater than 0 if this selector is more specific than otherSelector
     * a value less than 0 if this selector and otherSelector have the same specificity, and this selector <= otherSelector alphabetically
     * a value greater than 0 if this selector and otherSelector have the same specificity, and this selector > otherSelector alphabetically
     */
    compare(otherSelector) {
      return this.attributeCount - otherSelector.attributeCount || this.identifierCount - otherSelector.identifierCount || (this.source <= otherSelector.source ? -1 : 1);
    }
  }
  const selectorCache = /* @__PURE__ */ new Map();
  function union(...arrays) {
    return [...new Set(arrays.flat())];
  }
  function intersection(...arrays) {
    if (arrays.length === 0) {
      return [];
    }
    let result = [...new Set(arrays[0])];
    for (const array of arrays.slice(1)) {
      result = result.filter((x2) => array.includes(x2));
    }
    return result;
  }
  function analyzeParsedSelector(parsedSelector) {
    let attributeCount = 0;
    let identifierCount = 0;
    function analyzeSelector(selector) {
      switch (selector.type) {
        case "identifier":
          identifierCount++;
          return [selector.value];
        case "not":
          selector.selectors.map(analyzeSelector);
          return null;
        case "matches": {
          const typesForComponents = selector.selectors.map(analyzeSelector);
          if (typesForComponents.every(Boolean)) {
            return union(...typesForComponents);
          }
          return null;
        }
        case "compound": {
          const typesForComponents = selector.selectors.map(analyzeSelector).filter((typesForComponent) => typesForComponent);
          if (!typesForComponents.length) {
            return null;
          }
          return intersection(...typesForComponents);
        }
        case "attribute":
        case "field":
        case "nth-child":
        case "nth-last-child":
          attributeCount++;
          return null;
        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
          analyzeSelector(selector.left);
          return analyzeSelector(selector.right);
        case "class":
          if (selector.name === "function") {
            return [
              "FunctionDeclaration",
              "FunctionExpression",
              "ArrowFunctionExpression"
            ];
          }
          return null;
        default:
          return null;
      }
    }
    const nodeTypes = analyzeSelector(parsedSelector);
    return {
      nodeTypes,
      attributeCount,
      identifierCount
    };
  }
  function trySimpleParseSelector(selector) {
    if (selector === "*") {
      return {
        type: "wildcard",
        value: "*"
      };
    }
    if (/^[a-z]+$/iu.test(selector)) {
      return {
        type: "identifier",
        value: selector
      };
    }
    return null;
  }
  function tryParseSelector(selector) {
    try {
      return esquery.parse(selector);
    } catch (err) {
      if (err.location && err.location.start && typeof err.location.start.offset === "number") {
        throw new SyntaxError(
          `Syntax error in selector "${selector}" at position ${err.location.start.offset}: ${err.message}`,
          {
            cause: err
          }
        );
      }
      throw err;
    }
  }
  function parse(source) {
    if (selectorCache.has(source)) {
      return selectorCache.get(source);
    }
    const cleanSource = source.replace(/:exit$/u, "");
    const parsedSelector = trySimpleParseSelector(cleanSource) ?? tryParseSelector(cleanSource);
    const { nodeTypes, attributeCount, identifierCount } = analyzeParsedSelector(parsedSelector);
    const result = new ESQueryParsedSelector(
      source,
      source.endsWith(":exit"),
      parsedSelector,
      nodeTypes,
      attributeCount,
      identifierCount
    );
    selectorCache.set(source, result);
    return result;
  }
  function matches(node2, root, ancestry, options) {
    return esquery.matches(node2, root, ancestry, options);
  }
  esquery_1 = {
    parse,
    matches,
    ESQueryParsedSelector
  };
  return esquery_1;
}
var sourceCodeTraverser;
var hasRequiredSourceCodeTraverser;
function requireSourceCodeTraverser() {
  var _language;
  if (hasRequiredSourceCodeTraverser) return sourceCodeTraverser;
  hasRequiredSourceCodeTraverser = 1;
  const { parse, matches } = requireEsquery();
  const vk = requireEslintVisitorKeys$2();
  const STEP_KIND_VISIT = 1;
  const STEP_KIND_CALL = 2;
  function compareSpecificity(a2, b) {
    return a2.compare(b);
  }
  class ESQueryHelper {
    /**
     * Creates a new instance.
     * @param {SourceCodeVisitor} visitor The visitor containing the functions to call.
     * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.
     */
    constructor(visitor, esqueryOptions) {
      this.visitor = visitor;
      this.esqueryOptions = esqueryOptions;
      this.enterSelectorsByNodeType = /* @__PURE__ */ new Map();
      this.exitSelectorsByNodeType = /* @__PURE__ */ new Map();
      this.anyTypeEnterSelectors = [];
      this.anyTypeExitSelectors = [];
      visitor.forEachName((rawSelector) => {
        const selector = parse(rawSelector);
        if (selector.nodeTypes) {
          const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
          selector.nodeTypes.forEach((nodeType) => {
            if (!typeMap.has(nodeType)) {
              typeMap.set(nodeType, []);
            }
            typeMap.get(nodeType).push(selector);
          });
          return;
        }
        const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
        selectors.push(selector);
      });
      this.anyTypeEnterSelectors.sort(compareSpecificity);
      this.anyTypeExitSelectors.sort(compareSpecificity);
      this.enterSelectorsByNodeType.forEach(
        (selectorList) => selectorList.sort(compareSpecificity)
      );
      this.exitSelectorsByNodeType.forEach(
        (selectorList) => selectorList.sort(compareSpecificity)
      );
    }
    /**
     * Checks if a node matches a given selector.
     * @param {ASTNode} node The node to check
     * @param {ASTNode[]} ancestry The ancestry of the node being checked.
     * @param {ESQueryParsedSelector} selector An AST selector descriptor
     * @returns {boolean} `true` if the selector matches the node, `false` otherwise
     */
    matches(node2, ancestry, selector) {
      return matches(node2, selector.root, ancestry, this.esqueryOptions);
    }
    /**
     * Calculates all appropriate selectors to a node, in specificity order
     * @param {ASTNode} node The node to check
     * @param {ASTNode[]} ancestry The ancestry of the node being checked.
     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited
     * @returns {string[]} An array of selectors that match the node.
     */
    calculateSelectors(node2, ancestry, isExit) {
      var _a2;
      const nodeTypeKey = ((_a2 = this.esqueryOptions) == null ? void 0 : _a2.nodeTypeKey) || "type";
      const selectors = [];
      const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node2[nodeTypeKey]) || [];
      const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
      let selectorsByNodeTypeIndex = 0;
      let anyTypeSelectorsIndex = 0;
      while (selectorsByNodeTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
        const hasMoreNodeTypeSelectors = selectorsByNodeTypeIndex < selectorsByNodeType.length;
        const hasMoreAnyTypeSelectors = anyTypeSelectorsIndex < anyTypeSelectors.length;
        const anyTypeSelector = anyTypeSelectors[anyTypeSelectorsIndex];
        const nodeTypeSelector = selectorsByNodeType[selectorsByNodeTypeIndex];
        const isAnyTypeSelectorLessSpecific = hasMoreAnyTypeSelectors && hasMoreNodeTypeSelectors && anyTypeSelector.compare(nodeTypeSelector) < 0;
        if (!hasMoreNodeTypeSelectors || isAnyTypeSelectorLessSpecific) {
          anyTypeSelectorsIndex++;
          if (this.matches(node2, ancestry, anyTypeSelector)) {
            selectors.push(anyTypeSelector.source);
          }
        } else {
          selectorsByNodeTypeIndex++;
          if (this.matches(node2, ancestry, nodeTypeSelector)) {
            selectors.push(nodeTypeSelector.source);
          }
        }
      }
      return selectors;
    }
  }
  class SourceCodeTraverser {
    /**
     * Creates a new instance.
     * @param {Language} language The language of the source code being traversed.
     */
    constructor(language2) {
      /**
       * The language of the source code being traversed.
       * @type {Language}
       */
      __privateAdd(this, _language);
      __privateSet(this, _language, language2);
    }
    static getInstance(language2) {
      if (!this.instances.has(language2)) {
        this.instances.set(language2, new this(language2));
      }
      return this.instances.get(language2);
    }
    /**
     * Traverses the given source code synchronously.
     * @param {SourceCode} sourceCode The source code to traverse.
     * @param {SourceCodeVisitor} visitor The emitter to use for events.
     * @param {Object} options Options for traversal.
     * @param {ReturnType<SourceCode["traverse"]>} options.steps The steps to take during traversal.
     * @returns {void}
     * @throws {Error} If an error occurs during traversal.
     */
    traverseSync(sourceCode2, visitor, { steps } = {}) {
      const esquery = new ESQueryHelper(visitor, {
        visitorKeys: sourceCode2.visitorKeys ?? __privateGet(this, _language).visitorKeys,
        fallback: vk.getKeys,
        matchClass: __privateGet(this, _language).matchesSelectorClass ?? (() => false),
        nodeTypeKey: __privateGet(this, _language).nodeTypeKey
      });
      const currentAncestry = [];
      for (const step of steps ?? sourceCode2.traverse()) {
        switch (step.kind) {
          case STEP_KIND_VISIT: {
            try {
              if (step.phase === 1) {
                esquery.calculateSelectors(
                  step.target,
                  currentAncestry,
                  false
                ).forEach((selector) => {
                  visitor.callSync(
                    selector,
                    ...step.args ?? [step.target]
                  );
                });
                currentAncestry.unshift(step.target);
              } else {
                currentAncestry.shift();
                esquery.calculateSelectors(
                  step.target,
                  currentAncestry,
                  true
                ).forEach((selector) => {
                  visitor.callSync(
                    selector,
                    ...step.args ?? [step.target]
                  );
                });
              }
            } catch (err) {
              err.currentNode = step.target;
              throw err;
            }
            break;
          }
          case STEP_KIND_CALL: {
            visitor.callSync(step.target, ...step.args);
            break;
          }
          default:
            throw new Error(
              `Invalid traversal step found: "${step.kind}".`
            );
        }
      }
    }
  }
  _language = new WeakMap();
  /**
   * Map of languages to instances of this class.
   * @type {WeakMap<Language, SourceCodeTraverser>}
   */
  __publicField(SourceCodeTraverser, "instances", /* @__PURE__ */ new WeakMap());
  sourceCodeTraverser = { SourceCodeTraverser };
  return sourceCodeTraverser;
}
var ruleFixer;
var hasRequiredRuleFixer;
function requireRuleFixer() {
  var _sourceCode;
  if (hasRequiredRuleFixer) return ruleFixer;
  hasRequiredRuleFixer = 1;
  function insertTextAt(index, text) {
    return {
      range: [index, index],
      text
    };
  }
  class RuleFixer {
    /**
     * Creates a new instance.
     * @param {Object} options The options for the fixer.
     * @param {SourceCode} options.sourceCode The source code object representing the text to be fixed.
     */
    constructor({ sourceCode: sourceCode2 }) {
      /**
       * The source code object representing the text to be fixed.
       * @type {SourceCode}
       */
      __privateAdd(this, _sourceCode);
      __privateSet(this, _sourceCode, sourceCode2);
    }
    /**
     * Creates a fix command that inserts text after the given node or token.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextAfter(nodeOrToken, text) {
      const range = __privateGet(this, _sourceCode).getRange(nodeOrToken);
      return this.insertTextAfterRange(range, text);
    }
    /**
     * Creates a fix command that inserts text after the specified range in the source text.
     * The fix is not applied until applyFixes() is called.
     * @param {SourceRange} range The range to replace, first item is start of range, second
     *      is end of range.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextAfterRange(range, text) {
      return insertTextAt(range[1], text);
    }
    /**
     * Creates a fix command that inserts text before the given node or token.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextBefore(nodeOrToken, text) {
      const range = __privateGet(this, _sourceCode).getRange(nodeOrToken);
      return this.insertTextBeforeRange(range, text);
    }
    /**
     * Creates a fix command that inserts text before the specified range in the source text.
     * The fix is not applied until applyFixes() is called.
     * @param {SourceRange} range The range to replace, first item is start of range, second
     *      is end of range.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    insertTextBeforeRange(range, text) {
      return insertTextAt(range[0], text);
    }
    /**
     * Creates a fix command that replaces text at the node or token.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    replaceText(nodeOrToken, text) {
      const range = __privateGet(this, _sourceCode).getRange(nodeOrToken);
      return this.replaceTextRange(range, text);
    }
    /**
     * Creates a fix command that replaces text at the specified range in the source text.
     * The fix is not applied until applyFixes() is called.
     * @param {SourceRange} range The range to replace, first item is start of range, second
     *      is end of range.
     * @param {string} text The text to insert.
     * @returns {Object} The fix command.
     */
    replaceTextRange(range, text) {
      return {
        range,
        text
      };
    }
    /**
     * Creates a fix command that removes the node or token from the source.
     * The fix is not applied until applyFixes() is called.
     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
     * @returns {Object} The fix command.
     */
    remove(nodeOrToken) {
      const range = __privateGet(this, _sourceCode).getRange(nodeOrToken);
      return this.removeRange(range);
    }
    /**
     * Creates a fix command that removes the specified range of text from the source.
     * The fix is not applied until applyFixes() is called.
     * @param {SourceRange} range The range to remove, first item is start of range, second
     *      is end of range.
     * @returns {Object} The fix command.
     */
    removeRange(range) {
      return {
        range,
        text: ""
      };
    }
  }
  _sourceCode = new WeakMap();
  ruleFixer = { RuleFixer };
  return ruleFixer;
}
var interpolate_1;
var hasRequiredInterpolate;
function requireInterpolate() {
  if (hasRequiredInterpolate) return interpolate_1;
  hasRequiredInterpolate = 1;
  function getPlaceholderMatcher() {
    return /\{\{([^{}]+)\}\}/gu;
  }
  function interpolate(text, data2) {
    if (!data2) {
      return text;
    }
    const matcher2 = getPlaceholderMatcher();
    return text.replace(matcher2, (fullMatch, termWithWhitespace) => {
      const term = termWithWhitespace.trim();
      if (term in data2) {
        return data2[term];
      }
      return fullMatch;
    });
  }
  interpolate_1 = {
    getPlaceholderMatcher,
    interpolate
  };
  return interpolate_1;
}
var fileReport;
var hasRequiredFileReport;
function requireFileReport() {
  var _ruleMapper, _sourceCode, _language, _disableFixes;
  if (hasRequiredFileReport) return fileReport;
  hasRequiredFileReport = 1;
  const assert2 = requireAssert();
  const { RuleFixer } = requireRuleFixer();
  const { interpolate } = requireInterpolate();
  const ruleReplacements = require$$3;
  const DEFAULT_ERROR_LOC = {
    start: { line: 1, column: 0 },
    end: { line: 1, column: 1 }
  };
  function updateLocationInformation({ line, column, endLine, endColumn }, language2) {
    const columnOffset = language2.columnStart === 1 ? 0 : 1;
    const lineOffset = language2.lineStart === 1 ? 0 : 1;
    const finalEndLine = endLine === void 0 ? endLine : endLine + lineOffset;
    const finalEndColumn = endColumn === void 0 ? endColumn : endColumn + columnOffset;
    return {
      line: line + lineOffset,
      column: column + columnOffset,
      endLine: finalEndLine,
      endColumn: finalEndColumn
    };
  }
  function createMissingRuleMessage(ruleId) {
    return Object.hasOwn(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(", ")}` : `Definition for rule '${ruleId}' was not found.`;
  }
  function createLintingProblem(options, severity2, language2) {
    const {
      ruleId = null,
      loc = DEFAULT_ERROR_LOC,
      message = createMissingRuleMessage(options.ruleId)
    } = options;
    return {
      ruleId,
      message,
      ...updateLocationInformation(
        {
          line: loc.start.line,
          column: loc.start.column,
          endLine: loc.end.line,
          endColumn: loc.end.column
        },
        language2
      ),
      severity: severity2,
      nodeType: null
    };
  }
  function normalizeMultiArgReportCall(...args) {
    if (args.length === 1) {
      return Object.assign({}, args[0]);
    }
    if (typeof args[1] === "string") {
      return {
        node: args[0],
        message: args[1],
        data: args[2],
        fix: args[3]
      };
    }
    return {
      node: args[0],
      loc: args[1],
      message: args[2],
      data: args[3],
      fix: args[4]
    };
  }
  function assertValidNodeInfo(descriptor) {
    if (descriptor.node) {
      assert2(typeof descriptor.node === "object", "Node must be an object");
    } else {
      assert2(
        descriptor.loc,
        "Node must be provided when reporting error if location is not provided"
      );
    }
  }
  function normalizeReportLoc(descriptor) {
    if (descriptor.loc.start) {
      return descriptor.loc;
    }
    return { start: descriptor.loc, end: null };
  }
  function cloneFix(fix) {
    if (!fix) {
      return null;
    }
    return {
      range: [fix.range[0], fix.range[1]],
      text: fix.text
    };
  }
  function assertValidFix(fix) {
    if (fix) {
      assert2(
        fix.range && typeof fix.range[0] === "number" && typeof fix.range[1] === "number",
        `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`
      );
    }
  }
  function compareFixesByRange(a2, b) {
    return a2.range[0] - b.range[0] || a2.range[1] - b.range[1];
  }
  function mergeFixes(fixes, sourceCode2) {
    for (const fix of fixes) {
      assertValidFix(fix);
    }
    if (fixes.length === 0) {
      return null;
    }
    if (fixes.length === 1) {
      return cloneFix(fixes[0]);
    }
    fixes.sort(compareFixesByRange);
    const originalText = sourceCode2.text;
    const start = fixes[0].range[0];
    const end = fixes.at(-1).range[1];
    let text = "";
    let lastPos = Number.MIN_SAFE_INTEGER;
    for (const fix of fixes) {
      assert2(
        fix.range[0] >= lastPos,
        "Fix objects must not be overlapped in a report."
      );
      if (fix.range[0] >= 0) {
        text += originalText.slice(
          Math.max(0, start, lastPos),
          fix.range[0]
        );
      }
      text += fix.text;
      lastPos = fix.range[1];
    }
    text += originalText.slice(Math.max(0, start, lastPos), end);
    return { range: [start, end], text };
  }
  function normalizeFixes(descriptor, sourceCode2) {
    if (typeof descriptor.fix !== "function") {
      return null;
    }
    const ruleFixer2 = new RuleFixer({ sourceCode: sourceCode2 });
    const fix = descriptor.fix(ruleFixer2);
    if (fix && Symbol.iterator in fix) {
      return mergeFixes(Array.from(fix), sourceCode2);
    }
    assertValidFix(fix);
    return cloneFix(fix);
  }
  function mapSuggestions(descriptor, sourceCode2, messages) {
    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {
      return [];
    }
    return descriptor.suggest.map((suggestInfo) => {
      const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];
      return {
        ...suggestInfo,
        desc: interpolate(computedDesc, suggestInfo.data),
        fix: normalizeFixes(suggestInfo, sourceCode2)
      };
    }).filter(({ fix }) => fix);
  }
  function createProblem(options) {
    const { language: language2 } = options;
    const columnOffset = language2.columnStart === 1 ? 0 : 1;
    const lineOffset = language2.lineStart === 1 ? 0 : 1;
    const problem = {
      ruleId: options.ruleId,
      severity: options.severity,
      message: options.message,
      line: options.loc.start.line + lineOffset,
      column: options.loc.start.column + columnOffset,
      nodeType: options.node && options.node.type || null
    };
    if (options.messageId) {
      problem.messageId = options.messageId;
    }
    if (options.loc.end) {
      problem.endLine = options.loc.end.line + lineOffset;
      problem.endColumn = options.loc.end.column + columnOffset;
    }
    if (options.fix) {
      problem.fix = options.fix;
    }
    if (options.suggestions && options.suggestions.length > 0) {
      problem.suggestions = options.suggestions;
    }
    return problem;
  }
  function validateSuggestions(suggest, messages) {
    if (suggest && Array.isArray(suggest)) {
      suggest.forEach((suggestion) => {
        if (suggestion.messageId) {
          const { messageId } = suggestion;
          if (!messages) {
            throw new TypeError(
              `context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`
            );
          }
          if (!messages[messageId]) {
            throw new TypeError(
              `context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`
            );
          }
          if (suggestion.desc) {
            throw new TypeError(
              "context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one."
            );
          }
        } else if (!suggestion.desc) {
          throw new TypeError(
            "context.report() called with a suggest option that doesn't have either a `desc` or `messageId`"
          );
        }
        if (typeof suggestion.fix !== "function") {
          throw new TypeError(
            `context.report() called with a suggest option without a fix function. See: ${JSON.stringify(suggestion, null, 2)}`
          );
        }
      });
    }
  }
  function computeMessageFromDescriptor(descriptor, messages) {
    if (descriptor.messageId) {
      if (!messages) {
        throw new TypeError(
          "context.report() called with a messageId, but no messages were present in the rule metadata."
        );
      }
      const id2 = descriptor.messageId;
      if (descriptor.message) {
        throw new TypeError(
          "context.report() called with a message and a messageId. Please only pass one."
        );
      }
      if (!messages || !Object.hasOwn(messages, id2)) {
        throw new TypeError(
          `context.report() called with a messageId of '${id2}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`
        );
      }
      return messages[id2];
    }
    if (descriptor.message) {
      return descriptor.message;
    }
    throw new TypeError(
      "Missing `message` property in report() call; add a message that describes the linting problem."
    );
  }
  class FileReport {
    /**
     * Creates a new FileReport instance.
     * @param {Object} options The options for the file report
     * @param {(string) => RuleDefinition} options.ruleMapper A rule mapper that maps rule IDs to their metadata.
     * @param {SourceCode} options.sourceCode The source code object for the file.
     * @param {Language} options.language The language to use to adjust line and column offsets.
     * @param {boolean} [options.disableFixes=false] Whether to disable fixes for this report.
     */
    constructor({ ruleMapper, sourceCode: sourceCode2, language: language2, disableFixes = false }) {
      /**
       * The messages reported by the linter for this file.
       * @type {LintMessage[]}
       */
      __publicField(this, "messages", []);
      /**
       * A rule mapper that maps rule IDs to their metadata.
       * @type {(string) => RuleDefinition}
       */
      __privateAdd(this, _ruleMapper);
      /**
       * The source code object for the file.
       * @type {SourceCode}
       */
      __privateAdd(this, _sourceCode);
      /**
       * The language to use to adjust line and column offsets.
       * @type {Language}
       */
      __privateAdd(this, _language);
      /**
       * Whether to disable fixes for this report.
       * @type {boolean}
       */
      __privateAdd(this, _disableFixes);
      __privateSet(this, _ruleMapper, ruleMapper);
      __privateSet(this, _sourceCode, sourceCode2);
      __privateSet(this, _language, language2);
      __privateSet(this, _disableFixes, disableFixes);
    }
    /**
     * Adds a rule-generated message to the report.
     * @param {string} ruleId The rule ID that reported the problem.
     * @param {0|1|2} severity The severity of the problem (0 = off, 1 = warning, 2 = error).
     * @param {...*} args The arguments passed to `context.report()`.
     * @returns {LintMessage} The created message object.
     * @throws {TypeError} If the messageId is not found or both message and messageId are provided.
     * @throws {AssertionError} If the node is not an object or neither a node nor a loc is provided.
     */
    addRuleMessage(ruleId, severity2, ...args) {
      var _a2;
      const descriptor = normalizeMultiArgReportCall(...args);
      const ruleDefinition = __privateGet(this, _ruleMapper).call(this, ruleId);
      const messages = (_a2 = ruleDefinition == null ? void 0 : ruleDefinition.meta) == null ? void 0 : _a2.messages;
      assertValidNodeInfo(descriptor);
      const computedMessage = computeMessageFromDescriptor(
        descriptor,
        messages
      );
      validateSuggestions(descriptor.suggest, messages);
      this.messages.push(
        createProblem({
          ruleId,
          severity: severity2,
          node: descriptor.node,
          message: interpolate(computedMessage, descriptor.data),
          messageId: descriptor.messageId,
          loc: descriptor.loc ? normalizeReportLoc(descriptor) : __privateGet(this, _sourceCode).getLoc(descriptor.node),
          fix: __privateGet(this, _disableFixes) ? null : normalizeFixes(descriptor, __privateGet(this, _sourceCode)),
          suggestions: __privateGet(this, _disableFixes) ? [] : mapSuggestions(descriptor, __privateGet(this, _sourceCode), messages),
          language: __privateGet(this, _language)
        })
      );
      return this.messages.at(-1);
    }
    /**
     * Adds an error message to the report. Meant to be called outside of rules.
     * @param {LintProblem} descriptor The descriptor for the error message.
     * @returns {LintMessage} The created message object.
     */
    addError(descriptor) {
      const message = createLintingProblem(descriptor, 2, __privateGet(this, _language));
      this.messages.push(message);
      return message;
    }
    /**
     * Adds a fatal error message to the report. Meant to be called outside of rules.
     * @param {LintProblem} descriptor The descriptor for the fatal error message.
     * @returns {LintMessage} The created message object.
     */
    addFatal(descriptor) {
      const message = createLintingProblem(descriptor, 2, __privateGet(this, _language));
      message.fatal = true;
      this.messages.push(message);
      return message;
    }
    /**
     * Adds a warning message to the report. Meant to be called outside of rules.
     * @param {LintProblem} descriptor The descriptor for the warning message.
     * @returns {LintMessage} The created message object.
     */
    addWarning(descriptor) {
      const message = createLintingProblem(descriptor, 1, __privateGet(this, _language));
      this.messages.push(message);
      return message;
    }
  }
  _ruleMapper = new WeakMap();
  _sourceCode = new WeakMap();
  _language = new WeakMap();
  _disableFixes = new WeakMap();
  fileReport = {
    FileReport,
    updateLocationInformation
  };
  return fileReport;
}
var linter;
var hasRequiredLinter;
function requireLinter() {
  var _Linter_instances, eslintrcVerifyWithoutProcessors_fn, flatVerifyWithoutProcessors_fn;
  if (hasRequiredLinter) return linter;
  hasRequiredLinter = 1;
  const path = require$$0$3, eslintScope2 = requireEslintScope(), evk = requireEslintVisitorKeys$2(), espree2 = requireEspree(), merge = requireLodash_merge(), pkg = require$$5, {
    Legacy: {
      ConfigOps,
      ConfigValidator,
      environments: BuiltInEnvironments
    }
  } = requireEslintrcUniversal(), Traverser = requireTraverser(), { SourceCode } = requireSourceCode(), applyDisableDirectives2 = requireApplyDisableDirectives(), { ConfigCommentParser } = requireCjs$2(), Rules = requireRules(), SourceCodeFixer = requireSourceCodeFixer(), { SourceCodeVisitor } = requireSourceCodeVisitor(), timing2 = requireTiming();
  const { FlatConfigArray } = requireFlatConfigArray();
  const { startTime: startTime2, endTime } = requireStats();
  const { assertIsRuleSeverity } = requireFlatConfigSchema();
  const {
    normalizeSeverityToString,
    normalizeSeverityToNumber
  } = requireSeverity();
  const { deepMergeArrays } = requireDeepMergeArrays();
  const jslang = requireJs();
  const {
    activeFlags,
    inactiveFlags,
    getInactivityReasonMessage
  } = requireFlags();
  const debug = requireSrc()("eslint:linter");
  const MAX_AUTOFIX_PASSES = 10;
  const DEFAULT_PARSER_NAME = "espree";
  const DEFAULT_ECMA_VERSION = 5;
  const commentParser = new ConfigCommentParser();
  const parserSymbol = Symbol.for("eslint.RuleTester.parser");
  const { LATEST_ECMA_VERSION } = requireEcmaVersion();
  const { VFile } = requireVfile();
  const { ParserService } = requireParserService();
  const { FileContext } = requireFileContext();
  const { ProcessorService } = requireProcessorService();
  const { containsDifferentProperty } = requireOptionUtils();
  const { Config } = requireConfig();
  const { WarningService } = requireWarningService();
  const { SourceCodeTraverser } = requireSourceCodeTraverser();
  const { FileReport, updateLocationInformation } = requireFileReport();
  function isEspree(parser2) {
    return !!(parser2 === espree2 || parser2[parserSymbol] === espree2);
  }
  function addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {
    for (const id2 of /* @__PURE__ */ new Set([
      ...Object.keys(configGlobals),
      ...Object.keys(enabledGlobals)
    ])) {
      const configValue = configGlobals[id2] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id2]);
      const commentValue = enabledGlobals[id2] && enabledGlobals[id2].value;
      const value = commentValue || configValue;
      const sourceComments = enabledGlobals[id2] && enabledGlobals[id2].comments;
      if (value === "off") {
        continue;
      }
      let variable = globalScope.set.get(id2);
      if (!variable) {
        variable = new eslintScope2.Variable(id2, globalScope);
        globalScope.variables.push(variable);
        globalScope.set.set(id2, variable);
      }
      variable.eslintImplicitGlobalSetting = configValue;
      variable.eslintExplicitGlobal = sourceComments !== void 0;
      variable.eslintExplicitGlobalComments = sourceComments;
      variable.writeable = value === "writable";
    }
    Object.keys(exportedVariables).forEach((name2) => {
      const variable = globalScope.set.get(name2);
      if (variable) {
        variable.eslintUsed = true;
        variable.eslintExported = true;
      }
    });
    globalScope.through = globalScope.through.filter((reference) => {
      const name2 = reference.identifier.name;
      const variable = globalScope.set.get(name2);
      if (variable) {
        reference.resolved = variable;
        variable.references.push(reference);
        return false;
      }
      return true;
    });
  }
  function asArray2(value) {
    return Array.isArray(value) ? value : [value];
  }
  function addProblemIfSameSeverityAndOptions(config2, loc, report, ruleId, ruleOptions, ruleOptionsInline, severity2) {
    var _a2;
    const existingConfigRaw = (_a2 = config2.rules) == null ? void 0 : _a2[ruleId];
    const existingConfig = existingConfigRaw ? asArray2(existingConfigRaw) : ["off"];
    const existingSeverity = normalizeSeverityToString(existingConfig[0]);
    const inlineSeverity = normalizeSeverityToString(ruleOptions[0]);
    const sameSeverity = existingSeverity === inlineSeverity;
    if (!sameSeverity) {
      return;
    }
    const alreadyConfigured = existingConfigRaw ? `is already configured to '${existingSeverity}'` : "is not enabled so can't be turned off";
    let message;
    if (existingConfig.length === 1 && ruleOptions.length === 1 || existingSeverity === "off") {
      message = `Unused inline config ('${ruleId}' ${alreadyConfigured}).`;
    } else if (!containsDifferentProperty(
      ruleOptions.slice(1),
      existingConfig.slice(1)
    )) {
      message = ruleOptionsInline.length === 1 ? `Unused inline config ('${ruleId}' ${alreadyConfigured}).` : `Unused inline config ('${ruleId}' ${alreadyConfigured} with the same options).`;
    }
    if (message) {
      const numericSeverity = normalizeSeverityToNumber(severity2);
      const descriptor = {
        message,
        loc
      };
      if (numericSeverity === 1) {
        report.addWarning(descriptor);
      } else if (numericSeverity === 2) {
        report.addError(descriptor);
      }
    }
  }
  function createDisableDirectives({ type: type2, value, justification, node: node2 }, ruleMapper, language2, sourceCode2, report) {
    const ruleIds = Object.keys(commentParser.parseListConfig(value));
    const directiveRules = ruleIds.length ? ruleIds : [null];
    const directives2 = [];
    const parentDirective = { node: node2, value, ruleIds };
    for (const ruleId of directiveRules) {
      const loc = sourceCode2.getLoc(node2);
      if (ruleId === null || !!ruleMapper(ruleId)) {
        if (type2 === "disable-next-line") {
          const { line, column } = updateLocationInformation(
            loc.end,
            language2
          );
          directives2.push({
            parentDirective,
            type: type2,
            line,
            column,
            ruleId,
            justification
          });
        } else {
          const { line, column } = updateLocationInformation(
            loc.start,
            language2
          );
          directives2.push({
            parentDirective,
            type: type2,
            line,
            column,
            ruleId,
            justification
          });
        }
      } else {
        report.addError({ ruleId, loc });
      }
    }
    return directives2;
  }
  function getDirectiveComments(sourceCode2, ruleMapper, warnInlineConfig, config2, report) {
    const configuredRules = {};
    const enabledGlobals = /* @__PURE__ */ Object.create(null);
    const exportedVariables = {};
    const disableDirectives = [];
    const validator = new ConfigValidator({
      builtInRules: Rules
    });
    sourceCode2.getInlineConfigNodes().filter((token) => token.type !== "Shebang").forEach((comment2) => {
      const directive = commentParser.parseDirective(comment2.value);
      if (!directive) {
        return;
      }
      const {
        label,
        value,
        justification: justificationPart
      } = directive;
      const lineCommentSupported = /^eslint-disable-(?:next-)?line$/u.test(label);
      if (comment2.type === "Line" && !lineCommentSupported) {
        return;
      }
      const loc = sourceCode2.getLoc(comment2);
      if (warnInlineConfig) {
        const kind = comment2.type === "Block" ? `/*${label}*/` : `//${label}`;
        report.addWarning({
          ruleId: null,
          message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,
          loc
        });
        return;
      }
      if (label === "eslint-disable-line" && loc.start.line !== loc.end.line) {
        const message = `${label} comment should not span multiple lines.`;
        report.addError({
          message,
          loc
        });
        return;
      }
      switch (label) {
        case "eslint-disable":
        case "eslint-enable":
        case "eslint-disable-next-line":
        case "eslint-disable-line": {
          const directiveType = label.slice("eslint-".length);
          const directives2 = createDisableDirectives(
            {
              type: directiveType,
              value,
              justification: justificationPart,
              node: comment2
            },
            ruleMapper,
            jslang,
            sourceCode2,
            report
          );
          disableDirectives.push(...directives2);
          break;
        }
        case "exported":
          Object.assign(
            exportedVariables,
            commentParser.parseListConfig(value)
          );
          break;
        case "globals":
        case "global":
          for (const [id2, idSetting] of Object.entries(
            commentParser.parseStringConfig(value)
          )) {
            let normalizedValue;
            try {
              normalizedValue = ConfigOps.normalizeConfigGlobal(idSetting);
            } catch (err) {
              report.addError({
                loc,
                message: err.message
              });
              continue;
            }
            if (enabledGlobals[id2]) {
              enabledGlobals[id2].comments.push(comment2);
              enabledGlobals[id2].value = normalizedValue;
            } else {
              enabledGlobals[id2] = {
                comments: [comment2],
                value: normalizedValue
              };
            }
          }
          break;
        case "eslint": {
          const parseResult = commentParser.parseJSONLikeConfig(value);
          if (parseResult.ok) {
            Object.keys(parseResult.config).forEach((name2) => {
              const rule = ruleMapper(name2);
              const ruleValue = parseResult.config[name2];
              if (!rule) {
                report.addError({ ruleId: name2, loc });
                return;
              }
              if (Object.hasOwn(configuredRules, name2)) {
                report.addError({
                  message: `Rule "${name2}" is already configured by another configuration comment in the preceding code. This configuration is ignored.`,
                  loc
                });
                return;
              }
              let ruleOptions = asArray2(ruleValue);
              if (
                /*
                 * If inline config for the rule has only severity
                 */
                ruleOptions.length === 1 && /*
                 * And the rule was already configured
                 */
                config2.rules && Object.hasOwn(config2.rules, name2)
              ) {
                ruleOptions = [
                  ruleOptions[0],
                  // severity from the inline config
                  ...asArray2(config2.rules[name2]).slice(1)
                  // options from the provided config
                ];
              }
              try {
                validator.validateRuleOptions(
                  rule,
                  name2,
                  ruleOptions
                );
              } catch (err) {
                if (err.code === "ESLINT_INVALID_RULE_OPTIONS_SCHEMA") {
                  throw err;
                }
                report.addError({
                  ruleId: name2,
                  message: err.message,
                  loc
                });
                return;
              }
              configuredRules[name2] = ruleOptions;
            });
          } else {
            report.addFatal({
              loc,
              message: parseResult.error.message
            });
          }
          break;
        }
      }
    });
    return {
      configuredRules,
      enabledGlobals,
      exportedVariables,
      disableDirectives
    };
  }
  function getDirectiveCommentsForFlatConfig(sourceCode2, ruleMapper, language2, report) {
    const disableDirectives = [];
    if (sourceCode2.getDisableDirectives) {
      const { directives: directivesSources, problems: directivesProblems } = sourceCode2.getDisableDirectives();
      if (Array.isArray(directivesProblems)) {
        directivesProblems.forEach((problem) => report.addError(problem));
      }
      directivesSources.forEach((directive) => {
        const directives2 = createDisableDirectives(
          directive,
          ruleMapper,
          language2,
          sourceCode2,
          report
        );
        disableDirectives.push(...directives2);
      });
    }
    return disableDirectives;
  }
  function normalizeEcmaVersion(parser2, ecmaVersion2) {
    if (isEspree(parser2)) {
      if (ecmaVersion2 === "latest") {
        return espree2.latestEcmaVersion;
      }
    }
    return ecmaVersion2 >= 2015 ? ecmaVersion2 - 2009 : ecmaVersion2;
  }
  function normalizeEcmaVersionForLanguageOptions(ecmaVersion2) {
    switch (ecmaVersion2) {
      case 3:
        return 3;
      case 5:
      case void 0:
        return 5;
      default:
        if (typeof ecmaVersion2 === "number") {
          return ecmaVersion2 >= 2015 ? ecmaVersion2 : ecmaVersion2 + 2009;
        }
    }
    return LATEST_ECMA_VERSION;
  }
  const eslintEnvPattern = /\/\*\s*eslint-env\s.+?(?:\*\/|$)/gsu;
  function findEslintEnv(text) {
    let match, retv;
    eslintEnvPattern.lastIndex = 0;
    while ((match = eslintEnvPattern.exec(text)) !== null) {
      if (match[0].endsWith("*/")) {
        retv = Object.assign(
          retv || {},
          commentParser.parseListConfig(
            commentParser.parseDirective(match[0].slice(2, -2)).value
          )
        );
      }
    }
    return retv;
  }
  function normalizeFilename(filename) {
    const parts = filename.split(path.sep);
    const index = parts.lastIndexOf("<text>");
    return index === -1 ? filename : parts.slice(index).join(path.sep);
  }
  function normalizeVerifyOptions(providedOptions, config2) {
    const linterOptions = config2.linterOptions || config2;
    const disableInlineConfig = linterOptions.noInlineConfig === true;
    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;
    const configNameOfNoInlineConfig = config2.configNameOfNoInlineConfig ? ` (${config2.configNameOfNoInlineConfig})` : "";
    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;
    if (typeof reportUnusedDisableDirectives === "boolean") {
      reportUnusedDisableDirectives = reportUnusedDisableDirectives ? "error" : "off";
    }
    if (typeof reportUnusedDisableDirectives !== "string") {
      if (typeof linterOptions.reportUnusedDisableDirectives === "boolean") {
        reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives ? "warn" : "off";
      } else {
        reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives === void 0 ? "off" : normalizeSeverityToString(
          linterOptions.reportUnusedDisableDirectives
        );
      }
    }
    const reportUnusedInlineConfigs = linterOptions.reportUnusedInlineConfigs === void 0 ? "off" : normalizeSeverityToString(
      linterOptions.reportUnusedInlineConfigs
    );
    let ruleFilter = providedOptions.ruleFilter;
    if (typeof ruleFilter !== "function") {
      ruleFilter = () => true;
    }
    return {
      filename: normalizeFilename(providedOptions.filename || "<input>"),
      allowInlineConfig: !ignoreInlineConfig,
      warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,
      reportUnusedDisableDirectives,
      reportUnusedInlineConfigs,
      disableFixes: Boolean(providedOptions.disableFixes),
      stats: providedOptions.stats,
      ruleFilter
    };
  }
  function resolveParserOptions(parser2, providedOptions, enabledEnvironments) {
    const parserOptionsFromEnv = enabledEnvironments.filter((env2) => env2.parserOptions).reduce(
      (parserOptions, env2) => merge(parserOptions, env2.parserOptions),
      {}
    );
    const mergedParserOptions = merge(
      parserOptionsFromEnv,
      providedOptions || {}
    );
    const isModule = mergedParserOptions.sourceType === "module";
    if (isModule) {
      mergedParserOptions.ecmaFeatures = Object.assign(
        {},
        mergedParserOptions.ecmaFeatures,
        { globalReturn: false }
      );
    }
    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(
      parser2,
      mergedParserOptions.ecmaVersion
    );
    return mergedParserOptions;
  }
  function createLanguageOptions({
    globals: configuredGlobals,
    parser: parser2,
    parserOptions
  }) {
    const { ecmaVersion: ecmaVersion2, sourceType } = parserOptions;
    return {
      globals: configuredGlobals,
      ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion2),
      sourceType,
      parser: parser2,
      parserOptions
    };
  }
  function resolveGlobals(providedGlobals, enabledEnvironments) {
    return Object.assign(
      /* @__PURE__ */ Object.create(null),
      ...enabledEnvironments.filter((env2) => env2.globals).map((env2) => env2.globals),
      providedGlobals
    );
  }
  function storeTime(time, timeOpts, slots) {
    var _a2, _b, _c;
    const { type: type2, key } = timeOpts;
    if (!slots.times) {
      slots.times = { passes: [{}] };
    }
    const passIndex = slots.fixPasses;
    if (passIndex > slots.times.passes.length - 1) {
      slots.times.passes.push({});
    }
    if (key) {
      (_a2 = slots.times.passes[passIndex])[type2] ?? (_a2[type2] = {});
      (_b = slots.times.passes[passIndex][type2])[key] ?? (_b[key] = { total: 0 });
      slots.times.passes[passIndex][type2][key].total += time;
    } else {
      (_c = slots.times.passes[passIndex])[type2] ?? (_c[type2] = { total: 0 });
      slots.times.passes[passIndex][type2].total += time;
    }
  }
  function getRuleOptions(ruleConfig, defaultOptions) {
    if (Array.isArray(ruleConfig)) {
      return deepMergeArrays(defaultOptions, ruleConfig.slice(1));
    }
    return defaultOptions ?? [];
  }
  function analyzeScope(ast2, languageOptions, visitorKeys) {
    const parserOptions = languageOptions.parserOptions;
    const ecmaFeatures = parserOptions.ecmaFeatures || {};
    const ecmaVersion2 = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;
    return eslintScope2.analyze(ast2, {
      ignoreEval: true,
      nodejsScope: ecmaFeatures.globalReturn,
      impliedStrict: ecmaFeatures.impliedStrict,
      ecmaVersion: typeof ecmaVersion2 === "number" ? ecmaVersion2 : 6,
      sourceType: languageOptions.sourceType || "script",
      childVisitorKeys: evk.KEYS,
      fallback: Traverser.getKeys
    });
  }
  function createRuleListeners(rule, ruleContext) {
    if (!rule || typeof rule !== "object" || typeof rule.create !== "function") {
      throw new TypeError(
        `Error while loading rule '${ruleContext.id}': Rule must be an object with a \`create\` method`
      );
    }
    try {
      return rule.create(ruleContext);
    } catch (ex) {
      ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;
      throw ex;
    }
  }
  function runRules(sourceCode2, configuredRules, ruleMapper, parserName, language2, languageOptions, settings, filename, applyDefaultOptions, cwd2, physicalFilename, ruleFilter, stats2, slots, report) {
    const visitor = new SourceCodeVisitor();
    const fileContext2 = new FileContext({
      cwd: cwd2,
      filename,
      physicalFilename: physicalFilename || filename,
      sourceCode: sourceCode2,
      parserOptions: {
        ...languageOptions.parserOptions
      },
      parserPath: parserName,
      languageOptions,
      settings
    });
    const steps = sourceCode2.traverse();
    Object.keys(configuredRules).forEach((ruleId) => {
      var _a2;
      const severity2 = Config.getRuleNumericSeverity(configuredRules[ruleId]);
      if (severity2 === 0) {
        return;
      }
      if (ruleFilter && !ruleFilter({ ruleId, severity: severity2 })) {
        return;
      }
      const rule = ruleMapper(ruleId);
      if (!rule) {
        report.addError({ ruleId });
        return;
      }
      const ruleContext = fileContext2.extend({
        id: ruleId,
        options: getRuleOptions(
          configuredRules[ruleId],
          applyDefaultOptions ? (_a2 = rule.meta) == null ? void 0 : _a2.defaultOptions : void 0
        ),
        report(...args) {
          const problem = report.addRuleMessage(
            ruleId,
            severity2,
            ...args
          );
          if (problem.fix && !(rule.meta && rule.meta.fixable)) {
            throw new Error(
              'Fixable rules must set the `meta.fixable` property to "code" or "whitespace".'
            );
          }
          if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {
            if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== "undefined") {
              throw new Error(
                "Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint."
              );
            }
            throw new Error(
              "Rules with suggestions must set the `meta.hasSuggestions` property to `true`."
            );
          }
        }
      });
      const ruleListenersReturn = timing2.enabled || stats2 ? timing2.time(
        ruleId,
        createRuleListeners,
        stats2
      )(rule, ruleContext) : createRuleListeners(rule, ruleContext);
      const ruleListeners = stats2 ? ruleListenersReturn.result : ruleListenersReturn;
      if (stats2) {
        storeTime(
          ruleListenersReturn.tdiff,
          { type: "rules", key: ruleId },
          slots
        );
      }
      function addRuleErrorHandler(ruleListener) {
        return function ruleErrorHandler(...listenerArgs) {
          try {
            const ruleListenerReturn = ruleListener(...listenerArgs);
            const ruleListenerResult = stats2 ? ruleListenerReturn.result : ruleListenerReturn;
            if (stats2) {
              storeTime(
                ruleListenerReturn.tdiff,
                { type: "rules", key: ruleId },
                slots
              );
            }
            return ruleListenerResult;
          } catch (e2) {
            e2.ruleId = ruleId;
            throw e2;
          }
        };
      }
      if (typeof ruleListeners === "undefined" || ruleListeners === null) {
        throw new Error(
          `The create() function for rule '${ruleId}' did not return an object.`
        );
      }
      Object.keys(ruleListeners).forEach((selector) => {
        const ruleListener = timing2.enabled || stats2 ? timing2.time(ruleId, ruleListeners[selector], stats2) : ruleListeners[selector];
        visitor.add(selector, addRuleErrorHandler(ruleListener));
      });
    });
    const traverser2 = SourceCodeTraverser.getInstance(language2);
    traverser2.traverseSync(sourceCode2, visitor, { steps });
    return report;
  }
  function ensureText(textOrSourceCode) {
    if (typeof textOrSourceCode === "object") {
      const { hasBOM, text } = textOrSourceCode;
      const bom = hasBOM ? "\uFEFF" : "";
      return bom + text;
    }
    return String(textOrSourceCode);
  }
  function getEnv(slots, envId) {
    return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;
  }
  function getRule(slots, ruleId) {
    return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);
  }
  function normalizeCwd(cwd2) {
    if (cwd2) {
      return cwd2;
    }
    if (typeof browser$1$1 === "object") {
      return browser$1$1.cwd();
    }
    return void 0;
  }
  const internalSlotsMap = /* @__PURE__ */ new WeakMap();
  function assertEslintrcConfig(linter2) {
    const { configType } = internalSlotsMap.get(linter2);
    if (configType === "flat") {
      throw new Error(
        "This method cannot be used with flat config. Add your entries directly into the config array."
      );
    }
  }
  class Linter2 {
    /**
     * Initialize the Linter.
     * @param {Object} [config] the config object
     * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.
     * @param {Array<string>} [config.flags] the feature flags to enable.
     * @param {"flat"|"eslintrc"} [config.configType="flat"] the type of config used.
     * @param {WarningService} [config.warningService] The warning service to use.
     */
    constructor({
      cwd: cwd2,
      configType = "flat",
      flags: flags2 = [],
      warningService: warningService2 = new WarningService()
    } = {}) {
      __privateAdd(this, _Linter_instances);
      const processedFlags = [];
      flags2.forEach((flag) => {
        if (inactiveFlags.has(flag)) {
          const inactiveFlagData = inactiveFlags.get(flag);
          const inactivityReason = getInactivityReasonMessage(inactiveFlagData);
          const message = `The flag '${flag}' is inactive: ${inactivityReason}`;
          if (typeof inactiveFlagData.replacedBy === "undefined") {
            throw new Error(message);
          }
          if (typeof inactiveFlagData.replacedBy === "string") {
            processedFlags.push(inactiveFlagData.replacedBy);
          }
          warningService2.emitInactiveFlagWarning(flag, message);
          return;
        }
        if (!activeFlags.has(flag)) {
          throw new Error(`Unknown flag '${flag}'.`);
        }
        processedFlags.push(flag);
      });
      internalSlotsMap.set(this, {
        cwd: normalizeCwd(cwd2),
        flags: processedFlags,
        lastConfigArray: null,
        lastSourceCode: null,
        lastSuppressedMessages: [],
        configType,
        // TODO: Remove after flat config conversion
        parserMap: /* @__PURE__ */ new Map([["espree", espree2]]),
        ruleMap: new Rules(),
        warningService: warningService2
      });
      this.version = pkg.version;
    }
    /**
     * Getter for package version.
     * @static
     * @returns {string} The version from package.json.
     */
    static get version() {
      return pkg.version;
    }
    /**
     * Indicates if the given feature flag is enabled for this instance.
     * @param {string} flag The feature flag to check.
     * @returns {boolean} `true` if the feature flag is enabled, `false` if not.
     */
    hasFlag(flag) {
      return internalSlotsMap.get(this).flags.includes(flag);
    }
    /**
     * Same as linter.verify, except without support for processors.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.
     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
     * @throws {Error} If during rule execution.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
     */
    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
      const slots = internalSlotsMap.get(this);
      const filename = normalizeFilename(
        providedOptions.filename || "<input>"
      );
      let text;
      if (typeof textOrSourceCode === "string") {
        slots.lastSourceCode = null;
        text = textOrSourceCode;
      } else {
        slots.lastSourceCode = textOrSourceCode;
        text = textOrSourceCode.text;
      }
      const file = new VFile(filename, text, {
        physicalPath: providedOptions.physicalFilename
      });
      return __privateMethod(this, _Linter_instances, eslintrcVerifyWithoutProcessors_fn).call(this, file, providedConfig, providedOptions);
    }
    /**
     * Verifies the text against the rules specified by the second argument.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.
     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.
     *      If this is not set, the filename will default to '<input>' in the rule context. If
     *      an object, then it has "filename", "allowInlineConfig", and some properties.
     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.
     */
    verify(textOrSourceCode, config2, filenameOrOptions) {
      debug("Verify");
      const { configType, cwd: cwd2 } = internalSlotsMap.get(this);
      const options = typeof filenameOrOptions === "string" ? { filename: filenameOrOptions } : filenameOrOptions || {};
      const configToUse = config2 ?? {};
      if (configType !== "eslintrc") {
        let configArray = configToUse;
        if (!Array.isArray(configToUse) || typeof configToUse.getConfig !== "function") {
          configArray = new FlatConfigArray(configToUse, {
            basePath: cwd2
          });
          configArray.normalizeSync();
        }
        return this._distinguishSuppressedMessages(
          this._verifyWithFlatConfigArray(
            textOrSourceCode,
            configArray,
            options,
            true
          )
        );
      }
      if (typeof configToUse.extractConfig === "function") {
        return this._distinguishSuppressedMessages(
          this._verifyWithConfigArray(
            textOrSourceCode,
            configToUse,
            options
          )
        );
      }
      if (options.preprocess || options.postprocess) {
        return this._distinguishSuppressedMessages(
          this._verifyWithProcessor(
            textOrSourceCode,
            configToUse,
            options
          )
        );
      }
      return this._distinguishSuppressedMessages(
        this._verifyWithoutProcessors(
          textOrSourceCode,
          configToUse,
          options
        )
      );
    }
    /**
     * Verify with a processor.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {Config} config The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config2, options, configForRecursive) {
      const slots = internalSlotsMap.get(this);
      const filename = options.filename || "<input>";
      const filenameToExpose = normalizeFilename(filename);
      const physicalFilename = options.physicalFilename || filenameToExpose;
      const text = ensureText(textOrSourceCode);
      const file = new VFile(filenameToExpose, text, {
        physicalPath: physicalFilename
      });
      const preprocess = options.preprocess || ((rawText) => [rawText]);
      const postprocess = options.postprocess || ((messagesList) => messagesList.flat());
      const processorService2 = new ProcessorService();
      const preprocessResult = processorService2.preprocessSync(file, {
        processor: {
          preprocess,
          postprocess
        }
      });
      if (!preprocessResult.ok) {
        return preprocessResult.errors;
      }
      const filterCodeBlock = options.filterCodeBlock || ((blockFilename) => blockFilename.endsWith(".js"));
      const originalExtname = path.extname(filename);
      const { files } = preprocessResult;
      const messageLists = files.map((block) => {
        debug("A code block was found: %o", block.path || "(unnamed)");
        if (typeof block === "string") {
          return this._verifyWithFlatConfigArrayAndWithoutProcessors(
            block,
            config2,
            options
          );
        }
        if (!filterCodeBlock(block.path, block.body)) {
          debug("This code block was skipped.");
          return [];
        }
        if (configForRecursive && (text !== block.rawBody || path.extname(block.path) !== originalExtname)) {
          debug(
            "Resolving configuration again because the file content or extension was changed."
          );
          return this._verifyWithFlatConfigArray(
            block.rawBody,
            configForRecursive,
            {
              ...options,
              filename: block.path,
              physicalFilename: block.physicalPath
            }
          );
        }
        slots.lastSourceCode = null;
        return __privateMethod(this, _Linter_instances, flatVerifyWithoutProcessors_fn).call(this, block, config2, {
          ...options,
          filename: block.path,
          physicalFilename: block.physicalPath
        });
      });
      return processorService2.postprocessSync(file, messageLists, {
        processor: {
          preprocess,
          postprocess
        }
      });
    }
    /**
     * Same as linter.verify, except without support for processors.
     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
     * @param {Config} providedConfig An ESLintConfig instance to configure everything.
     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
     * @throws {Error} If during rule execution.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
     */
    _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
      const slots = internalSlotsMap.get(this);
      const filename = normalizeFilename(
        providedOptions.filename || "<input>"
      );
      let text;
      if (typeof textOrSourceCode === "string") {
        slots.lastSourceCode = null;
        text = textOrSourceCode;
      } else {
        slots.lastSourceCode = textOrSourceCode;
        text = textOrSourceCode.text;
      }
      const file = new VFile(filename, text, {
        physicalPath: providedOptions.physicalFilename
      });
      return __privateMethod(this, _Linter_instances, flatVerifyWithoutProcessors_fn).call(this, file, providedConfig, providedOptions);
    }
    /**
     * Verify a given code with `ConfigArray`.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {ConfigArray} configArray The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithConfigArray(textOrSourceCode, configArray, options) {
      debug("With ConfigArray: %s", options.filename);
      internalSlotsMap.get(this).lastConfigArray = configArray;
      const config2 = configArray.extractConfig(options.filename);
      const processor = config2.processor && configArray.pluginProcessors.get(config2.processor);
      if (processor) {
        debug("Apply the processor: %o", config2.processor);
        const { preprocess, postprocess, supportsAutofix } = processor;
        const disableFixes = options.disableFixes || !supportsAutofix;
        return this._verifyWithProcessor(
          textOrSourceCode,
          config2,
          { ...options, disableFixes, postprocess, preprocess },
          configArray
        );
      }
      return this._verifyWithoutProcessors(textOrSourceCode, config2, options);
    }
    /**
     * Verify a given code with a flat config.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {FlatConfigArray} configArray The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {boolean} [firstCall=false] Indicates if this is being called directly
     *      from verify(). (TODO: Remove once eslintrc is removed.)
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithFlatConfigArray(textOrSourceCode, configArray, options, firstCall = false) {
      debug("With flat config: %s", options.filename);
      const filename = options.filename || "__placeholder__.js";
      internalSlotsMap.get(this).lastConfigArray = configArray;
      const config2 = configArray.getConfig(filename);
      if (!config2) {
        return [
          {
            ruleId: null,
            severity: 1,
            message: `No matching configuration found for ${filename}.`,
            line: 0,
            column: 0,
            nodeType: null
          }
        ];
      }
      if (config2.processor) {
        debug("Apply the processor: %o", config2.processor);
        const { preprocess, postprocess, supportsAutofix } = config2.processor;
        const disableFixes = options.disableFixes || !supportsAutofix;
        return this._verifyWithFlatConfigArrayAndProcessor(
          textOrSourceCode,
          config2,
          { ...options, filename, disableFixes, postprocess, preprocess },
          configArray
        );
      }
      if (firstCall && (options.preprocess || options.postprocess)) {
        return this._verifyWithFlatConfigArrayAndProcessor(
          textOrSourceCode,
          config2,
          options
        );
      }
      return this._verifyWithFlatConfigArrayAndWithoutProcessors(
        textOrSourceCode,
        config2,
        options
      );
    }
    /**
     * Verify with a processor.
     * @param {string|SourceCode} textOrSourceCode The source code.
     * @param {ConfigData|ExtractedConfig} config The config array.
     * @param {VerifyOptions&ProcessorOptions} options The options.
     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
     */
    _verifyWithProcessor(textOrSourceCode, config2, options, configForRecursive) {
      const slots = internalSlotsMap.get(this);
      const filename = options.filename || "<input>";
      const filenameToExpose = normalizeFilename(filename);
      const physicalFilename = options.physicalFilename || filenameToExpose;
      const text = ensureText(textOrSourceCode);
      const file = new VFile(filenameToExpose, text, {
        physicalPath: physicalFilename
      });
      const preprocess = options.preprocess || ((rawText) => [rawText]);
      const postprocess = options.postprocess || ((messagesList) => messagesList.flat());
      const processorService2 = new ProcessorService();
      const preprocessResult = processorService2.preprocessSync(file, {
        processor: {
          preprocess,
          postprocess
        }
      });
      if (!preprocessResult.ok) {
        return preprocessResult.errors;
      }
      const filterCodeBlock = options.filterCodeBlock || ((blockFilePath) => blockFilePath.endsWith(".js"));
      const originalExtname = path.extname(filename);
      const { files } = preprocessResult;
      const messageLists = files.map((block) => {
        debug("A code block was found: %o", block.path ?? "(unnamed)");
        if (typeof block === "string") {
          return this._verifyWithoutProcessors(block, config2, options);
        }
        if (!filterCodeBlock(block.path, block.body)) {
          debug("This code block was skipped.");
          return [];
        }
        if (configForRecursive && (text !== block.rawBody || path.extname(block.path) !== originalExtname)) {
          debug(
            "Resolving configuration again because the file content or extension was changed."
          );
          return this._verifyWithConfigArray(
            block.rawBody,
            configForRecursive,
            {
              ...options,
              filename: block.path,
              physicalFilename: block.physicalPath
            }
          );
        }
        slots.lastSourceCode = null;
        return __privateMethod(this, _Linter_instances, eslintrcVerifyWithoutProcessors_fn).call(this, block, config2, {
          ...options,
          filename: block.path,
          physicalFilename: block.physicalPath
        });
      });
      return processorService2.postprocessSync(file, messageLists, {
        processor: {
          preprocess,
          postprocess
        }
      });
    }
    /**
     * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.
     * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.
     * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.
     * @returns {LintMessage[]} A list of LintMessage.
     */
    _distinguishSuppressedMessages(problems) {
      const messages = [];
      const suppressedMessages = [];
      const slots = internalSlotsMap.get(this);
      for (const problem of problems) {
        if (problem.suppressions) {
          suppressedMessages.push(problem);
        } else {
          messages.push(problem);
        }
      }
      slots.lastSuppressedMessages = suppressedMessages;
      return messages;
    }
    /**
     * Gets the SourceCode object representing the parsed source.
     * @returns {SourceCode} The SourceCode object.
     */
    getSourceCode() {
      return internalSlotsMap.get(this).lastSourceCode;
    }
    /**
     * Gets the times spent on (parsing, fixing, linting) a file.
     * @returns {{ passes: TimePass[]; }} The times.
     */
    getTimes() {
      return internalSlotsMap.get(this).times ?? { passes: [] };
    }
    /**
     * Gets the number of autofix passes that were made in the last run.
     * @returns {number} The number of autofix passes.
     */
    getFixPassCount() {
      return internalSlotsMap.get(this).fixPasses ?? 0;
    }
    /**
     * Gets the list of SuppressedLintMessage produced in the last running.
     * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage
     */
    getSuppressedMessages() {
      return internalSlotsMap.get(this).lastSuppressedMessages;
    }
    /**
     * Defines a new linting rule.
     * @param {string} ruleId A unique rule identifier
     * @param {Rule} rule A rule object
     * @returns {void}
     */
    defineRule(ruleId, rule) {
      assertEslintrcConfig(this);
      internalSlotsMap.get(this).ruleMap.define(ruleId, rule);
    }
    /**
     * Defines many new linting rules.
     * @param {Record<string, Rule>} rulesToDefine map from unique rule identifier to rule
     * @returns {void}
     */
    defineRules(rulesToDefine) {
      assertEslintrcConfig(this);
      Object.getOwnPropertyNames(rulesToDefine).forEach((ruleId) => {
        this.defineRule(ruleId, rulesToDefine[ruleId]);
      });
    }
    /**
     * Gets an object with all loaded rules.
     * @returns {Map<string, Rule>} All loaded rules
     */
    getRules() {
      assertEslintrcConfig(this);
      const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);
      return new Map(
        function* () {
          yield* ruleMap;
          if (lastConfigArray) {
            yield* lastConfigArray.pluginRules;
          }
        }()
      );
    }
    /**
     * Define a new parser module
     * @param {string} parserId Name of the parser
     * @param {Parser} parserModule The parser object
     * @returns {void}
     */
    defineParser(parserId, parserModule) {
      assertEslintrcConfig(this);
      internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
    }
    /**
     * Performs multiple autofix passes over the text until as many fixes as possible
     * have been applied.
     * @param {string} text The source text to apply fixes to.
     * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.
     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.
     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the
     *      SourceCodeFixer.
     */
    verifyAndFix(text, config2, options) {
      let messages, fixedResult, fixed = false, passNumber = 0, currentText = text, secondPreviousText, previousText;
      const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;
      const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
      const stats2 = options == null ? void 0 : options.stats;
      const slots = internalSlotsMap.get(this);
      if (stats2) {
        delete slots.times;
        slots.fixPasses = 0;
      }
      do {
        passNumber++;
        let tTotal;
        if (stats2) {
          tTotal = startTime2();
        }
        debug(
          `Linting code for ${debugTextDescription} (pass ${passNumber})`
        );
        messages = this.verify(currentText, config2, options);
        debug(
          `Generating fixed text for ${debugTextDescription} (pass ${passNumber})`
        );
        let t2;
        if (stats2) {
          t2 = startTime2();
        }
        fixedResult = SourceCodeFixer.applyFixes(
          currentText,
          messages,
          shouldFix
        );
        if (stats2) {
          if (fixedResult.fixed) {
            const time = endTime(t2);
            storeTime(time, { type: "fix" }, slots);
            slots.fixPasses++;
          } else {
            storeTime(0, { type: "fix" }, slots);
          }
        }
        if (messages.length === 1 && messages[0].fatal) {
          break;
        }
        fixed = fixed || fixedResult.fixed;
        secondPreviousText = previousText;
        previousText = currentText;
        currentText = fixedResult.output;
        if (stats2) {
          tTotal = endTime(tTotal);
          const passIndex = slots.times.passes.length - 1;
          slots.times.passes[passIndex].total = tTotal;
        }
        if (passNumber > 1 && currentText.length === secondPreviousText.length && currentText === secondPreviousText) {
          debug(
            `Circular fixes detected after pass ${passNumber}. Exiting fix loop.`
          );
          slots.warningService.emitCircularFixesWarning(
            (options == null ? void 0 : options.filename) ?? "text"
          );
          break;
        }
      } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);
      if (fixedResult.fixed) {
        let tTotal;
        if (stats2) {
          tTotal = startTime2();
        }
        fixedResult.messages = this.verify(currentText, config2, options);
        if (stats2) {
          storeTime(0, { type: "fix" }, slots);
          slots.times.passes.at(-1).total = endTime(tTotal);
        }
      }
      fixedResult.fixed = fixed;
      fixedResult.output = currentText;
      return fixedResult;
    }
  }
  _Linter_instances = new WeakSet();
  /**
   * Lint using eslintrc and without processors.
   * @param {VFile} file The file to lint.
   * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.
   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
   * @throws {Error} If during rule execution.
   * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
   */
  eslintrcVerifyWithoutProcessors_fn = function(file, providedConfig, providedOptions) {
    const slots = internalSlotsMap.get(this);
    const config2 = providedConfig || {};
    const options = normalizeVerifyOptions(providedOptions, config2);
    let parserName = DEFAULT_PARSER_NAME;
    let parser2 = espree2;
    if (typeof config2.parser === "object" && config2.parser !== null) {
      parserName = config2.parser.filePath;
      parser2 = config2.parser.definition;
    } else if (typeof config2.parser === "string") {
      if (!slots.parserMap.has(config2.parser)) {
        return [
          {
            ruleId: null,
            fatal: true,
            severity: 2,
            message: `Configured parser '${config2.parser}' was not found.`,
            line: 0,
            column: 0,
            nodeType: null
          }
        ];
      }
      parserName = config2.parser;
      parser2 = slots.parserMap.get(config2.parser);
    }
    const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(file.body) : {};
    const resolvedEnvConfig = Object.assign(
      { builtin: true },
      config2.env,
      envInFile
    );
    const enabledEnvs = Object.keys(resolvedEnvConfig).filter((envName) => resolvedEnvConfig[envName]).map((envName) => getEnv(slots, envName)).filter((env2) => env2);
    const parserOptions = resolveParserOptions(
      parser2,
      config2.parserOptions || {},
      enabledEnvs
    );
    const configuredGlobals = resolveGlobals(
      config2.globals || {},
      enabledEnvs
    );
    const settings = config2.settings || {};
    const languageOptions = createLanguageOptions({
      globals: config2.globals,
      parser: parser2,
      parserOptions
    });
    if (!slots.lastSourceCode) {
      let t2;
      if (options.stats) {
        t2 = startTime2();
      }
      const parserService2 = new ParserService();
      const parseResult = parserService2.parseSync(file, {
        language: jslang,
        languageOptions
      });
      if (options.stats) {
        const time = endTime(t2);
        const timeOpts = { type: "parse" };
        storeTime(time, timeOpts, slots);
      }
      if (!parseResult.ok) {
        return parseResult.errors;
      }
      slots.lastSourceCode = parseResult.sourceCode;
    } else {
      if (!slots.lastSourceCode.scopeManager) {
        slots.lastSourceCode = new SourceCode({
          text: slots.lastSourceCode.text,
          ast: slots.lastSourceCode.ast,
          hasBOM: slots.lastSourceCode.hasBOM,
          parserServices: slots.lastSourceCode.parserServices,
          visitorKeys: slots.lastSourceCode.visitorKeys,
          scopeManager: analyzeScope(
            slots.lastSourceCode.ast,
            languageOptions
          )
        });
      }
    }
    const sourceCode2 = slots.lastSourceCode;
    const report = new FileReport({
      ruleMapper: (ruleId) => getRule(slots, ruleId),
      language: jslang,
      sourceCode: sourceCode2,
      disableFixes: options.disableFixes
    });
    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(
      sourceCode2,
      (ruleId) => getRule(slots, ruleId),
      options.warnInlineConfig,
      config2,
      report
    ) : {
      configuredRules: {},
      enabledGlobals: {},
      exportedVariables: {},
      disableDirectives: []
    };
    addDeclaredGlobals(
      sourceCode2.scopeManager.scopes[0],
      configuredGlobals,
      {
        exportedVariables: commentDirectives.exportedVariables,
        enabledGlobals: commentDirectives.enabledGlobals
      }
    );
    const configuredRules = Object.assign(
      {},
      config2.rules,
      commentDirectives.configuredRules
    );
    try {
      runRules(
        sourceCode2,
        configuredRules,
        (ruleId) => getRule(slots, ruleId),
        parserName,
        jslang,
        languageOptions,
        settings,
        options.filename,
        true,
        slots.cwd,
        providedOptions.physicalFilename,
        null,
        options.stats,
        slots,
        report
      );
    } catch (err) {
      err.message += `
Occurred while linting ${options.filename}`;
      debug("An error occurred while traversing");
      debug("Filename:", options.filename);
      if (err.currentNode) {
        const { line } = sourceCode2.getLoc(err.currentNode).start;
        debug("Line:", line);
        err.message += `:${line}`;
      }
      debug("Parser Options:", parserOptions);
      debug("Parser Path:", parserName);
      debug("Settings:", settings);
      if (err.ruleId) {
        err.message += `
Rule: "${err.ruleId}"`;
      }
      throw err;
    }
    return applyDisableDirectives2({
      language: jslang,
      sourceCode: sourceCode2,
      directives: commentDirectives.disableDirectives,
      disableFixes: options.disableFixes,
      problems: report.messages.sort(
        (problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column
      ),
      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
    });
  };
  /**
   * Verify using flat config and without any processors.
   * @param {VFile} file The file to lint.
   * @param {Config} providedConfig An ESLintConfig instance to configure everything.
   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
   * @throws {Error} If during rule execution.
   * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
   */
  flatVerifyWithoutProcessors_fn = function(file, providedConfig, providedOptions) {
    var _a2, _b, _c;
    const slots = internalSlotsMap.get(this);
    const config2 = providedConfig || {};
    const { settings = {}, languageOptions } = config2;
    const options = normalizeVerifyOptions(providedOptions, config2);
    if (!slots.lastSourceCode) {
      let t2;
      if (options.stats) {
        t2 = startTime2();
      }
      const parserService2 = new ParserService();
      const parseResult = parserService2.parseSync(file, config2);
      if (options.stats) {
        const time = endTime(t2);
        storeTime(time, { type: "parse" }, slots);
      }
      if (!parseResult.ok) {
        return parseResult.errors;
      }
      slots.lastSourceCode = parseResult.sourceCode;
    } else {
      if (slots.lastSourceCode.scopeManager === null) {
        slots.lastSourceCode = new SourceCode({
          text: slots.lastSourceCode.text,
          ast: slots.lastSourceCode.ast,
          hasBOM: slots.lastSourceCode.hasBOM,
          parserServices: slots.lastSourceCode.parserServices,
          visitorKeys: slots.lastSourceCode.visitorKeys,
          scopeManager: analyzeScope(
            slots.lastSourceCode.ast,
            languageOptions
          )
        });
      }
    }
    const sourceCode2 = slots.lastSourceCode;
    const report = new FileReport({
      ruleMapper: (ruleId) => config2.getRuleDefinition(ruleId),
      language: config2.language,
      sourceCode: sourceCode2,
      disableFixes: options.disableFixes
    });
    (_a2 = sourceCode2.applyLanguageOptions) == null ? void 0 : _a2.call(sourceCode2, languageOptions);
    const mergedInlineConfig = {
      rules: {}
    };
    if (options.allowInlineConfig) {
      if (options.warnInlineConfig) {
        if (sourceCode2.getInlineConfigNodes) {
          sourceCode2.getInlineConfigNodes().forEach((node2) => {
            const loc = sourceCode2.getLoc(node2);
            const range = sourceCode2.getRange(node2);
            report.addWarning({
              message: `'${sourceCode2.text.slice(range[0], range[1])}' has no effect because you have 'noInlineConfig' setting in ${options.warnInlineConfig}.`,
              loc
            });
          });
        }
      } else {
        const inlineConfigResult = (_b = sourceCode2.applyInlineConfig) == null ? void 0 : _b.call(sourceCode2);
        if (inlineConfigResult) {
          inlineConfigResult.problems.forEach((problem) => {
            report.addFatal(problem);
          });
          for (const {
            config: inlineConfig,
            loc
          } of inlineConfigResult.configs) {
            Object.keys(inlineConfig.rules).forEach((ruleId) => {
              var _a3;
              const rule = config2.getRuleDefinition(ruleId);
              const ruleValue = inlineConfig.rules[ruleId];
              if (!rule) {
                report.addError({
                  ruleId,
                  loc
                });
                return;
              }
              if (Object.hasOwn(mergedInlineConfig.rules, ruleId)) {
                report.addError({
                  message: `Rule "${ruleId}" is already configured by another configuration comment in the preceding code. This configuration is ignored.`,
                  loc
                });
                return;
              }
              try {
                const ruleOptionsInline = asArray2(ruleValue);
                let ruleOptions = ruleOptionsInline;
                assertIsRuleSeverity(ruleId, ruleOptions[0]);
                let shouldValidateOptions = true;
                if (
                  /*
                   * If inline config for the rule has only severity
                   */
                  ruleOptions.length === 1 && /*
                   * And the rule was already configured
                   */
                  config2.rules && Object.hasOwn(config2.rules, ruleId)
                ) {
                  ruleOptions = [
                    ruleOptions[0],
                    // severity from the inline config
                    ...config2.rules[ruleId].slice(1)
                    // options from the provided config
                  ];
                  if (config2.rules[ruleId][0] > 0) {
                    shouldValidateOptions = false;
                  }
                } else {
                  const slicedOptions = ruleOptions.slice(1);
                  const mergedOptions = deepMergeArrays(
                    (_a3 = rule.meta) == null ? void 0 : _a3.defaultOptions,
                    slicedOptions
                  );
                  if (mergedOptions.length) {
                    ruleOptions = [
                      ruleOptions[0],
                      ...mergedOptions
                    ];
                  }
                }
                if (options.reportUnusedInlineConfigs !== "off") {
                  addProblemIfSameSeverityAndOptions(
                    config2,
                    loc,
                    report,
                    ruleId,
                    ruleOptions,
                    ruleOptionsInline,
                    options.reportUnusedInlineConfigs
                  );
                }
                if (shouldValidateOptions) {
                  config2.validateRulesConfig({
                    [ruleId]: ruleOptions
                  });
                }
                mergedInlineConfig.rules[ruleId] = ruleOptions;
              } catch (err) {
                if (err.code === "ESLINT_INVALID_RULE_OPTIONS_SCHEMA") {
                  throw err;
                }
                let baseMessage = err.message.slice(
                  err.message.startsWith('Key "rules":') ? err.message.indexOf(":", 12) + 1 : err.message.indexOf(":") + 1
                ).trim();
                if (err.messageTemplate) {
                  baseMessage += ` You passed "${ruleValue}".`;
                }
                report.addError({
                  ruleId,
                  message: `Inline configuration for rule "${ruleId}" is invalid:
	${baseMessage}
`,
                  loc
                });
              }
            });
          }
        }
      }
    }
    const commentDirectives = options.allowInlineConfig && !options.warnInlineConfig ? getDirectiveCommentsForFlatConfig(
      sourceCode2,
      (ruleId) => config2.getRuleDefinition(ruleId),
      config2.language,
      report
    ) : [];
    const configuredRules = Object.assign(
      {},
      config2.rules,
      mergedInlineConfig.rules
    );
    (_c = sourceCode2.finalize) == null ? void 0 : _c.call(sourceCode2);
    try {
      runRules(
        sourceCode2,
        configuredRules,
        (ruleId) => config2.getRuleDefinition(ruleId),
        void 0,
        config2.language,
        languageOptions,
        settings,
        options.filename,
        false,
        slots.cwd,
        providedOptions.physicalFilename,
        options.ruleFilter,
        options.stats,
        slots,
        report
      );
    } catch (err) {
      err.message += `
Occurred while linting ${options.filename}`;
      debug("An error occurred while traversing");
      debug("Filename:", options.filename);
      if (err.currentNode) {
        const { line } = sourceCode2.getLoc(err.currentNode).start;
        debug("Line:", line);
        err.message += `:${line}`;
      }
      debug("Parser Options:", languageOptions.parserOptions);
      debug("Settings:", settings);
      if (err.ruleId) {
        err.message += `
Rule: "${err.ruleId}"`;
      }
      throw err;
    }
    return applyDisableDirectives2({
      language: config2.language,
      sourceCode: sourceCode2,
      directives: commentDirectives,
      disableFixes: options.disableFixes,
      problems: report.messages.sort(
        (problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column
      ),
      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives,
      ruleFilter: options.ruleFilter,
      configuredRules
    });
  };
  linter = {
    Linter: Linter2,
    /**
     * Get the internal slots of a given Linter instance for tests.
     * @param {Linter} instance The Linter instance to get.
     * @returns {LinterInternalSlots} The internal slots.
     */
    getLinterInternalSlots(instance) {
      return internalSlotsMap.get(instance);
    }
  };
  return linter;
}
function getLinter() {
  return requireLinter().Linter;
}
var Linter = eslintLinterBrowserify.Linter = getLinter();
const eslint = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Linter,
  default: eslintLinterBrowserify
}, Symbol.toStringTag, { value: "Module" }));
const CodeMirror = {
  ...C,
  view: View,
  commands: Com,
  "lang-javascript": Lang_J,
  lint: Lint,
  search: Search,
  "eslint-linter-browserify": eslint,
  state: State,
  collab: Collab
};
export {
  CodeMirror
};
